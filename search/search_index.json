{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Lilia is an advanced roleplay framework for Garry's Mod. Inspired by Lillia from League of Legends, it lets you create immersive servers with stability, rich features, and open-source flexibility. Because Lilia is only a framework, you must install a roleplay schema and launch your server using that schema's gamemode (for example, <code>+gamemode skeleton</code>).</p>"},{"location":"#server-owners","title":"Server Owners","text":"<p>If you're looking to get your Lilia server up and running as soon as possible, check out the Getting Started Guide for a complete walkthrough including installation, configuration, and customization.</p>"},{"location":"#community","title":"Community","text":"<p>Questions? Want to show off your work? Maybe drop a new module release? Come join our community Discord server.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Lilia is still early in its lifespan, and there are still a few things missing here and there. Contributions to the documentation\u2014from function references to simple typo fixes\u2014are welcomed!</p> <p>If you'd like to contribute code, you can visit the GitHub repository and make a pull request.</p>"},{"location":"#learning","title":"Learning","text":"<p>Getting started with developing using the Lilia framework requires an intermediate level of Garry's Mod Lua knowledge. You'll want to learn the basics before you start making a schema. The Garry's Mod Wiki is a good place to start.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#version-6935-november-01-2025","title":"Version 6.935 (November 01, 2025)","text":""},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Update gettingstarted.md</li> <li>Successfully updated workshop Lilia to 6.933</li> <li>Yeah More Docs lmfao</li> <li>Successfully updated workshop Lilia to 6.931</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.929</li> <li>Docs</li> <li>Successfully updated workshop Lilia to 6.927</li> <li>Update item.lua</li> <li>docs</li> <li>Successfully updated workshop Lilia to 6.924</li> <li>liaTable and liaTabs  automatically adjust sizing</li> <li>Successfully updated workshop Lilia to 6.922</li> <li>Update net.lua</li> <li>Docs Overhaul</li> <li>Successfully updated workshop Lilia to 6.919</li> <li>Documented Item Meta</li> <li>Optimizations</li> <li>Successfully updated workshop Lilia to 6.916</li> <li>New Docs Format</li> </ul>"},{"location":"changelog/#version-6933-november-01-2025","title":"Version 6.933 (November 01, 2025)","text":""},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li>Yeah More Docs lmfao</li> <li>Successfully updated workshop Lilia to 6.931</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.929</li> <li>Docs</li> <li>Successfully updated workshop Lilia to 6.927</li> <li>Update item.lua</li> <li>docs</li> <li>Successfully updated workshop Lilia to 6.924</li> <li>liaTable and liaTabs  automatically adjust sizing</li> <li>Successfully updated workshop Lilia to 6.922</li> <li>Update net.lua</li> <li>Docs Overhaul</li> <li>Successfully updated workshop Lilia to 6.919</li> <li>Documented Item Meta</li> <li>Optimizations</li> <li>Successfully updated workshop Lilia to 6.916</li> <li>New Docs Format</li> <li>Successfully updated workshop Lilia to 6.914</li> <li>Way too many changes lel</li> </ul>"},{"location":"changelog/#version-6931-november-01-2025","title":"Version 6.931 (November 01, 2025)","text":""},{"location":"changelog/#changes_2","title":"Changes","text":"<ul> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.929</li> <li>Docs</li> <li>Successfully updated workshop Lilia to 6.927</li> <li>Update item.lua</li> <li>docs</li> <li>Successfully updated workshop Lilia to 6.924</li> <li>liaTable and liaTabs  automatically adjust sizing</li> <li>Successfully updated workshop Lilia to 6.922</li> <li>Update net.lua</li> <li>Docs Overhaul</li> <li>Successfully updated workshop Lilia to 6.919</li> <li>Documented Item Meta</li> <li>Optimizations</li> <li>Successfully updated workshop Lilia to 6.916</li> <li>New Docs Format</li> <li>Successfully updated workshop Lilia to 6.914</li> <li>Way too many changes lel</li> <li>Spacing</li> <li>Successfully updated workshop Lilia to 6.911</li> </ul>"},{"location":"changelog/#version-6929-november-01-2025","title":"Version 6.929 (November 01, 2025)","text":""},{"location":"changelog/#changes_3","title":"Changes","text":"<ul> <li>Docs</li> <li>Successfully updated workshop Lilia to 6.927</li> <li>Update item.lua</li> <li>docs</li> <li>Successfully updated workshop Lilia to 6.924</li> <li>liaTable and liaTabs  automatically adjust sizing</li> <li>Successfully updated workshop Lilia to 6.922</li> <li>Update net.lua</li> <li>Docs Overhaul</li> <li>Successfully updated workshop Lilia to 6.919</li> <li>Documented Item Meta</li> <li>Optimizations</li> <li>Successfully updated workshop Lilia to 6.916</li> <li>New Docs Format</li> <li>Successfully updated workshop Lilia to 6.914</li> <li>Way too many changes lel</li> <li>Spacing</li> <li>Successfully updated workshop Lilia to 6.911</li> <li>Update client.lua</li> <li>Update buttons.lua</li> </ul>"},{"location":"changelog/#version-6927-november-01-2025","title":"Version 6.927 (November 01, 2025)","text":""},{"location":"changelog/#changes_4","title":"Changes","text":"<ul> <li>Update item.lua</li> <li>docs</li> <li>Successfully updated workshop Lilia to 6.924</li> <li>liaTable and liaTabs  automatically adjust sizing</li> <li>Successfully updated workshop Lilia to 6.922</li> <li>Update net.lua</li> <li>Docs Overhaul</li> <li>Successfully updated workshop Lilia to 6.919</li> <li>Documented Item Meta</li> <li>Optimizations</li> <li>Successfully updated workshop Lilia to 6.916</li> <li>New Docs Format</li> <li>Successfully updated workshop Lilia to 6.914</li> <li>Way too many changes lel</li> <li>Spacing</li> <li>Successfully updated workshop Lilia to 6.911</li> <li>Update client.lua</li> <li>Update buttons.lua</li> <li>Successfully updated workshop Lilia to 6.98</li> <li>Update shared.lua</li> </ul>"},{"location":"changelog/#version-6924-november-01-2025","title":"Version 6.924 (November 01, 2025)","text":""},{"location":"changelog/#changes_5","title":"Changes","text":"<ul> <li>liaTable and liaTabs  automatically adjust sizing</li> <li>Successfully updated workshop Lilia to 6.922</li> <li>Update net.lua</li> <li>Docs Overhaul</li> <li>Successfully updated workshop Lilia to 6.919</li> <li>Documented Item Meta</li> <li>Optimizations</li> <li>Successfully updated workshop Lilia to 6.916</li> <li>New Docs Format</li> <li>Successfully updated workshop Lilia to 6.914</li> <li>Way too many changes lel</li> <li>Spacing</li> <li>Successfully updated workshop Lilia to 6.911</li> <li>Update client.lua</li> <li>Update buttons.lua</li> <li>Successfully updated workshop Lilia to 6.98</li> <li>Update shared.lua</li> <li>Fixes</li> <li>Successfully updated workshop Lilia to 6.95</li> <li>Revert \"Spacing\"</li> </ul>"},{"location":"changelog/#version-6919-october-30-2025","title":"Version 6.919 (October 30, 2025)","text":""},{"location":"changelog/#changes_6","title":"Changes","text":"<ul> <li>Documented Item Meta</li> <li>Optimizations</li> <li>Successfully updated workshop Lilia to 6.916</li> <li>New Docs Format</li> <li>Successfully updated workshop Lilia to 6.914</li> <li>Way too many changes lel</li> <li>Spacing</li> <li>Successfully updated workshop Lilia to 6.911</li> <li>Update client.lua</li> <li>Update buttons.lua</li> <li>Successfully updated workshop Lilia to 6.98</li> <li>Update shared.lua</li> <li>Fixes</li> <li>Successfully updated workshop Lilia to 6.95</li> <li>Revert \"Spacing\"</li> <li>Revert \"Successfully updated workshop Lilia to 6.92\"</li> <li>Successfully updated workshop Lilia to 6.92</li> <li>Spacing</li> <li>xd</li> <li>Successfully updated workshop Lilia to 6.899</li> </ul>"},{"location":"changelog/#version-6914-october-29-2025","title":"Version 6.914 (October 29, 2025)","text":""},{"location":"changelog/#changes_7","title":"Changes","text":"<ul> <li>Way too many changes lel</li> <li>Spacing</li> <li>Successfully updated workshop Lilia to 6.911</li> <li>Update client.lua</li> <li>Update buttons.lua</li> <li>Successfully updated workshop Lilia to 6.98</li> <li>Update shared.lua</li> <li>Fixes</li> <li>Successfully updated workshop Lilia to 6.95</li> <li>Revert \"Spacing\"</li> <li>Revert \"Successfully updated workshop Lilia to 6.92\"</li> <li>Successfully updated workshop Lilia to 6.92</li> <li>Spacing</li> <li>xd</li> <li>Successfully updated workshop Lilia to 6.899</li> <li>Update commands.lua</li> <li>Dumb Check</li> <li>Bot Command</li> <li>Successfully updated workshop Lilia to 6.895</li> <li>Example Usage</li> </ul>"},{"location":"changelog/#version-6911-october-27-2025","title":"Version 6.911 (October 27, 2025)","text":""},{"location":"changelog/#changes_8","title":"Changes","text":"<ul> <li>Update client.lua</li> <li>Update buttons.lua</li> <li>Successfully updated workshop Lilia to 6.98</li> <li>Update shared.lua</li> <li>Fixes</li> <li>Successfully updated workshop Lilia to 6.95</li> <li>Revert \"Spacing\"</li> <li>Revert \"Successfully updated workshop Lilia to 6.92\"</li> <li>Successfully updated workshop Lilia to 6.92</li> <li>Spacing</li> <li>xd</li> <li>Successfully updated workshop Lilia to 6.899</li> <li>Update commands.lua</li> <li>Dumb Check</li> <li>Bot Command</li> <li>Successfully updated workshop Lilia to 6.895</li> <li>Example Usage</li> <li>Successfully updated workshop Lilia to 6.893</li> <li>Empty Lines</li> <li>Small Voice Range Change</li> </ul>"},{"location":"changelog/#version-698-october-27-2025","title":"Version 6.98 (October 27, 2025)","text":""},{"location":"changelog/#changes_9","title":"Changes","text":"<ul> <li>Update shared.lua</li> <li>Fixes</li> <li>Successfully updated workshop Lilia to 6.95</li> <li>Revert \"Spacing\"</li> <li>Revert \"Successfully updated workshop Lilia to 6.92\"</li> <li>Successfully updated workshop Lilia to 6.92</li> <li>Spacing</li> <li>xd</li> <li>Successfully updated workshop Lilia to 6.899</li> <li>Update commands.lua</li> <li>Dumb Check</li> <li>Bot Command</li> <li>Successfully updated workshop Lilia to 6.895</li> <li>Example Usage</li> <li>Successfully updated workshop Lilia to 6.893</li> <li>Empty Lines</li> <li>Small Voice Range Change</li> <li>Spaciong</li> <li>Successfully updated workshop Lilia to 6.889</li> <li>Update installation.md</li> </ul>"},{"location":"changelog/#version-695-october-25-2025","title":"Version 6.95 (October 25, 2025)","text":""},{"location":"changelog/#changes_10","title":"Changes","text":"<ul> <li>Revert \"Spacing\"</li> <li>Revert \"Successfully updated workshop Lilia to 6.92\"</li> <li>Successfully updated workshop Lilia to 6.92</li> <li>Spacing</li> <li>xd</li> <li>Successfully updated workshop Lilia to 6.899</li> <li>Update commands.lua</li> <li>Dumb Check</li> <li>Bot Command</li> <li>Successfully updated workshop Lilia to 6.895</li> <li>Example Usage</li> <li>Successfully updated workshop Lilia to 6.893</li> <li>Empty Lines</li> <li>Small Voice Range Change</li> <li>Spaciong</li> <li>Successfully updated workshop Lilia to 6.889</li> <li>Update installation.md</li> <li>Update compatibility.md</li> <li>Items</li> <li>Naming of Page</li> </ul>"},{"location":"changelog/#version-6899-october-25-2025","title":"Version 6.899 (October 25, 2025)","text":""},{"location":"changelog/#changes_11","title":"Changes","text":"<ul> <li>Update commands.lua</li> <li>Dumb Check</li> <li>Bot Command</li> <li>Successfully updated workshop Lilia to 6.895</li> <li>Example Usage</li> <li>Successfully updated workshop Lilia to 6.893</li> <li>Empty Lines</li> <li>Small Voice Range Change</li> <li>Spaciong</li> <li>Successfully updated workshop Lilia to 6.889</li> <li>Update installation.md</li> <li>Update compatibility.md</li> <li>Items</li> <li>Naming of Page</li> <li>Successfully updated workshop Lilia to 6.884</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.882</li> <li>Create generate_docs.py</li> <li>Update faction.lua</li> <li>Update class.lua</li> </ul>"},{"location":"changelog/#version-6895-october-24-2025","title":"Version 6.895 (October 24, 2025)","text":""},{"location":"changelog/#changes_12","title":"Changes","text":"<ul> <li>Example Usage</li> <li>Successfully updated workshop Lilia to 6.893</li> <li>Empty Lines</li> <li>Small Voice Range Change</li> <li>Spaciong</li> <li>Successfully updated workshop Lilia to 6.889</li> <li>Update installation.md</li> <li>Update compatibility.md</li> <li>Items</li> <li>Naming of Page</li> <li>Successfully updated workshop Lilia to 6.884</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.882</li> <li>Create generate_docs.py</li> <li>Update faction.lua</li> <li>Update class.lua</li> <li>Linting</li> <li>Update player.lua</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.875</li> </ul>"},{"location":"changelog/#version-6893-october-24-2025","title":"Version 6.893 (October 24, 2025)","text":""},{"location":"changelog/#changes_13","title":"Changes","text":"<ul> <li>Empty Lines</li> <li>Small Voice Range Change</li> <li>Spaciong</li> <li>Successfully updated workshop Lilia to 6.889</li> <li>Update installation.md</li> <li>Update compatibility.md</li> <li>Items</li> <li>Naming of Page</li> <li>Successfully updated workshop Lilia to 6.884</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.882</li> <li>Create generate_docs.py</li> <li>Update faction.lua</li> <li>Update class.lua</li> <li>Linting</li> <li>Update player.lua</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.875</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.873</li> </ul>"},{"location":"changelog/#version-6889-october-24-2025","title":"Version 6.889 (October 24, 2025)","text":""},{"location":"changelog/#changes_14","title":"Changes","text":"<ul> <li>Update installation.md</li> <li>Update compatibility.md</li> <li>Items</li> <li>Naming of Page</li> <li>Successfully updated workshop Lilia to 6.884</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.882</li> <li>Create generate_docs.py</li> <li>Update faction.lua</li> <li>Update class.lua</li> <li>Linting</li> <li>Update player.lua</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.875</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.873</li> <li>Successfully updated workshop Lilia to 6.871</li> <li>Hooks</li> <li>Revert \"Merge branch 'main' of https://github.com/LiliaFramework/Lilia\"</li> <li>Update client.lua</li> </ul>"},{"location":"changelog/#version-6884-october-24-2025","title":"Version 6.884 (October 24, 2025)","text":""},{"location":"changelog/#changes_15","title":"Changes","text":"<ul> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.882</li> <li>Create generate_docs.py</li> <li>Update faction.lua</li> <li>Update class.lua</li> <li>Linting</li> <li>Update player.lua</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.875</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.873</li> <li>Successfully updated workshop Lilia to 6.871</li> <li>Hooks</li> <li>Revert \"Merge branch 'main' of https://github.com/LiliaFramework/Lilia\"</li> <li>Update client.lua</li> <li>Successfully updated workshop Lilia to 6.868</li> <li>Spacing</li> <li>Temp New Docs</li> <li>Successfully updated workshop Lilia to 6.865</li> <li>Fixes</li> </ul>"},{"location":"changelog/#version-6882-october-24-2025","title":"Version 6.882 (October 24, 2025)","text":""},{"location":"changelog/#changes_16","title":"Changes","text":"<ul> <li>Create generate_docs.py</li> <li>Update faction.lua</li> <li>Update class.lua</li> <li>Linting</li> <li>Update player.lua</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.875</li> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.873</li> <li>Successfully updated workshop Lilia to 6.871</li> <li>Hooks</li> <li>Revert \"Merge branch 'main' of https://github.com/LiliaFramework/Lilia\"</li> <li>Update client.lua</li> <li>Successfully updated workshop Lilia to 6.868</li> <li>Spacing</li> <li>Temp New Docs</li> <li>Successfully updated workshop Lilia to 6.865</li> <li>Fixes</li> <li>Many Optimizations</li> <li>Successfully updated workshop Lilia to 6.862</li> </ul>"},{"location":"changelog/#version-6875-october-24-2025","title":"Version 6.875 (October 24, 2025)","text":""},{"location":"changelog/#changes_17","title":"Changes","text":"<ul> <li>More Docs</li> <li>Successfully updated workshop Lilia to 6.873</li> <li>Successfully updated workshop Lilia to 6.871</li> <li>Hooks</li> <li>Revert \"Merge branch 'main' of https://github.com/LiliaFramework/Lilia\"</li> <li>Update client.lua</li> <li>Successfully updated workshop Lilia to 6.868</li> <li>Spacing</li> <li>Temp New Docs</li> <li>Successfully updated workshop Lilia to 6.865</li> <li>Fixes</li> <li>Many Optimizations</li> <li>Successfully updated workshop Lilia to 6.862</li> <li>Mini Bug Fix</li> <li>Successfully updated workshop Lilia to 6.860</li> <li>Wipes</li> <li>Update module.lua</li> <li>Successfully updated workshop Lilia to 6.857</li> <li>Auto Spawn</li> <li>Update panel.lua</li> </ul>"},{"location":"changelog/#version-6873-october-24-2025","title":"Version 6.873 (October 24, 2025)","text":""},{"location":"changelog/#changes_18","title":"Changes","text":"<ul> <li>Successfully updated workshop Lilia to 6.871</li> <li>Hooks</li> <li>Revert \"Merge branch 'main' of https://github.com/LiliaFramework/Lilia\"</li> <li>Update client.lua</li> <li>Successfully updated workshop Lilia to 6.868</li> <li>Spacing</li> <li>Temp New Docs</li> <li>Successfully updated workshop Lilia to 6.865</li> <li>Fixes</li> <li>Many Optimizations</li> <li>Successfully updated workshop Lilia to 6.862</li> <li>Mini Bug Fix</li> <li>Successfully updated workshop Lilia to 6.860</li> <li>Wipes</li> <li>Update module.lua</li> <li>Successfully updated workshop Lilia to 6.857</li> <li>Auto Spawn</li> <li>Update panel.lua</li> <li>Reapply \"Update character.lua\"</li> <li>Successfully updated workshop Lilia to 6.853</li> </ul>"},{"location":"changelog/#version-6871-october-24-2025","title":"Version 6.871 (October 24, 2025)","text":""},{"location":"changelog/#changes_19","title":"Changes","text":"<ul> <li>Revert \"Merge branch 'main' of https://github.com/LiliaFramework/Lilia\"</li> <li>Update client.lua</li> <li>Successfully updated workshop Lilia to 6.868</li> <li>Spacing</li> <li>Temp New Docs</li> <li>Successfully updated workshop Lilia to 6.865</li> <li>Fixes</li> <li>Many Optimizations</li> <li>Successfully updated workshop Lilia to 6.862</li> <li>Mini Bug Fix</li> <li>Successfully updated workshop Lilia to 6.860</li> <li>Wipes</li> <li>Update module.lua</li> <li>Successfully updated workshop Lilia to 6.857</li> <li>Auto Spawn</li> <li>Update panel.lua</li> <li>Reapply \"Update character.lua\"</li> <li>Successfully updated workshop Lilia to 6.853</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.851</li> </ul>"},{"location":"changelog/#version-6865-october-24-2025","title":"Version 6.865 (October 24, 2025)","text":""},{"location":"changelog/#changes_20","title":"Changes","text":"<ul> <li>Fixes</li> <li>Many Optimizations</li> <li>Successfully updated workshop Lilia to 6.862</li> <li>Mini Bug Fix</li> <li>Successfully updated workshop Lilia to 6.860</li> <li>Wipes</li> <li>Update module.lua</li> <li>Successfully updated workshop Lilia to 6.857</li> <li>Auto Spawn</li> <li>Update panel.lua</li> <li>Reapply \"Update character.lua\"</li> <li>Successfully updated workshop Lilia to 6.853</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.851</li> <li>Revert \"Update character.lua\"</li> <li>Successfully updated workshop Lilia to 6.849</li> <li>Update character.lua</li> <li>Update character.lua</li> <li>Successfully updated workshop Lilia to 6.846</li> <li>Death Minor Issue</li> </ul>"},{"location":"changelog/#version-6783-october-12-2025","title":"Version 6.783 (October 12, 2025)","text":""},{"location":"changelog/#changes_21","title":"Changes","text":"<ul> <li>Fixed Keybind bug</li> <li>Made Spawn Time an Int</li> <li>Successfully updated workshop Lilia to 6.780</li> <li>Update remove_comments.py</li> <li>Successfully updated workshop Lilia to 6.778</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.774</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.770</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.768</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>New Features</li> </ul>"},{"location":"changelog/#version-6780-october-12-2025","title":"Version 6.780 (October 12, 2025)","text":""},{"location":"changelog/#changes_22","title":"Changes","text":"<ul> <li>Update remove_comments.py</li> <li>Successfully updated workshop Lilia to 6.778</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.774</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.770</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.768</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>New Features</li> <li>Successfully updated workshop Lilia to 6.762</li> <li>Linting</li> <li>Workflow Update</li> </ul>"},{"location":"changelog/#version-6778-october-12-2025","title":"Version 6.778 (October 12, 2025)","text":""},{"location":"changelog/#changes_23","title":"Changes","text":"<ul> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.774</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.770</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.768</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>New Features</li> <li>Successfully updated workshop Lilia to 6.762</li> <li>Linting</li> <li>Workflow Update</li> <li>Successfully updated workshop Lilia to 6.759</li> <li>Bug Fixing &amp; Better UI in several panels</li> </ul>"},{"location":"changelog/#version-6774-october-12-2025","title":"Version 6.774 (October 12, 2025)","text":""},{"location":"changelog/#changes_24","title":"Changes","text":"<ul> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.770</li> <li>Update ci.yml</li> <li>Successfully updated workshop Lilia to 6.768</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>Update ci.yml</li> <li>New Features</li> <li>Successfully updated workshop Lilia to 6.762</li> <li>Linting</li> <li>Workflow Update</li> <li>Successfully updated workshop Lilia to 6.759</li> <li>Bug Fixing &amp; Better UI in several panels</li> <li>Successfully updated workshop Lilia to 6.757</li> <li>Localization</li> <li>Localization</li> <li>Successfully updated workshop Lilia to 6.754</li> </ul>"},{"location":"compatibility/","title":"Addon Compatibility","text":"<p>This page documents the optional compatibility libraries bundled with Lilia. These libraries greatly expand support for a variety of popular addons used across the Garry's Mod community.</p>"},{"location":"compatibility/#overview","title":"Overview","text":"<p>The compatibility system provides seamless integration between Lilia and popular Garry's Mod addons. It automatically detects installed addons, handles version compatibility, and provides API bridging to ensure smooth operation without manual configuration. The system prevents addon conflicts with intelligent override management, maps functions and events between Lilia and addon systems, and provides detailed logging with automatic disable mechanisms to maintain stability. This enables you to use your favorite addons with Lilia while maintaining framework integrity and server performance.</p>"},{"location":"compatibility/#compatibility-details","title":"Compatibility Details","text":"<p>The following sections detail the specific compatibility features provided for each supported addon.</p>"},{"location":"compatibility/#darkrp","title":"DarkRP","text":"<p>Purpose</p> <p>Provides comprehensive compatibility for DarkRP and most DarkRP addons, ensuring they work out of the box with Lilia.</p> <p>Features</p> <ul> <li>Provides helper functions like <code>isEmpty</code>, <code>findEmptyPos</code>, and text wrapping</li> <li>Implements <code>formatMoney</code>, <code>createEntity</code>, and <code>createCategory</code> shims</li> <li>Recreates widely used DarkRP globals and utilities</li> <li>Most DarkRP addons work out of the box without any modifications required</li> <li>Seamless integration with DarkRP's job system, money system, and core mechanics</li> </ul> <p>Technical Details</p> <p>Recreates widely used DarkRP globals and utilities so community &amp; GMODStore addons can run under Lilia without modification. The compatibility layer is designed to be comprehensive, covering the vast majority of DarkRP addons and ensuring they function identically to how they would on a standard DarkRP server.</p>"},{"location":"compatibility/#advanced-duplicator","title":"Advanced Duplicator","text":"<p>Purpose</p> <p>Provides security and stability improvements for the Advanced Duplicator addon.</p> <p>Features</p> <ul> <li>Prevents duplication of entities flagged as <code>NoDuplicate</code></li> <li>Rejects dupes containing props scaled to excessive sizes</li> <li>Logs attempted exploits and notifies the offending player</li> </ul> <p>Technical Details</p> <p>Hooks into dupe placement checks to stop players from spawning unstable or restricted entities. Oversized props can crash a server, so this layer validates models before allowing a dupe to spawn.</p>"},{"location":"compatibility/#advanced-duplicator-2","title":"Advanced Duplicator 2","text":"<p>Purpose</p> <p>Provides security and stability improvements for the Advanced Duplicator 2 addon.</p> <p>Features</p> <ul> <li>Performs the same safety checks as the original dupe compatibility library</li> <li>Respects AD2's internal entity lists when validating dupes</li> </ul> <p>Technical Details</p> <p>Integrates with AD2's duplication data system while still blocking problematic entities and scaling exploits.</p>"},{"location":"compatibility/#arccw","title":"ARCCW","text":"<p>Purpose</p> <p>Configures ARCCW weapon framework for optimal roleplay compatibility.</p> <p>Features</p> <ul> <li>Disables ARCCW's HUD and crosshair overrides to prevent conflicts with Lilia's UI</li> <li>Configures weapon dropping, attachment inventory, and malfunction settings</li> <li>Sets recommended console variables for optimal integration</li> </ul> <p>Technical Details</p> <p>Automatically configures ARCCW console variables to work seamlessly with Lilia's roleplay framework, ensuring weapons behave appropriately in a roleplay environment.</p>"},{"location":"compatibility/#cami","title":"CAMI","text":"<p>Purpose</p> <p>Provides integration between CAMI permission system and Lilia's administrator framework.</p> <p>Features</p> <ul> <li>Integrates CAMI permission system with Lilia's administrator framework</li> <li>Handles privilege registration and usergroup management automatically</li> <li>Provides compatibility for addons that rely on CAMI for permission checks</li> </ul> <p>Technical Details</p> <p>Bridges CAMI's permission system with Lilia's built-in administrator system, allowing addons that depend on CAMI to function properly while maintaining Lilia's permission structure.</p>"},{"location":"compatibility/#lvs","title":"LVS","text":"<p>Purpose</p> <p>Provides safety improvements for the LVS vehicle framework.</p> <p>Features</p> <ul> <li>Filters out self-inflicted damage from the player's own vehicle</li> </ul> <p>Technical Details</p> <p>Stops collisions or weapons fired from your own LVS vehicle from injuring you. Drivers can still take damage if an impact occurs close to their seat.</p>"},{"location":"compatibility/#pac3","title":"PAC3","text":"<p>Purpose</p> <p>Provides comprehensive integration with the PAC3 outfit system.</p> <p>Features</p> <ul> <li>Networks player outfit parts reliably between server and clients</li> <li>Adds commands for repairing, enabling, and disabling PAC3</li> <li>Honors the <code>BlockPackURLoad</code> configuration to restrict loading outfits from URLs</li> <li>Registers the \"Staff Permissions - Can Use PAC3\" privilege and the <code>P</code> flag for access control</li> </ul> <p>Technical Details</p> <p>Exposes helper methods and network messages to synchronize PAC3 outfits, preventing missing or broken parts on clients.</p>"},{"location":"compatibility/#permaprops","title":"PermaProps","text":"<p>Purpose</p> <p>Provides management and safety features for the PermaProps persistence addon.</p> <p>Features</p> <ul> <li>Blocks saving Lilia's persistent entities or map-created props as permanent</li> <li>Warns about overlapping saves and logs who saved each PermaProp</li> </ul> <p>Technical Details</p> <p>Prevents PermaProps from saving entities that would conflict with Lilia's persistence system, avoiding errors on future loads.</p>"},{"location":"compatibility/#prone-mod","title":"Prone Mod","text":"<p>Purpose</p> <p>Provides automatic recovery features for the Prone Mod addon.</p> <p>Features</p> <ul> <li>Forces players out of prone when they die or change character</li> </ul> <p>Technical Details</p> <p>Listens for death and character-switch events, automatically exiting prone to avoid players being stuck on respawn.</p>"},{"location":"compatibility/#sam","title":"SAM","text":"<p>Purpose</p> <p>Provides comprehensive integration with the SAM admin suite, combining SAM's powerful admin tools with Lilia's admin system for full compatibility.</p> <p>Features</p> <ul> <li>Recreates SAM chat commands via Lilia's command system</li> <li>Full integration with Lilia's admin system - SAM and Lilia work together seamlessly</li> <li>Includes utilities such as playtime tracking and blind/unblind commands</li> <li>Checks staff privileges before executing sensitive commands</li> <li>Provides configuration options for admin-only notifications and staff enforcement</li> <li>Adds cleardecals command for server maintenance</li> <li>Combines the best of both systems - SAM's advanced admin features with Lilia's modern framework</li> </ul> <p>Technical Details</p> <p>Mirrors SAM commands and enforces Lilia's permission checks so admins can use familiar tools seamlessly. The integration layer ensures that SAM's powerful admin capabilities work perfectly with Lilia's permission system, character management, and modern architecture. This provides administrators with the full feature set of both systems working in harmony.</p>"},{"location":"compatibility/#simfphys-vehicles","title":"Simfphys Vehicles","text":"<p>Purpose</p> <p>Provides comprehensive integration with the Simfphys vehicle framework.</p> <p>Features</p> <ul> <li>Applies crash damage to drivers on vehicle collisions</li> <li>Blocks Sit Anywhere seating on Simfphys vehicles</li> <li>Adds configuration options for seat damage and entry delays</li> <li>Requires privilege for editing vehicles</li> <li>Enables trunk functionality for Simfphys vehicles</li> </ul> <p>Technical Details</p> <p>Drivers only take damage when the vehicle is struck near their seat and a configurable delay is applied before entering cars. Vehicle editing requires the \"canEditSimfphysCars\" privilege, and vehicles are automatically configured to work with Lilia's trunk system.</p>"},{"location":"compatibility/#sit-anywhere","title":"Sit Anywhere","text":"<p>Purpose</p> <p>Provides safety and anti-abuse features for the Sit Anywhere addon.</p> <p>Features</p> <ul> <li>Sets recommended console variables on load</li> <li>Prevents sitting on players or vehicles</li> <li>Applies anti-prop-surf and tool-abuse protections</li> <li>Enables seat damage by default</li> </ul> <p>Technical Details</p> <p>Adjusts console settings and seat interactions to prevent trolling while maintaining roleplay utility.</p>"},{"location":"compatibility/#serverguard","title":"ServerGuard","text":"<p>Purpose</p> <p>Provides integration between ServerGuard admin suite and Lilia's administrator framework.</p> <p>Features</p> <ul> <li>Integrates ServerGuard permission system with Lilia's administrator framework</li> <li>Provides command bridging for admin functions between the two systems</li> <li>Handles privilege registration and permission management automatically</li> </ul> <p>Technical Details</p> <p>Bridges ServerGuard's admin system with Lilia's built-in administrator framework, allowing seamless integration of ServerGuard commands and permissions while maintaining Lilia's permission structure.</p>"},{"location":"compatibility/#ulx","title":"ULX","text":"<p>Purpose</p> <p>Provides integration with the ULX admin suite, combining ULX's admin tools with Lilia's admin system for enhanced functionality.</p> <p>Features</p> <ul> <li>Full integration with Lilia's admin system - ULX and Lilia work together seamlessly</li> <li>Provides comprehensive command bridging for admin functions</li> <li>Integrates with Lilia's permission system for unified admin management</li> <li>Combines ULX's proven admin tools with Lilia's modern framework</li> <li>Maintains ULX's familiar command structure while leveraging Lilia's advanced features</li> </ul> <p>Technical Details</p> <p>The integration layer ensures that ULX's admin capabilities work perfectly with Lilia's permission system, character management, and modern architecture. While ULX's CAMI version may be older, the compatibility layer bridges these differences to provide a seamless experience. This allows administrators to use ULX's familiar interface while benefiting from Lilia's enhanced admin system and modern framework features.</p>"},{"location":"compatibility/#vcmod","title":"VCMod","text":"<p>Purpose</p> <p>Provides financial integration for the VCMod vehicle framework.</p> <p>Features</p> <ul> <li>Redirects VCMod money hooks to a character's funds</li> <li>Checks vehicle purchases against the character's wallet</li> </ul> <p>Technical Details</p> <p>Forwards vehicle purchase and upgrade transactions to the roleplay money system, ensuring consistency with character finances.</p>"},{"location":"compatibility/#vjbase","title":"VJBase","text":"<p>Purpose</p> <p>Provides security and performance improvements for the VJBase NPC framework.</p> <p>Features</p> <ul> <li>Removes unprotected VJBase spawners and flags NPCs notarget</li> <li>Blocks dangerous network messages</li> <li>Applies safer default settings and removes heavy hooks</li> <li>Registers privilege for VJBase NPC properties</li> <li>Optimizes processing time based on player count</li> </ul> <p>Technical Details</p> <p>Intercepts exploitable VJBase network messages and disables resource-intensive hooks to maintain server security and performance. Automatically removes dangerous spawners and optimizes performance based on server population.</p>"},{"location":"gettingstarted/","title":"Getting Started with Lilia","text":"<p>This step-by-step guide will help you set up your first Lilia roleplay server. We'll start with the basics and build up to advanced features. Each section includes simple instructions and examples.</p>"},{"location":"gettingstarted/#step-1-install-lilia-framework","title":"Step 1: Install Lilia Framework","text":"<p>Lilia is the framework that powers your roleplay server. It requires a roleplay schema (gamemode) to function.</p>"},{"location":"gettingstarted/#basic-installation","title":"Basic Installation","text":"<ol> <li>Subscribe to Lilia on Steam Workshop</li> <li>Visit the Lilia Workshop page</li> <li>Click \"Subscribe\" to download it</li> <li> <p>Workshop ID: <code>3527535922</code></p> </li> <li> <p>Create Workshop Collection</p> </li> <li>In Steam Workshop, create a collection</li> <li>Add Lilia Framework to the collection</li> <li> <p>Note the collection ID number</p> </li> <li> <p>Configure Server Startup</p> </li> <li>Add this to your server startup parameters:      <pre><code>+host_workshop_collection YOUR_COLLECTION_ID\n</code></pre>      (Replace <code>YOUR_COLLECTION_ID</code> with your collection ID)</li> </ol>"},{"location":"gettingstarted/#download-a-schema","title":"Download a Schema","text":"<p>Lilia requires a schema to function. Start with the Skeleton Schema:</p> <ol> <li>Visit Skeleton Schema on GitHub</li> <li>Click \"Code\" \u2192 \"Download ZIP\"</li> <li>Extract the ZIP file</li> <li>Upload the <code>skeleton</code> folder to <code>garrysmod/gamemodes/</code></li> </ol>"},{"location":"gettingstarted/#launch-server","title":"Launch Server","text":"<p>Add this to your server startup parameters: <pre><code>+gamemode skeleton\n</code></pre></p> <p>Example complete startup command: <pre><code>+host_workshop_collection 123456789 +gamemode skeleton\n</code></pre></p>"},{"location":"gettingstarted/#verify-installation","title":"Verify Installation","text":"<p>Start your server and check the console for: <pre><code>[Lilia] [Bootstrap] Loaded successfully after X seconds.\n</code></pre></p>"},{"location":"gettingstarted/#step-2-set-up-admin-access","title":"Step 2: Set Up Admin Access","text":"<p>To manage your server, you need administrator permissions.</p>"},{"location":"gettingstarted/#basic-admin-setup","title":"Basic Admin Setup","text":"<ol> <li>Join your server as a regular player</li> <li>Open the console by pressing the <code>~</code> key (usually above Tab)</li> <li>Enter this command:    <pre><code>plysetgroup YOUR_NAME superadmin\n</code></pre>    (Replace <code>YOUR_NAME</code> with your exact player name)</li> </ol>"},{"location":"gettingstarted/#alternative-methods","title":"Alternative Methods","text":"<p>If you have admin systems installed:</p> <ul> <li> <p>SAM: Use the SAM interface to set your rank</p> </li> <li> <p>ULX: Use ULX commands or interface to set your usergroup</p> </li> <li> <p>ServerGuard: Use ServerGuard's rank management</p> </li> </ul>"},{"location":"gettingstarted/#permission-levels","title":"Permission Levels","text":"<p>Lilia has three permission levels:</p> <ul> <li> <p>User: Basic player permissions</p> </li> <li> <p>Admin: Moderation and basic administrative commands</p> </li> <li> <p>Super Admin: Full server control (recommended for owners)</p> </li> </ul>"},{"location":"gettingstarted/#step-3-create-your-first-faction","title":"Step 3: Create Your First Faction","text":"<p>Factions are the main groups in your roleplay server. Every player character belongs to one faction. Examples include Citizens, Police, Medical, etc.</p>"},{"location":"gettingstarted/#file-location","title":"File Location","text":"<p>Place faction files in your schema folder: <pre><code>garrysmod/gamemodes/YOUR_SCHEMA/schema/factions/\n</code></pre></p> <p>Use simple filenames like <code>citizen.lua</code>, <code>police.lua</code>, <code>doctor.lua</code>.</p>"},{"location":"gettingstarted/#create-a-citizen-faction","title":"Create a Citizen Faction","text":"<ol> <li>Create a new file named <code>citizen.lua</code> in your factions folder</li> <li>Add this code to the file:</li> </ol> <pre><code>-- Citizen Faction\nFACTION.name = \"Citizens\"\nFACTION.desc = \"Regular people living in the city\"\nFACTION.color = Color(100, 150, 100)\n\nFACTION.isDefault = true  -- Allow players to join\n\nFACTION.models = {\n    \"models/player/Group01/male_01.mdl\",\n    \"models/player/Group01/female_01.mdl\"\n}\n\nFACTION.items = {\n    \"item_wallet\"\n}\n\nlia.faction.register(\"citizen\", FACTION)\n</code></pre> <ol> <li>Save the file and restart your server</li> <li>Test by joining and creating a character - \"Citizens\" should appear as an option</li> </ol>"},{"location":"gettingstarted/#faction-properties","title":"Faction Properties","text":"Property Purpose Example <code>name</code> Display name <code>\"Police Department\"</code> <code>desc</code> Description <code>\"Law enforcement officers\"</code> <code>color</code> UI color <code>Color(0, 100, 255)</code> <code>isDefault</code> Joinable by players <code>true</code> or <code>false</code> <code>models</code> Player models <code>{\"models/player/police.mdl\"}</code> <code>weapons</code> Starting weapons <code>{\"weapon_pistol\"}</code> <code>items</code> Starting items <code>{\"item_badge\"}</code> <code>health</code> Max health <code>120</code> <code>armor</code> Armor value <code>50</code>"},{"location":"gettingstarted/#expanding-your-server","title":"Expanding Your Server","text":"<p>After basic factions work, you can add: - Additional factions (police, medical, etc.) - Weapons for specific factions - Custom health/armor values - Faction size limits</p> <p>For more faction options, see the Faction Guide.</p>"},{"location":"gettingstarted/#step-4-create-classes","title":"Step 4: Create Classes","text":"<p>Classes are specialized roles within factions. Think of them as sub-factions or regiments - specialized units within a larger organization.</p> <p>Examples:</p> <ul> <li> <p>Police Department: Officer, Detective, SWAT, Chief</p> </li> <li> <p>Army: Infantry, Sniper, Medic, Tank Commander</p> </li> <li> <p>Galactic Empire: Stormtrooper, Scout Trooper, Imperial Officer, Dark Trooper</p> </li> </ul> <p>Skip this if you only need basic factions. Classes work well for military, law enforcement, or complex organizational structures.</p>"},{"location":"gettingstarted/#file-location_1","title":"File Location","text":"<p>Place class files in your schema folder: <pre><code>garrysmod/gamemodes/YOUR_SCHEMA/schema/classes/\n</code></pre></p>"},{"location":"gettingstarted/#create-a-police-officer-class","title":"Create a Police Officer Class","text":"<p>First create a police faction, then add this class file:</p> <pre><code>-- Police Officer Class\nCLASS.name = \"Police Officer\"\nCLASS.desc = \"A basic law enforcement officer\"\nCLASS.faction = FACTION_POLICE\n\nCLASS.model = \"models/player/police.mdl\"\n\nCLASS.health = 120  -- More health than citizens\nCLASS.armor = 50    -- Police armor\n\nCLASS.weapons = {\n    \"weapon_pistol\",\n    \"weapon_stunstick\"\n}\n\nlia.class.register(\"police_officer\", CLASS)\n</code></pre>"},{"location":"gettingstarted/#when-to-use-classes","title":"When to Use Classes","text":"<p>Use classes for specialized units within factions:</p> <ul> <li>Military regiments: Infantry, Snipers, Medics, Engineers, Tank Commanders</li> <li>Law enforcement units: Patrol Officers, Detectives, SWAT, K-9 Units</li> <li>Medical divisions: Doctors, Surgeons, EMTs, Specialists</li> <li>Criminal organizations: Enforcers, Lieutenants, Capos, Bosses</li> <li>Sci-fi factions: Stormtroopers, Scout Troopers, Imperial Officers, Elite Guards</li> </ul>"},{"location":"gettingstarted/#faction-vs-class","title":"Faction vs Class","text":"Level Purpose Example Scope Faction Main organization \"United States Army\" Broad group everyone belongs to Class Specialized regiment \"Sniper Regiment\" Elite/specialized role within faction Faction Government \"Galactic Empire\" Large overarching group Class Military branch \"Stormtrooper Corps\" Specific military unit type <p>Classes are sub-factions that inherit from their parent faction but can have unique abilities, equipment, and restrictions.</p> <p>For more class options, see the Class Guide.</p>"},{"location":"gettingstarted/#step-5-customize-weapons","title":"Step 5: Customize Weapons","text":"<p>Weapon customization changes how weapons appear in inventories, shops, and gameplay. Most servers can skip this initially.</p>"},{"location":"gettingstarted/#why-customize-weapons","title":"Why Customize Weapons","text":"<ul> <li>Change weapon names (e.g., \"Pistol\" \u2192 \"Beretta 92FS\")</li> <li>Set prices for buying/selling</li> <li>Control weapon access</li> <li>Adjust inventory space usage</li> </ul>"},{"location":"gettingstarted/#basic-customization","title":"Basic Customization","text":"<p>Add this code to your schema's <code>sh_init.lua</code> file:</p> <pre><code>-- Customize pistol\nlia.item.addWeaponOverride(\"weapon_pistol\", {\n    name = \"9mm Pistol\",\n    price = 500,\n    desc = \"A standard police sidearm\"\n})\n\n-- Make shotgun expensive\nlia.item.addWeaponOverride(\"weapon_shotgun\", {\n    name = \"Combat Shotgun\",\n    price = 2500,\n    flag = \"s\"\n})\n</code></pre> <p>Add this code before <code>lia.item.generateWeapons()</code> is called.</p>"},{"location":"gettingstarted/#available-options","title":"Available Options","text":"Property Purpose Example <code>name</code> Display name <code>\"Police Pistol\"</code> <code>desc</code> Description <code>\"Standard issue firearm\"</code> <code>price</code> Shop price <code>1000</code> <code>flag</code> Required permission <code>\"p\"</code> <code>width</code>/<code>height</code> Inventory size <code>width = 3, height = 2</code> <code>ammo</code> Ammo type <code>\"pistol\"</code> <code>ammoAmount</code> Magazine size <code>17</code> <p>For more weapon options, see the Weapon Guide.</p>"},{"location":"gettingstarted/#step-6-add-extra-features-with-modules","title":"Step 6: Add Extra Features with Modules","text":"<p>Modules are plugins that add new features to your server.</p>"},{"location":"gettingstarted/#installing-a-module","title":"Installing a Module","text":"<ol> <li>Browse the modules at Lilia Modules Documentation</li> <li>Find the module you want and click on it to go to its \"About\" page</li> <li>Click the \"DOWNLOAD HERE\" link to download the specific module ZIP</li> <li>Extract the ZIP file</li> <li>Upload the module folder to <code>garrysmod/gamemodes/YOUR_SCHEMA/modules/</code></li> <li>Restart your server</li> </ol>"},{"location":"gettingstarted/#verify-installation_1","title":"Verify Installation","text":"<ul> <li>Check server console for success messages</li> <li>Test new features in-game</li> <li>Review module documentation for additional setup</li> </ul>"},{"location":"gettingstarted/#module-guidelines","title":"Module Guidelines","text":"<ul> <li>Start with a few modules rather than installing everything</li> <li>Read module instructions for any special setup requirements</li> <li>Ensure compatibility with your schema</li> <li>Back up your server before adding modules</li> </ul> <p>Browse all available modules in the Modules Section.</p>"},{"location":"gettingstarted/#troubleshooting","title":"Troubleshooting","text":"<p>Common Issues: - Server not starting: Check console for error messages - Features not working: Ensure server restart after changes - Players can't join factions: Verify <code>isDefault = true</code></p> <p>Resources: - Complete Documentation - Detailed guides - Discord Community - Support and discussion - GitHub Issues - Bug reports</p>"},{"location":"gettingstarted/#best-practices","title":"Best Practices","text":"<ul> <li>Start with basic features before adding complex ones</li> <li>Back up your server before making changes</li> <li>Test new features regularly</li> <li>Listen to player feedback for improvements</li> </ul>"},{"location":"installation/","title":"Installation Guide","text":"<p>Install the Lilia framework on your Garry's Mod server using Steam Workshop.</p> <p>Important: Lilia is a framework that runs beneath a roleplay schema. After installing Lilia, you must also install a schema and start your server using that schema's gamemode (e.g., <code>+gamemode skeleton</code>).</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>A working Garry's Mod server</li> <li>Basic server administration knowledge</li> <li>Internet connection for Workshop downloads</li> </ul> <p>Admin Tools: Lilia includes a built-in admin menu. SAM is also compatible. ULX is not supported.</p>"},{"location":"installation/#installation-steps","title":"Installation Steps","text":""},{"location":"installation/#step-1-subscribe-to-lilia","title":"Step 1: Subscribe to Lilia","text":"<ol> <li>Visit the Lilia Framework Workshop page</li> <li>Click \"Subscribe\" to download Lilia to your Garry's Mod installation</li> <li>Workshop ID: <code>3527535922</code></li> </ol>"},{"location":"installation/#step-2-configure-server-workshop","title":"Step 2: Configure Server Workshop","text":"<ol> <li>Create a Steam Workshop collection that includes the Lilia Framework</li> <li>Add this parameter to your server startup options:</li> </ol> <pre><code>+host_workshop_collection &lt;YourCollectionID&gt;\n</code></pre> <p>Note: Replace <code>&lt;YourCollectionID&gt;</code> with your Workshop collection ID. Add this to your server's startup parameters, not <code>server.cfg</code>.</p> <ol> <li>The server will automatically download Lilia when it starts</li> </ol> <p>Warning: Workshop errors will prevent Lilia from loading. Ensure your server has stable internet connectivity and monitor the console for errors during startup.</p>"},{"location":"installation/#step-3-install-a-schema","title":"Step 3: Install a Schema","text":"<ol> <li>Download a schema (e.g., Skeleton Schema)</li> <li>Extract and upload to <code>garrysmod/gamemodes/&lt;SchemaName&gt;/</code></li> <li>Add this to your server startup options:</li> </ol> <pre><code>+gamemode &lt;SchemaName&gt;\n</code></pre> <p>Example: <code>+gamemode skeleton</code></p>"},{"location":"installation/#step-4-start-your-server","title":"Step 4: Start Your Server","text":"<p>Launch your server and watch the console for:</p> <pre><code>[Lilia] [Bootstrap] Loaded successfully after X seconds.\n</code></pre> <p>If you see this message and no errors, Lilia is working correctly.</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<p>\"Gamemode 'skeleton' is missing\" - Check that your schema is installed in <code>garrysmod/gamemodes/</code> with the correct folder name</p> <p>Workshop items not downloading - Verify internet connection and Workshop parameters in startup options (not <code>server.cfg</code>)</p> <p>\"Lilia framework not found\" - Ensure you're subscribed to the Lilia Workshop addon and check console for download messages</p> <p>Server won't start with new gamemode - Verify <code>+gamemode &lt;SchemaName&gt;</code> is set in your server startup options</p> <p>Need more help? - Check server console for error messages - Visit Lilia Discord for community support - Review GitHub Issues for known problems</p>"},{"location":"definitions/attributes/","title":"Attribute Definitions","text":"<p>Character attribute definition system for the Lilia framework.</p> <p>Overview</p> <p>The attribute system provides functionality for defining character attributes within the Lilia framework. Attributes represent character statistics that can be modified, boosted, and used in gameplay calculations. The system includes automatic attribute loading from directories, localization support for attribute names and descriptions, and hooks for custom attribute behavior. Attributes can be configured with maximum values, starting limits, and whether they appear in character creation. The system supports attribute boosts through the character system and validation through callback methods that are automatically invoked during character setup.</p>"},{"location":"definitions/attributes/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the attribute</p> <p>When Called</p> <p>During attribute definition</p> <p>Example Usage</p> <pre><code>ATTRIBUTE.name = \"Strength\"\n</code></pre>"},{"location":"definitions/attributes/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the attribute that appears in tooltips and UI</p> <p>When Called</p> <p>During attribute definition</p> <p>Example Usage</p> <pre><code>ATTRIBUTE.desc = \"Physical power and muscle strength. Affects melee damage and carrying capacity.\"\n</code></pre>"},{"location":"definitions/attributes/#maxvalue","title":"maxValue","text":"<p>Purpose</p> <p>Sets the maximum value this attribute can reach</p> <p>When Called</p> <p>During attribute definition (used by GetAttributeMax hook)</p> <p>Example Usage</p> <pre><code>ATTRIBUTE.maxValue = 50\n</code></pre>"},{"location":"definitions/attributes/#startingmax","title":"startingMax","text":"<p>Purpose</p> <p>Sets the maximum value this attribute can have during character creation</p> <p>When Called</p> <p>During attribute definition (used by GetAttributeStartingMax hook)</p> <p>Example Usage</p> <pre><code>ATTRIBUTE.startingMax = 20\n</code></pre>"},{"location":"definitions/attributes/#nostartbonus","title":"noStartBonus","text":"<p>Purpose</p> <p>Prevents this attribute from appearing in character creation attribute allocation</p> <p>When Called</p> <p>During attribute definition (checked in character creation UI)</p> <p>Example Usage</p> <pre><code>ATTRIBUTE.noStartBonus = true\n</code></pre>"},{"location":"definitions/attributes/#onsetup","title":"OnSetup","text":"<p>Purpose</p> <p>Hook function called when setting up attributes for a character</p> <p>When Called</p> <p>When a character spawns or when their attributes are initialized</p> <p>Realm</p> <p>Server</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client whose character is being set up</li> <li><code>value</code> (number): The current attribute value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example Usage</p> <pre><code>function ATTRIBUTE:OnSetup(client, value)\n    local char = client:getChar()\n    if not char then return end\n        -- Set default attribute value if not already set\n        if value == 0 then\n            char:setAttrib(self.uniqueID, 10)\n            end\n        end\n</code></pre>"},{"location":"definitions/class/","title":"Class Definitions","text":"<p>Character class definition system for the Lilia framework.</p> <p>Overview</p> <p>The class system provides comprehensive functionality for defining character classes within the Lilia framework. Classes represent specific roles or professions that characters can assume within factions, creating a hierarchical structure where factions serve as parent containers for classes.</p> <p>Faction-Class Relationship:</p> <ul> <li> <p>Factions are the main organizational units (Citizens, Police, Medical, etc.)</p> </li> <li> <p>Classes are sub-divisions within factions (Officer, Detective, Captain within Police)</p> </li> <li> <p>Each character belongs to exactly ONE faction and ONE class within that faction</p> </li> <li> <p>Classes inherit all properties from their parent faction by default</p> </li> <li> <p>CLASS settings overpower FACTION settings - any property defined in a class takes precedence over the same property in the parent faction.</p> </li> </ul> <p>Example Hierarchy: <pre><code>Faction: Police Department\n\u251c\u2500\u2500 Class: Police Officer (inherits police models, weapons, color)\n\u251c\u2500\u2500 Class: Police Detective (inherits police properties, overrides with detective-specific items)\n\u251c\u2500\u2500 Class: Police Captain (inherits police properties, overrides with command-specific permissions)\n\u2514\u2500\u2500 Class: SWAT Officer (inherits police properties, overrides with tactical gear)\n</code></pre></p> <p>Classes are defined using the CLASS table structure, which includes properties for identification, visual representation, gameplay mechanics, and access control. The system includes callback methods that are automatically invoked during key character lifecycle events, enabling dynamic behavior and customization.</p> <p>Classes can have player limits, whitelist requirements, specialized loadouts, and attribute modifications that affect gameplay. The system supports modifying player health, armor, movement speeds, model scale, weapons, and NPC relationships, providing a flexible foundation for role-based gameplay systems.</p> <p>Access Control: Classes use the <code>isWhitelisted</code> property to require whitelist access, and the <code>OnCanBe</code> callback method to implement custom permission logic. The <code>OnCanBe</code> callback is called when a player attempts to join a class and can check attributes, permissions, or any other conditions before allowing access.</p> <p>In addition to the CLASS table properties, classes can also modify character variables such as classwhitelists to control which classes a character has access to.</p>"},{"location":"definitions/class/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the character class</p> <p>When Called</p> <p>During class definition</p> <p>Example Usage</p> <pre><code>CLASS.name = \"Police Officer\"\n</code></pre>"},{"location":"definitions/class/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the character class</p> <p>When Called</p> <p>During class definition</p> <p>Example Usage</p> <pre><code>CLASS.desc = \"A law enforcement officer responsible for maintaining order\"\n</code></pre>"},{"location":"definitions/class/#faction","title":"faction","text":"<p>Purpose</p> <p>Sets the faction ID this class belongs to</p> <p>When Called</p> <p>During class definition</p> <p>Example Usage</p> <pre><code>CLASS.faction = FACTION_POLICE\n</code></pre>"},{"location":"definitions/class/#limit","title":"limit","text":"<p>Purpose</p> <p>Sets the maximum number of players allowed in this class</p> <p>When Called</p> <p>During class definition</p> <p>Example Usage</p> <pre><code>CLASS.limit = 5  -- Maximum 5 players\nCLASS.limit = 0  -- Unlimited players\n</code></pre>"},{"location":"definitions/class/#model","title":"model","text":"<p>Purpose</p> <p>Sets the player model for this class</p> <p>When Called</p> <p>During class definition</p> <p>Example Usage</p> <pre><code>CLASS.model = \"models/player/barney.mdl\"\n</code></pre>"},{"location":"definitions/class/#iswhitelisted","title":"isWhitelisted","text":"<p>Purpose</p> <p>Sets whether this class requires whitelist access</p> <p>When Called</p> <p>During class definition</p> <p>Example Usage</p> <pre><code>CLASS.isWhitelisted = true  -- Requires whitelist permission to join\n</code></pre> <p>Note Complexity: <pre><code>\n</code></pre></p>"},{"location":"definitions/class/#isdefault","title":"isDefault","text":"<p>Purpose</p> <p>Sets whether this is the default class for the faction</p> <p>When Called</p> <p>During class definition</p> <p>Example Usage</p> <pre><code>CLASS.isDefault = true\n</code></pre>"},{"location":"definitions/class/#scoreboardhidden","title":"scoreboardHidden","text":"<p>Purpose</p> <p>Hides this class from the scoreboard display</p> <p>When Called</p> <p>During class definition</p> <p>Example Usage</p> <pre><code>CLASS.scoreboardHidden = true  -- Class will not appear in scoreboard categories\n</code></pre>"},{"location":"definitions/class/#pay","title":"pay","text":"<p>Purpose</p> <p>Sets the salary amount for this class</p> <p>When Called</p> <p>During class definition</p> <p>Example Usage</p> <pre><code>CLASS.pay = 100  -- $100 salary\n</code></pre>"},{"location":"definitions/class/#uniqueid","title":"uniqueID","text":"<p>Purpose</p> <p>Unique identifier for the class (INTERNAL - set automatically when registered)</p> <p>When Called</p> <p>Set automatically during class registration Note: This property is internal and should not be modified directly</p> <p>Example Usage</p> <pre><code>-- This is set automatically when you register the class\nlia.class.register(\"police_officer\", {\nname = \"Police Officer\",\n-- uniqueID will be \"police_officer\"\n})\n</code></pre>"},{"location":"definitions/class/#index","title":"index","text":"<p>Purpose</p> <p>Numeric index of the class in the class list (set automatically)</p> <p>When Called</p> <p>Set automatically during class registration</p> <p>Example Usage</p> <pre><code>-- This is set automatically when you register the class\nlia.class.register(\"police_officer\", {\nname = \"Police Officer\",\n-- index will be assigned based on registration order\n})\n</code></pre>"},{"location":"definitions/class/#color","title":"Color","text":"<p>Purpose</p> <p>Sets the team/class color for UI elements and identification</p> <p>When Called</p> <p>During class definition</p> <p>Example Usage</p> <pre><code>CLASS.Color = Color(0, 100, 255)  -- Blue color for police\n</code></pre>"},{"location":"definitions/class/#health","title":"health","text":"<p>Purpose</p> <p>Sets the maximum health for players in this class</p> <p>When Called</p> <p>During class definition (applied when player joins class)</p> <p>Example Usage</p> <pre><code>CLASS.health = 150  -- Police officers have 150 max health\n</code></pre>"},{"location":"definitions/class/#armor","title":"armor","text":"<p>Purpose</p> <p>Sets the armor value for players in this class</p> <p>When Called</p> <p>During class definition (applied when player joins class)</p> <p>Example Usage</p> <pre><code>CLASS.armor = 50  -- Police officers have 50 armor\n</code></pre>"},{"location":"definitions/class/#weapons","title":"weapons","text":"<p>Purpose</p> <p>Sets weapons to give to players when they join this class</p> <p>When Called</p> <p>During class definition (applied when player spawns)</p> <p>Example Usage</p> <pre><code>CLASS.weapons = {\"weapon_pistol\", \"weapon_stunstick\"}  -- Table of weapons\nCLASS.weapons = \"weapon_crowbar\"  -- Single weapon string\n</code></pre>"},{"location":"definitions/class/#scale","title":"scale","text":"<p>Purpose</p> <p>Sets the model scale for players in this class</p> <p>When Called</p> <p>During class definition (applied when player joins class)</p> <p>Example Usage</p> <pre><code>CLASS.scale = 1.1  -- Slightly larger model\n</code></pre>"},{"location":"definitions/class/#runspeed","title":"runSpeed","text":"<p>Purpose</p> <p>Sets the running speed for players in this class</p> <p>When Called</p> <p>During class definition (applied when player joins class)</p> <p>Example Usage</p> <pre><code>CLASS.runSpeed = 300  -- Absolute run speed\nCLASS.runSpeedMultiplier = true\nCLASS.runSpeed = 1.2  -- 20% faster than default\n</code></pre>"},{"location":"definitions/class/#walkspeed","title":"walkSpeed","text":"<p>Purpose</p> <p>Sets the walking speed for players in this class</p> <p>When Called</p> <p>During class definition (applied when player joins class)</p> <p>Example Usage</p> <pre><code>CLASS.walkSpeed = 150  -- Absolute walk speed\nCLASS.walkSpeedMultiplier = true\nCLASS.walkSpeed = 1.1  -- 10% faster than default\n</code></pre>"},{"location":"definitions/class/#jumppower","title":"jumpPower","text":"<p>Purpose</p> <p>Sets the jump power for players in this class</p> <p>When Called</p> <p>During class definition (applied when player joins class)</p> <p>Example Usage</p> <pre><code>CLASS.jumpPower = 200  -- Absolute jump power\nCLASS.jumpPowerMultiplier = true\nCLASS.jumpPower = 1.3  -- 30% higher jump\n</code></pre>"},{"location":"definitions/class/#npcrelations","title":"NPCRelations","text":"<p>Purpose</p> <p>Sets NPC relationship overrides for this class (inherits from faction)</p> <p>When Called</p> <p>During class definition (applied when player joins class)</p> <p>Example Usage</p> <pre><code>CLASS.NPCRelations = {\n[\"npc_metropolice\"] = D_LI,  -- Police are liked by metropolice\n[\"npc_citizen\"] = D_NU       -- Neutral to citizens\n}\n</code></pre>"},{"location":"definitions/class/#bloodcolor","title":"bloodcolor","text":"<p>Purpose</p> <p>Sets the blood color for players in this class</p> <p>When Called</p> <p>During class definition (applied when player joins class)</p> <p>Example Usage</p> <pre><code>CLASS.bloodcolor = BLOOD_COLOR_RED  -- Red blood\nCLASS.bloodcolor = BLOOD_COLOR_YELLOW  -- Yellow blood for aliens\n</code></pre>"},{"location":"definitions/class/#runspeedmultiplier","title":"runSpeedMultiplier","text":"<p>Purpose</p> <p>Whether runSpeed should be treated as a multiplier instead of absolute value</p> <p>When Called</p> <p>During class definition (used with runSpeed property)</p> <p>Example Usage</p> <pre><code>CLASS.runSpeedMultiplier = true\nCLASS.runSpeed = 1.2  -- 20% faster than default\n</code></pre>"},{"location":"definitions/class/#walkspeedmultiplier","title":"walkSpeedMultiplier","text":"<p>Purpose</p> <p>Whether walkSpeed should be treated as a multiplier instead of absolute value</p> <p>When Called</p> <p>During class definition (used with walkSpeed property)</p> <p>Example Usage</p> <pre><code>CLASS.walkSpeedMultiplier = true\nCLASS.walkSpeed = 1.1  -- 10% faster than default\n</code></pre>"},{"location":"definitions/class/#jumppowermultiplier","title":"jumpPowerMultiplier","text":"<p>Purpose</p> <p>Whether jumpPower should be treated as a multiplier instead of absolute value</p> <p>When Called</p> <p>During class definition (used with jumpPower property)</p> <p>Example Usage</p> <pre><code>CLASS.jumpPowerMultiplier = true\nCLASS.jumpPower = 1.3  -- 30% higher jump\n</code></pre>"},{"location":"definitions/class/#oncanbe","title":"OnCanBe","text":"<p>Purpose</p> <p>Check if a player can join this class</p> <p>When Called</p> <p>When a player attempts to join this class</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player trying to join</li> </ul> <p>Returns</p> <ul> <li>true to allow, false to deny</li> </ul> <p>Example Usage</p> <pre><code>function CLASS:OnCanBe(client)\n    local char = client:getChar()\n    if char then\n        -- Check character attributes\n        if char:getAttrib(\"str\", 0) &lt; 10 then\n            client:notify(\"You need at least 10 strength to join this class.\")\n            return false\n            end\n        -- Check permissions (use framework permission system)\n        if not client:hasFlags(\"P\") then  -- Example permission flag\n            client:notify(\"You don't have permission to join this class.\")\n            return false\n            end\n        -- Check custom conditions\n        if char:getData(\"banned_from_class\", false) then\n            client:notify(\"You are banned from this class.\")\n            return false\n            end\n        end\n    return true\n    end\n</code></pre>"},{"location":"definitions/class/#onset","title":"OnSet","text":"<p>Purpose</p> <p>Called when a player joins this class</p> <p>When Called</p> <p>When a player is assigned to this class</p> <p>Realm</p> <p>Server</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player joining the class</li> </ul> <p>Example Usage</p> <pre><code>function CLASS:OnSet(client)\n    client:notify(\"Welcome to \" .. self.name)\n    end\n</code></pre>"},{"location":"definitions/class/#ontransferred","title":"OnTransferred","text":"<p>Purpose</p> <p>Called when switching from another class to this class</p> <p>When Called</p> <p>When a player switches classes and this becomes the new class</p> <p>Realm</p> <p>Server</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player switching classes</li> <li><code>oldClass</code> (table): The previous class data</li> </ul> <p>Example Usage</p> <pre><code>function CLASS:OnTransferred(client, oldClass)\n    if oldClass then\n        client:notify(\"Switched from \" .. oldClass.name .. \" to \" .. self.name)\n        end\n    end\n</code></pre>"},{"location":"definitions/class/#onspawn","title":"OnSpawn","text":"<p>Purpose</p> <p>Called when a player spawns with this class</p> <p>When Called</p> <p>When a player spawns with this class</p> <p>Realm</p> <p>Server</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player spawning</li> </ul> <p>Example Usage</p> <pre><code>function CLASS:OnSpawn(client)\n    client:Give(\"weapon_stunstick\")\n    client:SetHealth(150)\n    client:SetArmor(50)\n    end\n</code></pre>"},{"location":"definitions/class/#onleave","title":"OnLeave","text":"<p>Purpose</p> <p>Called when leaving this class</p> <p>When Called</p> <p>When a player leaves this class</p> <p>Realm</p> <p>Server</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player leaving</li> </ul> <p>Example Usage</p> <pre><code>function CLASS:OnLeave(client)\n    client:StripWeapon(\"weapon_stunstick\")\n    end\n</code></pre>"},{"location":"definitions/faction/","title":"Faction Definitions","text":"<p>Character faction definition system for the Lilia framework.</p> <p>Overview</p> <p>The faction system provides comprehensive functionality for defining character factions within the Lilia framework. Factions represent the main organizational units that characters belong to, serving as parent containers for classes. Each character belongs to exactly ONE faction and can have multiple classes within that faction.</p> <p>Faction-Class Relationship:</p> <ul> <li> <p>Factions are the main organizational units (Citizens, Police, Medical, Staff)</p> </li> <li> <p>Classes are sub-divisions within factions (Officer, Detective, Captain within Police)</p> </li> <li> <p>Each character belongs to exactly ONE faction but can switch between classes within that faction</p> </li> <li> <p>CLASS settings overpower FACTION settings - any property defined in a class takes precedence over the same property in the parent faction.</p> </li> </ul> <p>Example Hierarchy: <pre><code>Faction: Police Department\n\u251c\u2500\u2500 Class: Police Officer (inherits police models, weapons, color)\n\u251c\u2500\u2500 Class: Police Detective (inherits police properties, overrides with detective-specific items)\n\u251c\u2500\u2500 Class: Police Captain (inherits police properties, overrides with command-specific permissions)\n\u2514\u2500\u2500 Class: SWAT Officer (inherits police properties, overrides with tactical gear)\n</code></pre></p> <p>Factions are defined using the FACTION table structure, which includes properties for identification, visual representation, gameplay mechanics, and access control. The system includes callback methods that are automatically invoked during key character lifecycle events, enabling dynamic behavior and customization.</p> <p>Factions can have player limits, whitelist requirements, specialized loadouts, and attribute modifications that affect gameplay. The system supports modifying player health, armor, movement speeds, model scale, weapons, and NPC relationships, providing a flexible foundation for role-based gameplay systems.</p> <p>Player Management: Factions support player limits (absolute or percentage-based), character restrictions (one character per player), custom name generation templates, and custom limit checking logic for advanced access control scenarios.</p> <p>Access Control: Factions use the <code>isDefault</code> property to determine if they are accessible to all players, and can implement custom permission logic through whitelist systems and the framework's permission system.</p> <p>In addition to the FACTION table properties, factions can also modify character variables such as classwhitelists to control which classes a character has access to within the faction.</p>"},{"location":"definitions/faction/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the character faction</p> <p>When Called</p> <p>During faction definition</p> <p>Example Usage</p> <pre><code>FACTION.name = \"Police Department\"\n</code></pre>"},{"location":"definitions/faction/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the character faction</p> <p>When Called</p> <p>During faction definition</p> <p>Example Usage</p> <pre><code>FACTION.desc = \"Law enforcement officers responsible for maintaining order and protecting citizens\"\n</code></pre>"},{"location":"definitions/faction/#color","title":"color","text":"<p>Purpose</p> <p>Sets the team/faction color for UI elements and identification</p> <p>When Called</p> <p>During faction definition</p> <p>Example Usage</p> <pre><code>FACTION.color = Color(0, 100, 255)  -- Blue color for police\n</code></pre>"},{"location":"definitions/faction/#models","title":"models","text":"<p>Purpose</p> <p>Sets the player models available for this faction</p> <p>When Called</p> <p>During faction definition</p> <p>Example Usage</p> <pre><code>FACTION.models = {\"models/player/police.mdl\", \"models/player/swat.mdl\"}\n-- Advanced: Complex model data with bodygroups\nFACTION.models = {\n\"male\" = {\n{\"models/player/police_male.mdl\", \"Male Officer\", {1, 2, 3}},\n{\"models/player/swat_male.mdl\", \"Male SWAT\", {0, 1, 2, 3}}\n},\n\"female\" = {\n{\"models/player/police_female.mdl\", \"Female Officer\", {1, 2}},\n{\"models/player/swat_female.mdl\", \"Female SWAT\", {0, 1, 2}}\n}\n}\n</code></pre>"},{"location":"definitions/faction/#weapons","title":"weapons","text":"<p>Purpose</p> <p>Sets weapons to give to players when they join this faction</p> <p>When Called</p> <p>During faction definition (applied when player spawns)</p> <p>Example Usage</p> <pre><code>FACTION.weapons = {\"weapon_pistol\", \"weapon_stunstick\"}  -- Table of weapons\nFACTION.weapons = \"weapon_crowbar\"  -- Single weapon string\n</code></pre>"},{"location":"definitions/faction/#isdefault","title":"isDefault","text":"<p>Purpose</p> <p>Sets whether this is a default faction that new characters can join</p> <p>When Called</p> <p>During faction definition</p> <p>Example Usage</p> <pre><code>FACTION.isDefault = true  -- Players can create characters in this faction\nFACTION.isDefault = false  -- Requires special permission or whitelist\n</code></pre>"},{"location":"definitions/faction/#uniqueid","title":"uniqueID","text":"<p>Purpose</p> <p>Unique identifier for the faction (INTERNAL - set automatically when registered)</p> <p>When Called</p> <p>Set automatically during faction registration Note: This property is internal and should not be modified directly Auto-Assignment: If not explicitly defined, the uniqueID is automatically set to the faction file name (without .lua extension)</p> <p>Example Usage</p> <pre><code>-- This is set automatically when you register the faction\nlia.faction.register(\"police\", {\nname = \"Police Department\",\n-- uniqueID will be \"police\"\n})\n-- For faction files, uniqueID is set to the filename\n-- File: factions/police.lua -&gt; uniqueID = \"police\"\n-- File: factions/sh_police.lua -&gt; uniqueID = \"police\" (sh_ prefix removed)\n-- File: factions/citizen.lua -&gt; uniqueID = \"citizen\"\n</code></pre>"},{"location":"definitions/faction/#index","title":"index","text":"<p>Purpose</p> <p>Numeric index of the faction in the faction list (set automatically or manually)</p> <p>When Called</p> <p>Set automatically during faction registration, or manually specified</p> <p>Example Usage</p> <pre><code>-- This is set automatically when you register the faction\nlia.faction.register(\"police\", {\nname = \"Police Department\",\n-- index will be assigned based on registration order\n})\n-- Or manually specify the team index\nFACTION.index = 2  -- Will use team index 2\n</code></pre>"},{"location":"definitions/faction/#health","title":"health","text":"<p>Purpose</p> <p>Sets the maximum health for players in this faction</p> <p>When Called</p> <p>During faction definition (applied when player joins faction)</p> <p>Example Usage</p> <pre><code>FACTION.health = 120  -- Police officers have 120 max health\n</code></pre>"},{"location":"definitions/faction/#armor","title":"armor","text":"<p>Purpose</p> <p>Sets the armor value for players in this faction</p> <p>When Called</p> <p>During faction definition (applied when player joins faction)</p> <p>Example Usage</p> <pre><code>FACTION.armor = 50  -- Standard police armor\n</code></pre>"},{"location":"definitions/faction/#scale","title":"scale","text":"<p>Purpose</p> <p>Sets the model scale for players in this faction</p> <p>When Called</p> <p>During faction definition (applied when player joins faction)</p> <p>Example Usage</p> <pre><code>FACTION.scale = 1.1  -- Slightly larger model\n</code></pre>"},{"location":"definitions/faction/#runspeed","title":"runSpeed","text":"<p>Purpose</p> <p>Sets the running speed for players in this faction</p> <p>When Called</p> <p>During faction definition (applied when player joins faction)</p> <p>Example Usage</p> <pre><code>FACTION.runSpeed = 300  -- Absolute run speed\nFACTION.runSpeedMultiplier = true\nFACTION.runSpeed = 1.2  -- 20% faster than default\n</code></pre>"},{"location":"definitions/faction/#walkspeed","title":"walkSpeed","text":"<p>Purpose</p> <p>Sets the walking speed for players in this faction</p> <p>When Called</p> <p>During faction definition (applied when player joins faction)</p> <p>Example Usage</p> <pre><code>FACTION.walkSpeed = 150  -- Absolute walk speed\nFACTION.walkSpeedMultiplier = true\nFACTION.walkSpeed = 1.1  -- 10% faster than default\n</code></pre>"},{"location":"definitions/faction/#jumppower","title":"jumpPower","text":"<p>Purpose</p> <p>Sets the jump power for players in this faction</p> <p>When Called</p> <p>During faction definition (applied when player joins faction)</p> <p>Example Usage</p> <pre><code>FACTION.jumpPower = 200  -- Absolute jump power\nFACTION.jumpPowerMultiplier = true\nFACTION.jumpPower = 1.3  -- 30% higher jump\n</code></pre>"},{"location":"definitions/faction/#npcrelations","title":"NPCRelations","text":"<p>Purpose</p> <p>Sets NPC relationship overrides for this faction</p> <p>When Called</p> <p>During faction definition (applied when player joins faction)</p> <p>Example Usage</p> <pre><code>FACTION.NPCRelations = {\n[\"npc_metropolice\"] = D_LI,  -- Police are liked by metropolice\n[\"npc_citizen\"] = D_NU       -- Neutral to citizens\n}\n</code></pre>"},{"location":"definitions/faction/#bloodcolor","title":"bloodcolor","text":"<p>Purpose</p> <p>Sets the blood color for players in this faction</p> <p>When Called</p> <p>During faction definition (applied when player joins faction)</p> <p>Example Usage</p> <pre><code>FACTION.bloodcolor = BLOOD_COLOR_RED  -- Red blood\nFACTION.bloodcolor = BLOOD_COLOR_YELLOW  -- Yellow blood for aliens\n</code></pre>"},{"location":"definitions/faction/#runspeedmultiplier","title":"runSpeedMultiplier","text":"<p>Purpose</p> <p>Whether runSpeed should be treated as a multiplier instead of absolute value</p> <p>When Called</p> <p>During faction definition (used with runSpeed property)</p> <p>Example Usage</p> <pre><code>FACTION.runSpeedMultiplier = true\nFACTION.runSpeed = 1.2  -- 20% faster than default\n</code></pre>"},{"location":"definitions/faction/#walkspeedmultiplier","title":"walkSpeedMultiplier","text":"<p>Purpose</p> <p>Whether walkSpeed should be treated as a multiplier instead of absolute value</p> <p>When Called</p> <p>During faction definition (used with walkSpeed property)</p> <p>Example Usage</p> <pre><code>FACTION.walkSpeedMultiplier = true\nFACTION.walkSpeed = 1.1  -- 10% faster than default\n</code></pre>"},{"location":"definitions/faction/#jumppowermultiplier","title":"jumpPowerMultiplier","text":"<p>Purpose</p> <p>Whether jumpPower should be treated as a multiplier instead of absolute value</p> <p>When Called</p> <p>During faction definition (used with jumpPower property)</p> <p>Example Usage</p> <pre><code>FACTION.jumpPowerMultiplier = true\nFACTION.jumpPower = 1.3  -- 30% higher jump\n</code></pre>"},{"location":"definitions/faction/#items","title":"items","text":"<p>Purpose</p> <p>Sets items to give to characters when they are created in this faction</p> <p>When Called</p> <p>During faction definition (applied when character is created)</p> <p>Example Usage</p> <pre><code>FACTION.items = {\"item_police_badge\", \"item_handcuffs\"}  -- Starting items for police\n</code></pre>"},{"location":"definitions/faction/#onecharonly","title":"oneCharOnly","text":"<p>Purpose</p> <p>Sets whether players can only have one character in this faction</p> <p>When Called</p> <p>During faction definition</p> <p>Example Usage</p> <pre><code>FACTION.oneCharOnly = true  -- Players can only have one character in this faction\nFACTION.oneCharOnly = false  -- Players can have multiple characters in this faction\n</code></pre>"},{"location":"definitions/faction/#limit","title":"limit","text":"<p>Purpose</p> <p>Sets the maximum number of players allowed in this faction</p> <p>When Called</p> <p>During faction definition</p> <p>Example Usage</p> <pre><code>FACTION.limit = 8  -- Maximum 8 players in this faction\nFACTION.limit = 0  -- Unlimited players\nFACTION.limit = 0.1  -- 10% of total server players\n</code></pre>"},{"location":"definitions/faction/#nametemplate","title":"NameTemplate","text":"<p>Purpose</p> <p>Sets a function to generate default character names for this faction</p> <p>When Called</p> <p>During faction definition</p> <p>Example Usage</p> <pre><code>function FACTION:NameTemplate(info, client)\n    local index = math.random(1000, 9999)\n    return \"CP-\" .. index  -- Returns \"CP-1234\" style names for Civil Protection\n    end\n</code></pre>"},{"location":"definitions/faction/#getdefaultname","title":"GetDefaultName","text":"<p>Purpose</p> <p>Sets a method to get the default character name for this faction</p> <p>When Called</p> <p>During faction definition</p> <p>Example Usage</p> <pre><code>function FACTION:GetDefaultName(client)\n    return \"Citizen \" .. math.random(1000, 9999)\n    end\n</code></pre>"},{"location":"definitions/faction/#getdefaultdesc","title":"GetDefaultDesc","text":"<p>Purpose</p> <p>Sets a method to get the default character description for this faction</p> <p>When Called</p> <p>During faction definition</p> <p>Example Usage</p> <pre><code>function FACTION:GetDefaultDesc(client)\n    return \"A citizen of the city\"\n    end\n</code></pre>"},{"location":"definitions/faction/#onchecklimitreached","title":"OnCheckLimitReached","text":"<p>Purpose</p> <p>Custom callback to check if faction player limit is reached</p> <p>When Called</p> <p>When a player tries to join a faction that might be at capacity</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character trying to join</li> <li><code>client</code> (Player): The player whose character is joining</li> </ul> <p>Returns</p> <ul> <li>true if limit reached, false if not</li> </ul> <p>Example Usage</p> <pre><code>function FACTION:OnCheckLimitReached(character, client)\n    -- Custom logic for checking faction limits\n    -- For example, check player permissions, character attributes, etc.\n    -- Check if player has special permission to bypass limits\n    if client:hasFlags(\"L\") then\n        return false  -- Allow admins to bypass limits\n        end\n    -- Use default limit checking\n    return self:CheckFactionLimitReached(character, client)\n    end\n</code></pre>"},{"location":"definitions/faction/#ontransferred","title":"OnTransferred","text":"<p>Purpose</p> <p>Called when a player transfers to this faction</p> <p>When Called</p> <p>When a player changes factions and this becomes their new faction</p> <p>Realm</p> <p>Server</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player transferring to this faction</li> </ul> <p>Example Usage</p> <pre><code>function FACTION:OnTransferred(client)\n    client:notify(\"Welcome to the \" .. self.name)\n    -- Set up faction-specific data\n    -- Could trigger department assignment or training\n    end\n</code></pre>"},{"location":"definitions/faction/#onspawn","title":"OnSpawn","text":"<p>Purpose</p> <p>Called when a player spawns with this faction</p> <p>When Called</p> <p>When a player spawns with this faction</p> <p>Realm</p> <p>Server</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player spawning</li> </ul> <p>Example Usage</p> <pre><code>function FACTION:OnSpawn(client)\n    -- Apply faction-specific spawn effects\n    client:Give(\"weapon_stunstick\")\n    client:SetHealth(self.health or 100)\n    client:SetArmor(self.armor or 0)\n    end\n</code></pre>"},{"location":"definitions/module/","title":"Module Definitions","text":"<p>Module definition system for the Lilia framework.</p> <p>Overview</p> <p>The module system provides comprehensive functionality for defining modules within the Lilia framework. Modules represent self-contained systems that add specific functionality to the gamemode, each with unique properties, behaviors, and configuration options. The system supports both server-side logic for gameplay mechanics and client-side properties for user interface and experience. Modules are defined using the MODULE table structure, which includes properties for identification, metadata, dependencies, privileges, and configuration. The system includes callback methods that are automatically invoked during key module lifecycle events, enabling dynamic behavior and customization. Modules can have dependencies, privileges, network strings, and various configuration options, providing a flexible foundation for modular systems.</p>"},{"location":"definitions/module/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the module</p> <p>Example Usage</p> <pre><code>-- Set the display name for the module\nMODULE.name = \"Inventory System\"\n</code></pre>"},{"location":"definitions/module/#author","title":"author","text":"<p>Purpose</p> <p>Sets the author of the module</p> <p>Example Usage</p> <pre><code>-- Set the module author\nMODULE.author = \"Samael\"\n</code></pre>"},{"location":"definitions/module/#discord","title":"discord","text":"<p>Purpose</p> <p>Sets the Discord contact for the module author</p> <p>Example Usage</p> <pre><code>-- Set the Discord contact for support\nMODULE.discord = \"@liliaplayer\"\n</code></pre>"},{"location":"definitions/module/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the module</p> <p>Example Usage</p> <pre><code>-- Set a detailed description of what the module does\nMODULE.desc = \"A comprehensive inventory management system\"\n</code></pre>"},{"location":"definitions/module/#version","title":"version","text":"<p>Purpose</p> <p>Sets the version number of the module</p> <p>Example Usage</p> <pre><code>-- Set the module version number\nMODULE.version = 1.0\n</code></pre>"},{"location":"definitions/module/#versionid","title":"versionID","text":"<p>Purpose</p> <p>Sets the unique version identifier for the module</p> <p>Example Usage</p> <pre><code>-- Set a unique identifier for version tracking\nMODULE.versionID = \"private_inventory\"\n</code></pre>"},{"location":"definitions/module/#uniqueid","title":"uniqueID","text":"<p>Purpose</p> <p>Unique identifier for the module (INTERNAL - set automatically when loaded)</p> <p>When Called</p> <p>Set automatically during module loading Note: This property is internal and should not be modified directly</p> <p>Example Usage</p> <pre><code>-- This is set automatically when the module is loaded from its folder name\n-- Module in folder \"inventory\" will have uniqueID = \"inventory\"\n</code></pre>"},{"location":"definitions/module/#privileges","title":"Privileges","text":"<p>Purpose</p> <p>Sets the privileges required for this module</p> <p>Example Usage</p> <pre><code>-- Define required privileges for module access\nMODULE.Privileges = {\n{\nName = \"canManageInventory\",\nMin = 1\n}\n}\n</code></pre>"},{"location":"definitions/module/#dependencies","title":"Dependencies","text":"<p>Purpose</p> <p>Sets the file dependencies for this module</p> <p>Example Usage</p> <pre><code>-- Define required files for this module\nMODULE.Dependencies = {\n{\nFile = \"gridinv.lua\",\nType = \"shared\"\n}\n}\n</code></pre>"},{"location":"definitions/module/#networkstrings","title":"NetworkStrings","text":"<p>Purpose</p> <p>Sets the network strings used by this module</p> <p>Example Usage</p> <pre><code>-- Define network strings for client-server communication\nMODULE.NetworkStrings = {\"liaInventoryOpen\", \"liaInventorySync\"}\n</code></pre>"},{"location":"definitions/module/#workshopcontent","title":"WorkshopContent","text":"<p>Purpose</p> <p>Sets the Workshop content IDs required by this module</p> <p>Example Usage</p> <pre><code>-- Set required Workshop content (single ID or table of IDs)\nMODULE.WorkshopContent = \"1234567890\"\nMODULE.WorkshopContent = {\"1234567890\", \"0987654321\"}\n</code></pre>"},{"location":"definitions/module/#websounds","title":"WebSounds","text":"<p>Purpose</p> <p>Sets the web-hosted sound files used by this module</p> <p>Example Usage</p> <pre><code>-- Define web-hosted sound files for the module\nMODULE.WebSounds = {\n[\"sounds/beep.wav\"] = \"https://example.com/sounds/beep.wav\"\n}\n</code></pre>"},{"location":"definitions/module/#webimages","title":"WebImages","text":"<p>Purpose</p> <p>Sets the web-hosted image files used by this module</p> <p>Example Usage</p> <pre><code>-- Define web-hosted image files for the module\nMODULE.WebImages = {\n[\"icons/inventory.png\"] = \"https://example.com/icons/inventory.png\"\n}\n</code></pre>"},{"location":"definitions/module/#enabled","title":"enabled","text":"<p>Purpose</p> <p>Sets whether the module is enabled by default</p> <p>Example Usage</p> <pre><code>-- Enable or disable the module by default\nMODULE.enabled = true\n</code></pre>"},{"location":"definitions/module/#folder","title":"folder","text":"<p>Purpose</p> <p>Sets the folder path for the module Internal Variable: This is set automatically by the module system ]]</p>"},{"location":"definitions/module/#path","title":"path","text":"<p>Purpose</p> <p>Sets the file path for the module Internal Variable: This is set automatically by the module system ]]</p>"},{"location":"definitions/module/#variable","title":"variable","text":"<p>Purpose</p> <p>Sets the variable name for the module Internal Variable: This is set automatically by the module system ]]</p>"},{"location":"definitions/module/#loading","title":"loading","text":"<p>Purpose</p> <p>Sets whether the module is currently loading Internal Variable: This is set automatically by the module system ]]</p>"},{"location":"definitions/module/#onloaded","title":"OnLoaded","text":"<p>Purpose</p> <p>Called when the module is fully loaded</p> <p>When Called</p> <p>After all module files have been loaded and initialized</p> <p>Realm</p> <p>Shared (called on both server and client)</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Example Usage</p> <pre><code>-- Called after all module files are loaded\nfunction MODULE:OnLoaded()\n    print(\"Module loaded successfully!\")\n    end\n</code></pre>"},{"location":"definitions/panels/","title":"Panel Definitions","text":"<p>Comprehensive documentation for all Lilia VGUI panels.</p> <p>Overview</p> <p>This file contains detailed documentation for every panel in the Lilia framework. Each panel entry includes its purpose, explanation, usage scenarios, and available methods. This serves as a complete reference for developers working with Lilia's UI system, providing comprehensive information about panel functionality and parameters. The panels are organized into logical categories including character panels, attribute panels, basic UI panels, input/form panels, layout/container panels, specialized panels, inventory panels, and vendor panels. Each category groups related functionality together for easier navigation and understanding. Note: All panels documented below are actually implemented in the Lilia framework. A total of 60+ panels are available for use in UI development.</p>"},{"location":"definitions/panels/#liacharacterbiography","title":"liaCharacterBiography","text":"<p>Purpose</p> <p>Displays character biography information A panel that shows and allows editing of character biography text</p> <p>When Used</p> <p>In character creation, character info display, or biography editing interfaces ]]</p>"},{"location":"definitions/panels/#liacharacterfaction","title":"liaCharacterFaction","text":"<p>Purpose</p> <p>Displays and manages character faction selection A panel for selecting and displaying character factions</p> <p>When Used</p> <p>During character creation or faction management interfaces ]]</p>"},{"location":"definitions/panels/#liacharactermodel","title":"liaCharacterModel","text":"<p>Purpose</p> <p>Displays character model with customization options A model panel specifically designed for character model display and customization</p> <p>When Used</p> <p>In character creation, model selection, or character preview interfaces ]]</p>"},{"location":"definitions/panels/#liacharbgmusic","title":"liaCharBGMusic","text":"<p>Purpose</p> <p>Manages character background music selection A panel for selecting and previewing background music for characters</p> <p>When Used</p> <p>In character creation or settings interfaces ]]</p>"},{"location":"definitions/panels/#liacharacter","title":"liaCharacter","text":"<p>Purpose</p> <p>Main character display and management panel The primary panel for character information display and basic management</p> <p>When Used</p> <p>In character selection, character info screens, or character management interfaces ]]</p>"},{"location":"definitions/panels/#liacharacterconfirm","title":"liaCharacterConfirm","text":"<p>Purpose</p> <p>Character confirmation dialog A confirmation panel for character-related actions</p> <p>When Used</p> <p>When confirming character creation, deletion, or other character actions ]]</p>"},{"location":"definitions/panels/#liacharactercreation","title":"liaCharacterCreation","text":"<p>Purpose</p> <p>Character creation interface The main panel for creating new characters</p> <p>When Used</p> <p>During the character creation process ]]</p>"},{"location":"definitions/panels/#liacharactercreatestep","title":"liaCharacterCreateStep","text":"<p>Purpose</p> <p>Individual character creation step A panel representing a single step in character creation</p> <p>When Used</p> <p>As part of the character creation process ]]</p>"},{"location":"definitions/panels/#liaattribbar","title":"liaAttribBar","text":"<p>Purpose</p> <p>Displays attribute progress bar A progress bar specifically designed for displaying attribute values</p> <p>When Used</p> <p>In character creation, attribute display, or skill interfaces ]]</p>"},{"location":"definitions/panels/#liacharacterattribs","title":"liaCharacterAttribs","text":"<p>Purpose</p> <p>Character attributes management panel A panel for managing and displaying character attributes</p> <p>When Used</p> <p>In character creation, attribute allocation, or character info screens ]]</p>"},{"location":"definitions/panels/#liacharacterattribsrow","title":"liaCharacterAttribsRow","text":"<p>Purpose</p> <p>Individual attribute row in attributes panel A single row representing one attribute with controls</p> <p>When Used</p> <p>As part of the character attributes panel ]]</p>"},{"location":"definitions/panels/#liabutton","title":"liaButton","text":"<p>Purpose</p> <p>Styled button with Lilia theming A custom button panel with Lilia's visual styling and effects</p> <p>When Used</p> <p>Throughout the UI for interactive elements ]]</p>"},{"location":"definitions/panels/#liacustomfontbutton","title":"liaCustomFontButton","text":"<p>Purpose</p> <p>Button with custom font support A button panel that defaults to liaSmallFont but allows custom font specification while maintaining Lilia styling</p> <p>When Used</p> <p>Throughout the UI for interactive elements where custom fonts are needed ]]</p>"},{"location":"definitions/panels/#liacategory","title":"liaCategory","text":"<p>Purpose</p> <p>Category header for organizing UI elements A collapsible category header for grouping related UI elements</p> <p>When Used</p> <p>In settings panels, option menus, or any organized interface ]]</p>"},{"location":"definitions/panels/#liachatbox","title":"liaChatBox","text":"<p>Purpose</p> <p>Main chat interface The primary chat system interface with message display and input</p> <p>When Used</p> <p>For all chat communication in the game ]]</p>"},{"location":"definitions/panels/#liacheckbox","title":"liaCheckbox","text":"<p>Purpose</p> <p>Custom checkbox with Lilia styling A toggle checkbox with custom visual design</p> <p>When Used</p> <p>For boolean options, settings, or toggles ]]</p>"},{"location":"definitions/panels/#liasimplecheckbox","title":"liaSimpleCheckbox","text":"<p>Purpose</p> <p>Simple checkbox variant A simplified checkbox without complex styling</p> <p>When Used</p> <p>For basic boolean inputs where simple styling is preferred ]]</p>"},{"location":"definitions/panels/#liacharinfo","title":"liaCharInfo","text":"<p>Purpose</p> <p>Character information display A panel for displaying detailed character information</p> <p>When Used</p> <p>In character selection, info screens, or character management ]]</p>"},{"location":"definitions/panels/#liamenu","title":"liaMenu","text":"<p>Purpose</p> <p>Menu container panel A container panel designed for menu layouts</p> <p>When Used</p> <p>For main menus, submenus, or menu-based interfaces ]]</p>"},{"location":"definitions/panels/#liaclasses","title":"liaClasses","text":"<p>Purpose</p> <p>Character class selection A panel for selecting character classes or jobs</p> <p>When Used</p> <p>In character creation or class selection interfaces ]]</p>"},{"location":"definitions/panels/#liacombobox","title":"liaComboBox","text":"<p>Purpose</p> <p>Dropdown combo box A dropdown selection box with custom styling</p> <p>When Used</p> <p>For selecting from multiple options ]]</p>"},{"location":"definitions/panels/#liadermamenu","title":"liaDermaMenu","text":"<p>Purpose</p> <p>Custom context menu A styled context menu for right-click actions</p> <p>When Used</p> <p>For context menus, right-click menus, or popup menus ]]</p>"},{"location":"definitions/panels/#liadlistview","title":"liaDListView","text":"<p>Purpose</p> <p>Custom list view A styled list view with custom theming</p> <p>When Used</p> <p>For displaying lists of items, data, or options ]]</p>"},{"location":"definitions/panels/#liadoormenu","title":"liaDoorMenu","text":"<p>Purpose</p> <p>Door interaction menu A specialized menu for door interactions</p> <p>When Used</p> <p>When interacting with doors or similar entities ]]</p>"},{"location":"definitions/panels/#liadprogressbar","title":"liaDProgressBar","text":"<p>Purpose</p> <p>Progress bar with custom styling A progress bar with Lilia theming and animations</p> <p>When Used</p> <p>For loading bars, progress indicators, or value displays ]]</p>"},{"location":"definitions/panels/#liaentry","title":"liaEntry","text":"<p>Purpose</p> <p>Text input entry field A styled text input field with custom theming</p> <p>When Used</p> <p>For text input, forms, or data entry ]]</p>"},{"location":"definitions/panels/#liaframe","title":"liaFrame","text":"<p>Purpose</p> <p>Main frame container The primary frame panel with title bar, close button, and theming</p> <p>When Used</p> <p>As the main container for most UI windows and dialogs ]]</p>"},{"location":"definitions/panels/#liaitemlist","title":"liaItemList","text":"<p>Purpose</p> <p>Item list display A panel for displaying lists of items with icons and information</p> <p>When Used</p> <p>In inventory interfaces, item selection, or item browsing ]]</p>"},{"location":"definitions/panels/#liaitemselector","title":"liaItemSelector","text":"<p>Purpose</p> <p>Item selection interface A specialized panel for selecting items from a list</p> <p>When Used</p> <p>In item trading, crafting, or selection interfaces ]]</p>"},{"location":"definitions/panels/#liahorizontalscroll","title":"liaHorizontalScroll","text":"<p>Purpose</p> <p>Horizontal scroll container A container that provides horizontal scrolling</p> <p>When Used</p> <p>For horizontal layouts that need scrolling ]]</p>"},{"location":"definitions/panels/#liahorizontalscrollbar","title":"liaHorizontalScrollBar","text":"<p>Purpose</p> <p>Horizontal scroll bar A horizontal scroll bar control</p> <p>When Used</p> <p>With horizontal scroll panels ]]</p>"},{"location":"definitions/panels/#liaitemicon","title":"liaItemIcon","text":"<p>Purpose</p> <p>Item icon display A panel for displaying item icons with tooltips</p> <p>When Used</p> <p>In inventory, item lists, or item displays ]]</p>"},{"location":"definitions/panels/#liatabbutton","title":"liaTabButton","text":"<p>Purpose</p> <p>Tab button for tabbed interfaces A button designed for tab navigation</p> <p>When Used</p> <p>In tabbed interfaces or tab navigation ]]</p>"},{"location":"definitions/panels/#lialoadingfailure","title":"liaLoadingFailure","text":"<p>Purpose</p> <p>Loading failure display A panel shown when loading fails</p> <p>When Used</p> <p>When content fails to load ]]</p>"},{"location":"definitions/panels/#liamodelpanel","title":"liaModelPanel","text":"<p>Purpose</p> <p>3D model display panel A panel for displaying 3D models with camera controls</p> <p>When Used</p> <p>For model previews, character display, or 3D content ]]</p>"},{"location":"definitions/panels/#liafacingmodelpanel","title":"liaFacingModelPanel","text":"<p>Purpose</p> <p>Facing model panel for character display A specialized model panel that faces the camera</p> <p>When Used</p> <p>For character portraits or facing displays ]]</p>"},{"location":"definitions/panels/#lianotice","title":"liaNotice","text":"<p>Purpose</p> <p>Notification display A panel for displaying notifications or alerts</p> <p>When Used</p> <p>For system notifications, alerts, or messages ]]</p>"},{"location":"definitions/panels/#lianoticepanel","title":"liaNoticePanel","text":"<p>Purpose</p> <p>Notice panel container A container for multiple notice panels</p> <p>When Used</p> <p>For managing multiple notifications ]]</p>"},{"location":"definitions/panels/#lianumslider","title":"liaNumSlider","text":"<p>Purpose</p> <p>Numeric slider control A slider for numeric value input</p> <p>When Used</p> <p>For numeric input with visual feedback ]]</p>"},{"location":"definitions/panels/#liablurreddframe","title":"liaBlurredDFrame","text":"<p>Purpose</p> <p>Blurred frame background A frame with blurred background effect</p> <p>When Used</p> <p>For modal dialogs or overlay frames ]]</p>"},{"location":"definitions/panels/#liasemitransparentdframe","title":"liaSemiTransparentDFrame","text":"<p>Purpose</p> <p>Semi-transparent frame A frame with semi-transparent background</p> <p>When Used</p> <p>For overlay panels or semi-transparent windows ]]</p>"},{"location":"definitions/panels/#liasemitransparentdpanel","title":"liaSemiTransparentDPanel","text":"<p>Purpose</p> <p>Semi-transparent panel A panel with semi-transparent background</p> <p>When Used</p> <p>For overlay elements or semi-transparent containers ]]</p>"},{"location":"definitions/panels/#liaquick","title":"liaQuick","text":"<p>Purpose</p> <p>Quick settings panel A panel for quick access to settings and options</p> <p>When Used</p> <p>For quick settings access or option panels ]]</p>"},{"location":"definitions/panels/#liaprivilegerow","title":"liaPrivilegeRow","text":"<p>Purpose</p> <p>Privilege row display A row displaying privilege information</p> <p>When Used</p> <p>In admin panels or privilege management ]]</p>"},{"location":"definitions/panels/#liaradialpanel","title":"liaRadialPanel","text":"<p>Purpose</p> <p>Radial panel for circular layouts A panel that arranges children in a radial pattern</p> <p>When Used</p> <p>For radial menus, circular layouts, or radial interfaces ]]</p>"},{"location":"definitions/panels/#liascoreboard","title":"liaScoreboard","text":"<p>Purpose</p> <p>Player scoreboard A panel displaying player scores and information</p> <p>When Used</p> <p>For displaying player rankings, scores, or statistics ]]</p>"},{"location":"definitions/panels/#liascrollpanel","title":"liaScrollPanel","text":"<p>Purpose</p> <p>Scrollable panel container A panel that provides vertical scrolling for content</p> <p>When Used</p> <p>For content that exceeds panel size ]]</p>"},{"location":"definitions/panels/#liasheet","title":"liaSheet","text":"<p>Purpose</p> <p>Tabbed sheet container A container that manages multiple tabbed panels</p> <p>When Used</p> <p>For organizing content into tabs ]]</p>"},{"location":"definitions/panels/#liaslidebox","title":"liaSlideBox","text":"<p>Purpose</p> <p>Sliding box container A container that slides content in and out</p> <p>When Used</p> <p>For sliding panels or animated content ]]</p>"},{"location":"definitions/panels/#liaspawnicon","title":"liaSpawnIcon","text":"<p>Purpose</p> <p>Spawn icon display A panel for displaying spawn icons with tooltips</p> <p>When Used</p> <p>For entity spawning, model selection, or icon displays ]]</p>"},{"location":"definitions/panels/#liatable","title":"liaTable","text":"<p>Purpose</p> <p>Data table display A panel for displaying tabular data</p> <p>When Used</p> <p>For data tables, lists, or structured information ]]</p>"},{"location":"definitions/panels/#liatabs","title":"liaTabs","text":"<p>Purpose</p> <p>Tab navigation container A container that manages tab navigation</p> <p>When Used</p> <p>For tabbed interfaces or navigation ]]</p>"},{"location":"definitions/panels/#liausergroupbutton","title":"liaUserGroupButton","text":"<p>Purpose</p> <p>User group button A button representing a user group</p> <p>When Used</p> <p>In admin panels or user management ]]</p>"},{"location":"definitions/panels/#liausergrouplist","title":"liaUserGroupList","text":"<p>Purpose</p> <p>User group list A list displaying user groups</p> <p>When Used</p> <p>In admin panels or user management interfaces ]]</p>"},{"location":"definitions/panels/#liavoicepanel","title":"liaVoicePanel","text":"<p>Purpose</p> <p>Voice panel for voice chat A panel for voice chat controls and indicators</p> <p>When Used</p> <p>For voice chat interfaces or voice controls ]]</p>"},{"location":"definitions/panels/#liamarkuppanel","title":"liaMarkupPanel","text":"<p>Purpose</p> <p>Markup text display panel A panel for displaying formatted markup text</p> <p>When Used</p> <p>For rich text display, formatted content, or styled text ]]</p>"},{"location":"definitions/panels/#liagridinvitem","title":"liaGridInvItem","text":"<p>Purpose</p> <p>Grid inventory item A single item in a grid-based inventory</p> <p>When Used</p> <p>In grid inventory displays ]]</p>"},{"location":"definitions/panels/#liagridinventorypanel","title":"liaGridInventoryPanel","text":"<p>Purpose</p> <p>Grid inventory panel A panel displaying inventory in grid format</p> <p>When Used</p> <p>For grid-based inventory systems ]]</p>"},{"location":"definitions/panels/#liainventory","title":"liaInventory","text":"<p>Purpose</p> <p>Main inventory interface The primary inventory management interface</p> <p>When Used</p> <p>For inventory management and item handling ]]</p>"},{"location":"definitions/panels/#liagridinventory","title":"liaGridInventory","text":"<p>Purpose</p> <p>Grid inventory container A container for grid-based inventory systems</p> <p>When Used</p> <p>As the main container for grid inventories ]]</p>"},{"location":"definitions/panels/#liavendor","title":"liaVendor","text":"<p>Purpose</p> <p>Vendor interface A panel for vendor interactions and trading</p> <p>When Used</p> <p>For NPC vendors, trading interfaces, or shops ]]</p>"},{"location":"definitions/panels/#liavendoritem","title":"liaVendorItem","text":"<p>Purpose</p> <p>Vendor item display A panel for displaying individual vendor items</p> <p>When Used</p> <p>In vendor interfaces for item display ]]</p>"},{"location":"definitions/panels/#liavendoreditor","title":"liaVendorEditor","text":"<p>Purpose</p> <p>Vendor editor interface A panel for editing vendor settings and items</p> <p>When Used</p> <p>In admin panels for vendor management ]]</p>"},{"location":"definitions/panels/#liavendorfactioneditor","title":"liaVendorFactionEditor","text":"<p>Purpose</p> <p>Vendor faction editor A panel for editing vendor faction restrictions</p> <p>When Used</p> <p>In admin panels for vendor faction management ]]</p>"},{"location":"definitions/panels/#liavendorbodygroupeditor","title":"liaVendorBodygroupEditor","text":"<p>Purpose</p> <p>Vendor bodygroup editor A panel for editing vendor bodygroup settings</p> <p>When Used</p> <p>In admin panels for vendor appearance management ]]</p>"},{"location":"definitions/items/aid/","title":"Aid Item Definition","text":"<p>Medical aid item system for the Lilia framework.</p>"},{"location":"definitions/items/aid/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the aid item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.name = \"Medical Kit\"\n</code></pre>"},{"location":"definitions/items/aid/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the aid item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.desc = \"A medical kit that restores health\"\n</code></pre>"},{"location":"definitions/items/aid/#model","title":"model","text":"<p>Purpose</p> <p>Sets the 3D model for the aid item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.model = \"models/weapons/w_package.mdl\"\n</code></pre>"},{"location":"definitions/items/aid/#width","title":"width","text":"<p>Purpose</p> <p>Sets the inventory width of the aid item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.width = 1  -- Takes 1 slot width\n</code></pre>"},{"location":"definitions/items/aid/#height","title":"height","text":"<p>Purpose</p> <p>Sets the inventory height of the aid item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.height = 1  -- Takes 1 slot height\n</code></pre>"},{"location":"definitions/items/aid/#health","title":"health","text":"<p>Purpose</p> <p>Sets the amount of health restored by the aid item</p> <p>When Called</p> <p>During item definition (used in use functions)</p> <p>Example Usage</p> <pre><code>ITEM.health = 25  -- Restores 25 health points\n</code></pre>"},{"location":"definitions/items/ammo/","title":"Ammo Item Definition","text":"<p>Ammunition item system for the Lilia framework.</p>"},{"location":"definitions/items/ammo/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the ammo item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.name = \"Pistol Ammo\"\n</code></pre>"},{"location":"definitions/items/ammo/#model","title":"model","text":"<p>Purpose</p> <p>Sets the 3D model for the ammo item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.model = \"models/props_c17/SuitCase001a.mdl\"\n</code></pre>"},{"location":"definitions/items/ammo/#width","title":"width","text":"<p>Purpose</p> <p>Sets the inventory width of the ammo item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.width = 1  -- Takes 1 slot width\n</code></pre>"},{"location":"definitions/items/ammo/#height","title":"height","text":"<p>Purpose</p> <p>Sets the inventory height of the ammo item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.height = 1  -- Takes 1 slot height\n</code></pre>"},{"location":"definitions/items/ammo/#ammo","title":"ammo","text":"<p>Purpose</p> <p>Sets the ammo type for the item</p> <p>When Called</p> <p>During item definition (used in use functions)</p> <p>Example Usage</p> <pre><code>ITEM.ammo = \"pistol\"  -- Pistol ammunition type\nITEM.ammo = \"smg1\"    -- SMG ammunition type\n</code></pre>"},{"location":"definitions/items/ammo/#category","title":"category","text":"<p>Purpose</p> <p>Sets the category for the ammo item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.category = \"itemCatAmmunition\"\n</code></pre>"},{"location":"definitions/items/books/","title":"Books Item Definition","text":"<p>Literature item system for the Lilia framework.</p>"},{"location":"definitions/items/books/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the book item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.name = \"Medical Journal\"\n</code></pre>"},{"location":"definitions/items/books/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the book item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.desc = \"A medical journal containing important information\"\n</code></pre>"},{"location":"definitions/items/books/#category","title":"category","text":"<p>Purpose</p> <p>Sets the category for the book item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.category = \"itemCatLiterature\"\n</code></pre>"},{"location":"definitions/items/books/#model","title":"model","text":"<p>Purpose</p> <p>Sets the 3D model for the book item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.model = \"models/props_lab/bindergraylabel01b.mdl\"\n</code></pre>"},{"location":"definitions/items/books/#contents","title":"contents","text":"<p>Purpose</p> <p>Sets the HTML content to display when reading the book</p> <p>When Called</p> <p>During item definition (used in Read function)</p> <p>Example Usage</p> <pre><code>ITEM.contents = \"&lt;h1&gt;Chapter 1&lt;/h1&gt;&lt;p&gt;This is the content...&lt;/p&gt;\"\n</code></pre>"},{"location":"definitions/items/entities/","title":"Entities Item Definition","text":"<p>Entity placement item system for the Lilia framework.</p>"},{"location":"definitions/items/entities/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the entity item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.name = \"Chair\"\n</code></pre>"},{"location":"definitions/items/entities/#model","title":"model","text":"<p>Purpose</p> <p>Sets the 3D model for the entity item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.model = \"models/props_c17/FurnitureChair001a.mdl\"\n</code></pre>"},{"location":"definitions/items/entities/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the entity item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.desc = \"A comfortable chair for sitting\"\n</code></pre>"},{"location":"definitions/items/entities/#category","title":"category","text":"<p>Purpose</p> <p>Sets the category for the entity item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.category = \"entities\"\n</code></pre>"},{"location":"definitions/items/entities/#entityid","title":"entityid","text":"<p>Purpose</p> <p>Sets the entity class name to spawn</p> <p>When Called</p> <p>During item definition (used in Place function)</p> <p>Example Usage</p> <pre><code>ITEM.entityid = \"prop_physics\"\n</code></pre>"},{"location":"definitions/items/grenade/","title":"Grenade Item Definition","text":"<p>Grenade item system for the Lilia framework.</p>"},{"location":"definitions/items/grenade/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the grenade item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.name = \"Fragmentation Grenade\"\n</code></pre>"},{"location":"definitions/items/grenade/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the grenade item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.desc = \"A deadly fragmentation grenade\"\n</code></pre>"},{"location":"definitions/items/grenade/#category","title":"category","text":"<p>Purpose</p> <p>Sets the category for the grenade item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.category = \"itemCatGrenades\"\n</code></pre>"},{"location":"definitions/items/grenade/#model","title":"model","text":"<p>Purpose</p> <p>Sets the 3D model for the grenade item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.model = \"models/weapons/w_eq_fraggrenade.mdl\"\n</code></pre>"},{"location":"definitions/items/grenade/#class","title":"class","text":"<p>Purpose</p> <p>Sets the weapon class name for the grenade</p> <p>When Called</p> <p>During item definition (used in Use function)</p> <p>Example Usage</p> <pre><code>ITEM.class = \"weapon_frag\"\n</code></pre>"},{"location":"definitions/items/grenade/#width","title":"width","text":"<p>Purpose</p> <p>Sets the inventory width of the grenade item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.width = 1  -- Takes 1 slot width\n</code></pre>"},{"location":"definitions/items/grenade/#height","title":"height","text":"<p>Purpose</p> <p>Sets the inventory height of the grenade item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.height = 1  -- Takes 1 slot height\n</code></pre>"},{"location":"definitions/items/grenade/#dropondeath","title":"DropOnDeath","text":"<p>Purpose</p> <p>Sets whether the grenade drops when player dies</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.DropOnDeath = true  -- Drops on death\n</code></pre>"},{"location":"definitions/items/outfit/","title":"Outfit Item Definition","text":"<p>Outfit item system for the Lilia framework.</p>"},{"location":"definitions/items/outfit/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.name = \"Police Uniform\"\n</code></pre>"},{"location":"definitions/items/outfit/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.desc = \"A standard police uniform\"\n</code></pre>"},{"location":"definitions/items/outfit/#category","title":"category","text":"<p>Purpose</p> <p>Sets the category for the outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.category = \"outfit\"\n</code></pre>"},{"location":"definitions/items/outfit/#model","title":"model","text":"<p>Purpose</p> <p>Sets the 3D model for the outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.model = \"models/props_c17/BriefCase001a.mdl\"\n</code></pre>"},{"location":"definitions/items/outfit/#width","title":"width","text":"<p>Purpose</p> <p>Sets the inventory width of the outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.width = 1  -- Takes 1 slot width\n</code></pre>"},{"location":"definitions/items/outfit/#height","title":"height","text":"<p>Purpose</p> <p>Sets the inventory height of the outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.height = 1  -- Takes 1 slot height\n</code></pre>"},{"location":"definitions/items/outfit/#outfitcategory","title":"outfitCategory","text":"<p>Purpose</p> <p>Sets the outfit category for conflict checking</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.outfitCategory = \"model\"  -- Prevents multiple items of same category\n</code></pre>"},{"location":"definitions/items/outfit/#pacdata","title":"pacData","text":"<p>Purpose</p> <p>Sets the PAC data for the outfit</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.pacData = {}  -- PAC attachment data\n</code></pre>"},{"location":"definitions/items/outfit/#isoutfit","title":"isOutfit","text":"<p>Purpose</p> <p>Marks the item as an outfit</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.isOutfit = true\n</code></pre>"},{"location":"definitions/items/outfit/#removeoutfit","title":"removeOutfit","text":"<p>Purpose</p> <p>Custom paint function to show equipped status</p> <p>When Called</p> <p>When rendering the item in inventory (CLIENT only)</p> <p>Example Usage</p> <pre><code>function ITEM:paintOver(item, w, h)\n    if item:getData(\"equip\") then\n        surface.SetDrawColor(110, 255, 110, 100)\n        surface.DrawRect(w - 14, h - 14, 8, 8)\n    end\nend\n</code></pre>"},{"location":"definitions/items/outfit/#wearoutfit","title":"wearOutfit","text":"<p>Purpose</p> <p>Removes the outfit from the player</p> <p>When Called</p> <p>When unequipping the outfit</p> <p>Example Usage</p> <pre><code>function ITEM:removeOutfit(client)\n    -- Custom removal logic\nend\n</code></pre>"},{"location":"definitions/items/outfit/#oncanbetransfered","title":"OnCanBeTransfered","text":"<p>Purpose</p> <p>Applies the outfit to the player</p> <p>When Called</p> <p>When equipping the outfit</p> <p>Example Usage</p> <pre><code>function ITEM:wearOutfit(client, isForLoadout)\n    -- Custom wear logic\nend\n</code></pre>"},{"location":"definitions/items/outfit/#onloadout","title":"onLoadout","text":"<p>Purpose</p> <p>Prevents transfer of equipped outfits</p> <p>When Called</p> <p>When attempting to transfer the item</p> <p>Example Usage</p> <pre><code>function ITEM:OnCanBeTransfered(_, newInventory)\n    if newInventory and self:getData(\"equip\") then return false end\n    return true\nend\n</code></pre>"},{"location":"definitions/items/outfit/#onremoved","title":"onRemoved","text":"<p>Purpose</p> <p>Handles outfit loading on player spawn</p> <p>When Called</p> <p>When player spawns with equipped outfit</p> <p>Example Usage</p> <pre><code>function ITEM:onLoadout()\n    if self:getData(\"equip\") then self:wearOutfit(self.player, true) end\nend\n</code></pre>"},{"location":"definitions/items/outfit/#name_1","title":"name","text":"<p>Purpose</p> <p>Handles outfit removal when item is removed</p> <p>When Called</p> <p>When item is removed from inventory</p> <p>Example Usage</p> <pre><code>function ITEM:onRemoved()\n    if IsValid(receiver) and receiver:IsPlayer() and self:getData(\"equip\") then self:removeOutfit(receiver) end\nend\n</code></pre>"},{"location":"definitions/items/outfit/#name_2","title":"name","text":"<p>Purpose</p> <p>Handles outfit removal when item is dropped</p> <p>When Called</p> <p>When item is dropped</p> <p>Example Usage</p> <pre><code>ITEM:hook(\"drop\", function(item) if item:getData(\"equip\") then item:removeOutfit(item.player) end end)\n</code></pre>"},{"location":"definitions/items/pacoutfit/","title":"PAC Outfit Item Definition","text":"<p>PAC outfit item system for the Lilia framework.</p>"},{"location":"definitions/items/pacoutfit/#name","title":"name","text":"<p>Purpose</p> <p>Prevents loading if PAC addon is not available</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>if not pac then return end\n</code></pre>"},{"location":"definitions/items/pacoutfit/#name_1","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the PAC outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.name = \"Hat\"\n</code></pre>"},{"location":"definitions/items/pacoutfit/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the PAC outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.desc = \"A stylish hat\"\n</code></pre>"},{"location":"definitions/items/pacoutfit/#category","title":"category","text":"<p>Purpose</p> <p>Sets the category for the PAC outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.category = \"outfit\"\n</code></pre>"},{"location":"definitions/items/pacoutfit/#model","title":"model","text":"<p>Purpose</p> <p>Sets the 3D model for the PAC outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.model = \"models/Gibs/HGIBS.mdl\"\n</code></pre>"},{"location":"definitions/items/pacoutfit/#width","title":"width","text":"<p>Purpose</p> <p>Sets the inventory width of the PAC outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.width = 1  -- Takes 1 slot width\n</code></pre>"},{"location":"definitions/items/pacoutfit/#height","title":"height","text":"<p>Purpose</p> <p>Sets the inventory height of the PAC outfit item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.height = 1  -- Takes 1 slot height\n</code></pre>"},{"location":"definitions/items/pacoutfit/#outfitcategory","title":"outfitCategory","text":"<p>Purpose</p> <p>Sets the outfit category for conflict checking</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.outfitCategory = \"hat\"  -- Prevents multiple items of same category\n</code></pre>"},{"location":"definitions/items/pacoutfit/#pacdata","title":"pacData","text":"<p>Purpose</p> <p>Sets the PAC data for the outfit</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.pacData = {}  -- PAC attachment data\n</code></pre>"},{"location":"definitions/items/pacoutfit/#removepart","title":"removePart","text":"<p>Purpose</p> <p>Custom paint function to show equipped status</p> <p>When Called</p> <p>When rendering the item in inventory (CLIENT only)</p> <p>Example Usage</p> <pre><code>function ITEM:paintOver(item, w, h)\n    if item:getData(\"equip\") then\n        surface.SetDrawColor(110, 255, 110, 100)\n        surface.DrawRect(w - 14, h - 14, 8, 8)\n        end\n    end\n</code></pre>"},{"location":"definitions/items/pacoutfit/#oncanbetransfered","title":"onCanBeTransfered","text":"<p>Purpose</p> <p>Removes the PAC part from the player</p> <p>When Called</p> <p>When unequipping the PAC outfit</p> <p>Example Usage</p> <pre><code>function ITEM:removePart(client)\n    local char = client:getChar()\n    self:setData(\"equip\", false)\n    if client.removePart then client:removePart(self.uniqueID) end\n        -- Remove attribute boosts\n        end\n</code></pre>"},{"location":"definitions/items/pacoutfit/#onloadout","title":"onLoadout","text":"<p>Purpose</p> <p>Prevents transfer of equipped PAC outfits</p> <p>When Called</p> <p>When attempting to transfer the item</p> <p>Example Usage</p> <pre><code>function ITEM:onCanBeTransfered(_, newInventory)\n    if newInventory and self:getData(\"equip\") then return false end\n        return true\n        end\n</code></pre>"},{"location":"definitions/items/pacoutfit/#onremoved","title":"onRemoved","text":"<p>Purpose</p> <p>Handles PAC outfit loading on player spawn</p> <p>When Called</p> <p>When player spawns with equipped PAC outfit</p> <p>Example Usage</p> <pre><code>function ITEM:onLoadout()\n    if self:getData(\"equip\") and self.player.addPart then self.player:addPart(self.uniqueID) end\n        end\n</code></pre>"},{"location":"definitions/items/pacoutfit/#name_2","title":"name","text":"<p>Purpose</p> <p>Handles PAC outfit removal when item is removed</p> <p>When Called</p> <p>When item is removed from inventory</p> <p>Example Usage</p> <pre><code>function ITEM:onRemoved()\n    local inv = lia.item.inventories[self.invID]\n    local receiver = inv.getReceiver and inv:getReceiver()\n    if IsValid(receiver) and receiver:IsPlayer() and self:getData(\"equip\") then self:removePart(receiver) end\n        end\n</code></pre>"},{"location":"definitions/items/pacoutfit/#name_3","title":"name","text":"<p>Purpose</p> <p>Handles PAC outfit removal when item is dropped</p> <p>When Called</p> <p>When item is dropped</p> <p>Example Usage</p> <pre><code>ITEM:hook(\"drop\", function(item)\nlocal client = item.player\nif item:getData(\"equip\") then item:removePart(client) end\n    end)\n</code></pre>"},{"location":"definitions/items/stackable/","title":"Stackable Item Definition","text":"<p>Stackable item system for the Lilia framework.</p>"},{"location":"definitions/items/stackable/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the stackable item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.name = \"Ammo Box\"\n</code></pre>"},{"location":"definitions/items/stackable/#model","title":"model","text":"<p>Purpose</p> <p>Sets the 3D model for the stackable item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.model = \"models/props_junk/cardboard_box001a.mdl\"\n</code></pre>"},{"location":"definitions/items/stackable/#width","title":"width","text":"<p>Purpose</p> <p>Sets the inventory width of the stackable item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.width = 1  -- Takes 1 slot width\n</code></pre>"},{"location":"definitions/items/stackable/#height","title":"height","text":"<p>Purpose</p> <p>Sets the inventory height of the stackable item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.height = 1  -- Takes 1 slot height\n</code></pre>"},{"location":"definitions/items/stackable/#isstackable","title":"isStackable","text":"<p>Purpose</p> <p>Marks the item as stackable</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.isStackable = true\n</code></pre>"},{"location":"definitions/items/stackable/#maxquantity","title":"maxQuantity","text":"<p>Purpose</p> <p>Sets the maximum quantity for the stackable item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.maxQuantity = 10  -- Maximum 10 items per stack\n</code></pre>"},{"location":"definitions/items/stackable/#cansplit","title":"canSplit","text":"<p>Purpose</p> <p>Sets whether the item can be split</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.canSplit = true  -- Allows splitting the stack\n</code></pre>"},{"location":"definitions/items/url/","title":"URL Item Definition","text":"<p>URL item system for the Lilia framework.</p>"},{"location":"definitions/items/url/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the URL item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.name = \"Website Link\"\n</code></pre>"},{"location":"definitions/items/url/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the URL item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.desc = \"A link to an external website\"\n</code></pre>"},{"location":"definitions/items/url/#model","title":"model","text":"<p>Purpose</p> <p>Sets the 3D model for the URL item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.model = \"models/props_interiors/pot01a.mdl\"\n</code></pre>"},{"location":"definitions/items/url/#url","title":"url","text":"<p>Purpose</p> <p>Sets the URL to open when the item is used</p> <p>When Called</p> <p>During item definition (used in use function)</p> <p>Example Usage</p> <pre><code>ITEM.url = \"https://example.com\"\n</code></pre>"},{"location":"definitions/items/weapons/","title":"Weapons Item Definition","text":"<p>Weapon item system for the Lilia framework.</p>"},{"location":"definitions/items/weapons/#name","title":"name","text":"<p>Purpose</p> <p>Sets the display name of the weapon item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.name = \"Pistol\"\n</code></pre>"},{"location":"definitions/items/weapons/#desc","title":"desc","text":"<p>Purpose</p> <p>Sets the description of the weapon item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.desc = \"A standard issue pistol\"\n</code></pre>"},{"location":"definitions/items/weapons/#category","title":"category","text":"<p>Purpose</p> <p>Sets the category for the weapon item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.category = \"weapons\"\n</code></pre>"},{"location":"definitions/items/weapons/#model","title":"model","text":"<p>Purpose</p> <p>Sets the 3D model for the weapon item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.model = \"models/weapons/w_pistol.mdl\"\n</code></pre>"},{"location":"definitions/items/weapons/#class","title":"class","text":"<p>Purpose</p> <p>Sets the weapon class name</p> <p>When Called</p> <p>During item definition (used in equip/unequip functions)</p> <p>Example Usage</p> <pre><code>ITEM.class = \"weapon_pistol\"\n</code></pre>"},{"location":"definitions/items/weapons/#width","title":"width","text":"<p>Purpose</p> <p>Sets the inventory width of the weapon item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.width = 2  -- Takes 2 slot width\n</code></pre>"},{"location":"definitions/items/weapons/#height","title":"height","text":"<p>Purpose</p> <p>Sets the inventory height of the weapon item</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.height = 2  -- Takes 2 slot height\n</code></pre>"},{"location":"definitions/items/weapons/#isweapon","title":"isWeapon","text":"<p>Purpose</p> <p>Marks the item as a weapon</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.isWeapon = true\n</code></pre>"},{"location":"definitions/items/weapons/#requiredskilllevels","title":"RequiredSkillLevels","text":"<p>Purpose</p> <p>Sets required skill levels for the weapon</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.RequiredSkillLevels = {}  -- No skill requirements\n</code></pre>"},{"location":"definitions/items/weapons/#dropondeath","title":"DropOnDeath","text":"<p>Purpose</p> <p>Sets whether the weapon drops when player dies</p> <p>When Called</p> <p>During item definition</p> <p>Example Usage</p> <pre><code>ITEM.DropOnDeath = true  -- Drops on death\n</code></pre>"},{"location":"definitions/items/weapons/#oncanbetransfered","title":"OnCanBeTransfered","text":"<p>Purpose</p> <p>Post-hook for weapon dropping</p> <p>When Called</p> <p>After weapon is dropped</p> <p>Example Usage</p> <pre><code>function ITEM.postHooks:drop()\n    local client = self.player\n    if not client or not IsValid(client) then return end\n        if client:HasWeapon(self.class) then\n            client:notifyErrorLocalized(\"invalidWeapon\")\n            client:StripWeapon(self.class)\n            end\n        end\n</code></pre>"},{"location":"definitions/items/weapons/#oncanbetransfered_1","title":"OnCanBeTransfered","text":"<p>Purpose</p> <p>Handles weapon dropping with ragdoll and equip checks</p> <p>When Called</p> <p>When weapon is dropped</p> <p>Example Usage</p> <pre><code>ITEM:hook(\"drop\", function(item)\nlocal client = item.player\nif not client or not IsValid(client) then return false end\n    if IsValid(client:getNetVar(\"ragdoll\")) then\n        client:notifyErrorLocalized(\"noRagdollAction\")\n        return false\n        end\n    -- Handle equipped weapon removal\n    end)\n</code></pre>"},{"location":"definitions/items/weapons/#onloadout","title":"onLoadout","text":"<p>Purpose</p> <p>Prevents transfer of equipped weapons</p> <p>When Called</p> <p>When attempting to transfer the weapon</p> <p>Example Usage</p> <pre><code>function ITEM:OnCanBeTransfered(_, newInventory)\n    if newInventory and self:getData(\"equip\") then return false end\n        return true\n        end\n</code></pre>"},{"location":"definitions/items/weapons/#onsave","title":"OnSave","text":"<p>Purpose</p> <p>Handles weapon loading on player spawn</p> <p>When Called</p> <p>When player spawns with equipped weapon</p> <p>Example Usage</p> <pre><code>function ITEM:onLoadout()\n    if self:getData(\"equip\") then\n        local client = self.player\n        if not client or not IsValid(client) then return end\n            local weapon = client:Give(self.class, true)\n            if IsValid(weapon) then\n                client:RemoveAmmo(weapon:Clip1(), weapon:GetPrimaryAmmoType())\n                weapon:SetClip1(self:getData(\"ammo\", 0))\n            else\n                lia.error(L(\"weaponDoesNotExist\", self.class))\n                end\n            end\n        end\n</code></pre>"},{"location":"definitions/items/weapons/#getname","title":"getName","text":"<p>Purpose</p> <p>Saves weapon ammo data</p> <p>When Called</p> <p>When saving the weapon item</p> <p>Example Usage</p> <pre><code>function ITEM:OnSave()\n    local client = self.player\n    if not client or not IsValid(client) then return end\n        local weapon = client:GetWeapon(self.class)\n        if IsValid(weapon) then self:setData(\"ammo\", weapon:Clip1()) end\n            end\n</code></pre>"},{"location":"definitions/items/weapons/#name_1","title":"name","text":"<p>Purpose</p> <p>Custom name function for weapons (CLIENT only)</p> <p>When Called</p> <p>When displaying weapon name</p> <p>Example Usage</p> <pre><code>function ITEM:getName()\n    local weapon = weapons.GetStored(self.class)\n    if weapon and weapon.PrintName then return language.GetPhrase(weapon.PrintName) end\n        return self.name\n        end\n</code></pre>"},{"location":"hooks/client/","title":"Client-Side Hooks","text":"<p>Client-side hook system for the Lilia framework.</p> <p>Overview</p> <p>Client-side hooks in the Lilia framework handle UI, rendering, input, and other client-specific functionality; they can be used to customize the user experience and can be overridden or extended by addons and modules.</p>"},{"location":"hooks/client/#addbarfield","title":"AddBarField","text":"<p>Purpose</p> <p>Adds a bar field to a character information section in the F1 menu</p> <p>When Called</p> <p>When you want to add a progress bar field to display character statistics</p> <p>Parameters</p> <ul> <li><code>sectionName</code> (string): The name of the section to add the field to</li> <li><code>fieldName</code> (string): Unique identifier for the field</li> <li><code>labelText</code> (string): Display text for the field label</li> <li><code>minFunc</code> (function): Function that returns the minimum value for the bar</li> <li><code>maxFunc</code> (function): Function that returns the maximum value for the bar</li> <li><code>valueFunc</code> (function): Function that returns the current value for the bar</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a health bar field\nhook.Run(\"AddBarField\", \"character\", \"health\", \"Health\",\nfunction() return 0 end,\nfunction() return 100 end,\nfunction() return LocalPlayer():Health() end)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add a stamina bar field with character data\nhook.Run(\"AddBarField\", \"character\", \"stamina\", \"Stamina\",\nfunction() return 0 end,\nfunction() return 100 end,\nfunction()\nlocal char = LocalPlayer():getChar()\nreturn char and char:getAttrib(\"stm\") or 0\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add multiple attribute bars dynamically\nlocal attributes = {\"str\", \"con\", \"dex\", \"int\", \"wis\", \"cha\"}\nfor _, attrId in ipairs(attributes) do\n    local attr = lia.attribs.list[attrId]\n    if attr then\n        hook.Run(\"AddBarField\", \"attributes\", attrId, attr.name,\n            function() return attr.min or 0 end,\n            function() return hook.Run(\"GetAttributeMax\", LocalPlayer(), attrId) or attr.max or 100 end,\n            function()\n                local char = LocalPlayer():getChar()\n                return char and char:getAttrib(attrId) or 0\n            end)\n    end\nend\n</code></pre></p>"},{"location":"hooks/client/#addsection","title":"AddSection","text":"<p>Purpose</p> <p>Adds a new section to the character information panel in the F1 menu</p> <p>When Called</p> <p>When you want to create a new section for displaying character information</p> <p>Parameters</p> <ul> <li><code>sectionName</code> (string): The name of the section to create</li> <li><code>color</code> (Color): The color for the section header (optional)</li> <li><code>priority</code> (number): Display priority, lower numbers appear first (optional)</li> <li><code>location</code> (number): Location of the section in the panel (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a basic section\nhook.Run(\"AddSection\", \"General Info\", Color(255, 255, 255), 1, 1)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add a section with custom styling\nhook.Run(\"AddSection\", \"Character Stats\", Color(100, 150, 200), 2, 1)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add multiple sections with conditional logic\nlocal sections = {\n{name = \"Basic Info\", color = Color(255, 255, 255), priority = 1},\n{name = \"Attributes\", color = Color(100, 200, 100), priority = 2},\n{name = \"Skills\", color = Color(200, 100, 100), priority = 3}\n}\nfor _, section in ipairs(sections) do\n    hook.Run(\"AddSection\", section.name, section.color, section.priority, 1)\n    end\n</code></pre></p>"},{"location":"hooks/client/#addtextfield","title":"AddTextField","text":"<p>Purpose</p> <p>Adds a text field to a character information section in the F1 menu</p> <p>When Called</p> <p>When you want to add a text field to display character information</p> <p>Parameters</p> <ul> <li><code>sectionName</code> (string): The name of the section to add the field to</li> <li><code>fieldName</code> (string): Unique identifier for the field</li> <li><code>labelText</code> (string): Display text for the field label</li> <li><code>valueFunc</code> (function): Function that returns the current value to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a character name field\nhook.Run(\"AddTextField\", \"General Info\", \"name\", \"Name\",\nfunction() return LocalPlayer():Name() end)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add a faction field with character data\nhook.Run(\"AddTextField\", \"General Info\", \"faction\", \"Faction\",\nfunction()\nlocal char = LocalPlayer():getChar()\nreturn char and char:getFaction() and char:getFaction().name or \"Unknown\"\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add multiple character info fields dynamically\nlocal infoFields = {\n{name = \"name\", label = \"Name\", func = function() return LocalPlayer():Name() end},\n{name = \"desc\", label = \"Description\", func = function()\nlocal char = LocalPlayer():getChar()\nreturn char and char:getDesc() or \"No description\"\nend},\n{name = \"money\", label = \"Money\", func = function()\nlocal char = LocalPlayer():getChar()\nreturn char and lia.currency.format(char:getMoney()) or \"$0\"\nend}\n}\nfor _, field in ipairs(infoFields) do\n    hook.Run(\"AddTextField\", \"General Info\", field.name, field.label, field.func)\n    end\n</code></pre></p>"},{"location":"hooks/client/#addtoadminstickhud","title":"AddToAdminStickHUD","text":"<p>Purpose</p> <p>Adds information to the admin stick HUD display when looking at entities</p> <p>When Called</p> <p>When an admin uses the admin stick and looks at an entity</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The admin player using the admin stick</li> <li><code>target</code> (Entity): The entity being looked at</li> <li><code>information</code> (table): Table to add information strings to</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic entity information\nhook.Add(\"AddToAdminStickHUD\", \"MyAddon\", function(client, target, information)\nif IsValid(target) then\n    table.insert(information, \"Entity: \" .. target:GetClass())\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add vendor-specific information\nhook.Add(\"AddToAdminStickHUD\", \"VendorInfo\", function(client, target, information)\nif IsValid(target) and target.IsVendor then\n    local name = target:getName()\n    if name and name ~= \"\" then\n        table.insert(information, \"Vendor Name: \" .. name)\n        end\n    local animation = target:getNetVar(\"animation\", \"\")\n    if animation and animation ~= \"\" then\n        table.insert(information, \"Animation: \" .. animation)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add comprehensive entity information with validation\nhook.Add(\"AddToAdminStickHUD\", \"DetailedInfo\", function(client, target, information)\nif not IsValid(target) then return end\n    -- Basic entity info\n    table.insert(information, \"Class: \" .. target:GetClass())\n    table.insert(information, \"Model: \" .. target:GetModel())\n    -- Position info\n    local pos = target:GetPos()\n    table.insert(information, string.format(\"Position: %.1f, %.1f, %.1f\", pos.x, pos.y, pos.z))\n    -- Custom entity data\n    if target.IsVendor then\n        local name = target:getName()\n        if name and name ~= \"\" then\n            table.insert(information, \"Vendor: \" .. name)\n            end\n    elseif target.IsDoor then\n        local doorData = target:getNetVar(\"doorData\")\n        if doorData then\n            table.insert(information, \"Door Title: \" .. (doorData.title or \"Untitled\"))\n            table.insert(information, \"Door Price: $\" .. (doorData.price or 0))\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/client/#adjustpacpartdata","title":"AdjustPACPartData","text":"<p>Purpose</p> <p>Allows modification of PAC3 part data before it's applied to a player</p> <p>When Called</p> <p>When PAC3 parts are being attached to a player, allowing customization</p> <p>Parameters</p> <ul> <li><code>wearer</code> (Player): The player who will wear the PAC3 part</li> <li><code>id</code> (string): The identifier of the PAC3 part</li> <li><code>data</code> (table): The PAC3 part data to be modified</li> </ul> <p>Returns</p> <ul> <li>table|nil - Modified part data, or nil to use original data</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Modify part color\nhook.Add(\"AdjustPACPartData\", \"MyAddon\", function(wearer, id, data)\nif id == \"my_hat\" then\n    data.color = Color(255, 0, 0) -- Make hat red\n    return data\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Modify part based on player faction\nhook.Add(\"AdjustPACPartData\", \"FactionPAC\", function(wearer, id, data)\nlocal char = wearer:getChar()\nif not char then return end\n    if id == \"uniform\" then\n        local faction = char:getFaction()\n        if faction == \"police\" then\n            data.color = Color(0, 0, 255) -- Blue for police\n        elseif faction == \"medic\" then\n            data.color = Color(255, 255, 255) -- White for medics\n            end\n        return data\n        end\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex PAC part modification system\nhook.Add(\"AdjustPACPartData\", \"AdvancedPAC\", function(wearer, id, data)\nlocal char = wearer:getChar()\nif not char then return end\n    -- Check if this is an item-based part\n    local item = lia.item.list[id]\n    if item and isfunction(item.pacAdjust) then\n        local result = item:pacAdjust(data, wearer)\n        if result ~= nil then return result end\n            end\n        -- Apply faction-specific modifications\n        local faction = char:getFaction()\n        local modifications = {\n        [\"police\"] = {\n        [\"badge\"] = {scale = 1.2, color = Color(255, 215, 0)},\n        [\"uniform\"] = {color = Color(0, 0, 100)}\n        },\n        [\"medic\"] = {\n        [\"uniform\"] = {color = Color(255, 255, 255)},\n        [\"cross\"] = {scale = 1.5, color = Color(255, 0, 0)}\n        }\n        }\n        local factionMods = modifications[faction]\n        if factionMods and factionMods[id] then\n            local mod = factionMods[id]\n            for key, value in pairs(mod) do\n                data[key] = value\n                end\n            end\n        -- Apply character-specific modifications\n        local charData = char:getData()\n        if charData.rank and charData.rank == \"officer\" then\n            data.scale = (data.scale or 1) * 1.1 -- Officers get slightly larger parts\n            end\n        return data\n        end)\n</code></pre></p>"},{"location":"hooks/client/#attachpart","title":"AttachPart","text":"<p>Purpose</p> <p>Attaches a PAC3 part to a player</p> <p>When Called</p> <p>When a PAC3 part needs to be attached to a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to attach the part to</li> <li><code>id</code> (string): The identifier of the PAC3 part to attach</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Attach a hat to a player\nhook.Run(\"AttachPart\", client, \"hat_01\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Attach part with validation\nhook.Add(\"AttachPart\", \"MyAddon\", function(client, id)\nif id == \"special_hat\" then\n    local char = client:getChar()\n    if char and char:getFaction() == \"police\" then\n        -- Only police can wear this hat\n        hook.Run(\"AttachPart\", client, id)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex part attachment system\nhook.Add(\"AttachPart\", \"AdvancedPAC\", function(client, id)\nlocal char = client:getChar()\nif not char then return end\n    -- Check if player has permission for this part\n    local partPermissions = {\n    [\"police_badge\"] = {\"police\", \"sheriff\"},\n    [\"medic_cross\"] = {\"medic\", \"doctor\"},\n    [\"crown\"] = {\"mayor\", \"king\"}\n    }\n    local allowedFactions = partPermissions[id]\n    if allowedFactions then\n        local faction = char:getFaction()\n        if not table.HasValue(allowedFactions, faction) then\n            client:ChatPrint(\"You don't have permission to wear this item!\")\n            return\n            end\n        end\n    -- Check character level requirements\n    local levelRequirements = {\n    [\"epic_armor\"] = 10,\n    [\"legendary_weapon\"] = 20\n    }\n    local requiredLevel = levelRequirements[id]\n    if requiredLevel then\n        local charLevel = char:getData(\"level\", 1)\n        if charLevel &lt; requiredLevel then\n            client:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to wear this item!\")\n            return\n            end\n        end\n    -- Attach the part\n    hook.Run(\"AttachPart\", client, id)\n    -- Log the attachment\n    print(client:Name() .. \" attached PAC part: \" .. id)\n    end)\n</code></pre></p>"},{"location":"hooks/client/#candisplaycharinfo","title":"CanDisplayCharInfo","text":"<p>Purpose</p> <p>Determines if character information should be displayed for a given name</p> <p>When Called</p> <p>When displaying character information in UI elements</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The character name to check</li> </ul> <p>Returns</p> <ul> <li>boolean - True if info should be displayed, false otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display all character info\nhook.Add(\"CanDisplayCharInfo\", \"MyAddon\", function(name)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide info for certain characters\nhook.Add(\"CanDisplayCharInfo\", \"PrivacyMode\", function(name)\nlocal hiddenNames = {\"admin\", \"moderator\", \"staff\"}\nfor _, hidden in ipairs(hiddenNames) do\n    if string.find(string.lower(name), string.lower(hidden)) then\n        return false\n        end\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex privacy system\nhook.Add(\"CanDisplayCharInfo\", \"AdvancedPrivacy\", function(name)\nlocal char = LocalPlayer():getChar()\nif not char then return true end\n    -- Check if player has privacy mode enabled\n    if char:getData(\"privacyMode\", false) then\n        return false\n        end\n    -- Check faction restrictions\n    local faction = char:getFaction()\n    if faction == \"police\" then\n        -- Police can see all info\n        return true\n    elseif faction == \"citizen\" then\n        -- Citizens can only see other citizens\n        local targetChar = lia.char.getCharacters()[name]\n        if targetChar and targetChar:getFaction() ~= \"citizen\" then\n            return false\n            end\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/client/#canopenbagpanel","title":"CanOpenBagPanel","text":"<p>Purpose</p> <p>Called to check if a bag panel can be opened</p> <p>When Called</p> <p>When attempting to open a bag's inventory panel</p> <p>Parameters</p> <ul> <li><code>item</code> (Item): The bag item being opened</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Always allow\nhook.Add(\"CanOpenBagPanel\", \"MyAddon\", function(item)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check if bag is locked\nhook.Add(\"CanOpenBagPanel\", \"BagPanelCheck\", function(item)\nif item:getData(\"locked\", false) then\n    LocalPlayer():ChatPrint(\"This bag is locked\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex bag access system\nhook.Add(\"CanOpenBagPanel\", \"AdvancedBagAccess\", function(item)\nlocal char = LocalPlayer():getChar()\nif not char then return false end\n    -- Check if bag is locked\n    if item:getData(\"locked\", false) then\n        local hasKey = char:getInv():hasItem(\"bag_key_\" .. item:getID())\n        if not hasKey then\n            LocalPlayer():ChatPrint(\"This bag is locked and you don't have the key\")\n            return false\n            end\n        end\n    -- Check bag ownership\n    local owner = item:getData(\"owner\")\n    if owner and owner ~= char:getID() then\n        LocalPlayer():ChatPrint(\"This bag belongs to someone else\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/client/#charlistcolumns","title":"CharListColumns","text":"<p>Purpose</p> <p>Called to modify character list columns</p> <p>When Called</p> <p>When building the character list display</p> <p>Parameters</p> <ul> <li><code>columns</code> (table): The columns to display in the character list</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add custom column\nhook.Add(\"CharListColumns\", \"MyAddon\", function(columns)\ntable.insert(columns, \"Custom Column\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Modify existing columns\nhook.Add(\"CharListColumns\", \"ColumnModification\", function(columns)\n-- Add custom columns\ntable.insert(columns, \"Level\")\ntable.insert(columns, \"Faction\")\n-- Remove default columns\nfor i = #columns, 1, -1 do\n    if columns[i] == \"Unwanted Column\" then\n        table.remove(columns, i)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex column system\nhook.Add(\"CharListColumns\", \"AdvancedColumns\", function(columns)\n-- Clear existing columns\ncolumns = {}\n-- Add custom columns\ntable.insert(columns, \"Name\")\ntable.insert(columns, \"Level\")\ntable.insert(columns, \"Faction\")\ntable.insert(columns, \"Money\")\ntable.insert(columns, \"Last Seen\")\n-- Add faction-specific columns\nlocal char = LocalPlayer():getChar()\nif char then\n    local faction = char:getFaction()\n    if faction == \"police\" then\n        table.insert(columns, \"Warnings\")\n        table.insert(columns, \"Arrests\")\n    elseif faction == \"medic\" then\n        table.insert(columns, \"Heals\")\n        table.insert(columns, \"Revives\")\n        end\n    end\n-- Add admin columns\nif LocalPlayer():IsAdmin() then\n    table.insert(columns, \"SteamID\")\n    table.insert(columns, \"IP Address\")\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#charlistentry","title":"CharListEntry","text":"<p>Purpose</p> <p>Called to modify character list entries</p> <p>When Called</p> <p>When building each character list entry</p> <p>Parameters</p> <ul> <li><code>entry</code> (table): The character data for this entry</li> <li><code>row</code> (Panel): The row panel being created</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add custom data to entry\nhook.Add(\"CharListEntry\", \"MyAddon\", function(entry, row)\nentry.customData = \"Custom Value\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Modify entry display\nhook.Add(\"CharListEntry\", \"EntryModification\", function(entry, row)\n-- Add level data\nentry.level = entry.level or 1\n-- Add faction data\nentry.faction = entry.faction or \"citizen\"\n-- Add money data\nentry.money = entry.money or 0\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entry system\nhook.Add(\"CharListEntry\", \"AdvancedEntry\", function(entry, row)\n-- Add level data\nentry.level = entry.level or 1\n-- Add faction data\nentry.faction = entry.faction or \"citizen\"\n-- Add money data\nentry.money = entry.money or 0\n-- Add last seen data\nentry.lastSeen = entry.lastSeen or \"Never\"\n-- Add faction-specific data\nif entry.faction == \"police\" then\n    entry.warnings = entry.warnings or 0\n    entry.arrests = entry.arrests or 0\nelseif entry.faction == \"medic\" then\n    entry.heals = entry.heals or 0\n    entry.revives = entry.revives or 0\n    end\n-- Add admin data\nif LocalPlayer():IsAdmin() then\n    entry.steamID = entry.steamID or \"Unknown\"\n    entry.ipAddress = entry.ipAddress or \"Unknown\"\n    end\n-- Add custom styling\nif entry.level &gt;= 10 then\n    entry.isHighLevel = true\n    end\nif entry.money &gt;= 10000 then\n    entry.isRich = true\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#charlistextradetails","title":"CharListExtraDetails","text":"<p>Purpose</p> <p>Called to add extra details to character list entries</p> <p>When Called</p> <p>When building character list entries with additional information</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client viewing the character list</li> <li><code>entry</code> (table): The character data for this entry</li> <li><code>stored</code> (table): The stored character data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic extra details\nhook.Add(\"CharListExtraDetails\", \"MyAddon\", function(client, entry, stored)\nentry.extraInfo = \"Additional Information\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add faction-specific details\nhook.Add(\"CharListExtraDetails\", \"FactionDetails\", function(client, entry, stored)\nlocal faction = entry.faction or \"citizen\"\nif faction == \"police\" then\n    entry.extraInfo = \"Police Officer\"\nelseif faction == \"medic\" then\n    entry.extraInfo = \"Medical Staff\"\nelse\n    entry.extraInfo = \"Civilian\"\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex extra details system\nhook.Add(\"CharListExtraDetails\", \"AdvancedExtraDetails\", function(client, entry, stored)\n-- Add basic extra details\nentry.extraInfo = \"Additional Information\"\n-- Add faction-specific details\nlocal faction = entry.faction or \"citizen\"\nif faction == \"police\" then\n    entry.extraInfo = \"Police Officer\"\n    entry.rank = entry.rank or \"Officer\"\n    entry.badge = entry.badge or \"0000\"\nelseif faction == \"medic\" then\n    entry.extraInfo = \"Medical Staff\"\n    entry.rank = entry.rank or \"Nurse\"\n    entry.license = entry.license or \"N/A\"\nelse\n    entry.extraInfo = \"Civilian\"\n    entry.occupation = entry.occupation or \"Unemployed\"\n    end\n-- Add level-based details\nlocal level = entry.level or 1\nif level &gt;= 10 then\n    entry.extraInfo = entry.extraInfo .. \" (High Level)\"\n    end\n-- Add money-based details\nlocal money = entry.money or 0\nif money &gt;= 10000 then\n    entry.extraInfo = entry.extraInfo .. \" (Rich)\"\n    end\n-- Add admin details\nif client:IsAdmin() then\n    entry.adminInfo = \"Admin View\"\n    entry.steamID = entry.steamID or \"Unknown\"\n    entry.ipAddress = entry.ipAddress or \"Unknown\"\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#charlistloaded","title":"CharListLoaded","text":"<p>Purpose</p> <p>Called when character list is loaded</p> <p>When Called</p> <p>When the character list data is successfully loaded</p> <p>Parameters</p> <ul> <li><code>newCharList</code> (table): The loaded character list data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character list loading\nhook.Add(\"CharListLoaded\", \"MyAddon\", function(newCharList)\nprint(\"Character list loaded with \" .. #newCharList .. \" characters\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Process character list data\nhook.Add(\"CharListLoaded\", \"CharListProcessing\", function(newCharList)\n-- Count characters by faction\nlocal factionCount = {}\nfor _, char in ipairs(newCharList) do\n    local faction = char.faction or \"citizen\"\n    factionCount[faction] = (factionCount[faction] or 0) + 1\n    end\n-- Display faction counts\nfor faction, count in pairs(factionCount) do\n    print(faction .. \": \" .. count .. \" characters\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character list processing\nhook.Add(\"CharListLoaded\", \"AdvancedCharListProcessing\", function(newCharList)\n-- Count characters by faction\nlocal factionCount = {}\nfor _, char in ipairs(newCharList) do\n    local faction = char.faction or \"citizen\"\n    factionCount[faction] = (factionCount[faction] or 0) + 1\n    end\n-- Display faction counts\nfor faction, count in pairs(factionCount) do\n    print(faction .. \": \" .. count .. \" characters\")\n    end\n-- Process character data\nfor _, char in ipairs(newCharList) do\n    -- Add level data\n    char.level = char.level or 1\n    -- Add faction data\n    char.faction = char.faction or \"citizen\"\n    -- Add money data\n    char.money = char.money or 0\n    -- Add last seen data\n    char.lastSeen = char.lastSeen or \"Never\"\n    -- Add faction-specific data\n    if char.faction == \"police\" then\n        char.warnings = char.warnings or 0\n        char.arrests = char.arrests or 0\n    elseif char.faction == \"medic\" then\n        char.heals = char.heals or 0\n        char.revives = char.revives or 0\n        end\n    end\n-- Sort characters by level\ntable.sort(newCharList, function(a, b)\nreturn (a.level or 1) &gt; (b.level or 1)\nend)\nprint(\"Character list loaded and processed with \" .. #newCharList .. \" characters\")\nend)\n</code></pre></p>"},{"location":"hooks/client/#charlistupdated","title":"CharListUpdated","text":"<p>Purpose</p> <p>Called when character list is updated</p> <p>When Called</p> <p>When the character list data is modified</p> <p>Parameters</p> <ul> <li><code>oldCharList</code> (table): The previous character list data</li> <li><code>newCharList</code> (table): The updated character list data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character list updates\nhook.Add(\"CharListUpdated\", \"MyAddon\", function(oldCharList, newCharList)\nprint(\"Character list updated from \" .. #oldCharList .. \" to \" .. #newCharList .. \" characters\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track character changes\nhook.Add(\"CharListUpdated\", \"CharChangeTracking\", function(oldCharList, newCharList)\n-- Find new characters\nfor _, newChar in ipairs(newCharList) do\n    local found = false\n    for _, oldChar in ipairs(oldCharList) do\n        if oldChar.id == newChar.id then\n            found = true\n            break\n            end\n        end\n    if not found then\n        print(\"New character: \" .. newChar.name)\n        end\n    end\n-- Find removed characters\nfor _, oldChar in ipairs(oldCharList) do\n    local found = false\n    for _, newChar in ipairs(newCharList) do\n        if oldChar.id == newChar.id then\n            found = true\n            break\n            end\n        end\n    if not found then\n        print(\"Removed character: \" .. oldChar.name)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character list update system\nhook.Add(\"CharListUpdated\", \"AdvancedCharListUpdate\", function(oldCharList, newCharList)\n-- Create lookup tables for efficient comparison\nlocal oldChars = {}\nfor _, char in ipairs(oldCharList) do\n    oldChars[char.id] = char\n    end\nlocal newChars = {}\nfor _, char in ipairs(newCharList) do\n    newChars[char.id] = char\n    end\n-- Find new characters\nfor _, newChar in ipairs(newCharList) do\n    if not oldChars[newChar.id] then\n        print(\"New character: \" .. newChar.name .. \" (ID: \" .. newChar.id .. \")\")\n        end\n    end\n-- Find removed characters\nfor _, oldChar in ipairs(oldCharList) do\n    if not newChars[oldChar.id] then\n        print(\"Removed character: \" .. oldChar.name .. \" (ID: \" .. oldChar.id .. \")\")\n        end\n    end\n-- Find modified characters\nfor _, newChar in ipairs(newCharList) do\n    local oldChar = oldChars[newChar.id]\n    if oldChar then\n        -- Check for changes\n        if oldChar.name ~= newChar.name then\n            print(\"Character name changed: \" .. oldChar.name .. \" -&gt; \" .. newChar.name)\n            end\n        if oldChar.faction ~= newChar.faction then\n            print(\"Character faction changed: \" .. oldChar.name .. \" \" .. oldChar.faction .. \" -&gt; \" .. newChar.faction)\n            end\n        if oldChar.level ~= newChar.level then\n            print(\"Character level changed: \" .. newChar.name .. \" \" .. oldChar.level .. \" -&gt; \" .. newChar.level)\n            end\n        end\n    end\n-- Update character counts\nlocal oldCount = #oldCharList\nlocal newCount = #newCharList\nprint(\"Character list updated: \" .. oldCount .. \" -&gt; \" .. newCount .. \" characters\")\nend)\n</code></pre></p>"},{"location":"hooks/client/#charmenuclosed","title":"CharMenuClosed","text":"<p>Purpose</p> <p>Called when the character menu is closed</p> <p>When Called</p> <p>When the character selection menu is closed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log menu closing\nhook.Add(\"CharMenuClosed\", \"MyAddon\", function()\nprint(\"Character menu closed\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up menu data\nhook.Add(\"CharMenuClosed\", \"MenuCleanup\", function()\n-- Clear cached character data\nlia.charCache = nil\nprint(\"Character menu closed and cache cleared\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex menu close handling\nhook.Add(\"CharMenuClosed\", \"AdvancedMenuClose\", function()\n-- Clear cached character data\nlia.charCache = nil\n-- Reset menu state\nlia.menuState = nil\n-- Log menu close time\nlocal closeTime = os.time()\nlia.lastMenuClose = closeTime\nprint(\"Character menu closed at \" .. os.date(\"%H:%M:%S\", closeTime))\nend)\n</code></pre></p>"},{"location":"hooks/client/#charmenuopened","title":"CharMenuOpened","text":"<p>Purpose</p> <p>Called when the character menu is opened</p> <p>When Called</p> <p>When the character selection menu is opened</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The character menu panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log menu opening\nhook.Add(\"CharMenuOpened\", \"MyAddon\", function(self)\nprint(\"Character menu opened\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load character data\nhook.Add(\"CharMenuOpened\", \"MenuDataLoad\", function(self)\n-- Load character list\nlia.charList = lia.char.getAll()\nprint(\"Character menu opened with \" .. #lia.charList .. \" characters\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex menu open handling\nhook.Add(\"CharMenuOpened\", \"AdvancedMenuOpen\", function(self)\n-- Load character list\nlia.charList = lia.char.getAll()\n-- Set menu state\nlia.menuState = \"open\"\n-- Log menu open time\nlocal openTime = os.time()\nlia.lastMenuOpen = openTime\n-- Apply custom styling\nif self then\n    self:SetBackgroundColor(Color(0, 0, 0, 200))\n    end\nprint(\"Character menu opened at \" .. os.date(\"%H:%M:%S\", openTime))\nend)\n</code></pre></p>"},{"location":"hooks/client/#chataddtext","title":"ChatAddText","text":"<p>Purpose</p> <p>Called to add text to the chat</p> <p>When Called</p> <p>When text is being added to the chatbox</p> <p>Parameters</p> <ul> <li><code>markup</code> (table): The markup table containing text formatting</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log chat text\nhook.Add(\"ChatAddText\", \"MyAddon\", function(markup, ...)\nprint(\"Chat text added\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Modify chat text color\nhook.Add(\"ChatAddText\", \"ChatColorMod\", function(markup, ...)\n-- Change text color based on content\nlocal args = {...}\nfor i, arg in ipairs(args) do\n    if isstring(arg) and string.find(arg, \"important\") then\n        markup.color = Color(255, 0, 0)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex chat text processing\nhook.Add(\"ChatAddText\", \"AdvancedChatText\", function(markup, ...)\nlocal args = {...}\n-- Process each argument\nfor i, arg in ipairs(args) do\n    if isstring(arg) then\n        -- Highlight player names\n        if string.find(arg, LocalPlayer():Name()) then\n            markup.color = Color(255, 255, 0)\n            end\n        -- Filter inappropriate content\n        local bannedWords = {\"spam\", \"hack\"}\n        for _, word in ipairs(bannedWords) do\n            if string.find(string.lower(arg), string.lower(word)) then\n                return false -- Block the message\n                end\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#chatboxpanelcreated","title":"ChatboxPanelCreated","text":"<p>Purpose</p> <p>Called when the chatbox panel is created</p> <p>When Called</p> <p>When the chatbox UI panel is initialized</p> <p>Parameters</p> <ul> <li><code>panel</code> (Panel): The chatbox panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log panel creation\nhook.Add(\"ChatboxPanelCreated\", \"MyAddon\", function(panel)\nprint(\"Chatbox panel created\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize chatbox appearance\nhook.Add(\"ChatboxPanelCreated\", \"ChatboxCustomize\", function(panel)\nif panel then\n    panel:SetBackgroundColor(Color(0, 0, 0, 200))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex chatbox customization\nhook.Add(\"ChatboxPanelCreated\", \"AdvancedChatbox\", function(panel)\nif not panel then return end\n    -- Customize appearance\n    panel:SetBackgroundColor(Color(0, 0, 0, 200))\n    panel:SetSize(500, 300)\n    -- Add custom buttons\n    local closeBtn = panel:Add(\"DButton\")\n    closeBtn:SetText(\"X\")\n    closeBtn:SetSize(20, 20)\n    closeBtn.DoClick = function()\n    panel:SetVisible(false)\n    end\nprint(\"Chatbox panel created and customized\")\nend)\n</code></pre></p>"},{"location":"hooks/client/#chatboxtextadded","title":"ChatboxTextAdded","text":"<p>Purpose</p> <p>Called when text is added to the chatbox</p> <p>When Called</p> <p>When new text is displayed in the chatbox</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log chatbox text\nhook.Add(\"ChatboxTextAdded\", \"MyAddon\", function(...)\nprint(\"Text added to chatbox\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Process chatbox text\nhook.Add(\"ChatboxTextAdded\", \"ChatboxProcess\", function(...)\nlocal args = {...}\nfor i, arg in ipairs(args) do\n    if isstring(arg) then\n        print(\"Chatbox text: \" .. arg)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex chatbox text handling\nhook.Add(\"ChatboxTextAdded\", \"AdvancedChatboxText\", function(...)\nlocal args = {...}\n-- Process each argument\nfor i, arg in ipairs(args) do\n    if isstring(arg) then\n        -- Highlight player mentions\n        if string.find(arg, \"@\" .. LocalPlayer():Name()) then\n            surface.PlaySound(\"buttons/button15.wav\")\n            end\n        -- Log important messages\n        if string.find(arg, \"[ADMIN]\") or string.find(arg, \"[SYSTEM]\") then\n            lia.chatLog = lia.chatLog or {}\n            table.insert(lia.chatLog, {text = arg, time = os.time()})\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#choosecharacter","title":"ChooseCharacter","text":"<p>Purpose</p> <p>Called when a character is chosen</p> <p>When Called</p> <p>When a player selects a character to play</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The ID of the character being chosen</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character choice\nhook.Add(\"ChooseCharacter\", \"MyAddon\", function(id)\nprint(\"Chose character ID: \" .. id)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Cache character data\nhook.Add(\"ChooseCharacter\", \"CharacterCache\", function(id)\nlia.selectedCharID = id\nprint(\"Selected character: \" .. id)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character selection\nhook.Add(\"ChooseCharacter\", \"AdvancedCharSelect\", function(id)\n-- Cache character ID\nlia.selectedCharID = id\n-- Log selection time\nlia.charSelectTime = os.time()\n-- Play selection sound\nsurface.PlaySound(\"buttons/button14.wav\")\n-- Notify server\nnet.Start(\"CharacterSelected\")\nnet.WriteUInt(id, 32)\nnet.SendToServer()\nprint(\"Selected character ID: \" .. id .. \" at \" .. os.date(\"%H:%M:%S\"))\nend)\n</code></pre></p>"},{"location":"hooks/client/#configurecharactercreationsteps","title":"ConfigureCharacterCreationSteps","text":"<p>Purpose</p> <p>Called to configure character creation steps</p> <p>When Called</p> <p>When setting up the character creation process</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The character creation panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log creation step configuration\nhook.Add(\"ConfigureCharacterCreationSteps\", \"MyAddon\", function(self)\nprint(\"Configuring character creation steps\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add custom creation step\nhook.Add(\"ConfigureCharacterCreationSteps\", \"CustomStep\", function(self)\nif self then\n    self:AddStep(\"Custom\", function(panel)\n    -- Custom step UI\n    local label = panel:Add(\"DLabel\")\n    label:SetText(\"Custom Step\")\n    end)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex creation step configuration\nhook.Add(\"ConfigureCharacterCreationSteps\", \"AdvancedCreationSteps\", function(self)\nif not self then return end\n    -- Add custom background step\n    self:AddStep(\"Background\", function(panel)\n    local label = panel:Add(\"DLabel\")\n    label:SetText(\"Select Background\")\n    label:Dock(TOP)\n    local combo = panel:Add(\"DComboBox\")\n    combo:Dock(TOP)\n    combo:AddChoice(\"Soldier\")\n    combo:AddChoice(\"Merchant\")\n    combo:AddChoice(\"Scholar\")\n    end)\n    -- Add custom traits step\n    self:AddStep(\"Traits\", function(panel)\n    local label = panel:Add(\"DLabel\")\n    label:SetText(\"Select Traits\")\n    label:Dock(TOP)\n    for i = 1, 3 do\n        local checkbox = panel:Add(\"DCheckBoxLabel\")\n        checkbox:SetText(\"Trait \" .. i)\n        checkbox:Dock(TOP)\n        end\n    end)\n    print(\"Character creation steps configured\")\n    end)\n</code></pre></p>"},{"location":"hooks/client/#createchat","title":"CreateChat","text":"<p>Purpose</p> <p>Called to create the chat interface</p> <p>When Called</p> <p>When the chat UI is being initialized</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log chat creation\nhook.Add(\"CreateChat\", \"MyAddon\", function()\nprint(\"Chat interface created\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize chat appearance\nhook.Add(\"CreateChat\", \"ChatCustomize\", function()\nif lia.chat then\n    lia.chat:SetBackgroundColor(Color(0, 0, 0, 200))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex chat customization\nhook.Add(\"CreateChat\", \"AdvancedChatSetup\", function()\nif not lia.chat then return end\n    -- Customize appearance\n    lia.chat:SetBackgroundColor(Color(0, 0, 0, 200))\n    lia.chat:SetSize(500, 300)\n    -- Add custom chat tabs\n    lia.chat:AddTab(\"Global\", Color(255, 255, 255))\n    lia.chat:AddTab(\"Local\", Color(100, 200, 100))\n    lia.chat:AddTab(\"Admin\", Color(255, 0, 0))\n    print(\"Chat interface created and customized\")\n    end)\n</code></pre></p>"},{"location":"hooks/client/#createinformationbuttons","title":"CreateInformationButtons","text":"<p>Purpose</p> <p>Called to create information buttons in the F1 menu</p> <p>When Called</p> <p>When building the information panel buttons</p> <p>Parameters</p> <ul> <li><code>pages</code> (table): The pages table to add buttons to</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>    -- Simple: Add a basic information button\n    hook.Add(\"CreateInformationButtons\", \"MyAddon\", function(pages)\n    pages[\"Custom\"] = function(panel)\n    panel:Add(\"DLabel\"):SetText(\"Custom Information\")\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>    -- Medium: Add multiple information pages\n    hook.Add(\"CreateInformationButtons\", \"InfoPages\", function(pages)\n    pages[\"Rules\"] = function(panel)\n    local label = panel:Add(\"DLabel\")\n    label:SetText(\"Server Rules\")\n    label:Dock(TOP)\n    end\npages[\"Commands\"] = function(panel)\nlocal label = panel:Add(\"DLabel\")\nlabel:SetText(\"Available Commands\")\nlabel:Dock(TOP)\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>    -- High: Complex information pages\n    hook.Add(\"CreateInformationButtons\", \"AdvancedInfoPages\", function(pages)\n    pages[\"Rules\"] = function(panel)\n    local scroll = panel:Add(\"DScrollPanel\")\n    scroll:Dock(FILL)\n    local rules = {\n    \"1. No RDM\",\n    \"2. No prop spam\",\n    \"3. Respect staff\"\n    }\n    for i, rule in ipairs(rules) do\n        local label = scroll:Add(\"DLabel\")\n        label:SetText(rule)\n        label:Dock(TOP)\n        end\n    end\npages[\"Commands\"] = function(panel)\nlocal scroll = panel:Add(\"DScrollPanel\")\nscroll:Dock(FILL)\nfor cmd, data in pairs(lia.command.list) do\n    local label = scroll:Add(\"DLabel\")\n    label:SetText(\"/\" .. cmd .. \" - \" .. (data.description or \"No description\"))\n    label:Dock(TOP)\n    end\nend\nend)\n</code></pre></p>"},{"location":"hooks/client/#createinventorypanel","title":"CreateInventoryPanel","text":"<p>Purpose</p> <p>Called to create an inventory panel</p> <p>When Called</p> <p>When an inventory UI panel needs to be created</p> <p>Parameters</p> <ul> <li><code>inventory</code> (Inventory): The inventory to create a panel for</li> <li><code>parent</code> (Panel): The parent panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log inventory panel creation\nhook.Add(\"CreateInventoryPanel\", \"MyAddon\", function(inventory, parent)\nprint(\"Creating inventory panel\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize inventory panel\nhook.Add(\"CreateInventoryPanel\", \"InventoryCustomize\", function(inventory, parent)\nif parent then\n    parent:SetBackgroundColor(Color(50, 50, 50, 200))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory panel customization\nhook.Add(\"CreateInventoryPanel\", \"AdvancedInventoryPanel\", function(inventory, parent)\nif not parent then return end\n    -- Customize appearance\n    parent:SetBackgroundColor(Color(50, 50, 50, 200))\n    -- Add weight display\n    local weightLabel = parent:Add(\"DLabel\")\n    weightLabel:SetText(\"Weight: \" .. inventory:getWeight() .. \"/\" .. inventory:getMaxWeight())\n    weightLabel:Dock(BOTTOM)\n    -- Add money display\n    local char = LocalPlayer():getChar()\n    if char then\n        local moneyLabel = parent:Add(\"DLabel\")\n        moneyLabel:SetText(\"Money: $\" .. char:getMoney())\n        moneyLabel:Dock(BOTTOM)\n        end\n    print(\"Inventory panel created and customized\")\n    end)\n</code></pre></p>"},{"location":"hooks/client/#createmenubuttons","title":"CreateMenuButtons","text":"<p>Purpose</p> <p>Called to create menu buttons</p> <p>When Called</p> <p>When building the main menu button tabs</p> <p>Parameters</p> <ul> <li><code>tabs</code> (table): The tabs table to add buttons to</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>    -- Simple: Add a basic menu button\n    hook.Add(\"CreateMenuButtons\", \"MyAddon\", function(tabs)\n    tabs[\"Custom\"] = function(panel)\n    panel:Add(\"DLabel\"):SetText(\"Custom Menu\")\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>    -- Medium: Add multiple menu tabs\n    hook.Add(\"CreateMenuButtons\", \"MenuTabs\", function(tabs)\n    tabs[\"Settings\"] = function(panel)\n    local label = panel:Add(\"DLabel\")\n    label:SetText(\"Settings\")\n    label:Dock(TOP)\n    end\ntabs[\"Help\"] = function(panel)\nlocal label = panel:Add(\"DLabel\")\nlabel:SetText(\"Help &amp; Support\")\nlabel:Dock(TOP)\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>    -- High: Complex menu system\n    hook.Add(\"CreateMenuButtons\", \"AdvancedMenu\", function(tabs)\n    tabs[\"Settings\"] = function(panel)\n    local scroll = panel:Add(\"DScrollPanel\")\n    scroll:Dock(FILL)\n    -- Add settings options\n    local options = {\n    {name = \"Volume\", type = \"slider\"},\n    {name = \"FOV\", type = \"slider\"},\n    {name = \"HUD Scale\", type = \"slider\"}\n    }\n    for _, option in ipairs(options) do\n        local container = scroll:Add(\"DPanel\")\n        container:Dock(TOP)\n        container:SetHeight(50)\n        local label = container:Add(\"DLabel\")\n        label:SetText(option.name)\n        label:Dock(LEFT)\n        if option.type == \"slider\" then\n            local slider = container:Add(\"DNumSlider\")\n            slider:Dock(FILL)\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#dermaskinchanged","title":"DermaSkinChanged","text":"<p>Purpose</p> <p>Called when derma skin is changed</p> <p>When Called</p> <p>When the UI skin is changed</p> <p>Parameters</p> <ul> <li><code>newSkin</code> (string): The new skin name</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log skin change\nhook.Add(\"DermaSkinChanged\", \"MyAddon\", function(newSkin)\nprint(\"Skin changed to: \" .. newSkin)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save skin preference\nhook.Add(\"DermaSkinChanged\", \"SkinPreference\", function(newSkin)\nlocal char = LocalPlayer():getChar()\nif char then\n    char:setData(\"preferredSkin\", newSkin)\n    end\nprint(\"Skin changed to: \" .. newSkin)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex skin management system\nhook.Add(\"DermaSkinChanged\", \"AdvancedSkinManagement\", function(newSkin)\nlocal char = LocalPlayer():getChar()\nif char then\n    char:setData(\"preferredSkin\", newSkin)\n    end\n-- Update UI elements\nfor _, panel in ipairs(vgui.GetWorldPanel():GetChildren()) do\n    if IsValid(panel) and panel.UpdateSkin then\n        panel:UpdateSkin(newSkin)\n        end\n    end\n-- Save to file\nfile.Write(\"lilia_skin.txt\", newSkin)\nprint(\"Skin changed to: \" .. newSkin .. \" and saved\")\nend)\n</code></pre></p>"},{"location":"hooks/client/#drawcharinfo","title":"DrawCharInfo","text":"<p>Purpose</p> <p>Called to draw character information</p> <p>When Called</p> <p>When character information needs to be rendered</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose character info is being drawn</li> <li><code>character</code> (Character): The character being displayed</li> <li><code>info</code> (table): The information table to populate</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic character info\nhook.Add(\"DrawCharInfo\", \"MyAddon\", function(client, character, info)\ninfo[\"Name\"] = character:getName()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add multiple character details\nhook.Add(\"DrawCharInfo\", \"CharDetails\", function(client, character, info)\ninfo[\"Name\"] = character:getName()\ninfo[\"Faction\"] = character:getFaction()\ninfo[\"Money\"] = \"$\" .. character:getMoney()\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character information display\nhook.Add(\"DrawCharInfo\", \"AdvancedCharInfo\", function(client, character, info)\n-- Basic info\ninfo[\"Name\"] = character:getName()\ninfo[\"Faction\"] = character:getFaction()\ninfo[\"Money\"] = \"$\" .. character:getMoney()\n-- Level and experience\nlocal level = character:getData(\"level\", 1)\nlocal exp = character:getData(\"experience\", 0)\ninfo[\"Level\"] = level .. \" (\" .. exp .. \" XP)\"\n-- Attributes\nlocal attributes = character:getAttribs()\nfor attr, value in pairs(attributes) do\n    info[\"Attribute: \" .. attr] = value\n    end\n-- Play time\nlocal playTime = character:getData(\"playTime\", 0)\nlocal hours = math.floor(playTime / 3600)\nlocal minutes = math.floor((playTime % 3600) / 60)\ninfo[\"Play Time\"] = hours .. \"h \" .. minutes .. \"m\"\nend)\n</code></pre></p>"},{"location":"hooks/client/#drawdoorinfobox","title":"DrawDoorInfoBox","text":"<p>Purpose</p> <p>Called to draw door information box</p> <p>When Called</p> <p>When rendering door information UI</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The door entity</li> <li><code>infoTexts</code> (table): The information texts to display</li> <li><code>alphaOverride</code> (number): Alpha override value for transparency</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic door info\nhook.Add(\"DrawDoorInfoBox\", \"MyAddon\", function(entity, infoTexts, alphaOverride)\ntable.insert(infoTexts, \"Door: \" .. entity:EntIndex())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add door ownership info\nhook.Add(\"DrawDoorInfoBox\", \"DoorOwnership\", function(entity, infoTexts, alphaOverride)\nlocal owner = entity:getNetVar(\"owner\")\nif owner then\n    table.insert(infoTexts, \"Owner: \" .. owner)\nelse\n    table.insert(infoTexts, \"Unowned\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door information display\nhook.Add(\"DrawDoorInfoBox\", \"AdvancedDoorInfo\", function(entity, infoTexts, alphaOverride)\n-- Door title\nlocal title = entity:getNetVar(\"title\", \"Door\")\ntable.insert(infoTexts, \"Title: \" .. title)\n-- Owner info\nlocal owner = entity:getNetVar(\"owner\")\nif owner then\n    table.insert(infoTexts, \"Owner: \" .. owner)\nelse\n    table.insert(infoTexts, \"Unowned\")\n    end\n-- Price info\nlocal price = entity:getNetVar(\"price\", 0)\nif price &gt; 0 then\n    table.insert(infoTexts, \"Price: $\" .. price)\n    end\n-- Lock status\nlocal locked = entity:getNetVar(\"locked\", false)\ntable.insert(infoTexts, \"Status: \" .. (locked and \"Locked\" or \"Unlocked\"))\n-- Faction restriction\nlocal faction = entity:getNetVar(\"faction\")\nif faction then\n    table.insert(infoTexts, \"Faction: \" .. faction)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#drawentityinfo","title":"DrawEntityInfo","text":"<p>Purpose</p> <p>Called to draw entity information</p> <p>When Called</p> <p>When rendering entity information UI</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The entity to draw information for</li> <li><code>alpha</code> (number): The alpha/transparency value</li> <li><code>position</code> (Vector): The position to draw at</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic entity info\nhook.Add(\"DrawEntityInfo\", \"MyAddon\", function(entity, alpha, position)\ndraw.SimpleText(entity:GetClass(), \"Default\", position.x, position.y, Color(255, 255, 255, alpha))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add entity details\nhook.Add(\"DrawEntityInfo\", \"EntityDetails\", function(entity, alpha, position)\nlocal text = entity:GetClass()\nif entity:GetModel() then\n    text = text .. \"\\n\" .. entity:GetModel()\n    end\ndraw.SimpleText(text, \"Default\", position.x, position.y, Color(255, 255, 255, alpha))\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entity information display\nhook.Add(\"DrawEntityInfo\", \"AdvancedEntityInfo\", function(entity, alpha, position)\nlocal y = position.y\n-- Entity class\ndraw.SimpleText(\"Class: \" .. entity:GetClass(), \"Default\", position.x, y, Color(255, 255, 255, alpha))\ny = y + 15\n-- Entity model\nif entity:GetModel() then\n    draw.SimpleText(\"Model: \" .. entity:GetModel(), \"Default\", position.x, y, Color(200, 200, 200, alpha))\n    y = y + 15\n    end\n-- Entity health\nif entity:Health() &gt; 0 then\n    draw.SimpleText(\"Health: \" .. entity:Health(), \"Default\", position.x, y, Color(100, 255, 100, alpha))\n    y = y + 15\n    end\n-- Custom entity data\nif entity.getName then\n    local name = entity:getName()\n    if name and name ~= \"\" then\n        draw.SimpleText(\"Name: \" .. name, \"Default\", position.x, y, Color(255, 255, 100, alpha))\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#drawliliamodelview","title":"DrawLiliaModelView","text":"<p>Purpose</p> <p>Called to draw Lilia model view</p> <p>When Called</p> <p>When rendering a model view panel</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The model view panel</li> <li><code>ent</code> (Entity): The entity being displayed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log model view drawing\nhook.Add(\"DrawLiliaModelView\", \"MyAddon\", function(self, ent)\nprint(\"Drawing model view\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize model view\nhook.Add(\"DrawLiliaModelView\", \"ModelViewCustomize\", function(self, ent)\nif ent then\n    ent:SetAngles(Angle(0, 45, 0))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex model view customization\nhook.Add(\"DrawLiliaModelView\", \"AdvancedModelView\", function(self, ent)\nif not ent then return end\n    -- Rotate model\n    local ang = ent:GetAngles()\n    ang.y = ang.y + FrameTime() * 30\n    ent:SetAngles(ang)\n    -- Apply lighting\n    local lightPos = ent:GetPos() + Vector(0, 0, 50)\n    render.SetLightingOrigin(lightPos)\n    -- Draw model with custom material\n    if ent.customMaterial then\n        ent:SetMaterial(ent.customMaterial)\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/client/#drawplayerragdoll","title":"DrawPlayerRagdoll","text":"<p>Purpose</p> <p>Called to draw a player's ragdoll</p> <p>When Called</p> <p>When rendering a player ragdoll entity</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The ragdoll entity</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log ragdoll drawing\nhook.Add(\"DrawPlayerRagdoll\", \"MyAddon\", function(entity)\nprint(\"Drawing ragdoll: \" .. entity:EntIndex())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize ragdoll appearance\nhook.Add(\"DrawPlayerRagdoll\", \"RagdollCustomize\", function(entity)\nif entity:GetModel() then\n    entity:SetColor(Color(255, 200, 200))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ragdoll rendering\nhook.Add(\"DrawPlayerRagdoll\", \"AdvancedRagdoll\", function(entity)\nif not IsValid(entity) then return end\n    -- Apply custom material\n    local owner = entity:getNetVar(\"owner\")\n    if owner then\n        local ply = player.GetBySteamID(owner)\n        if IsValid(ply) then\n            local char = ply:getChar()\n            if char then\n                -- Apply faction-based coloring\n                local faction = char:getFaction()\n                local colors = {\n                [\"police\"] = Color(0, 0, 255),\n                [\"medic\"] = Color(255, 255, 255),\n                [\"citizen\"] = Color(200, 200, 200)\n                }\n                local color = colors[faction] or Color(255, 255, 255)\n                entity:SetColor(color)\n                end\n            end\n        end\n    -- Draw death time\n    local deathTime = entity:getNetVar(\"deathTime\", 0)\n    if deathTime &gt; 0 then\n        local timeSinceDeath = CurTime() - deathTime\n        local pos = entity:GetPos() + Vector(0, 0, 50)\n        local ang = LocalPlayer():EyeAngles()\n        ang:RotateAroundAxis(ang:Forward(), 90)\n        ang:RotateAroundAxis(ang:Right(), 90)\n        cam.Start3D2D(pos, ang, 0.1)\n        draw.SimpleText(\"Dead for: \" .. math.floor(timeSinceDeath) .. \"s\", \"Default\", 0, 0, Color(255, 255, 255), TEXT_ALIGN_CENTER)\n        cam.End3D2D()\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/client/#exitstorage","title":"ExitStorage","text":"<p>Purpose</p> <p>Called when exiting storage</p> <p>When Called</p> <p>When a player closes a storage container</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log storage exit\nhook.Add(\"ExitStorage\", \"MyAddon\", function()\nprint(\"Exited storage\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up storage UI\nhook.Add(\"ExitStorage\", \"StorageCleanup\", function()\nif lia.storagePanel then\n    lia.storagePanel:Remove()\n    lia.storagePanel = nil\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage exit handling\nhook.Add(\"ExitStorage\", \"AdvancedStorageExit\", function()\n-- Clean up storage UI\nif lia.storagePanel then\n    lia.storagePanel:Remove()\n    lia.storagePanel = nil\n    end\n-- Clear storage cache\nlia.currentStorage = nil\n-- Log storage exit time\nlocal exitTime = os.time()\nlia.lastStorageExit = exitTime\n-- Calculate storage session duration\nif lia.storageEnterTime then\n    local duration = exitTime - lia.storageEnterTime\n    print(\"Storage session duration: \" .. duration .. \" seconds\")\n    lia.storageEnterTime = nil\n    end\n-- Notify server\nnet.Start(\"StorageExited\")\nnet.SendToServer()\nend)\n</code></pre></p>"},{"location":"hooks/client/#f1menuclosed","title":"F1MenuClosed","text":"<p>Purpose</p> <p>Called when the F1 menu is closed</p> <p>When Called</p> <p>When the F1 character information menu is closed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log F1 menu closing\nhook.Add(\"F1MenuClosed\", \"MyAddon\", function()\nprint(\"F1 menu closed\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up F1 menu data\nhook.Add(\"F1MenuClosed\", \"F1MenuCleanup\", function()\nlia.f1MenuOpen = false\nprint(\"F1 menu closed and state updated\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex F1 menu close handling\nhook.Add(\"F1MenuClosed\", \"AdvancedF1Close\", function()\n-- Update menu state\nlia.f1MenuOpen = false\n-- Log menu close time\nlocal closeTime = os.time()\nlia.lastF1Close = closeTime\n-- Calculate menu session duration\nif lia.f1OpenTime then\n    local duration = closeTime - lia.f1OpenTime\n    print(\"F1 menu session duration: \" .. duration .. \" seconds\")\n    lia.f1OpenTime = nil\n    end\n-- Clear cached character data\nlia.f1CharCache = nil\nprint(\"F1 menu closed at \" .. os.date(\"%H:%M:%S\", closeTime))\nend)\n</code></pre></p>"},{"location":"hooks/client/#f1menuopened","title":"F1MenuOpened","text":"<p>Purpose</p> <p>Called when the F1 menu is opened</p> <p>When Called</p> <p>When the F1 character information menu is opened</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The F1 menu panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log F1 menu opening\nhook.Add(\"F1MenuOpened\", \"MyAddon\", function(self)\nprint(\"F1 menu opened\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update F1 menu state\nhook.Add(\"F1MenuOpened\", \"F1MenuState\", function(self)\nlia.f1MenuOpen = true\nlia.f1OpenTime = os.time()\nprint(\"F1 menu opened\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex F1 menu open handling\nhook.Add(\"F1MenuOpened\", \"AdvancedF1Open\", function(self)\n-- Update menu state\nlia.f1MenuOpen = true\n-- Log menu open time\nlocal openTime = os.time()\nlia.f1OpenTime = openTime\n-- Cache character data\nlocal char = LocalPlayer():getChar()\nif char then\n    lia.f1CharCache = {\n    name = char:getName(),\n    faction = char:getFaction(),\n    money = char:getMoney(),\n    level = char:getData(\"level\", 1)\n    }\n    end\n-- Customize panel appearance\nif self then\n    self:SetBackgroundColor(Color(0, 0, 0, 200))\n    end\nprint(\"F1 menu opened at \" .. os.date(\"%H:%M:%S\", openTime))\nend)\n</code></pre></p>"},{"location":"hooks/client/#filtercharmodels","title":"FilterCharModels","text":"<p>Purpose</p> <p>Called to filter character models</p> <p>When Called</p> <p>When character models need to be filtered or restricted</p> <p>Parameters</p> <ul> <li><code>models</code> (table): The table of available models to filter</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log model filtering\nhook.Add(\"FilterCharModels\", \"MyAddon\", function(models)\nprint(\"Filtering \" .. #models .. \" character models\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Remove specific models\nhook.Add(\"FilterCharModels\", \"ModelRestriction\", function(models)\nlocal bannedModels = {\n\"models/player/combine_soldier.mdl\",\n\"models/player/combine_super_soldier.mdl\"\n}\nfor i = #models, 1, -1 do\n    if table.HasValue(bannedModels, models[i]) then\n        table.remove(models, i)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex model filtering system\nhook.Add(\"FilterCharModels\", \"AdvancedModelFilter\", function(models)\nlocal char = LocalPlayer():getChar()\nif not char then return end\n    local faction = char:getFaction()\n    -- Faction-specific model restrictions\n    local factionModels = {\n    [\"police\"] = {\n    allowed = {\"models/player/police.mdl\", \"models/player/cop.mdl\"},\n    banned = {\"models/player/criminal.mdl\"}\n    },\n    [\"criminal\"] = {\n    allowed = {\"models/player/criminal.mdl\", \"models/player/thug.mdl\"},\n    banned = {\"models/player/police.mdl\"}\n    }\n    }\n    local restrictions = factionModels[faction]\n    if restrictions then\n        for i = #models, 1, -1 do\n            local model = models[i]\n            -- Check if model is banned\n            if table.HasValue(restrictions.banned, model) then\n                table.remove(models, i)\n                -- Check if only specific models are allowed\n            elseif restrictions.allowed and #restrictions.allowed &gt; 0 then\n                if not table.HasValue(restrictions.allowed, model) then\n                    table.remove(models, i)\n                    end\n                end\n            end\n        end\n    print(\"Filtered models for \" .. faction .. \": \" .. #models .. \" remaining\")\n    end)\n</code></pre></p>"},{"location":"hooks/client/#filterdoorinfo","title":"FilterDoorInfo","text":"<p>Purpose</p> <p>Called to filter door information</p> <p>When Called</p> <p>When door information is being displayed</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The door entity</li> <li><code>doorData</code> (table): The door data</li> <li><code>doorInfo</code> (table): The door information to filter</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log door info filtering\nhook.Add(\"FilterDoorInfo\", \"MyAddon\", function(entity, doorData, doorInfo)\nprint(\"Filtering door info for \" .. entity:EntIndex())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide sensitive door information\nhook.Add(\"FilterDoorInfo\", \"DoorInfoSecurity\", function(entity, doorData, doorInfo)\nlocal char = LocalPlayer():getChar()\nif not char then return end\n    -- Hide owner info for non-owners\n    local owner = entity:getNetVar(\"owner\")\n    if owner and owner ~= char:getID() then\n        doorInfo.owner = \"Hidden\"\n        end\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door information filtering\nhook.Add(\"FilterDoorInfo\", \"AdvancedDoorInfoFilter\", function(entity, doorData, doorInfo)\nlocal char = LocalPlayer():getChar()\nif not char then return end\n    local faction = char:getFaction()\n    local owner = entity:getNetVar(\"owner\")\n    local isOwner = owner and owner == char:getID()\n    -- Filter based on ownership\n    if not isOwner then\n        -- Hide sensitive information from non-owners\n        doorInfo.owner = \"Private\"\n        doorInfo.price = \"Hidden\"\n        doorInfo.sharedWith = nil\n        end\n    -- Filter based on faction\n    if faction == \"police\" then\n        -- Police can see more information\n        doorInfo.locked = entity:getNetVar(\"locked\", false)\n        doorInfo.faction = entity:getNetVar(\"faction\")\n    elseif faction == \"criminal\" then\n        -- Criminals see limited information\n        doorInfo.owner = \"Unknown\"\n        doorInfo.price = \"Unknown\"\n        end\n    -- Add faction-specific warnings\n    local doorFaction = entity:getNetVar(\"faction\")\n    if doorFaction and doorFaction ~= faction then\n        doorInfo.warning = \"Restricted Access\"\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/client/#getadjustedpartdata","title":"GetAdjustedPartData","text":"<p>Purpose</p> <p>Called to get adjusted PAC part data</p> <p>When Called</p> <p>When retrieving PAC part data with adjustments applied</p> <p>Parameters</p> <ul> <li><code>wearer</code> (Player): The player wearing the part</li> <li><code>id</code> (string): The part ID</li> </ul> <p>Returns</p> <ul> <li>table - The adjusted part data</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return basic part data\nhook.Add(\"GetAdjustedPartData\", \"MyAddon\", function(wearer, id)\nreturn {scale = 1, color = Color(255, 255, 255)}\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Apply basic adjustments\nhook.Add(\"GetAdjustedPartData\", \"PartAdjustments\", function(wearer, id)\nlocal char = wearer:getChar()\nif not char then return {} end\n    local data = {scale = 1, color = Color(255, 255, 255)}\n    -- Apply faction-based adjustments\n    local faction = char:getFaction()\n    if faction == \"police\" then\n        data.color = Color(0, 0, 255)\n    elseif faction == \"medic\" then\n        data.color = Color(255, 255, 255)\n        end\n    return data\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex part data adjustment system\nhook.Add(\"GetAdjustedPartData\", \"AdvancedPartData\", function(wearer, id)\nlocal char = wearer:getChar()\nif not char then return {} end\n    local data = {scale = 1, color = Color(255, 255, 255)}\n    -- Apply faction-based adjustments\n    local faction = char:getFaction()\n    local factionMods = {\n    [\"police\"] = {color = Color(0, 0, 255), scale = 1.1},\n    [\"medic\"] = {color = Color(255, 255, 255), scale = 1.0},\n    [\"criminal\"] = {color = Color(255, 0, 0), scale = 0.9}\n    }\n    local mod = factionMods[faction]\n    if mod then\n        data.color = mod.color\n        data.scale = mod.scale\n        end\n    -- Apply level-based adjustments\n    local level = char:getData(\"level\", 1)\n    if level &gt;= 10 then\n        data.scale = data.scale * 1.2\n        end\n    -- Apply character-specific data\n    local charData = char:getData(\"partMods\", {})\n    if charData[id] then\n        for key, value in pairs(charData[id]) do\n            data[key] = value\n            end\n        end\n    return data\n    end)\n</code></pre></p>"},{"location":"hooks/client/#getdoorinfoforadminstick","title":"GetDoorInfoForAdminStick","text":"<p>Purpose</p> <p>Called to get door information for admin stick</p> <p>When Called</p> <p>When displaying door information in the admin stick HUD</p> <p>Parameters</p> <ul> <li><code>target</code> (Entity): The door entity</li> <li><code>extraInfo</code> (table): Additional information to add</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic door info\nhook.Add(\"GetDoorInfoForAdminStick\", \"MyAddon\", function(target, extraInfo)\ntable.insert(extraInfo, \"Door: \" .. target:EntIndex())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add door ownership info\nhook.Add(\"GetDoorInfoForAdminStick\", \"DoorOwnership\", function(target, extraInfo)\nlocal owner = target:getNetVar(\"owner\")\nif owner then\n    table.insert(extraInfo, \"Owner: \" .. owner)\nelse\n    table.insert(extraInfo, \"Unowned\")\n    end\nlocal locked = target:getNetVar(\"locked\", false)\ntable.insert(extraInfo, \"Status: \" .. (locked and \"Locked\" or \"Unlocked\"))\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door information display\nhook.Add(\"GetDoorInfoForAdminStick\", \"AdvancedDoorInfo\", function(target, extraInfo)\n-- Door title\nlocal title = target:getNetVar(\"title\", \"Door\")\ntable.insert(extraInfo, \"Title: \" .. title)\n-- Owner information\nlocal owner = target:getNetVar(\"owner\")\nif owner then\n    local ownerChar = lia.char.getByID(owner)\n    if ownerChar then\n        table.insert(extraInfo, \"Owner: \" .. ownerChar:getName() .. \" (ID: \" .. owner .. \")\")\n    else\n        table.insert(extraInfo, \"Owner: \" .. owner)\n        end\nelse\n    table.insert(extraInfo, \"Unowned\")\n    end\n-- Price information\nlocal price = target:getNetVar(\"price\", 0)\nif price &gt; 0 then\n    table.insert(extraInfo, \"Price: $\" .. price)\n    end\n-- Lock status\nlocal locked = target:getNetVar(\"locked\", false)\ntable.insert(extraInfo, \"Status: \" .. (locked and \"Locked\" or \"Unlocked\"))\n-- Faction restriction\nlocal faction = target:getNetVar(\"faction\")\nif faction then\n    table.insert(extraInfo, \"Faction: \" .. faction)\n    end\n-- Shared with information\nlocal sharedWith = target:getNetVar(\"sharedWith\", {})\nif #sharedWith &gt; 0 then\n    table.insert(extraInfo, \"Shared with: \" .. #sharedWith .. \" players\")\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#getinjuredtext","title":"GetInjuredText","text":"<p>Purpose</p> <p>Called to get injured text</p> <p>When Called</p> <p>When displaying injury status text</p> <p>Parameters</p> <ul> <li><code>c</code> (Character): The character to get injury text for</li> </ul> <p>Returns</p> <ul> <li>string - The injury text to display</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return basic injury text\nhook.Add(\"GetInjuredText\", \"MyAddon\", function(c)\nreturn \"Injured\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Base text on health level\nhook.Add(\"GetInjuredText\", \"HealthBasedText\", function(c)\nlocal health = c:getData(\"health\", 100)\nif health &lt;= 0 then\n    return \"Dead\"\nelseif health &lt;= 25 then\n    return \"Critically Injured\"\nelseif health &lt;= 50 then\n    return \"Badly Injured\"\nelseif health &lt;= 75 then\n    return \"Slightly Injured\"\nelse\n    return \"Healthy\"\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex injury text system\nhook.Add(\"GetInjuredText\", \"AdvancedInjuryText\", function(c)\nlocal health = c:getData(\"health\", 100)\nlocal maxHealth = c:getData(\"maxHealth\", 100)\nlocal healthPercent = (health / maxHealth) * 100\nlocal injuryText = \"\"\n-- Health status\nif health &lt;= 0 then\n    injuryText = \"Dead\"\nelseif healthPercent &lt;= 10 then\n    injuryText = \"Critically Injured\"\nelseif healthPercent &lt;= 25 then\n    injuryText = \"Badly Injured\"\nelseif healthPercent &lt;= 50 then\n    injuryText = \"Injured\"\nelseif healthPercent &lt;= 75 then\n    injuryText = \"Slightly Injured\"\nelse\n    injuryText = \"Healthy\"\n    end\n-- Add specific injury types\nlocal injuries = c:getData(\"injuries\", {})\nif #injuries &gt; 0 then\n    injuryText = injuryText .. \" (\" .. table.concat(injuries, \", \") .. \")\"\n    end\n-- Add bleeding status\nif c:getData(\"bleeding\", false) then\n    injuryText = injuryText .. \" [BLEEDING]\"\n    end\n-- Add unconscious status\nif c:getData(\"unconscious\", false) then\n    injuryText = \"Unconscious\"\n    end\nreturn injuryText\nend)\n</code></pre></p>"},{"location":"hooks/client/#modifyvoiceindicatortext","title":"ModifyVoiceIndicatorText","text":"<p>Purpose</p> <p>Allows modification of the voice indicator text displayed when a player is speaking</p> <p>When Called</p> <p>When the voice indicator is being drawn during voice chat</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The LocalPlayer() who is currently speaking</li> <li><code>voiceText</code> (string): The current voice indicator text (e.g., \"You are talking - 3 people can hear you\")</li> <li><code>voiceType</code> (string): The voice type string (e.g., \"talking\", \"whispering\", \"yelling\")</li> </ul> <p>Returns</p> <ul> <li>string|nil - Return a string to replace the voice text, or return nil/false to keep the original text</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add emojis to voice indicator\nhook.Add(\"ModifyVoiceIndicatorText\", \"AddVoiceEmojis\", function(client, voiceText, voiceType)\nif voiceType == L(\"whispering\") then\n    return \"?? \" .. voiceText .. \" ??\"\nelseif voiceType == L(\"yelling\") then\n    return \"?? \" .. voiceText .. \" ??\"\nelseif voiceType == L(\"talking\") then\n    return \"?? \" .. voiceText .. \" ??\"\n    end\nreturn nil -- Keep original text\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom formatting based on voice type\nhook.Add(\"ModifyVoiceIndicatorText\", \"CustomVoiceFormat\", function(client, voiceText, voiceType)\nlocal char = client:getChar()\nif not char then return nil end\n    local name = char:getName()\n    if voiceType == L(\"whispering\") then\n        return name .. \" is whispering quietly...\"\n    elseif voiceType == L(\"yelling\") then\n        return name .. \" is YELLING LOUDLY!\"\n    elseif voiceType == L(\"talking\") then\n        return name .. \" is speaking normally\"\n        end\n    return nil -- Keep original text\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced voice indicator with listener count calculation\nhook.Add(\"ModifyVoiceIndicatorText\", \"AdvancedVoiceIndicator\", function(client, voiceText, voiceType)\nlocal char = client:getChar()\nif not char then return nil end\n    -- Extract listener count if voice range is enabled\n    local listenerCount = 0\n    if lia.option.get(\"voiceRange\", false) then\n        local match = voiceText:match(\"(%d+) people can hear you\")\n        if match then\n            listenerCount = tonumber(match)\n            end\n        end\n    -- Custom formatting with color codes\n    local prefix = \"\"\n    local suffix = \"\"\n    if voiceType == L(\"whispering\") then\n        prefix = \"[QUIET] \"\n        suffix = \" whispers softly\"\n    elseif voiceType == L(\"yelling\") then\n        prefix = \"[LOUD] \"\n        suffix = \" YELLS LOUDLY\"\n    elseif voiceType == L(\"talking\") then\n        prefix = \"[NORMAL] \"\n        suffix = \" speaks\"\n        end\n    local result = prefix .. voiceText:gsub(\"You are \", \"\"):gsub(\" - %d+ people can hear you\", \"\") .. suffix\n    -- Add listener count back if it was present\n    if listenerCount &gt; 0 then\n        result = result .. \" - \" .. listenerCount .. \" people can hear you\"\n        end\n    return result\n    end)\n</code></pre></p>"},{"location":"hooks/client/#getmainmenuposition","title":"GetMainMenuPosition","text":"<p>Purpose</p> <p>Called to get main menu position</p> <p>When Called</p> <p>When positioning the main menu UI</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character to position menu for</li> </ul> <p>Returns</p> <ul> <li>table - Position data for the menu</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default position\nhook.Add(\"GetMainMenuPosition\", \"MyAddon\", function(character)\nreturn {x = 100, y = 100}\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Position based on screen size\nhook.Add(\"GetMainMenuPosition\", \"ScreenBasedPosition\", function(character)\nlocal w, h = ScrW(), ScrH()\nreturn {\nx = w * 0.1,\ny = h * 0.1,\nw = w * 0.8,\nh = h * 0.8\n}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex menu positioning system\nhook.Add(\"GetMainMenuPosition\", \"AdvancedMenuPosition\", function(character)\nlocal w, h = ScrW(), ScrH()\n-- Get character-specific settings\nlocal charData = character:getData(\"menuSettings\", {})\nlocal savedPos = charData.position\nif savedPos then\n    -- Use saved position\n    return {\n    x = savedPos.x,\n    y = savedPos.y,\n    w = savedPos.w or w * 0.8,\n    h = savedPos.h or h * 0.8\n    }\n    end\n-- Default positioning based on faction\nlocal faction = character:getFaction()\nlocal positions = {\n[\"police\"] = {x = w * 0.05, y = h * 0.05},\n[\"medic\"] = {x = w * 0.1, y = h * 0.1},\n[\"citizen\"] = {x = w * 0.15, y = h * 0.15}\n}\nlocal pos = positions[faction] or {x = w * 0.1, y = h * 0.1}\nreturn {\nx = pos.x,\ny = pos.y,\nw = w * 0.8,\nh = h * 0.8\n}\nend)\n</code></pre></p>"},{"location":"hooks/client/#getweaponname","title":"GetWeaponName","text":"<p>Purpose</p> <p>Called to get weapon name</p> <p>When Called</p> <p>When displaying the name of a weapon</p> <p>Parameters</p> <ul> <li><code>weapon</code> (Weapon): The weapon entity</li> </ul> <p>Returns</p> <ul> <li>string - The display name of the weapon</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return weapon class name\nhook.Add(\"GetWeaponName\", \"MyAddon\", function(weapon)\nreturn weapon:GetClass()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use weapon print name\nhook.Add(\"GetWeaponName\", \"WeaponPrintName\", function(weapon)\nreturn weapon:GetPrintName() or weapon:GetClass()\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex weapon naming system\nhook.Add(\"GetWeaponName\", \"AdvancedWeaponNaming\", function(weapon)\nlocal baseName = weapon:GetPrintName() or weapon:GetClass()\n-- Check for custom weapon data\nlocal weaponData = weapon:getNetVar(\"weaponData\", {})\nif weaponData.customName then\n    baseName = weaponData.customName\n    end\n-- Add quality prefix\nlocal quality = weaponData.quality or \"common\"\nlocal qualityPrefixes = {\n[\"common\"] = \"\",\n[\"uncommon\"] = \"[Uncommon] \",\n[\"rare\"] = \"[Rare] \",\n[\"epic\"] = \"[Epic] \",\n[\"legendary\"] = \"[Legendary] \"\n}\nlocal qualityPrefix = qualityPrefixes[quality] or \"\"\n-- Add enchantment suffix\nlocal enchantments = weaponData.enchantments or {}\nlocal enchantmentSuffix = \"\"\nif #enchantments &gt; 0 then\n    enchantmentSuffix = \" of \" .. table.concat(enchantments, \", \")\n    end\n-- Add durability suffix\nlocal durability = weaponData.durability\nlocal maxDurability = weaponData.maxDurability\nif durability and maxDurability then\n    local durabilityPercent = (durability / maxDurability) * 100\n    if durabilityPercent &lt; 25 then\n        enchantmentSuffix = enchantmentSuffix .. \" (Damaged)\"\n    elseif durabilityPercent &lt; 50 then\n        enchantmentSuffix = enchantmentSuffix .. \" (Worn)\"\n        end\n    end\nreturn qualityPrefix .. baseName .. enchantmentSuffix\nend)\n</code></pre></p>"},{"location":"hooks/client/#displayplayerhudinformation","title":"DisplayPlayerHUDInformation","text":"<p>Purpose</p> <p>Called to display player HUD information, primarily for admin tools</p> <p>When Called</p> <p>Every frame during HUD rendering to allow modules to add custom HUD information</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The local player</li> <li><code>hudInfos</code> (table): Array of HUD information objects to display, each containing text, position, color, and font properties</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic player health info\nhook.Add(\"DisplayPlayerHUDInformation\", \"BasicHUDInfo\", function(client, hudInfos)\ntable.insert(hudInfos, {\ntext = \"Health: \" .. client:Health(),\nposition = Vector(10, 10),\ncolor = Color(255, 0, 0)\n})\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add character and faction info\nhook.Add(\"DisplayPlayerHUDInformation\", \"CharacterHUDInfo\", function(client, hudInfos)\nlocal char = client:getChar()\nif char then\n    table.insert(hudInfos, {\n    text = \"Name: \" .. char:getName(),\n    position = Vector(10, 30),\n    color = Color(255, 255, 255)\n    })\n    local faction = lia.faction.indices[client:Team()]\n    if faction then\n        table.insert(hudInfos, {\n        text = \"Faction: \" .. faction.name,\n        position = Vector(10, 50),\n        color = faction.color or Color(100, 100, 100)\n        })\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced admin HUD with multiple info panels\nhook.Add(\"DisplayPlayerHUDInformation\", \"AdvancedAdminHUD\", function(client, hudInfos)\nif not client:IsAdmin() then return end\n    -- Player count info\n    local playerCount = #player.GetAll()\n    table.insert(hudInfos, {\n    text = \"Players: \" .. playerCount,\n    position = Vector(ScrW() - 200, 10),\n    color = Color(0, 255, 0),\n    font = \"liaMediumFont\"\n    })\n    -- Server time\n    local time = os.date(\"%H:%M:%S\")\n    table.insert(hudInfos, {\n    text = \"Server Time: \" .. time,\n    position = Vector(ScrW() - 200, 30),\n    color = Color(255, 255, 0)\n    })\n    -- Performance info\n    local fps = 1 / FrameTime()\n    table.insert(hudInfos, {\n    text = string.format(\"FPS: %.0f\", fps),\n    position = Vector(ScrW() - 200, 50),\n    color = fps &gt; 30 and Color(0, 255, 0) or Color(255, 0, 0)\n    })\n    -- Character info if available\n    local char = client:getChar()\n    if char then\n        local money = char:getMoney()\n        table.insert(hudInfos, {\n        text = \"Money: \" .. lia.currency.format(money),\n        position = Vector(ScrW() - 200, 70),\n        color = Color(0, 255, 255)\n        })\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/client/#initializedkeybinds","title":"InitializedKeybinds","text":"<p>Purpose</p> <p>Called when keybinds are initialized</p> <p>When Called</p> <p>When the keybind system has finished loading</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log keybind initialization\nhook.Add(\"InitializedKeybinds\", \"MyAddon\", function()\nprint(\"Keybinds initialized\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register custom keybinds\nhook.Add(\"InitializedKeybinds\", \"CustomKeybinds\", function()\nlia.keybind.add(\"my_action\", \"My Action\", KEY_F1, function()\nprint(\"My action triggered!\")\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>    -- High: Complex keybind initialization system\n    hook.Add(\"InitializedKeybinds\", \"AdvancedKeybindInit\", function()\n    -- Register custom keybinds\n    local keybinds = {\n    {\n    key = \"my_action\",\n    name = \"My Action\",\n    keyCode = KEY_F1,\n    callback = function()\n    print(\"My action triggered!\")\n    end\n},\n{\nkey = \"my_other_action\",\nname = \"My Other Action\",\nkeyCode = KEY_F2,\ncallback = function()\nprint(\"My other action triggered!\")\nend\n}\n}\nfor _, keybind in ipairs(keybinds) do\nlia.keybind.add(keybind.key, keybind.name, keybind.keyCode, keybind.callback)\nend\n-- Set up keybind categories\nlia.keybind.addCategory(\"My Addon\", \"Custom keybinds for my addon\")\n-- Load saved keybind settings\nlocal savedKeybinds = lia.data.get(\"myAddonKeybinds\", {})\nfor key, keyCode in pairs(savedKeybinds) do\nlia.keybind.setKey(key, keyCode)\nend\nprint(\"Keybind system initialized with \" .. #keybinds .. \" custom keybinds\")\nend)\n</code></pre></p>"},{"location":"hooks/client/#initializedoptions","title":"InitializedOptions","text":"<p>Purpose</p> <p>Called when options are initialized</p> <p>When Called</p> <p>When the option system has finished loading</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log option initialization\nhook.Add(\"InitializedOptions\", \"MyAddon\", function()\nprint(\"Options initialized\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register custom options\nhook.Add(\"InitializedOptions\", \"CustomOptions\", function()\nlia.option.add(\"myOption\", \"My Option\", \"A custom option\", true)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex option initialization system\nhook.Add(\"InitializedOptions\", \"AdvancedOptionInit\", function()\n-- Register custom options\nlocal options = {\n{\nkey = \"myOption\",\nname = \"My Option\",\ndescription = \"A custom option\",\ndefault = true,\ntype = \"boolean\"\n},\n{\nkey = \"myValue\",\nname = \"My Value\",\ndescription = \"A custom value\",\ndefault = 100,\ntype = \"number\",\nmin = 0,\nmax = 1000\n},\n{\nkey = \"myString\",\nname = \"My String\",\ndescription = \"A custom string\",\ndefault = \"default\",\ntype = \"string\"\n}\n}\nfor _, option in ipairs(options) do\n    lia.option.add(option.key, option.name, option.description, option.default)\n    end\n-- Set up option callbacks\nlia.option.addCallback(\"myOption\", function(value)\nprint(\"My option changed: \" .. tostring(value))\nend)\n-- Load saved options\nlocal savedOptions = lia.data.get(\"myAddonOptions\", {})\nfor key, value in pairs(savedOptions) do\n    lia.option.set(key, value)\n    end\nprint(\"Option system initialized with \" .. #options .. \" custom options\")\nend)\n</code></pre></p>"},{"location":"hooks/client/#interactionmenuclosed","title":"InteractionMenuClosed","text":"<p>Purpose</p> <p>Called when the interaction menu is closed</p> <p>When Called</p> <p>When the interaction menu UI is closed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log menu closing\nhook.Add(\"InteractionMenuClosed\", \"MyAddon\", function()\nprint(\"Interaction menu closed\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up menu data\nhook.Add(\"InteractionMenuClosed\", \"MenuCleanup\", function()\nlia.interactionMenuOpen = false\nlia.currentInteractionTarget = nil\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex interaction menu close handling\nhook.Add(\"InteractionMenuClosed\", \"AdvancedMenuClose\", function()\n-- Update menu state\nlia.interactionMenuOpen = false\n-- Clear interaction target\nlia.currentInteractionTarget = nil\n-- Log menu close time\nlocal closeTime = os.time()\nlia.lastInteractionMenuClose = closeTime\n-- Calculate menu session duration\nif lia.interactionMenuOpenTime then\n    local duration = closeTime - lia.interactionMenuOpenTime\n    print(\"Interaction menu session duration: \" .. duration .. \" seconds\")\n    lia.interactionMenuOpenTime = nil\n    end\n-- Clear cached interaction data\nlia.interactionCache = nil\nprint(\"Interaction menu closed at \" .. os.date(\"%H:%M:%S\", closeTime))\nend)\n</code></pre></p>"},{"location":"hooks/client/#interactionmenuopened","title":"InteractionMenuOpened","text":"<p>Purpose</p> <p>Called when the interaction menu is opened</p> <p>When Called</p> <p>When the interaction menu UI is opened</p> <p>Parameters</p> <ul> <li><code>frame</code> (Panel): The interaction menu frame</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log menu opening\nhook.Add(\"InteractionMenuOpened\", \"MyAddon\", function(frame)\nprint(\"Interaction menu opened\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update menu state\nhook.Add(\"InteractionMenuOpened\", \"MenuState\", function(frame)\nlia.interactionMenuOpen = true\nlia.interactionMenuOpenTime = os.time()\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex interaction menu open handling\nhook.Add(\"InteractionMenuOpened\", \"AdvancedMenuOpen\", function(frame)\n-- Update menu state\nlia.interactionMenuOpen = true\n-- Log menu open time\nlocal openTime = os.time()\nlia.interactionMenuOpenTime = openTime\n-- Cache interaction target\nlocal target = lia.util.getEntityInDirection(LocalPlayer())\nif IsValid(target) then\n    lia.currentInteractionTarget = target\n    -- Cache interaction data\n    lia.interactionCache = {\n    entity = target,\n    class = target:GetClass(),\n    model = target:GetModel(),\n    position = target:GetPos()\n    }\n    end\n-- Customize frame appearance\nif frame then\n    frame:SetBackgroundColor(Color(0, 0, 0, 200))\n    frame:SetSize(300, 400)\n    end\nprint(\"Interaction menu opened at \" .. os.date(\"%H:%M:%S\", openTime))\nend)\n</code></pre></p>"},{"location":"hooks/client/#interceptclickitemicon","title":"InterceptClickItemIcon","text":"<p>Purpose</p> <p>Called when an item icon is clicked</p> <p>When Called</p> <p>When a player clicks on an item icon in inventory</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The inventory panel</li> <li><code>itemIcon</code> (Panel): The item icon that was clicked</li> <li><code>keyCode</code> (number): The mouse button code</li> </ul> <p>Returns</p> <ul> <li>boolean - True to intercept, false to allow</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item clicks\nhook.Add(\"InterceptClickItemIcon\", \"MyAddon\", function(self, itemIcon, keyCode)\nprint(\"Item clicked: \" .. (itemIcon.item and itemIcon.item.name or \"Unknown\"))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom right-click menu\nhook.Add(\"InterceptClickItemIcon\", \"CustomItemMenu\", function(self, itemIcon, keyCode)\nif keyCode == MOUSE_RIGHT then\n    local menu = DermaMenu()\n    menu:AddOption(\"Use\", function()\n    itemIcon.item:use()\n    end)\n    menu:AddOption(\"Drop\", function()\n    itemIcon.item:drop()\n    end)\n    menu:Open()\n    return true\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item interaction system\nhook.Add(\"InterceptClickItemIcon\", \"AdvancedItemInteraction\", function(self, itemIcon, keyCode)\nif not itemIcon.item then return end\n    local item = itemIcon.item\n    local char = LocalPlayer():getChar()\n    if not char then return end\n        -- Right-click for context menu\n        if keyCode == MOUSE_RIGHT then\n            local menu = DermaMenu()\n            -- Add use option\n            menu:AddOption(\"Use\", function()\n            item:use()\n            end)\n            -- Add drop option if not equipped\n            if not item:getData(\"equipped\", false) then\n                menu:AddOption(\"Drop\", function()\n                item:drop()\n                end)\n                end\n            -- Add equip/unequip option\n            if item:getData(\"equipped\", false) then\n                menu:AddOption(\"Unequip\", function()\n                item:unequip()\n                end)\n            else\n                menu:AddOption(\"Equip\", function()\n                item:equip()\n                end)\n                end\n            -- Add examine option\n            menu:AddOption(\"Examine\", function()\n            item:examine()\n            end)\n            menu:Open()\n            return true\n            end\n        -- Middle-click for quick use\n        if keyCode == MOUSE_MIDDLE then\n            item:use()\n            return true\n            end\n        end)\n</code></pre></p>"},{"location":"hooks/client/#inventoryclosed","title":"InventoryClosed","text":"<p>Purpose</p> <p>Called when an inventory is closed</p> <p>When Called</p> <p>When a player closes an inventory panel</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The inventory panel</li> <li><code>inventory</code> (Inventory): The inventory that was closed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log inventory close\nhook.Add(\"InventoryClosed\", \"MyAddon\", function(self, inventory)\nprint(\"Inventory closed\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save inventory state\nhook.Add(\"InventoryClosed\", \"SaveInventoryState\", function(self, inventory)\nlocal char = LocalPlayer():getChar()\nif char then\n    char:setData(\"lastInventoryClose\", os.time())\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory close handling\nhook.Add(\"InventoryClosed\", \"AdvancedInventoryClose\", function(self, inventory)\nlocal char = LocalPlayer():getChar()\nif not char then return end\n    -- Save inventory state\n    char:setData(\"lastInventoryClose\", os.time())\n    -- Check for unsaved changes\n    if inventory:hasUnsavedChanges() then\n        Derma_Query(\n        \"You have unsaved changes. Save before closing?\",\n        \"Unsaved Changes\",\n        \"Save\",\n        function()\n        inventory:save()\n        end,\n        \"Don't Save\",\n        function()\n        inventory:revert()\n        end\n    )\n    end\n-- Clear selection\ninventory:clearSelection()\n-- Trigger custom event\nhook.Run(\"CustomInventoryClosed\", inventory)\nend)\n</code></pre></p>"},{"location":"hooks/client/#inventoryitemiconcreated","title":"InventoryItemIconCreated","text":"<p>Purpose</p> <p>Called when an inventory item icon is created</p> <p>When Called</p> <p>When building the visual icon for an item in inventory</p> <p>Parameters</p> <ul> <li><code>icon</code> (Panel): The icon panel being created</li> <li><code>item</code> (Item): The item the icon represents</li> <li><code>self</code> (Panel): The inventory panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log icon creation\nhook.Add(\"InventoryItemIconCreated\", \"MyAddon\", function(icon, item, self)\nprint(\"Item icon created: \" .. item.name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize icon appearance\nhook.Add(\"InventoryItemIconCreated\", \"CustomizeItemIcon\", function(icon, item, self)\n-- Set icon size\nicon:SetSize(64, 64)\n-- Add quality border\nlocal quality = item:getData(\"quality\", \"common\")\nif quality == \"rare\" then\n    icon:SetBorderColor(Color(0, 100, 255))\nelseif quality == \"epic\" then\n    icon:SetBorderColor(Color(150, 0, 255))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item icon customization\nhook.Add(\"InventoryItemIconCreated\", \"AdvancedItemIcon\", function(icon, item, self)\n-- Set icon size\nicon:SetSize(64, 64)\n-- Add quality border\nlocal quality = item:getData(\"quality\", \"common\")\nlocal borderColors = {\n[\"common\"] = Color(150, 150, 150),\n[\"uncommon\"] = Color(0, 200, 0),\n[\"rare\"] = Color(0, 100, 255),\n[\"epic\"] = Color(150, 0, 255),\n[\"legendary\"] = Color(255, 200, 0)\n}\nicon:SetBorderColor(borderColors[quality] or Color(150, 150, 150))\n-- Add durability bar\nlocal durability = item:getData(\"durability\")\nif durability then\n    local durabilityBar = icon:Add(\"DPanel\")\n    durabilityBar:SetSize(icon:GetWide(), 5)\n    durabilityBar:SetPos(0, icon:GetTall() - 5)\n    local durabilityPercent = durability / 100\n    local barColor = Color(255 * (1 - durabilityPercent), 255 * durabilityPercent, 0)\n    durabilityBar:SetBackgroundColor(barColor)\n    end\n-- Add quantity label\nlocal quantity = item:getData(\"quantity\", 1)\nif quantity &gt; 1 then\n    local quantityLabel = icon:Add(\"DLabel\")\n    quantityLabel:SetText(\"x\" .. quantity)\n    quantityLabel:SetFont(\"DermaDefaultBold\")\n    quantityLabel:SetTextColor(Color(255, 255, 255))\n    quantityLabel:SizeToContents()\n    quantityLabel:SetPos(icon:GetWide() - quantityLabel:GetWide() - 5, 5)\n    end\n-- Add equipped indicator\nif item:getData(\"equipped\", false) then\n    local equippedIcon = icon:Add(\"DLabel\")\n    equippedIcon:SetText(\"E\")\n    equippedIcon:SetFont(\"DermaDefaultBold\")\n    equippedIcon:SetTextColor(Color(0, 255, 0))\n    equippedIcon:SizeToContents()\n    equippedIcon:SetPos(5, 5)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#inventoryopened","title":"InventoryOpened","text":"<p>Purpose</p> <p>Called when an inventory is opened</p> <p>When Called</p> <p>When a player opens an inventory panel</p> <p>Parameters</p> <ul> <li><code>panel</code> (Panel): The inventory panel</li> <li><code>inventory</code> (Inventory): The inventory being opened</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log inventory open\nhook.Add(\"InventoryOpened\", \"MyAddon\", function(panel, inventory)\nprint(\"Inventory opened\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save open state\nhook.Add(\"InventoryOpened\", \"SaveInventoryOpen\", function(panel, inventory)\nlocal char = LocalPlayer():getChar()\nif char then\n    char:setData(\"lastInventoryOpen\", os.time())\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory open handling\nhook.Add(\"InventoryOpened\", \"AdvancedInventoryOpen\", function(panel, inventory)\nlocal char = LocalPlayer():getChar()\nif not char then return end\n    -- Save open state\n    char:setData(\"lastInventoryOpen\", os.time())\n    -- Customize panel appearance\n    panel:SetBackgroundColor(Color(50, 50, 50, 200))\n    panel:SetSize(600, 400)\n    panel:Center()\n    -- Add custom title\n    local title = panel:Add(\"DLabel\")\n    title:SetText(\"Inventory - \" .. char:getName())\n    title:SetFont(\"DermaLarge\")\n    title:Dock(TOP)\n    title:SetHeight(30)\n    -- Add weight display\n    local weight = inventory:getData(\"weight\", 0)\n    local maxWeight = inventory:getData(\"maxWeight\", 100)\n    local weightLabel = panel:Add(\"DLabel\")\n    weightLabel:SetText(string.format(\"Weight: %d / %d\", weight, maxWeight))\n    weightLabel:Dock(BOTTOM)\n    weightLabel:SetHeight(20)\n    -- Trigger custom event\n    hook.Run(\"CustomInventoryOpened\", inventory)\n    end)\n</code></pre></p>"},{"location":"hooks/client/#inventorypanelcreated","title":"InventoryPanelCreated","text":"<p>Purpose</p> <p>Called when an inventory panel is created</p> <p>When Called</p> <p>When building an inventory UI panel</p> <p>Parameters</p> <ul> <li><code>panel</code> (Panel): The inventory panel being created</li> <li><code>inventory</code> (Inventory): The inventory the panel represents</li> <li><code>parent</code> (Panel): The parent panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log panel creation\nhook.Add(\"InventoryPanelCreated\", \"MyAddon\", function(panel, inventory, parent)\nprint(\"Inventory panel created\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize panel appearance\nhook.Add(\"InventoryPanelCreated\", \"CustomizeInventoryPanel\", function(panel, inventory, parent)\npanel:SetBackgroundColor(Color(50, 50, 50, 200))\npanel:SetSize(500, 350)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>    -- High: Complex inventory panel customization\n    hook.Add(\"InventoryPanelCreated\", \"AdvancedInventoryPanel\", function(panel, inventory, parent)\n    -- Customize appearance\n    panel:SetBackgroundColor(Color(50, 50, 50, 200))\n    panel:SetSize(600, 400)\n    -- Add title bar\n    local titleBar = panel:Add(\"DPanel\")\n    titleBar:Dock(TOP)\n    titleBar:SetHeight(30)\n    titleBar:SetBackgroundColor(Color(30, 30, 30, 255))\n    local title = titleBar:Add(\"DLabel\")\n    title:SetText(\"Inventory\")\n    title:SetFont(\"DermaLarge\")\n    title:Dock(FILL)\n    title:SetContentAlignment(5)\n    -- Add close button\n    local closeBtn = titleBar:Add(\"DButton\")\n    closeBtn:SetText(\"X\")\n    closeBtn:Dock(RIGHT)\n    closeBtn:SetWidth(30)\n    closeBtn.DoClick = function()\n    panel:Close()\n    end\n-- Add weight bar\nlocal weight = inventory:getData(\"weight\", 0)\nlocal maxWeight = inventory:getData(\"maxWeight\", 100)\nlocal weightBar = panel:Add(\"DPanel\")\nweightBar:Dock(BOTTOM)\nweightBar:SetHeight(25)\nweightBar:SetBackgroundColor(Color(30, 30, 30, 255))\nlocal weightLabel = weightBar:Add(\"DLabel\")\nweightLabel:SetText(string.format(\"Weight: %d / %d (%.1f%%)\", weight, maxWeight, (weight / maxWeight) * 100))\nweightLabel:Dock(FILL)\nweightLabel:SetContentAlignment(5)\n-- Add filter buttons\nlocal filterPanel = panel:Add(\"DPanel\")\nfilterPanel:Dock(TOP)\nfilterPanel:SetHeight(30)\nfilterPanel:SetBackgroundColor(Color(40, 40, 40, 255))\nlocal filterAll = filterPanel:Add(\"DButton\")\nfilterAll:SetText(\"All\")\nfilterAll:Dock(LEFT)\nfilterAll:SetWidth(60)\nfilterAll.DoClick = function()\ninventory:setFilter(nil)\nend\nlocal filterWeapons = filterPanel:Add(\"DButton\")\nfilterWeapons:SetText(\"Weapons\")\nfilterWeapons:Dock(LEFT)\nfilterWeapons:SetWidth(80)\nfilterWeapons.DoClick = function()\ninventory:setFilter(\"weapon\")\nend\nlocal filterArmor = filterPanel:Add(\"DButton\")\nfilterArmor:SetText(\"Armor\")\nfilterArmor:Dock(LEFT)\nfilterArmor:SetWidth(70)\nfilterArmor.DoClick = function()\ninventory:setFilter(\"armor\")\nend\nend)\n</code></pre></p>"},{"location":"hooks/client/#itempaintover","title":"ItemPaintOver","text":"<p>Purpose</p> <p>Called to paint over an item icon</p> <p>When Called</p> <p>When rendering additional graphics on an item icon</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The item icon panel</li> <li><code>itemTable</code> (table): The item data table</li> <li><code>w</code> (number): The width of the icon</li> <li><code>h</code> (number): The height of the icon</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw item name\nhook.Add(\"ItemPaintOver\", \"MyAddon\", function(self, itemTable, w, h)\ndraw.SimpleText(itemTable.name, \"DermaDefault\", w / 2, h - 10, Color(255, 255, 255), TEXT_ALIGN_CENTER)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw durability bar\nhook.Add(\"ItemPaintOver\", \"DrawDurabilityBar\", function(self, itemTable, w, h)\nlocal item = self.item\nif not item then return end\n    local durability = item:getData(\"durability\", 100)\n    local barWidth = (w - 4) * (durability / 100)\n    surface.SetDrawColor(0, 0, 0, 200)\n    surface.DrawRect(2, h - 8, w - 4, 6)\n    local barColor = Color(255 * (1 - durability / 100), 255 * (durability / 100), 0)\n    surface.SetDrawColor(barColor)\n    surface.DrawRect(2, h - 8, barWidth, 6)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item icon overlay\nhook.Add(\"ItemPaintOver\", \"AdvancedItemOverlay\", function(self, itemTable, w, h)\nlocal item = self.item\nif not item then return end\n    -- Draw durability bar\n    local durability = item:getData(\"durability\", 100)\n    if durability &lt; 100 then\n        local barWidth = (w - 4) * (durability / 100)\n        surface.SetDrawColor(0, 0, 0, 200)\n        surface.DrawRect(2, h - 8, w - 4, 6)\n        local barColor = Color(255 * (1 - durability / 100), 255 * (durability / 100), 0)\n        surface.SetDrawColor(barColor)\n        surface.DrawRect(2, h - 8, barWidth, 6)\n        end\n    -- Draw quantity\n    local quantity = item:getData(\"quantity\", 1)\n    if quantity &gt; 1 then\n        draw.SimpleText(\"x\" .. quantity, \"DermaDefaultBold\", w - 5, 5, Color(255, 255, 255), TEXT_ALIGN_RIGHT)\n        end\n    -- Draw equipped indicator\n    if item:getData(\"equipped\", false) then\n        draw.SimpleText(\"E\", \"DermaDefaultBold\", 5, 5, Color(0, 255, 0))\n        end\n    -- Draw quality border\n    local quality = item:getData(\"quality\", \"common\")\n    local borderColors = {\n    [\"common\"] = Color(150, 150, 150),\n    [\"uncommon\"] = Color(0, 200, 0),\n    [\"rare\"] = Color(0, 100, 255),\n    [\"epic\"] = Color(150, 0, 255),\n    [\"legendary\"] = Color(255, 200, 0)\n    }\n    local borderColor = borderColors[quality] or Color(150, 150, 150)\n    surface.SetDrawColor(borderColor)\n    surface.DrawOutlinedRect(0, 0, w, h, 2)\n    end)\n</code></pre></p>"},{"location":"hooks/client/#itemshowentitymenu","title":"ItemShowEntityMenu","text":"<p>Purpose</p> <p>Called to show entity menu for an item</p> <p>When Called</p> <p>When displaying the interaction menu for an item entity</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The item entity</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log entity menu display\nhook.Add(\"ItemShowEntityMenu\", \"MyAddon\", function(entity)\nprint(\"Showing menu for: \" .. tostring(entity))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add custom menu options\nhook.Add(\"ItemShowEntityMenu\", \"CustomEntityMenu\", function(entity)\nlocal item = entity:getNetVar(\"item\")\nif not item then return end\n    local menu = DermaMenu()\n    menu:AddOption(\"Examine\", function()\n    chat.AddText(\"You examine the \" .. item.name)\n    end)\n    menu:Open()\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entity menu system\nhook.Add(\"ItemShowEntityMenu\", \"AdvancedEntityMenu\", function(entity)\nif not IsValid(entity) then return end\n    local item = entity:getNetVar(\"item\")\n    if not item then return end\n        local client = LocalPlayer()\n        local char = client:getChar()\n        if not char then return end\n            -- Create menu\n            local menu = DermaMenu()\n            -- Add examine option\n            menu:AddOption(\"Examine\", function()\n            local desc = item.desc or \"No description\"\n            chat.AddText(Color(255, 255, 255), \"You examine the \", Color(100, 200, 255), item.name, Color(255, 255, 255), \": \" .. desc)\n            end)\n            -- Add pickup option if close enough\n            local distance = client:GetPos():Distance(entity:GetPos())\n            if distance &lt; 100 then\n                menu:AddOption(\"Pick Up\", function()\n                net.Start(\"liaItemPickup\")\n                net.WriteEntity(entity)\n                net.SendToServer()\n                end)\n            else\n                local option = menu:AddOption(\"Pick Up (Too Far)\")\n                option:SetEnabled(false)\n                end\n            -- Add custom options based on item type\n            if item.category == \"weapons\" then\n                menu:AddOption(\"Inspect Weapon\", function()\n                chat.AddText(\"This weapon has \" .. (item:getData(\"ammo\", 0)) .. \" rounds\")\n                end)\n                end\n            menu:Open()\n            end)\n</code></pre></p>"},{"location":"hooks/client/#kickedfromchar","title":"KickedFromChar","text":"<p>Purpose</p> <p>Called when a player is kicked from a character</p> <p>When Called</p> <p>When a player is forcibly removed from their character</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The character ID</li> <li><code>isCurrentChar</code> (boolean): Whether this is the current character</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character kick\nhook.Add(\"KickedFromChar\", \"MyAddon\", function(id, isCurrentChar)\nprint(\"Kicked from character: \" .. id)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Show notification\nhook.Add(\"KickedFromChar\", \"NotifyCharKick\", function(id, isCurrentChar)\nif isCurrentChar then\n    lia.util.notify(\"You have been kicked from your character\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character kick handling\nhook.Add(\"KickedFromChar\", \"AdvancedCharKick\", function(id, isCurrentChar)\n-- Show notification\nif isCurrentChar then\n    lia.util.notify(\"You have been kicked from your character\", 4)\n    -- Clear character-specific UI\n    if IsValid(lia.gui.charInfo) then\n        lia.gui.charInfo:Remove()\n        end\n    if IsValid(lia.gui.inventory) then\n        lia.gui.inventory:Remove()\n        end\n    -- Log the kick\n    lia.log.write(\"client_char_kick\", {\n    charID = id,\n    timestamp = os.time()\n    })\n    -- Save any pending data\n    net.Start(\"liaSaveCharData\")\n    net.WriteUInt(id, 32)\n    net.SendToServer()\n    -- Return to character selection\n    timer.Simple(1, function()\n    vgui.Create(\"liaCharacterMenu\")\n    end)\nelse\n    -- Just log if not current character\n    print(\"Character \" .. id .. \" was kicked\")\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#loadcharinformation","title":"LoadCharInformation","text":"<p>Purpose</p> <p>Called to load character information</p> <p>When Called</p> <p>When character data needs to be loaded</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character info load\nhook.Add(\"LoadCharInformation\", \"MyAddon\", function()\nprint(\"Loading character information\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load custom character data\nhook.Add(\"LoadCharInformation\", \"LoadCustomCharData\", function()\nlocal char = LocalPlayer():getChar()\nif char then\n    -- Request custom data from server\n    netstream.Start(\"RequestCustomCharData\", char:getID())\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character data loading\nhook.Add(\"LoadCharInformation\", \"AdvancedCharDataLoad\", function()\nlocal char = LocalPlayer():getChar()\nif not char then return end\n    -- Request custom data from server\n    netstream.Start(\"RequestCustomCharData\", char:getID())\n    -- Initialize client-side character systems\n    MyAddon.InitializeCharacter(char)\n    -- Load character preferences\n    local prefs = char:getData(\"preferences\", {})\n    for key, value in pairs(prefs) do\n        MyAddon.SetPreference(key, value)\n        end\n    print(\"Character information loaded for \" .. char:getName())\n    end)\n</code></pre></p>"},{"location":"hooks/client/#loadmainmenuinformation","title":"LoadMainMenuInformation","text":"<p>Purpose</p> <p>Called to load main menu information</p> <p>When Called</p> <p>When building the main menu character information</p> <p>Parameters</p> <ul> <li><code>info</code> (table): The information table to populate</li> <li><code>character</code> (Character): The character being displayed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic info\nhook.Add(\"LoadMainMenuInformation\", \"MyAddon\", function(info, character)\ninfo[\"Level\"] = character:getData(\"level\", 1)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add multiple info fields\nhook.Add(\"LoadMainMenuInformation\", \"AddCharacterInfo\", function(info, character)\ninfo[\"Level\"] = character:getData(\"level\", 1)\ninfo[\"Experience\"] = character:getData(\"exp\", 0)\ninfo[\"Money\"] = lia.currency.get(character:getMoney())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex menu information system\nhook.Add(\"LoadMainMenuInformation\", \"AdvancedMenuInfo\", function(info, character)\n-- Basic info\ninfo[\"Level\"] = character:getData(\"level\", 1)\ninfo[\"Experience\"] = character:getData(\"exp\", 0) .. \" / \" .. character:getData(\"expNeeded\", 100)\ninfo[\"Money\"] = lia.currency.get(character:getMoney())\n-- Faction info\nlocal faction = lia.faction.indices[character:getFaction()]\nif faction then\n    info[\"Faction\"] = faction.name\n    info[\"Rank\"] = character:getData(\"rankName\", \"Recruit\")\n    end\n-- Stats\ninfo[\"Health\"] = character:getData(\"health\", 100)\ninfo[\"Armor\"] = character:getData(\"armor\", 0)\n-- Playtime\nlocal playTime = character:getData(\"playTime\", 0)\nlocal hours = math.floor(playTime / 3600)\nlocal minutes = math.floor((playTime % 3600) / 60)\ninfo[\"Playtime\"] = string.format(\"%dh %dm\", hours, minutes)\nend)\n</code></pre></p>"},{"location":"hooks/client/#modifyscoreboardmodel","title":"ModifyScoreboardModel","text":"<p>Purpose</p> <p>Called to modify a player's model on the scoreboard</p> <p>When Called</p> <p>When rendering a player's model in the scoreboard</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The viewing player</li> <li><code>ply</code> (Player): The player whose model is being displayed</li> </ul> <p>Returns</p> <ul> <li>string - The modified model path</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return player model\nhook.Add(\"ModifyScoreboardModel\", \"MyAddon\", function(client, ply)\nreturn ply:GetModel()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Show faction models\nhook.Add(\"ModifyScoreboardModel\", \"ScoreboardFactionModels\", function(client, ply)\nlocal char = ply:getChar()\nif char then\n    return char:getModel()\n    end\nreturn ply:GetModel()\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex scoreboard model system\nhook.Add(\"ModifyScoreboardModel\", \"AdvancedScoreboardModel\", function(client, ply)\nlocal char = ply:getChar()\nif not char then return ply:GetModel() end\n    -- Show outfit model if equipped\n    local outfit = char:getData(\"outfit\")\n    if outfit then\n        local outfitItem = lia.item.instances[outfit]\n        if outfitItem and outfitItem.model then\n            return outfitItem.model\n            end\n        end\n    -- Show character model\n    return char:getModel()\n    end)\n</code></pre></p>"},{"location":"hooks/client/#onadminstickmenuclosed","title":"OnAdminStickMenuClosed","text":"<p>Purpose</p> <p>Called when admin stick menu is closed</p> <p>When Called</p> <p>When the admin stick context menu is closed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log menu close\nhook.Add(\"OnAdminStickMenuClosed\", \"MyAddon\", function()\nprint(\"Admin stick menu closed\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up menu state\nhook.Add(\"OnAdminStickMenuClosed\", \"CleanupAdminMenu\", function()\nMyAddon.selectedEntity = nil\nMyAddon.menuOpen = false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex menu cleanup\nhook.Add(\"OnAdminStickMenuClosed\", \"AdvancedMenuCleanup\", function()\n-- Clear selection\nMyAddon.selectedEntity = nil\nMyAddon.menuOpen = false\n-- Save menu state\nlocal char = LocalPlayer():getChar()\nif char then\n    char:setData(\"lastAdminMenuClose\", os.time())\n    end\n-- Clean up temporary data\nMyAddon.tempData = {}\nprint(\"Admin stick menu closed and cleaned up\")\nend)\n</code></pre></p>"},{"location":"hooks/client/#onchatreceived","title":"OnChatReceived","text":"<p>Purpose</p> <p>Called when a chat message is received</p> <p>When Called</p> <p>When a player receives a chat message</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player receiving the message</li> <li><code>chatType</code> (string): The type of chat message</li> <li><code>text</code> (string): The message text</li> <li><code>anonymous</code> (boolean): Whether the message is anonymous</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log received messages\nhook.Add(\"OnChatReceived\", \"MyAddon\", function(client, chatType, text, anonymous)\nprint(\"Received \" .. chatType .. \" message: \" .. text)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Filter messages based on type\nhook.Add(\"OnChatReceived\", \"MessageFiltering\", function(client, chatType, text, anonymous)\nif chatType == \"ooc\" then\n    -- OOC messages are always visible\n    return true\nelseif chatType == \"ic\" then\n    -- IC messages only if player has character\n    local char = client:getChar()\n    return char ~= nil\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex chat system\nhook.Add(\"OnChatReceived\", \"AdvancedChat\", function(client, chatType, text, anonymous)\nlocal char = client:getChar()\nif not char then return end\n    -- Check if player is muted\n    if char:getData(\"muted\", false) then\n        client:ChatPrint(\"You are muted and cannot receive messages\")\n        return false\n        end\n    -- Check if player is gagged\n    if char:getData(\"gagged\", false) then\n        client:ChatPrint(\"You are gagged and cannot receive messages\")\n        return false\n        end\n    -- Check message type restrictions\n    local faction = char:getFaction()\n    if chatType == \"ooc\" and faction == \"police\" then\n        client:ChatPrint(\"Police officers cannot use OOC chat\")\n        return false\n        end\n    -- Check for spam protection\n    local lastMessage = char:getData(\"lastMessage\", 0)\n    local messageCooldown = 1 -- 1 second cooldown\n    if os.time() - lastMessage &lt; messageCooldown then\n        client:ChatPrint(\"Please wait before sending another message\")\n        return false\n        end\n    -- Check for inappropriate content\n    local bannedWords = {\"spam\", \"hack\", \"cheat\", \"exploit\"}\n    for _, word in ipairs(bannedWords) do\n        if string.find(string.lower(text), string.lower(word)) then\n            client:ChatPrint(\"Your message was blocked for inappropriate content\")\n            return false\n            end\n        end\n    -- Update last message time\n    char:setData(\"lastMessage\", os.time())\n    -- Check for admin commands\n    if string.sub(text, 1, 1) == \"!\" then\n        local command = string.sub(text, 2)\n        if command == \"admin\" then\n            -- Admin command\n            client:ChatPrint(\"Admin command executed\")\n            return false\n            end\n        end\n    -- Log message\n    print(string.format(\"[%s] %s: %s\", chatType, client:Name(), text))\n    end)\n</code></pre></p>"},{"location":"hooks/client/#oncreateiteminteractionmenu","title":"OnCreateItemInteractionMenu","text":"<p>Purpose</p> <p>Called when creating an item interaction menu</p> <p>When Called</p> <p>When building the context menu for an item</p> <p>Parameters</p> <ul> <li><code>self</code> (Item): The item instance</li> <li><code>menu</code> (Menu): The menu being created</li> <li><code>itemTable</code> (table): The item table data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic menu option\nhook.Add(\"OnCreateItemInteractionMenu\", \"MyAddon\", function(self, menu, itemTable)\nmenu:AddOption(\"Use Item\", function()\nprint(\"Used item: \" .. itemTable.name)\nend)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add conditional menu options\nhook.Add(\"OnCreateItemInteractionMenu\", \"ItemMenuOptions\", function(self, menu, itemTable)\n-- Always add use option\nmenu:AddOption(\"Use\", function()\nself:use()\nend)\n-- Add drop option if not equipped\nif not self:getData(\"equipped\", false) then\n    menu:AddOption(\"Drop\", function()\n    self:drop()\n    end)\n    end\n-- Add examine option\nmenu:AddOption(\"Examine\", function()\nself:examine()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item interaction menu system\nhook.Add(\"OnCreateItemInteractionMenu\", \"AdvancedItemMenu\", function(self, menu, itemTable)\nlocal char = LocalPlayer():getChar()\nif not char then return end\n    -- Basic options\n    menu:AddOption(\"Use\", function()\n    self:use()\n    end)\n    -- Conditional options based on item state\n    if not self:getData(\"equipped\", false) then\n        menu:AddOption(\"Equip\", function()\n        self:equip()\n        end)\n        menu:AddOption(\"Drop\", function()\n        self:drop()\n        end)\n    else\n        menu:AddOption(\"Unequip\", function()\n        self:unequip()\n        end)\n        end\n    -- Examine option\n    menu:AddOption(\"Examine\", function()\n    self:examine()\n    end)\n    -- Admin options\n    if LocalPlayer():IsAdmin() then\n        menu:AddSpacer()\n        menu:AddOption(\"Admin: Delete\", function()\n        self:remove()\n        end)\n        menu:AddOption(\"Admin: Duplicate\", function()\n        local newItem = lia.item.instance(itemTable.uniqueID)\n        if newItem then\n            char:getInv():add(newItem)\n            end\n        end)\n        end\n    -- Faction-specific options\n    local faction = char:getFaction()\n    if faction == \"police\" and itemTable.uniqueID == \"weapon_pistol\" then\n        menu:AddOption(\"Police: Check Ammo\", function()\n        local ammo = self:getData(\"ammo\", 0)\n        LocalPlayer():ChatPrint(\"Ammo: \" .. ammo)\n        end)\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/client/#oncreatestoragepanel","title":"OnCreateStoragePanel","text":"<p>Purpose</p> <p>Called when creating a storage panel</p> <p>When Called</p> <p>When building the storage UI panel</p> <p>Parameters</p> <ul> <li><code>localInvPanel</code> (Panel): The local inventory panel</li> <li><code>storageInvPanel</code> (Panel): The storage inventory panel</li> <li><code>storage</code> (Entity): The storage entity</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log storage panel creation\nhook.Add(\"OnCreateStoragePanel\", \"MyAddon\", function(localInvPanel, storageInvPanel, storage)\nprint(\"Storage panel created\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize storage panel appearance\nhook.Add(\"OnCreateStoragePanel\", \"StoragePanelCustomize\", function(localInvPanel, storageInvPanel, storage)\nif localInvPanel then\n    localInvPanel:SetBackgroundColor(Color(50, 50, 50, 200))\n    end\nif storageInvPanel then\n    storageInvPanel:SetBackgroundColor(Color(100, 50, 50, 200))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage panel system\nhook.Add(\"OnCreateStoragePanel\", \"AdvancedStoragePanel\", function(localInvPanel, storageInvPanel, storage)\nif not IsValid(storage) then return end\n    -- Customize local inventory panel\n    if localInvPanel then\n        localInvPanel:SetBackgroundColor(Color(50, 50, 50, 200))\n        localInvPanel:SetSize(400, 300)\n        -- Add title\n        local title = localInvPanel:Add(\"DLabel\")\n        title:SetText(\"Your Inventory\")\n        title:SetFont(\"DermaDefault\")\n        title:Dock(TOP)\n        title:SetHeight(25)\n        end\n    -- Customize storage inventory panel\n    if storageInvPanel then\n        storageInvPanel:SetBackgroundColor(Color(100, 50, 50, 200))\n        storageInvPanel:SetSize(400, 300)\n        -- Add title\n        local title = storageInvPanel:Add(\"DLabel\")\n        title:SetText(\"Storage\")\n        title:SetFont(\"DermaDefault\")\n        title:Dock(TOP)\n        title:SetHeight(25)\n        end\n    -- Add storage info\n    local storageType = storage:getNetVar(\"storageType\", \"general\")\n    local maxWeight = storage:getNetVar(\"maxWeight\", 100)\n    local maxItems = storage:getNetVar(\"maxItems\", 50)\n    -- Add info labels\n    if storageInvPanel then\n        local infoLabel = storageInvPanel:Add(\"DLabel\")\n        infoLabel:SetText(string.format(\"Type: %s | Weight: %d | Items: %d\",\n        storageType, maxWeight, maxItems))\n        infoLabel:SetFont(\"DermaDefault\")\n        infoLabel:Dock(TOP)\n        infoLabel:SetHeight(20)\n        end\n    print(\"Storage panel created for \" .. storageType .. \" storage\")\n    end)\n</code></pre></p>"},{"location":"hooks/client/#ondeathsoundplayed","title":"OnDeathSoundPlayed","text":"<p>Purpose</p> <p>Called when a death sound is played</p> <p>When Called</p> <p>When a player death sound is triggered</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who died</li> <li><code>deathSound</code> (string): The sound file that was played</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log death sounds\nhook.Add(\"OnDeathSoundPlayed\", \"MyAddon\", function(client, deathSound)\nprint(\"Death sound played: \" .. deathSound)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track death sounds\nhook.Add(\"OnDeathSoundPlayed\", \"TrackDeathSounds\", function(client, deathSound)\nMyAddon.deathSounds = MyAddon.deathSounds or {}\ntable.insert(MyAddon.deathSounds, {\nplayer = client:Name(),\nsound = deathSound,\ntime = os.time()\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex death sound handling\nhook.Add(\"OnDeathSoundPlayed\", \"AdvancedDeathSound\", function(client, deathSound)\n-- Log death sound\nlia.log.write(\"death_sound_played\", {\nplayer = client:SteamID(),\nsound = deathSound,\ntimestamp = os.time()\n})\n-- Check for custom death sounds\nlocal char = client:getChar()\nif char then\n    local customSound = char:getData(\"customDeathSound\")\n    if customSound and customSound ~= deathSound then\n        client:EmitSound(customSound)\n        end\n    end\n-- Add death sound to statistics\nlocal stats = client:getData(\"deathStats\", {sounds = {}})\nstats.sounds[deathSound] = (stats.sounds[deathSound] or 0) + 1\nclient:setData(\"deathStats\", stats)\nend)\n</code></pre></p>"},{"location":"hooks/client/#onopenvendormenu","title":"OnOpenVendorMenu","text":"<p>Purpose</p> <p>Called when a vendor menu is opened</p> <p>When Called</p> <p>When a player opens a vendor's trading interface</p> <p>Parameters</p> <ul> <li><code>self</code> (Entity): The vendor entity</li> <li><code>vendor</code> (table): The vendor data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor menu opening\nhook.Add(\"OnOpenVendorMenu\", \"MyAddon\", function(self, vendor)\nprint(\"Vendor menu opened: \" .. vendor.name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize vendor menu appearance\nhook.Add(\"OnOpenVendorMenu\", \"VendorCustomization\", function(self, vendor)\nif vendor.faction == \"police\" then\n    -- Police vendors have special styling\n    self:SetColor(Color(0, 0, 255, 255))\nelseif vendor.faction == \"medic\" then\n    -- Medic vendors have different styling\n    self:SetColor(Color(255, 255, 255, 255))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor menu system\nhook.Add(\"OnOpenVendorMenu\", \"AdvancedVendorMenu\", function(self, vendor)\nlocal char = LocalPlayer():getChar()\nif not char then return end\n    -- Check faction restrictions\n    local allowedFactions = vendor.allowedFactions\n    if allowedFactions and not table.HasValue(allowedFactions, char:getFaction()) then\n        LocalPlayer():ChatPrint(\"Your faction cannot access this vendor\")\n        return false\n        end\n    -- Check level requirements\n    local requiredLevel = vendor.requiredLevel\n    if requiredLevel then\n        local charLevel = char:getData(\"level\", 1)\n        if charLevel &lt; requiredLevel then\n            LocalPlayer():ChatPrint(\"You need to be level \" .. requiredLevel .. \" to access this vendor\")\n            return false\n            end\n        end\n    -- Check time restrictions\n    local timeRestriction = vendor.timeRestriction\n    if timeRestriction then\n        local currentHour = tonumber(os.date(\"%H\"))\n        if currentHour &lt; timeRestriction.start or currentHour &gt; timeRestriction.end then\n            LocalPlayer():ChatPrint(\"This vendor is only open from \" .. timeRestriction.start .. \":00 to \" .. timeRestriction.end .. \":00\")\n            return false\n            end\n        end\n    -- Apply faction-specific discounts\n    local faction = char:getFaction()\n    local discounts = {\n    [\"police\"] = 0.1, -- 10% discount\n    [\"medic\"] = 0.05, -- 5% discount\n    [\"citizen\"] = 0.0  -- No discount\n    }\n    local discount = discounts[faction] or 0\n    vendor.discount = discount\n    -- Update vendor appearance based on faction\n    if faction == \"police\" then\n        self:SetColor(Color(0, 0, 255, 255))\n    elseif faction == \"medic\" then\n        self:SetColor(Color(255, 255, 255, 255))\n    else\n        self:SetColor(Color(255, 255, 255, 255))\n        end\n    -- Log vendor access\n    print(string.format(\"%s accessed vendor %s (Faction: %s)\",\n    LocalPlayer():Name(), vendor.name, faction))\n    end)\n</code></pre></p>"},{"location":"hooks/client/#onpainsoundplayed","title":"OnPainSoundPlayed","text":"<p>Purpose</p> <p>Called when a pain sound is played</p> <p>When Called</p> <p>When a player pain sound is triggered</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is in pain</li> <li><code>painSound</code> (string): The sound file that was played</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log pain sounds\nhook.Add(\"OnPainSoundPlayed\", \"MyAddon\", function(client, painSound)\nprint(\"Pain sound played: \" .. painSound)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track pain sounds\nhook.Add(\"OnPainSoundPlayed\", \"TrackPainSounds\", function(client, painSound)\nMyAddon.painSounds = MyAddon.painSounds or {}\ntable.insert(MyAddon.painSounds, {\nplayer = client:Name(),\nsound = painSound,\ntime = os.time()\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex pain sound handling\nhook.Add(\"OnPainSoundPlayed\", \"AdvancedPainSound\", function(client, painSound)\n-- Log pain sound\nlia.log.write(\"pain_sound_played\", {\nplayer = client:SteamID(),\nsound = painSound,\ntimestamp = os.time()\n})\n-- Check for custom pain sounds\nlocal char = client:getChar()\nif char then\n    local customSound = char:getData(\"customPainSound\")\n    if customSound and customSound ~= painSound then\n        client:EmitSound(customSound)\n        end\n    end\n-- Add pain sound to statistics\nlocal stats = client:getData(\"painStats\", {sounds = {}})\nstats.sounds[painSound] = (stats.sounds[painSound] or 0) + 1\nclient:setData(\"painStats\", stats)\nend)\n</code></pre></p>"},{"location":"hooks/client/#onthemechanged","title":"OnThemeChanged","text":"<p>Purpose</p> <p>Called when the UI theme is changed</p> <p>When Called</p> <p>When the active theme is switched</p> <p>Parameters</p> <ul> <li><code>themeName</code> (string): The name of the new theme</li> <li><code>themeData</code> (table): The theme configuration data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log theme changes\nhook.Add(\"OnThemeChanged\", \"MyAddon\", function(themeName, themeData)\nprint(\"Theme changed to: \" .. themeName)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update UI colors\nhook.Add(\"OnThemeChanged\", \"UpdateUIColors\", function(themeName, themeData)\nif themeData.colors then\n    MyAddon.primaryColor = themeData.colors.primary\n    MyAddon.secondaryColor = themeData.colors.secondary\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex theme change handling\nhook.Add(\"OnThemeChanged\", \"AdvancedThemeChange\", function(themeName, themeData)\n-- Update all UI elements\nif IsValid(MyAddon.mainPanel) then\n    MyAddon.mainPanel:SetBackgroundColor(themeData.colors.background)\n    end\n-- Reload custom fonts\nif themeData.fonts then\n    for fontName, fontData in pairs(themeData.fonts) do\n        surface.CreateFont(fontName, fontData)\n        end\n    end\n-- Save theme preference\nlia.data.set(\"preferredTheme\", themeName)\n-- Notify user\nlia.util.notify(\"Theme changed to \" .. themeName)\nend)\n</code></pre></p>"},{"location":"hooks/client/#openadminstickui","title":"OpenAdminStickUI","text":"<p>Purpose</p> <p>Called when the admin stick UI is opened</p> <p>When Called</p> <p>When an admin opens the admin stick interface</p> <p>Parameters</p> <ul> <li><code>tgt</code> (Entity): The target entity being examined</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log admin stick usage\nhook.Add(\"OpenAdminStickUI\", \"MyAddon\", function(tgt)\nprint(\"Admin stick UI opened for \" .. tostring(tgt))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize admin stick display\nhook.Add(\"OpenAdminStickUI\", \"CustomAdminStick\", function(tgt)\nif IsValid(tgt) and tgt:IsPlayer() then\n    local char = tgt:getChar()\n    if char then\n        print(\"Examining player: \" .. char:getName())\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex admin stick functionality\nhook.Add(\"OpenAdminStickUI\", \"AdvancedAdminStick\", function(tgt)\nif not IsValid(tgt) then return end\n    -- Store target for later use\n    MyAddon.currentTarget = tgt\n    -- Add custom information to admin stick\n    if tgt:IsPlayer() then\n        local char = tgt:getChar()\n        if char then\n            hook.Run(\"AddToAdminStickHUD\", LocalPlayer(), tgt, {\n            \"Character: \" .. char:getName(),\n            \"Faction: \" .. char:getFaction(),\n            \"Class: \" .. char:getClass()\n            })\n            end\n        end\n    -- Log admin stick usage\n    lia.log.write(\"admin_stick_opened\", {\n    admin = LocalPlayer():SteamID(),\n    target = IsValid(tgt) and tgt:EntIndex() or \"Invalid\",\n    timestamp = os.time()\n    })\n    end)\n</code></pre></p>"},{"location":"hooks/client/#paintitem","title":"PaintItem","text":"<p>Purpose</p> <p>Called to paint/render an item</p> <p>When Called</p> <p>When an item needs custom rendering</p> <p>Parameters</p> <ul> <li><code>item</code> (Item): The item being painted</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw item name\nhook.Add(\"PaintItem\", \"MyAddon\", function(item)\ndraw.SimpleText(item.name, \"DermaDefault\", 10, 10, Color(255, 255, 255))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw item with quality color\nhook.Add(\"PaintItem\", \"PaintItemQuality\", function(item)\nlocal quality = item:getData(\"quality\", \"common\")\nlocal color = Color(255, 255, 255)\nif quality == \"rare\" then\n    color = Color(0, 100, 255)\nelseif quality == \"epic\" then\n    color = Color(150, 0, 255)\n    end\ndraw.SimpleText(item.name, \"DermaDefault\", 10, 10, color)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item rendering\nhook.Add(\"PaintItem\", \"AdvancedItemPaint\", function(item)\nlocal x, y = 10, 10\n-- Draw item name with quality color\nlocal quality = item:getData(\"quality\", \"common\")\nlocal qualityColors = {\n[\"common\"] = Color(150, 150, 150),\n[\"uncommon\"] = Color(0, 200, 0),\n[\"rare\"] = Color(0, 100, 255),\n[\"epic\"] = Color(150, 0, 255),\n[\"legendary\"] = Color(255, 200, 0)\n}\nlocal color = qualityColors[quality] or Color(255, 255, 255)\ndraw.SimpleText(item.name, \"DermaDefaultBold\", x, y, color)\n-- Draw durability\nlocal durability = item:getData(\"durability\", 100)\ny = y + 20\ndraw.SimpleText(\"Durability: \" .. durability .. \"%\", \"DermaDefault\", x, y, Color(255, 255, 255))\n-- Draw quantity\nlocal quantity = item:getData(\"quantity\", 1)\nif quantity &gt; 1 then\n    y = y + 15\n    draw.SimpleText(\"Quantity: x\" .. quantity, \"DermaDefault\", x, y, Color(255, 255, 255))\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#populateadminstick","title":"PopulateAdminStick","text":"<p>Purpose</p> <p>Called to populate the admin stick menu</p> <p>When Called</p> <p>When building the admin stick context menu</p> <p>Parameters</p> <ul> <li><code>tempMenu</code> (Menu): The menu being populated</li> <li><code>tgt</code> (Entity): The target entity</li> <li><code>stores</code> (table): A table containing references to existing submenu categories</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic option\nhook.Add(\"PopulateAdminStick\", \"MyAddon\", function(tempMenu, tgt, stores)\ntempMenu:AddOption(\"Custom Action\", function()\nprint(\"Custom action performed\")\nend)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add conditional options\nhook.Add(\"PopulateAdminStick\", \"ConditionalAdminOptions\", function(tempMenu, tgt, stores)\nif IsValid(tgt) and tgt:IsPlayer() then\n    tempMenu:AddOption(\"Teleport To\", function()\n    RunConsoleCommand(\"lia_plyteleporttome\", tgt:SteamID())\n    end)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex admin stick menu\nhook.Add(\"PopulateAdminStick\", \"AdvancedAdminStick\", function(tempMenu, tgt, stores)\nif not IsValid(tgt) then return end\n    -- Player options\n    if tgt:IsPlayer() then\n        tempMenu:AddOption(\"Teleport To\", function()\n        RunConsoleCommand(\"lia_plyteleporttome\", tgt:SteamID())\n        end)\n        tempMenu:AddOption(\"Kick\", function()\n        RunConsoleCommand(\"lia_kick\", tgt:SteamID())\n        end)\n        tempMenu:AddOption(\"Ban\", function()\n        RunConsoleCommand(\"lia_ban\", tgt:SteamID())\n        end)\n        end\n    -- Entity options\n    tempMenu:AddOption(\"Remove\", function()\n    RunConsoleCommand(\"lia_removeentity\", tgt:EntIndex())\n    end)\n    tempMenu:AddOption(\"Copy Model\", function()\n    SetClipboardText(tgt:GetModel())\n    end)\n    end)\n\n-- Add to existing submenu categories\nhook.Add(\"PopulateAdminStick\", \"AddToExistingMenus\", function(tempMenu, tgt, stores)\n-- Add to existing teleportation submenu\nif stores and stores[\"teleportation\"] and IsValid(stores[\"teleportation\"]) then\n    stores[\"teleportation\"]:AddOption(\"Custom Teleport\", function()\n    RunConsoleCommand(\"lia_customteleport\", tgt:SteamID())\n    end)\n    end\n-- Add to existing utility commands submenu\nif stores and stores[\"utility_commands\"] and IsValid(stores[\"utility_commands\"]) then\n    stores[\"utility_commands\"]:AddOption(\"Custom Utility\", function()\n    print(\"Custom utility command\")\n    end)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#getadminsticklists","title":"GetAdminStickLists","text":"<p>Purpose</p> <p>Called to add custom list options to the admin stick menu</p> <p>When Called</p> <p>When building the admin stick context menu, before it's populated</p> <p>Parameters</p> <ul> <li><code>tgt</code> (Entity): The target entity</li> <li><code>lists</code> (table): The table to populate with list data</li> </ul> <p>Returns</p> <ul> <li>None (modified by reference)</li> </ul> <p>Realm</p> <p>Client List Data Structure: Each entry in lists should be a table with: - name (string) - The display name of the list - category (string) - The category key (e.g., \"characterManagement\", \"utility\") - subcategory (string) - The subcategory key within the category - items (table) - Array of items to display Each item in items should be a table with: - name (string) - The display name of the option - callback (function) - Function to execute when clicked (receives target and item as parameters) - icon (string, optional) - Icon path to display</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a list of custom options\nhook.Add(\"GetAdminStickLists\", \"MyAddon\", function(tgt, lists)\ntable.insert(lists, {\nname = \"Custom Weapons\",\ncategory = \"characterManagement\",\nsubcategory = \"items\",\nitems = {\n{ name = \"Gun 1\", callback = function(target, item) RunConsoleCommand(\"say\", \"/give\", target:SteamID(), \"weapon_pistol\") end },\n{ name = \"Gun 2\", callback = function(target, item) RunConsoleCommand(\"say\", \"/give\", target:SteamID(), \"weapon_rifle\") end }\n}\n})\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>    -- Medium: Add conditional list based on target\n    hook.Add(\"GetAdminStickLists\", \"ConditionalLists\", function(tgt, lists)\n    if tgt:IsPlayer() and tgt:getChar() then\n        table.insert(lists, {\n        name = \"Quick Factions\",\n        category = \"characterManagement\",\n        subcategory = \"factions\",\n        items = {\n        {\n        name = \"Police\",\n        icon = \"icon16/user_police.png\",\n        callback = function(target, item)\n        RunConsoleCommand(\"say\", \"/setfaction\", target:SteamID(), \"police\")\n        end\n    },\n    {\n    name = \"Medic\",\n    icon = \"icon16/user_medical.png\",\n    callback = function(target, item)\n    RunConsoleCommand(\"say\", \"/setfaction\", target:SteamID(), \"medic\")\n    end\n}\n}\n})\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add multiple lists with dynamic data\nhook.Add(\"GetAdminStickLists\", \"AdvancedLists\", function(tgt, lists)\nif not IsValid(tgt) or not tgt:IsPlayer() then return end\n    -- Add available ranks based on target's class\n    local targetChar = tgt:getChar()\n    if targetChar then\n        local targetClass = targetChar:getClass()\n        local ranks = lia.ranking.rankTable[targetClass]\n        if ranks then\n            local rankItems = {}\n            for rankKey, rankData in pairs(ranks) do\n                table.insert(rankItems, {\n                name = rankData.RankName or rankKey,\n                icon = \"icon16/user_green.png\",\n                callback = function(target, item)\n                local cmd = 'say /setrank ' .. QuoteArgs(GetIdentifier(target), rankKey)\n                LocalPlayer():ConCommand(cmd)\n                end\n            })\n            end\n        table.insert(lists, {\n        name = \"Ranks\",\n        category = \"characterManagement\",\n        subcategory = \"ranking\",\n        items = rankItems\n        })\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#registeradminsticksubcategories","title":"RegisterAdminStickSubcategories","text":"<p>Purpose</p> <p>Called to register custom subcategories for admin stick menu categories</p> <p>When Called</p> <p>During admin stick menu generation, before menu population</p> <p>Parameters</p> <ul> <li><code>categories</code> (table): The categories table to modify by reference</li> </ul> <p>Returns</p> <ul> <li>None (modified by reference)</li> </ul> <p>Realm</p> <p>Client Category Structure: categories[categoryKey] should be a table with: - name (string) - Display name of the category - icon (string) - Icon path for the category - subcategories (table) - Table of subcategories Each subcategory in subcategories[subKey] should be a table with: - name (string) - Display name of the subcategory - icon (string) - Icon path for the subcategory</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a single subcategory to an existing category\nhook.Add(\"RegisterAdminStickSubcategories\", \"MyAddonSubcategories\", function(categories)\nif categories.characterManagement then\n    categories.characterManagement.subcategories = categories.characterManagement.subcategories or {}\n    categories.characterManagement.subcategories.myAddon = {\n    name = \"My Addon Tools\",\n    icon = \"icon16/plugin.png\"\n    }\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add multiple subcategories and ensure category exists\nhook.Add(\"RegisterAdminStickSubcategories\", \"BankingSubcategories\", function(categories)\n-- Ensure banking category exists\ncategories.banking = categories.banking or {\nname = \"Banking\",\nicon = \"icon16/money.png\",\nsubcategories = {}\n}\n-- Add subcategories\ncategories.banking.subcategories.admin = {\nname = \"Admin Banking\",\nicon = \"icon16/shield.png\"\n}\ncategories.banking.subcategories.player = {\nname = \"Player Banking\",\nicon = \"icon16/user_green.png\"\n}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex addon with multiple categories and subcategories\nhook.Add(\"RegisterAdminStickSubcategories\", \"ComplexAddon\", function(categories)\n-- Create main category\ncategories.myComplexAddon = {\nname = \"My Complex Addon\",\nicon = \"icon16/application.png\",\nsubcategories = {\nmanagement = {\nname = \"Management\",\nicon = \"icon16/cog.png\"\n},\nstatistics = {\nname = \"Statistics\",\nicon = \"icon16/chart_bar.png\"\n},\nmaintenance = {\nname = \"Maintenance\",\nicon = \"icon16/wrench.png\"\n}\n}\n}\n-- Add to existing category\nif categories.characterManagement then\n    categories.characterManagement.subcategories.myAddon = {\n    name = \"My Addon Integration\",\n    icon = \"icon16/plugin_add.png\"\n    }\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#populateadmintabs","title":"PopulateAdminTabs","text":"<p>Purpose</p> <p>Called to populate admin tabs</p> <p>When Called</p> <p>When building the admin panel tabs</p> <p>Parameters</p> <ul> <li><code>adminPages</code> (table): The admin pages table</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>    -- Simple: Add basic tab\n    hook.Add(\"PopulateAdminTabs\", \"MyAddon\", function(adminPages)\n    adminPages[\"Custom\"] = function(parent)\n    local panel = parent:Add(\"DPanel\")\n    panel:Dock(FILL)\n    return panel\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>    -- Medium: Add tab with content\n    hook.Add(\"PopulateAdminTabs\", \"CustomAdminTab\", function(adminPages)\n    adminPages[\"Custom Tools\"] = function(parent)\n    local panel = parent:Add(\"DPanel\")\n    panel:Dock(FILL)\n    local button = panel:Add(\"DButton\")\n    button:SetText(\"Custom Action\")\n    button:Dock(TOP)\n    button.DoClick = function()\n    RunConsoleCommand(\"lia_customaction\")\n    end\nreturn panel\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>    -- High: Complex admin tab system\n    hook.Add(\"PopulateAdminTabs\", \"AdvancedAdminTabs\", function(adminPages)\n    adminPages[\"Custom Management\"] = function(parent)\n    local panel = parent:Add(\"DPanel\")\n    panel:Dock(FILL)\n    panel:SetBackgroundColor(Color(50, 50, 50))\n    -- Add title\n    local title = panel:Add(\"DLabel\")\n    title:SetText(\"Custom Management Tools\")\n    title:SetFont(\"DermaLarge\")\n    title:Dock(TOP)\n    title:SetHeight(30)\n    -- Add buttons\n    local btnPanel = panel:Add(\"DPanel\")\n    btnPanel:Dock(TOP)\n    btnPanel:SetHeight(200)\n    local teleportBtn = btnPanel:Add(\"DButton\")\n    teleportBtn:SetText(\"Teleport All Players\")\n    teleportBtn:Dock(TOP)\n    teleportBtn:SetHeight(30)\n    teleportBtn.DoClick = function()\n    RunConsoleCommand(\"lia_teleportall\")\n    end\nlocal healBtn = btnPanel:Add(\"DButton\")\nhealBtn:SetText(\"Heal All Players\")\nhealBtn:Dock(TOP)\nhealBtn:SetHeight(30)\nhealBtn.DoClick = function()\nRunConsoleCommand(\"lia_healall\")\nend\nreturn panel\nend\nend)\n</code></pre></p>"},{"location":"hooks/client/#populateconfigurationbuttons","title":"PopulateConfigurationButtons","text":"<p>Purpose</p> <p>Called to populate configuration buttons</p> <p>When Called</p> <p>When building the configuration menu</p> <p>Parameters</p> <ul> <li><code>pages</code> (table): The configuration pages table</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>    -- Simple: Add basic config page\n    hook.Add(\"PopulateConfigurationButtons\", \"MyAddon\", function(pages)\n    pages[\"Custom\"] = function(parent)\n    local panel = parent:Add(\"DPanel\")\n    panel:Dock(FILL)\n    return panel\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>    -- Medium: Add config page with options\n    hook.Add(\"PopulateConfigurationButtons\", \"CustomConfigPage\", function(pages)\n    pages[\"My Settings\"] = function(parent)\n    local panel = parent:Add(\"DPanel\")\n    panel:Dock(FILL)\n    local checkbox = panel:Add(\"DCheckBoxLabel\")\n    checkbox:SetText(\"Enable Feature\")\n    checkbox:Dock(TOP)\n    checkbox:SetValue(GetConVar(\"myfeature_enabled\"):GetBool())\n    checkbox.OnChange = function(self, val)\n    RunConsoleCommand(\"myfeature_enabled\", val and \"1\" or \"0\")\n    end\nreturn panel\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>    -- High: Complex configuration system\n    hook.Add(\"PopulateConfigurationButtons\", \"AdvancedConfigSystem\", function(pages)\n    pages[\"Advanced Settings\"] = function(parent)\n    local panel = parent:Add(\"DPanel\")\n    panel:Dock(FILL)\n    panel:SetBackgroundColor(Color(50, 50, 50))\n    -- Add title\n    local title = panel:Add(\"DLabel\")\n    title:SetText(\"Advanced Configuration\")\n    title:SetFont(\"DermaLarge\")\n    title:Dock(TOP)\n    title:SetHeight(30)\n    -- Add settings\n    local settingsPanel = panel:Add(\"DPanel\")\n    settingsPanel:Dock(FILL)\n    -- Enable feature checkbox\n    local enableCheckbox = settingsPanel:Add(\"DCheckBoxLabel\")\n    enableCheckbox:SetText(\"Enable Advanced Features\")\n    enableCheckbox:Dock(TOP)\n    enableCheckbox:SetValue(GetConVar(\"advanced_enabled\"):GetBool())\n    enableCheckbox.OnChange = function(self, val)\n    RunConsoleCommand(\"advanced_enabled\", val and \"1\" or \"0\")\n    end\n-- Slider for value\nlocal slider = settingsPanel:Add(\"DNumSlider\")\nslider:SetText(\"Feature Intensity\")\nslider:Dock(TOP)\nslider:SetMin(0)\nslider:SetMax(100)\nslider:SetValue(GetConVar(\"advanced_intensity\"):GetInt())\nslider.OnValueChanged = function(self, val)\nRunConsoleCommand(\"advanced_intensity\", tostring(math.floor(val)))\nend\nreturn panel\nend\nend)\n</code></pre></p>"},{"location":"hooks/client/#populateinventoryitems","title":"PopulateInventoryItems","text":"<p>Purpose</p> <p>Called to populate inventory items</p> <p>When Called</p> <p>When building the inventory item list</p> <p>Parameters</p> <ul> <li><code>pnlContent</code> (Panel): The content panel</li> <li><code>tree</code> (Panel): The tree view panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic category\nhook.Add(\"PopulateInventoryItems\", \"MyAddon\", function(pnlContent, tree)\nlocal node = tree:AddNode(\"Custom Items\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>    -- Medium: Add category with items\n    hook.Add(\"PopulateInventoryItems\", \"CustomInventoryItems\", function(pnlContent, tree)\n    local node = tree:AddNode(\"Custom Items\")\n    for _, item in pairs(lia.item.list) do\n        if item.category == \"custom\" then\n            local itemNode = node:AddNode(item.name)\n            itemNode.DoClick = function()\n            -- Show item details\n            end\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>    -- High: Complex inventory population\n    hook.Add(\"PopulateInventoryItems\", \"AdvancedInventoryPopulation\", function(pnlContent, tree)\n    -- Group items by custom category\n    local categories = {}\n    for _, item in pairs(lia.item.list) do\n        local category = item.customCategory or \"Other\"\n        categories[category] = categories[category] or {}\n        table.insert(categories[category], item)\n        end\n    -- Create nodes for each category\n    for category, items in pairs(categories) do\n        local categoryNode = tree:AddNode(category)\n        categoryNode:SetIcon(\"icon16/folder.png\")\n        -- Add items to category\n        for _, item in ipairs(items) do\n            local itemNode = categoryNode:AddNode(item.name)\n            itemNode:SetIcon(\"icon16/box.png\")\n            itemNode.DoClick = function()\n            -- Show item details in content panel\n            pnlContent:Clear()\n            local itemPanel = pnlContent:Add(\"DPanel\")\n            itemPanel:Dock(FILL)\n            local nameLabel = itemPanel:Add(\"DLabel\")\n            nameLabel:SetText(item.name)\n            nameLabel:SetFont(\"DermaLarge\")\n            nameLabel:Dock(TOP)\n            local descLabel = itemPanel:Add(\"DLabel\")\n            descLabel:SetText(item.desc or \"No description\")\n            descLabel:Dock(TOP)\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#postdrawinventory","title":"PostDrawInventory","text":"<p>Purpose</p> <p>Called after drawing the inventory</p> <p>When Called</p> <p>After the inventory UI has been rendered</p> <p>Parameters</p> <ul> <li><code>mainPanel</code> (Panel): The main inventory panel</li> <li><code>parentPanel</code> (Panel): The parent panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log inventory draw\nhook.Add(\"PostDrawInventory\", \"MyAddon\", function(mainPanel, parentPanel)\nprint(\"Inventory drawn\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add custom UI elements\nhook.Add(\"PostDrawInventory\", \"CustomInventoryUI\", function(mainPanel, parentPanel)\nif IsValid(mainPanel) then\n    local label = mainPanel:Add(\"DLabel\")\n    label:SetText(\"Custom Inventory\")\n    label:Dock(BOTTOM)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory UI customization\nhook.Add(\"PostDrawInventory\", \"AdvancedInventoryUI\", function(mainPanel, parentPanel)\nif not IsValid(mainPanel) then return end\n    local char = LocalPlayer():getChar()\n    if not char then return end\n        -- Add weight display\n        local inventory = char:getInv()\n        if inventory then\n            local weight = inventory:getData(\"weight\", 0)\n            local maxWeight = inventory:getData(\"maxWeight\", 100)\n            local weightLabel = mainPanel:Add(\"DLabel\")\n            weightLabel:SetText(string.format(\"Weight: %d / %d\", weight, maxWeight))\n            weightLabel:Dock(BOTTOM)\n            weightLabel:SetHeight(20)\n            end\n        end)\n</code></pre></p>"},{"location":"hooks/client/#postloadfonts","title":"PostLoadFonts","text":"<p>Purpose</p> <p>Called after fonts are loaded</p> <p>When Called</p> <p>After the font system has been initialized</p> <p>Parameters</p> <ul> <li><code>mainFont</code> (string): The main font name</li> <li><code>configuredFont</code> (string): The configured font name</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log font load\nhook.Add(\"PostLoadFonts\", \"MyAddon\", function(mainFont, configuredFont)\nprint(\"Fonts loaded: \" .. mainFont)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create custom fonts\nhook.Add(\"PostLoadFonts\", \"CreateCustomFonts\", function(mainFont, configuredFont)\nsurface.CreateFont(\"MyCustomFont\", {\nfont = mainFont,\nsize = 24,\nweight = 500\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex font system\nhook.Add(\"PostLoadFonts\", \"AdvancedFontSystem\", function(mainFont, configuredFont)\n-- Create custom fonts\nlocal fontSizes = {16, 20, 24, 28, 32}\nfor _, size in ipairs(fontSizes) do\n    surface.CreateFont(\"MyCustomFont_\" .. size, {\n    font = mainFont,\n    size = size,\n    weight = 500,\n    antialias = true\n    })\n    end\n-- Create bold variants\nfor _, size in ipairs(fontSizes) do\n    surface.CreateFont(\"MyCustomFontBold_\" .. size, {\n    font = mainFont,\n    size = size,\n    weight = 700,\n    antialias = true\n    })\n    end\nprint(\"Custom fonts created\")\nend)\n</code></pre></p>"},{"location":"hooks/client/#predrawphysgunbeam","title":"PreDrawPhysgunBeam","text":"<p>Purpose</p> <p>Called before drawing the physgun beam</p> <p>When Called</p> <p>Before the physgun beam is rendered</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log physgun beam\nhook.Add(\"PreDrawPhysgunBeam\", \"MyAddon\", function()\nprint(\"Drawing physgun beam\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize beam appearance\nhook.Add(\"PreDrawPhysgunBeam\", \"CustomizeBeam\", function()\nlocal client = LocalPlayer()\nif IsValid(client) and client:GetActiveWeapon():GetClass() == \"weapon_physgun\" then\n    -- Custom beam color\n    render.SetColorMaterial()\n    render.DrawBeam(client:GetShootPos(), client:GetEyeTrace().HitPos, 8, 0, 1, Color(255, 0, 0, 255))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex physgun beam system\nhook.Add(\"PreDrawPhysgunBeam\", \"AdvancedPhysgunBeam\", function()\nlocal client = LocalPlayer()\nif not IsValid(client) then return end\n    local weapon = client:GetActiveWeapon()\n    if not IsValid(weapon) or weapon:GetClass() ~= \"weapon_physgun\" then return end\n        local trace = client:GetEyeTrace()\n        if not trace.Hit then return end\n            local target = trace.Entity\n            if not IsValid(target) then return end\n                -- Different colors for different entities\n                local color = Color(255, 255, 255, 255)\n                if target:IsPlayer() then\n                    color = Color(255, 0, 0, 255)\n                elseif target:IsVehicle() then\n                    color = Color(0, 255, 0, 255)\n                elseif target:GetClass():find(\"prop_\") then\n                    color = Color(0, 0, 255, 255)\n                    end\n                -- Draw custom beam\n                render.SetColorMaterial()\n                render.DrawBeam(client:GetShootPos(), trace.HitPos, 8, 0, 1, color)\n                end)\n</code></pre></p>"},{"location":"hooks/client/#refreshfonts","title":"RefreshFonts","text":"<p>Purpose</p> <p>Called to refresh fonts</p> <p>When Called</p> <p>When the font system needs to be refreshed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log font refresh\nhook.Add(\"RefreshFonts\", \"MyAddon\", function()\nprint(\"Fonts refreshed\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Recreate custom fonts\nhook.Add(\"RefreshFonts\", \"RecreateCustomFonts\", function()\nsurface.CreateFont(\"MyCustomFont\", {\nfont = \"Arial\",\nsize = 24,\nweight = 500\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex font refresh system\nhook.Add(\"RefreshFonts\", \"AdvancedFontRefresh\", function()\n-- Clear existing fonts\nfor k, v in pairs(surface.GetFonts()) do\n    if string.find(k, \"MyCustom\") then\n        surface.CreateFont(k, {\n        font = \"Arial\",\n        size = 24,\n        weight = 500\n        })\n        end\n    end\n-- Create new fonts with current settings\nlocal mainFont = GetConVar(\"lia_font\"):GetString()\nfor i = 16, 32, 4 do\n    surface.CreateFont(\"MyCustomFont_\" .. i, {\n    font = mainFont,\n    size = i,\n    weight = 500,\n    antialias = true\n    })\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#removepart","title":"RemovePart","text":"<p>Purpose</p> <p>Called when a PAC3 part is removed</p> <p>When Called</p> <p>When a PAC3 part is detached from a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player losing the part</li> <li><code>id</code> (string): The part ID</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log part removal\nhook.Add(\"RemovePart\", \"MyAddon\", function(client, id)\nprint(client:Name() .. \" removed part: \" .. id)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track part usage\nhook.Add(\"RemovePart\", \"TrackPartUsage\", function(client, id)\nlocal char = client:getChar()\nif char then\n    local partsUsed = char:getData(\"partsUsed\", {})\n    partsUsed[id] = (partsUsed[id] or 0) + 1\n    char:setData(\"partsUsed\", partsUsed)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex part removal system\nhook.Add(\"RemovePart\", \"AdvancedPartRemoval\", function(client, id)\nlocal char = client:getChar()\nif not char then return end\n    -- Track part usage\n    local partsUsed = char:getData(\"partsUsed\", {})\n    partsUsed[id] = (partsUsed[id] or 0) + 1\n    char:setData(\"partsUsed\", partsUsed)\n    -- Log to database\n    lia.db.query(\"INSERT INTO part_logs (timestamp, charid, partid, action) VALUES (?, ?, ?, ?)\",\n    os.time(), char:getID(), id, \"removed\")\n    -- Notify nearby players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply ~= client and ply:GetPos():Distance(client:GetPos()) &lt; 500 then\n            ply:ChatPrint(client:Name() .. \" removed a part\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/client/#resetcharacterpanel","title":"ResetCharacterPanel","text":"<p>Purpose</p> <p>Called to reset the character panel</p> <p>When Called</p> <p>When the character panel needs to be refreshed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log panel reset\nhook.Add(\"ResetCharacterPanel\", \"MyAddon\", function()\nprint(\"Character panel reset\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clear custom data\nhook.Add(\"ResetCharacterPanel\", \"ClearCustomData\", function()\nMyAddon.selectedCharacter = nil\nMyAddon.panelData = {}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex panel reset system\nhook.Add(\"ResetCharacterPanel\", \"AdvancedPanelReset\", function()\n-- Clear custom data\nMyAddon.selectedCharacter = nil\nMyAddon.panelData = {}\nMyAddon.customButtons = {}\n-- Reset UI state\nif IsValid(MyAddon.customPanel) then\n    MyAddon.customPanel:Remove()\n    MyAddon.customPanel = nil\n    end\n-- Rebuild panel\ntimer.Simple(0.1, function()\nMyAddon.RebuildPanel()\nend)\nend)\n</code></pre></p>"},{"location":"hooks/client/#scoreboardclosed","title":"ScoreboardClosed","text":"<p>Purpose</p> <p>Called when the scoreboard is closed</p> <p>When Called</p> <p>When the scoreboard UI is closed</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The scoreboard panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log scoreboard close\nhook.Add(\"ScoreboardClosed\", \"MyAddon\", function(self)\nprint(\"Scoreboard closed\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up scoreboard data\nhook.Add(\"ScoreboardClosed\", \"CleanupScoreboard\", function(self)\nMyAddon.scoreboardData = {}\nMyAddon.selectedPlayer = nil\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex scoreboard cleanup\nhook.Add(\"ScoreboardClosed\", \"AdvancedScoreboardCleanup\", function(self)\n-- Clean up data\nMyAddon.scoreboardData = {}\nMyAddon.selectedPlayer = nil\nMyAddon.customPanels = {}\n-- Save scoreboard state\nlocal char = LocalPlayer():getChar()\nif char then\n    char:setData(\"lastScoreboardClose\", os.time())\n    end\n-- Notify other systems\nhook.Run(\"CustomScoreboardClosed\", self)\nend)\n</code></pre></p>"},{"location":"hooks/client/#scoreboardopened","title":"ScoreboardOpened","text":"<p>Purpose</p> <p>Called when the scoreboard is opened</p> <p>When Called</p> <p>When the scoreboard UI is displayed</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The scoreboard panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log scoreboard open\nhook.Add(\"ScoreboardOpened\", \"MyAddon\", function(self)\nprint(\"Scoreboard opened\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize scoreboard data\nhook.Add(\"ScoreboardOpened\", \"InitializeScoreboard\", function(self)\nMyAddon.scoreboardData = {\nplayers = player.GetAll(),\nlastUpdate = os.time()\n}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>    -- High: Complex scoreboard initialization\n    hook.Add(\"ScoreboardOpened\", \"AdvancedScoreboardInit\", function(self)\n    -- Initialize data\n    MyAddon.scoreboardData = {\n    players = player.GetAll(),\n    lastUpdate = os.time(),\n    customData = {}\n    }\n    -- Load custom panels\n    MyAddon.customPanels = {}\n    -- Add custom buttons\n    local customBtn = self:Add(\"DButton\")\n    customBtn:SetText(\"Custom Action\")\n    customBtn:Dock(TOP)\n    customBtn.DoClick = function()\n    hook.Run(\"CustomScoreboardAction\")\n    end\n-- Notify other systems\nhook.Run(\"CustomScoreboardOpened\", self)\nend)\n</code></pre></p>"},{"location":"hooks/client/#scoreboardrowcreated","title":"ScoreboardRowCreated","text":"<p>Purpose</p> <p>Called when a scoreboard row is created</p> <p>When Called</p> <p>When a player row is added to the scoreboard</p> <p>Parameters</p> <ul> <li><code>slot</code> (Panel): The row panel</li> <li><code>ply</code> (Player): The player for the row</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log row creation\nhook.Add(\"ScoreboardRowCreated\", \"MyAddon\", function(slot, ply)\nprint(\"Scoreboard row created for \" .. ply:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize row appearance\nhook.Add(\"ScoreboardRowCreated\", \"CustomizeRow\", function(slot, ply)\nlocal char = ply:getChar()\nif char then\n    local faction = char:getFaction()\n    if faction == \"police\" then\n        slot:SetBackgroundColor(Color(0, 0, 255, 50))\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex scoreboard row customization\nhook.Add(\"ScoreboardRowCreated\", \"AdvancedRowCustomization\", function(slot, ply)\nlocal char = ply:getChar()\nif not char then return end\n    -- Faction-based coloring\n    local faction = char:getFaction()\n    local factionColors = {\n    [\"police\"] = Color(0, 0, 255, 50),\n    [\"medic\"] = Color(0, 255, 0, 50),\n    [\"criminal\"] = Color(255, 0, 0, 50)\n    }\n    local color = factionColors[faction] or Color(255, 255, 255, 50)\n    slot:SetBackgroundColor(color)\n    -- Add custom elements\n    local customLabel = slot:Add(\"DLabel\")\n    customLabel:SetText(\"[\" .. faction .. \"]\")\n    customLabel:Dock(RIGHT)\n    customLabel:SetTextColor(Color(255, 255, 255))\n    end)\n</code></pre></p>"},{"location":"hooks/client/#scoreboardrowremoved","title":"ScoreboardRowRemoved","text":"<p>Purpose</p> <p>Called when a scoreboard row is removed</p> <p>When Called</p> <p>When a player row is removed from the scoreboard</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The scoreboard panel</li> <li><code>ply</code> (Player): The player whose row was removed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log row removal\nhook.Add(\"ScoreboardRowRemoved\", \"MyAddon\", function(self, ply)\nprint(\"Scoreboard row removed for \" .. ply:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up row data\nhook.Add(\"ScoreboardRowRemoved\", \"CleanupRowData\", function(self, ply)\nMyAddon.playerData[ply:SteamID()] = nil\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex row cleanup\nhook.Add(\"ScoreboardRowRemoved\", \"AdvancedRowCleanup\", function(self, ply)\n-- Clean up player data\nMyAddon.playerData[ply:SteamID()] = nil\n-- Remove custom elements\nif IsValid(MyAddon.customElements[ply:SteamID()]) then\n    MyAddon.customElements[ply:SteamID()]:Remove()\n    MyAddon.customElements[ply:SteamID()] = nil\n    end\n-- Update scoreboard statistics\nMyAddon.UpdateStats()\nend)\n</code></pre></p>"},{"location":"hooks/client/#setuppacdatafromitems","title":"SetupPACDataFromItems","text":"<p>Purpose</p> <p>Called to set up PAC3 data from items</p> <p>When Called</p> <p>When configuring PAC3 data based on equipped items</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log PAC3 setup\nhook.Add(\"SetupPACDataFromItems\", \"MyAddon\", function()\nprint(\"Setting up PAC3 data from items\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Apply item-based PAC3 data\nhook.Add(\"SetupPACDataFromItems\", \"ApplyItemPAC3\", function()\nlocal char = LocalPlayer():getChar()\nif char then\n    local inv = char:getInv()\n    if inv then\n        for _, item in pairs(inv:getItems()) do\n            if item:getData(\"equipped\", false) and item.pacData then\n                hook.Run(\"AttachPart\", LocalPlayer(), item.pacData)\n                end\n            end\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex PAC3 item system\nhook.Add(\"SetupPACDataFromItems\", \"AdvancedPAC3Items\", function()\nlocal char = LocalPlayer():getChar()\nif not char then return end\n    local inv = char:getInv()\n    if not inv then return end\n        -- Clear existing PAC3 data\n        hook.Run(\"RemoveAllParts\", LocalPlayer())\n        -- Apply item-based PAC3 data\n        for _, item in pairs(inv:getItems()) do\n            if item:getData(\"equipped\", false) then\n                local pacData = item:getData(\"pacData\")\n                if pacData then\n                    hook.Run(\"AttachPart\", LocalPlayer(), pacData)\n                    end\n                -- Apply item-specific PAC3 effects\n                if item.pacEffects then\n                    for _, effect in ipairs(item.pacEffects) do\n                        hook.Run(\"ApplyPACEffect\", LocalPlayer(), effect)\n                        end\n                    end\n                end\n            end\n        -- Apply faction-specific PAC3 data\n        local faction = char:getFaction()\n        local factionPAC = lia.faction.indices[faction] and lia.faction.indices[faction].pacData\n        if factionPAC then\n            hook.Run(\"AttachPart\", LocalPlayer(), factionPAC)\n            end\n        end)\n</code></pre></p>"},{"location":"hooks/client/#shouldshowquickmenu","title":"ShouldShowQuickMenu","text":"<p>Purpose</p> <p>Called to determine if the quick menu should be shown when the context menu opens</p> <p>When Called</p> <p>When the context menu (right-click menu) is opened</p> <p>Returns</p> <ul> <li>boolean - Return false to prevent the quick menu from opening, return nil or true to allow it</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Disable quick menu completely\nhook.Add(\"ShouldShowQuickMenu\", \"DisableQuickMenu\", function()\nreturn false\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Disable quick menu for specific players\nhook.Add(\"ShouldShowQuickMenu\", \"RestrictQuickMenu\", function()\nif LocalPlayer():GetUserGroup() == \"user\" then\n    return false\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Conditional quick menu based on game state\nhook.Add(\"ShouldShowQuickMenu\", \"ConditionalQuickMenu\", function()\nlocal char = LocalPlayer():getChar()\nif not char then return false end\n    -- Only show for certain factions\n    local allowedFactions = {\"police\", \"medic\"}\n    return table.HasValue(allowedFactions, char:getFaction())\n    end)\n</code></pre></p>"},{"location":"hooks/client/#setupquickmenu","title":"SetupQuickMenu","text":"<p>Purpose</p> <p>Called to set up the quick menu</p> <p>When Called</p> <p>When initializing the quick access menu</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The quick menu panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log quick menu setup\nhook.Add(\"SetupQuickMenu\", \"MyAddon\", function(self)\nprint(\"Setting up quick menu\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>    -- Medium: Add custom buttons\n    hook.Add(\"SetupQuickMenu\", \"AddCustomButtons\", function(self)\n    local customBtn = self:Add(\"DButton\")\n    customBtn:SetText(\"Custom Action\")\n    customBtn:Dock(TOP)\n    customBtn.DoClick = function()\n    print(\"Custom action clicked\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>    -- High: Complex quick menu system\n    hook.Add(\"SetupQuickMenu\", \"AdvancedQuickMenu\", function(self)\n    local char = LocalPlayer():getChar()\n    if not char then return end\n        -- Add faction-specific buttons\n        local faction = char:getFaction()\n        if faction == \"police\" then\n            local arrestBtn = self:Add(\"DButton\")\n            arrestBtn:SetText(\"Arrest\")\n            arrestBtn:Dock(TOP)\n            arrestBtn.DoClick = function()\n            RunConsoleCommand(\"lia_arrest\")\n            end\n    elseif faction == \"medic\" then\n        local healBtn = self:Add(\"DButton\")\n        healBtn:SetText(\"Heal\")\n        healBtn:Dock(TOP)\n        healBtn.DoClick = function()\n        RunConsoleCommand(\"lia_heal\")\n        end\n    end\n-- Add universal buttons\nlocal inventoryBtn = self:Add(\"DButton\")\ninventoryBtn:SetText(\"Inventory\")\ninventoryBtn:Dock(TOP)\ninventoryBtn.DoClick = function()\nRunConsoleCommand(\"lia_inventory\")\nend\nend)\n</code></pre></p>"},{"location":"hooks/client/#shouldallowscoreboardoverride","title":"ShouldAllowScoreboardOverride","text":"<p>Purpose</p> <p>Called to check if scoreboard override should be allowed</p> <p>When Called</p> <p>When determining if a player can override scoreboard behavior</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player</li> <li><code>override</code> (string): The override type</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all overrides\nhook.Add(\"ShouldAllowScoreboardOverride\", \"MyAddon\", function(ply, override)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check admin status\nhook.Add(\"ShouldAllowScoreboardOverride\", \"AdminOverride\", function(ply, override)\nreturn ply:IsAdmin()\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex override system\nhook.Add(\"ShouldAllowScoreboardOverride\", \"AdvancedOverride\", function(ply, override)\n-- Admins can always override\nif ply:IsAdmin() then return true end\n    -- Check specific override types\n    if override == \"customization\" then\n        return ply:getNetVar(\"canCustomizeScoreboard\", false)\n    elseif override == \"sorting\" then\n        return ply:getNetVar(\"canSortScoreboard\", false)\n        end\n    return false\n    end)\n</code></pre></p>"},{"location":"hooks/client/#shouldbardraw","title":"ShouldBarDraw","text":"<p>Purpose</p> <p>Called to check if a bar should be drawn</p> <p>When Called</p> <p>When determining if a UI bar should be rendered</p> <p>Parameters</p> <ul> <li><code>bar</code> (table): The bar data</li> </ul> <p>Returns</p> <ul> <li>boolean - True to draw, false to hide</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Always draw bars\nhook.Add(\"ShouldBarDraw\", \"MyAddon\", function(bar)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide specific bars\nhook.Add(\"ShouldBarDraw\", \"HideSpecificBars\", function(bar)\nif bar.name == \"health\" and LocalPlayer():Health() &gt;= 100 then\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex bar visibility system\nhook.Add(\"ShouldBarDraw\", \"AdvancedBarVisibility\", function(bar)\nlocal char = LocalPlayer():getChar()\nif not char then return false end\n    -- Hide bars for specific factions\n    local faction = char:getFaction()\n    if faction == \"ghost\" and bar.name ~= \"stamina\" then\n        return false\n        end\n    -- Hide bars when in cutscene\n    if char:getData(\"inCutscene\", false) then\n        return false\n        end\n    -- Hide bars when dead\n    if LocalPlayer():Health() &lt;= 0 then\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/client/#shoulddisablethirdperson","title":"ShouldDisableThirdperson","text":"<p>Purpose</p> <p>Called to check if thirdperson should be disabled</p> <p>When Called</p> <p>When determining if thirdperson view should be blocked</p> <p>Parameters</p> <ul> <li><code>self</code> (Player): The player</li> </ul> <p>Returns</p> <ul> <li>boolean - True to disable, false to allow</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Never disable thirdperson\nhook.Add(\"ShouldDisableThirdperson\", \"MyAddon\", function(self)\nreturn false\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Disable in specific areas\nhook.Add(\"ShouldDisableThirdperson\", \"DisableInAreas\", function(self)\nlocal pos = self:GetPos()\nlocal restrictedAreas = {\nVector(0, 0, 0), -- Example restricted area\n}\nfor _, area in ipairs(restrictedAreas) do\n    if pos:Distance(area) &lt; 500 then\n        return true\n        end\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex thirdperson restrictions\nhook.Add(\"ShouldDisableThirdperson\", \"AdvancedThirdpersonRestrictions\", function(self)\nlocal char = self:getChar()\nif not char then return false end\n    -- Disable for specific factions\n    local faction = char:getFaction()\n    if faction == \"ghost\" then\n        return true\n        end\n    -- Disable in vehicles\n    if self:InVehicle() then\n        return true\n        end\n    -- Disable when tied\n    if char:getData(\"tied\", false) then\n        return true\n        end\n    -- Disable in restricted areas\n    local pos = self:GetPos()\n    local restrictedAreas = lia.data.get(\"restrictedAreas\", {})\n    for _, area in ipairs(restrictedAreas) do\n        if pos:Distance(area.pos) &lt; area.radius then\n            return true\n            end\n        end\n    return false\n    end)\n</code></pre></p>"},{"location":"hooks/client/#shoulddrawammo","title":"ShouldDrawAmmo","text":"<p>Purpose</p> <p>Called to check if ammo should be drawn</p> <p>When Called</p> <p>When determining if weapon ammo should be displayed</p> <p>Parameters</p> <ul> <li><code>wpn</code> (Weapon): The weapon</li> </ul> <p>Returns</p> <ul> <li>boolean - True to draw, false to hide</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Always draw ammo\nhook.Add(\"ShouldDrawAmmo\", \"MyAddon\", function(wpn)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide ammo for specific weapons\nhook.Add(\"ShouldDrawAmmo\", \"HideSpecificAmmo\", function(wpn)\nlocal weaponClass = wpn:GetClass()\nlocal hideAmmoWeapons = {\"weapon_crowbar\", \"weapon_stunstick\"}\nreturn not table.HasValue(hideAmmoWeapons, weaponClass)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ammo display system\nhook.Add(\"ShouldDrawAmmo\", \"AdvancedAmmoDisplay\", function(wpn)\nlocal char = LocalPlayer():getChar()\nif not char then return false end\n    -- Hide ammo for melee weapons\n    local weaponClass = wpn:GetClass()\n    local meleeWeapons = {\"weapon_crowbar\", \"weapon_stunstick\", \"weapon_knife\"}\n    if table.HasValue(meleeWeapons, weaponClass) then\n        return false\n        end\n    -- Hide ammo when in cutscene\n    if char:getData(\"inCutscene\", false) then\n        return false\n        end\n    -- Hide ammo for specific factions\n    local faction = char:getFaction()\n    if faction == \"ghost\" then\n        return false\n        end\n    -- Check weapon ammo type\n    local ammoType = wpn:GetPrimaryAmmoType()\n    if ammoType == -1 then\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/client/#shoulddrawentityinfo","title":"ShouldDrawEntityInfo","text":"<p>Purpose</p> <p>Called to check if entity info should be drawn</p> <p>When Called</p> <p>When determining if entity information should be displayed</p> <p>Parameters</p> <ul> <li><code>e</code> (Entity): The entity</li> </ul> <p>Returns</p> <ul> <li>boolean - True to draw, false to hide</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Always draw entity info\nhook.Add(\"ShouldDrawEntityInfo\", \"MyAddon\", function(e)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide info for specific entities\nhook.Add(\"ShouldDrawEntityInfo\", \"HideSpecificInfo\", function(e)\nlocal class = e:GetClass()\nlocal hideClasses = {\"prop_physics\", \"prop_dynamic\"}\nreturn not table.HasValue(hideClasses, class)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entity info system\nhook.Add(\"ShouldDrawEntityInfo\", \"AdvancedEntityInfo\", function(e)\nif not IsValid(e) then return false end\n    local char = LocalPlayer():getChar()\n    if not char then return false end\n        -- Hide info when in cutscene\n        if char:getData(\"inCutscene\", false) then\n            return false\n            end\n        -- Hide info for specific entity types\n        local class = e:GetClass()\n        local hideClasses = {\n        \"prop_physics\",\n        \"prop_dynamic\",\n        \"func_door\",\n        \"func_button\"\n        }\n        if table.HasValue(hideClasses, class) then\n            return false\n            end\n        -- Show info for players\n        if e:IsPlayer() then\n            return true\n            end\n        -- Show info for vehicles\n        if e:IsVehicle() then\n            return true\n            end\n        -- Show info for NPCs\n        if e:IsNPC() then\n            return true\n            end\n        return false\n        end)\n</code></pre></p>"},{"location":"hooks/client/#shoulddrawplayerinfo","title":"ShouldDrawPlayerInfo","text":"<p>Purpose</p> <p>Determines if player information should be drawn</p> <p>When Called</p> <p>When deciding whether to draw player info above a player</p> <p>Parameters</p> <ul> <li><code>e</code> (Entity): The entity to check</li> </ul> <p>Returns</p> <ul> <li>boolean - True if player info should be drawn, false otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw all player info\nhook.Add(\"ShouldDrawPlayerInfo\", \"MyAddon\", function(e)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide info for certain players\nhook.Add(\"ShouldDrawPlayerInfo\", \"PlayerInfoVisibility\", function(e)\nif not e:IsPlayer() then return false end\n    local char = e:getChar()\n    if not char then return false end\n        -- Hide info for hidden players\n        if char:getData(\"hidden\", false) then\n            return false\n            end\n        return true\n        end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex player info visibility system\nhook.Add(\"ShouldDrawPlayerInfo\", \"AdvancedPlayerInfo\", function(e)\nif not e:IsPlayer() then return false end\n    local ply = LocalPlayer()\n    local char = ply:getChar()\n    if not char then return false end\n        local targetChar = e:getChar()\n        if not targetChar then return false end\n            -- Don't draw info for self\n            if e == ply then return false end\n                -- Check distance\n                local distance = ply:GetPos():Distance(e:GetPos())\n                if distance &gt; 500 then return false end\n                    -- Check if target is hidden\n                    if targetChar:getData(\"hidden\", false) then\n                        return false\n                        end\n                    -- Check if target is in stealth mode\n                    if targetChar:getData(\"stealth\", false) then\n                        return false\n                        end\n                    -- Check faction visibility\n                    local plyFaction = char:getFaction()\n                    local targetFaction = targetChar:getFaction()\n                    if plyFaction == \"police\" and targetFaction == \"criminal\" then\n                        -- Police can always see criminals\n                        return true\n                    elseif plyFaction == \"criminal\" and targetFaction == \"police\" then\n                        -- Criminals can see police\n                        return true\n                    elseif plyFaction == targetFaction then\n                        -- Same faction can see each other\n                        return true\n                        end\n                    -- Check if player has recognition\n                    if targetChar:isRecognized(ply) then\n                        return true\n                        end\n                    -- Check if target is in same group\n                    local plyGroup = char:getData(\"group\")\n                    local targetGroup = targetChar:getData(\"group\")\n                    if plyGroup and plyGroup == targetGroup then\n                        return true\n                        end\n                    -- Check if target is in same team\n                    if ply:Team() == e:Team() then\n                        return true\n                        end\n                    return false\n                    end)\n</code></pre></p>"},{"location":"hooks/client/#shoulddrawwepselect","title":"ShouldDrawWepSelect","text":"<p>Purpose</p> <p>Called to determine if weapon selection should be drawn</p> <p>When Called</p> <p>When the system checks if weapon selection UI should be displayed</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to check for</li> </ul> <p>Returns</p> <ul> <li>boolean - Whether to draw weapon selection (true) or not (false)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Always show weapon selection\nhook.Add(\"ShouldDrawWepSelect\", \"MyAddon\", function(client)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional weapon selection\nhook.Add(\"ShouldDrawWepSelect\", \"ConditionalWepSelect\", function(client)\nlocal char = client:getChar()\nif char and char:getData(\"hideWeaponSelect\", false) then\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex weapon selection logic\nhook.Add(\"ShouldDrawWepSelect\", \"AdvancedWepSelect\", function(client)\n-- Check if player is in a vehicle\nif client:InVehicle() then\n    return false\n    end\n-- Check if player is typing\nif client:IsTyping() then\n    return false\n    end\n-- Check custom conditions\nlocal char = client:getChar()\nif char then\n    local faction = char:getFaction()\n    if faction == FACTION_CITIZEN then\n        return true\n    elseif faction == FACTION_POLICE then\n        return char:getData(\"showWeaponSelect\", true)\n        end\n    end\n-- Check admin status\nif client:IsAdmin() then\n    return true\n    end\nreturn false\nend)\n</code></pre></p>"},{"location":"hooks/client/#shouldhidebars","title":"ShouldHideBars","text":"<p>Purpose</p> <p>Determines if all bars should be hidden</p> <p>When Called</p> <p>When the bar system is about to render</p> <p>Returns</p> <ul> <li>boolean - True if bars should be hidden, false otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Never hide bars\nhook.Add(\"ShouldHideBars\", \"MyAddon\", function()\nreturn false\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide bars in certain situations\nhook.Add(\"ShouldHideBars\", \"BarHiding\", function()\nlocal ply = LocalPlayer()\n-- Hide bars when dead\nif not ply:Alive() then\n    return true\n    end\n-- Hide bars when in vehicle\nif ply:InVehicle() then\n    return true\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex bar hiding system\nhook.Add(\"ShouldHideBars\", \"AdvancedBarHiding\", function()\nlocal ply = LocalPlayer()\nlocal char = ply:getChar()\nif not char then return true end\n    -- Hide bars when dead\n    if not ply:Alive() then\n        return true\n        end\n    -- Hide bars when in vehicle\n    if ply:InVehicle() then\n        return true\n        end\n    -- Hide bars when in menu\n    if IsValid(lia.gui.menu) and lia.gui.menu:IsVisible() then\n        return true\n        end\n    -- Hide bars when in character creation\n    if IsValid(lia.gui.charCreate) and lia.gui.charCreate:IsVisible() then\n        return true\n        end\n    -- Hide bars when in inventory\n    if IsValid(lia.gui.inv1) and lia.gui.inv1:IsVisible() then\n        return true\n        end\n    -- Hide bars when in third person\n    if ply:GetViewEntity() ~= ply then\n        return true\n        end\n    -- Hide bars when in cinematic mode\n    if char:getData(\"cinematicMode\", false) then\n        return true\n        end\n    -- Hide bars when in spectator mode\n    if ply:GetObserverMode() ~= OBS_MODE_NONE then\n        return true\n        end\n    -- Hide bars when HUD is disabled\n    if not ply:ShouldDrawLocalPlayer() then\n        return true\n        end\n    -- Hide bars when in admin mode\n    if ply:IsAdmin() and ply:getData(\"adminMode\", false) then\n        return true\n        end\n    return false\n    end)\n</code></pre></p>"},{"location":"hooks/client/#shouldmenubuttonshow","title":"ShouldMenuButtonShow","text":"<p>Purpose</p> <p>Called to check if a menu button should be shown</p> <p>When Called</p> <p>When displaying menu buttons</p> <p>Parameters</p> <ul> <li><code>button</code> (string): The button identifier</li> </ul> <p>Returns</p> <ul> <li>boolean - True to show, false to hide</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Show all buttons\nhook.Add(\"ShouldMenuButtonShow\", \"MyAddon\", function(button)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide specific buttons\nhook.Add(\"ShouldMenuButtonShow\", \"HideButtons\", function(button)\nlocal hiddenButtons = {\"admin\", \"debug\"}\nreturn not table.HasValue(hiddenButtons, button)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex button visibility system\nhook.Add(\"ShouldMenuButtonShow\", \"AdvancedButtonVisibility\", function(button)\nlocal client = LocalPlayer()\nif not IsValid(client) then return false end\n    local char = client:getChar()\n    if not char then return false end\n        -- Check permissions\n        local permissions = {\n        [\"admin\"] = client:IsAdmin(),\n        [\"moderator\"] = client:IsAdmin() or client:IsSuperAdmin(),\n        [\"character\"] = true,\n        [\"inventory\"] = true,\n        [\"settings\"] = true\n        }\n        -- Check faction restrictions\n        local faction = char:getFaction()\n        if button == \"faction\" and faction == \"ghost\" then\n            return false\n            end\n        -- Check character level\n        local level = char:getData(\"level\", 1)\n        if button == \"advanced\" and level &lt; 10 then\n            return false\n            end\n        return permissions[button] or false\n        end)\n</code></pre></p>"},{"location":"hooks/client/#shouldplaydeathsound","title":"ShouldPlayDeathSound","text":"<p>Purpose</p> <p>Called to check if a death sound should be played</p> <p>When Called</p> <p>When a player dies</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who died</li> <li><code>deathSound</code> (string): The death sound to play</li> </ul> <p>Returns</p> <ul> <li>boolean - True to play, false to suppress</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Play all death sounds\nhook.Add(\"ShouldPlayDeathSound\", \"MyAddon\", function(client, deathSound)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Suppress specific sounds\nhook.Add(\"ShouldPlayDeathSound\", \"SuppressSounds\", function(client, deathSound)\nlocal suppressedSounds = {\"vo/npc/male01/pain01.wav\"}\nreturn not table.HasValue(suppressedSounds, deathSound)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex death sound system\nhook.Add(\"ShouldPlayDeathSound\", \"AdvancedDeathSound\", function(client, deathSound)\nif not IsValid(client) then return false end\n    local char = client:getChar()\n    if not char then return true end\n        -- Check if sounds are enabled\n        local soundEnabled = lia.config.get(\"deathSounds\", true)\n        if not soundEnabled then return false end\n            -- Check faction restrictions\n            local faction = char:getFaction()\n            if faction == \"ghost\" then\n                return false\n                end\n            -- Check death type\n            local deathType = char:getData(\"deathType\", \"normal\")\n            if deathType == \"silent\" then\n                return false\n                end\n            -- Check distance to other players\n            local pos = client:GetPos()\n            local nearbyPlayers = 0\n            for _, ply in ipairs(player.GetAll()) do\n                if ply ~= client and ply:GetPos():Distance(pos) &lt; 500 then\n                    nearbyPlayers = nearbyPlayers + 1\n                    end\n                end\n            -- Only play if other players are nearby\n            return nearbyPlayers &gt; 0\n            end)\n</code></pre></p>"},{"location":"hooks/client/#shouldplaypainsound","title":"ShouldPlayPainSound","text":"<p>Purpose</p> <p>Called to check if a pain sound should be played</p> <p>When Called</p> <p>When a player takes damage</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player taking damage</li> <li><code>painSound</code> (string): The pain sound to play</li> </ul> <p>Returns</p> <ul> <li>boolean - True to play, false to suppress</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Play all pain sounds\nhook.Add(\"ShouldPlayPainSound\", \"MyAddon\", function(client, painSound)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Suppress specific sounds\nhook.Add(\"ShouldPlayPainSound\", \"SuppressPainSounds\", function(client, painSound)\nlocal suppressedSounds = {\"vo/npc/male01/pain01.wav\"}\nreturn not table.HasValue(suppressedSounds, painSound)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex pain sound system\nhook.Add(\"ShouldPlayPainSound\", \"AdvancedPainSound\", function(client, painSound)\nif not IsValid(client) then return false end\n    local char = client:getChar()\n    if not char then return true end\n        -- Check if sounds are enabled\n        local soundEnabled = lia.config.get(\"painSounds\", true)\n        if not soundEnabled then return false end\n            -- Check faction restrictions\n            local faction = char:getFaction()\n            if faction == \"ghost\" then\n                return false\n                end\n            -- Check pain threshold\n            local health = client:Health()\n            local maxHealth = client:GetMaxHealth()\n            local healthPercent = health / maxHealth\n            if healthPercent &gt; 0.8 then\n                return false\n                end\n            -- Check damage type\n            local damageType = char:getData(\"lastDamageType\", \"generic\")\n            if damageType == \"silent\" then\n                return false\n                end\n            -- Check distance to other players\n            local pos = client:GetPos()\n            local nearbyPlayers = 0\n            for _, ply in ipairs(player.GetAll()) do\n                if ply ~= client and ply:GetPos():Distance(pos) &lt; 300 then\n                    nearbyPlayers = nearbyPlayers + 1\n                    end\n                end\n            -- Only play if other players are nearby\n            return nearbyPlayers &gt; 0\n            end)\n</code></pre></p>"},{"location":"hooks/client/#shouldrespawnscreenappear","title":"ShouldRespawnScreenAppear","text":"<p>Purpose</p> <p>Called to check if the respawn screen should appear</p> <p>When Called</p> <p>When a player dies</p> <p>Returns</p> <ul> <li>boolean - True to show respawn screen, false to hide</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Always show respawn screen\nhook.Add(\"ShouldRespawnScreenAppear\", \"MyAddon\", function()\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide respawn screen for specific factions\nhook.Add(\"ShouldRespawnScreenAppear\", \"HideForFactions\", function()\nlocal char = LocalPlayer():getChar()\nif not char then return true end\n    local faction = char:getFaction()\n    local hiddenFactions = {\"ghost\", \"spectator\"}\n    return not table.HasValue(hiddenFactions, faction)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex respawn screen system\nhook.Add(\"ShouldRespawnScreenAppear\", \"AdvancedRespawnScreen\", function()\nlocal client = LocalPlayer()\nif not IsValid(client) then return true end\n    local char = client:getChar()\n    if not char then return true end\n        -- Check if respawn screen is enabled\n        local respawnEnabled = lia.config.get(\"respawnScreen\", true)\n        if not respawnEnabled then return false end\n            -- Check faction restrictions\n            local faction = char:getFaction()\n            if faction == \"ghost\" then\n                return false\n                end\n            -- Check death type\n            local deathType = char:getData(\"deathType\", \"normal\")\n            if deathType == \"instant\" then\n                return false\n                end\n            -- Check if player has respawn tokens\n            local respawnTokens = char:getData(\"respawnTokens\", 0)\n            if respawnTokens &lt;= 0 then\n                return false\n                end\n            -- Check time restrictions\n            local lastDeath = char:getData(\"lastDeath\", 0)\n            local timeSinceDeath = CurTime() - lastDeath\n            if timeSinceDeath &lt; 5 then\n                return false\n                end\n            return true\n            end)\n</code></pre></p>"},{"location":"hooks/client/#shouldshowclassonscoreboard","title":"ShouldShowClassOnScoreboard","text":"<p>Purpose</p> <p>Called to check if a class should be shown on the scoreboard</p> <p>When Called</p> <p>When displaying the scoreboard</p> <p>Parameters</p> <ul> <li><code>clsData</code> (table): The class data</li> </ul> <p>Returns</p> <ul> <li>boolean - True to show, false to hide</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Show all classes\nhook.Add(\"ShouldShowClassOnScoreboard\", \"MyAddon\", function(clsData)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide specific classes\nhook.Add(\"ShouldShowClassOnScoreboard\", \"HideClasses\", function(clsData)\nlocal hiddenClasses = {\"admin\", \"debug\"}\nreturn not table.HasValue(hiddenClasses, clsData.uniqueID)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex class visibility system\nhook.Add(\"ShouldShowClassOnScoreboard\", \"AdvancedClassVisibility\", function(clsData)\nlocal client = LocalPlayer()\nif not IsValid(client) then return false end\n    local char = client:getChar()\n    if not char then return false end\n        -- Check if scoreboard is enabled\n        local scoreboardEnabled = lia.config.get(\"scoreboard\", true)\n        if not scoreboardEnabled then return false end\n            -- Check faction restrictions\n            local faction = char:getFaction()\n            if clsData.faction and clsData.faction ~= faction then\n                return false\n                end\n            -- Check level requirements\n            local level = char:getData(\"level\", 1)\n            if clsData.minLevel and level &lt; clsData.minLevel then\n                return false\n                end\n            -- Check permissions\n            if clsData.adminOnly and not client:IsAdmin() then\n                return false\n                end\n            -- Check if class is active\n            if clsData.disabled then\n                return false\n                end\n            return true\n            end)\n</code></pre></p>"},{"location":"hooks/client/#shouldshowfactiononscoreboard","title":"ShouldShowFactionOnScoreboard","text":"<p>Purpose</p> <p>Called to check if a faction should be shown on the scoreboard</p> <p>When Called</p> <p>When displaying the scoreboard</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player whose faction is being checked</li> </ul> <p>Returns</p> <ul> <li>boolean - True to show, false to hide</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Show all factions\nhook.Add(\"ShouldShowFactionOnScoreboard\", \"MyAddon\", function(ply)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide specific factions\nhook.Add(\"ShouldShowFactionOnScoreboard\", \"HideFactions\", function(ply)\nlocal char = ply:getChar()\nif not char then return false end\n    local faction = char:getFaction()\n    local hiddenFactions = {\"ghost\", \"spectator\"}\n    return not table.HasValue(hiddenFactions, faction)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex faction visibility system\nhook.Add(\"ShouldShowFactionOnScoreboard\", \"AdvancedFactionVisibility\", function(ply)\nif not IsValid(ply) then return false end\n    local char = ply:getChar()\n    if not char then return false end\n        local client = LocalPlayer()\n        if not IsValid(client) then return false end\n            -- Check if scoreboard is enabled\n            local scoreboardEnabled = lia.config.get(\"scoreboard\", true)\n            if not scoreboardEnabled then return false end\n                -- Check faction restrictions\n                local faction = char:getFaction()\n                if faction == \"ghost\" then\n                    return false\n                    end\n                -- Check if player is recognized\n                local clientChar = client:getChar()\n                if clientChar then\n                    local isRecognized = clientChar:isRecognized(ply)\n                    if not isRecognized then\n                        return false\n                        end\n                    end\n                -- Check distance\n                local distance = client:GetPos():Distance(ply:GetPos())\n                if distance &gt; 1000 then\n                    return false\n                    end\n                -- Check if faction is public\n                local factionData = lia.faction.list[faction]\n                if factionData and factionData.hidden then\n                    return false\n                    end\n                return true\n                end)\n</code></pre></p>"},{"location":"hooks/client/#shouldshowplayeronscoreboard","title":"ShouldShowPlayerOnScoreboard","text":"<p>Purpose</p> <p>Called to check if a player should be shown on the scoreboard</p> <p>When Called</p> <p>When displaying the scoreboard</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player to check</li> </ul> <p>Returns</p> <ul> <li>boolean - True to show, false to hide</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Show all players\nhook.Add(\"ShouldShowPlayerOnScoreboard\", \"MyAddon\", function(ply)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hide specific players\nhook.Add(\"ShouldShowPlayerOnScoreboard\", \"HidePlayers\", function(ply)\nlocal char = ply:getChar()\nif not char then return false end\n    local faction = char:getFaction()\n    local hiddenFactions = {\"ghost\", \"spectator\"}\n    return not table.HasValue(hiddenFactions, faction)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex player visibility system\nhook.Add(\"ShouldShowPlayerOnScoreboard\", \"AdvancedPlayerVisibility\", function(ply)\nif not IsValid(ply) then return false end\n    local char = ply:getChar()\n    if not char then return false end\n        local client = LocalPlayer()\n        if not IsValid(client) then return false end\n            -- Check if scoreboard is enabled\n            local scoreboardEnabled = lia.config.get(\"scoreboard\", true)\n            if not scoreboardEnabled then return false end\n                -- Check faction restrictions\n                local faction = char:getFaction()\n                if faction == \"ghost\" then\n                    return false\n                    end\n                -- Check if player is recognized\n                local clientChar = client:getChar()\n                if clientChar then\n                    local isRecognized = clientChar:isRecognized(ply)\n                    if not isRecognized then\n                        return false\n                        end\n                    end\n                -- Check distance\n                local distance = client:GetPos():Distance(ply:GetPos())\n                if distance &gt; 1000 then\n                    return false\n                    end\n                -- Check if player is online\n                if not ply:IsValid() or not ply:IsConnected() then\n                    return false\n                    end\n                -- Check if player is in same area\n                local area = char:getData(\"area\", \"unknown\")\n                local clientArea = clientChar and clientChar:getData(\"area\", \"unknown\") or \"unknown\"\n                if area ~= clientArea then\n                    return false\n                    end\n                return true\n                end)\n</code></pre></p>"},{"location":"hooks/client/#shouldspawnclientragdoll","title":"ShouldSpawnClientRagdoll","text":"<p>Purpose</p> <p>Called to check if a client ragdoll should be spawned</p> <p>When Called</p> <p>When a player dies</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who died</li> </ul> <p>Returns</p> <ul> <li>boolean - True to spawn, false to suppress</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Spawn all ragdolls\nhook.Add(\"ShouldSpawnClientRagdoll\", \"MyAddon\", function(client)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Suppress ragdolls for specific factions\nhook.Add(\"ShouldSpawnClientRagdoll\", \"SuppressRagdolls\", function(client)\nlocal char = client:getChar()\nif not char then return true end\n    local faction = char:getFaction()\n    local suppressedFactions = {\"ghost\", \"spectator\"}\n    return not table.HasValue(suppressedFactions, faction)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ragdoll spawning system\nhook.Add(\"ShouldSpawnClientRagdoll\", \"AdvancedRagdollSpawning\", function(client)\nif not IsValid(client) then return false end\n    local char = client:getChar()\n    if not char then return true end\n        -- Check if ragdolls are enabled\n        local ragdollsEnabled = lia.config.get(\"ragdolls\", true)\n        if not ragdollsEnabled then return false end\n            -- Check faction restrictions\n            local faction = char:getFaction()\n            if faction == \"ghost\" then\n                return false\n                end\n            -- Check death type\n            local deathType = char:getData(\"deathType\", \"normal\")\n            if deathType == \"disintegrate\" then\n                return false\n                end\n            -- Check if player has ragdoll tokens\n            local ragdollTokens = char:getData(\"ragdollTokens\", 0)\n            if ragdollTokens &lt;= 0 then\n                return false\n                end\n            -- Check performance\n            local ragdollCount = 0\n            for _, ent in ipairs(ents.FindByClass(\"prop_ragdoll\")) do\n                ragdollCount = ragdollCount + 1\n                end\n            if ragdollCount &gt; 10 then\n                return false\n                end\n            -- Check distance to other players\n            local pos = client:GetPos()\n            local nearbyPlayers = 0\n            for _, ply in ipairs(player.GetAll()) do\n                if ply ~= client and ply:GetPos():Distance(pos) &lt; 500 then\n                    nearbyPlayers = nearbyPlayers + 1\n                    end\n                end\n            -- Only spawn if other players are nearby\n            return nearbyPlayers &gt; 0\n            end)\n</code></pre></p>"},{"location":"hooks/client/#showplayeroptions","title":"ShowPlayerOptions","text":"<p>Purpose</p> <p>Called to show player options menu</p> <p>When Called</p> <p>When displaying player options</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player to show options for</li> <li><code>initialOpts</code> (table): Initial options table</li> </ul> <p>Returns</p> <ul> <li>table - Modified options table</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic options\nhook.Add(\"ShowPlayerOptions\", \"MyAddon\", function(ply, initialOpts)\ntable.insert(initialOpts, {\"Examine\", function() print(\"Examining \" .. ply:Name()) end})\nreturn initialOpts\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add faction-specific options\nhook.Add(\"ShowPlayerOptions\", \"FactionOptions\", function(ply, initialOpts)\nlocal char = ply:getChar()\nif not char then return initialOpts end\n    local faction = char:getFaction()\n    if faction == \"police\" then\n        table.insert(initialOpts, {\"Arrest\", function() print(\"Arresting \" .. ply:Name()) end})\n        end\n    return initialOpts\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex player options system\nhook.Add(\"ShowPlayerOptions\", \"AdvancedPlayerOptions\", function(ply, initialOpts)\nif not IsValid(ply) then return initialOpts end\n    local char = ply:getChar()\n    if not char then return initialOpts end\n        local client = LocalPlayer()\n        if not IsValid(client) then return initialOpts end\n            local clientChar = client:getChar()\n            if not clientChar then return initialOpts end\n                -- Check if player is recognized\n                local isRecognized = clientChar:isRecognized(ply)\n                if not isRecognized then\n                    table.insert(initialOpts, {\"Recognize\", function()\n                    net.Start(\"liaRecognizePlayer\")\n                    net.WriteEntity(ply)\n                    net.SendToServer()\n                    end})\n                    end\n                -- Check faction permissions\n                local faction = char:getFaction()\n                local clientFaction = clientChar:getFaction()\n                if clientFaction == \"police\" then\n                    table.insert(initialOpts, {\"Arrest\", function()\n                    net.Start(\"liaArrestPlayer\")\n                    net.WriteEntity(ply)\n                    net.SendToServer()\n                    end})\n                    table.insert(initialOpts, {\"Search\", function()\n                    net.Start(\"liaSearchPlayer\")\n                    net.WriteEntity(ply)\n                    net.SendToServer()\n                    end})\n                    end\n                if clientFaction == \"medic\" then\n                    table.insert(initialOpts, {\"Heal\", function()\n                    net.Start(\"liaHealPlayer\")\n                    net.WriteEntity(ply)\n                    net.SendToServer()\n                    end})\n                    end\n                -- Check admin permissions\n                if client:IsAdmin() then\n                    table.insert(initialOpts, {\"Admin Options\", function()\n                    local menu = DermaMenu()\n                    menu:AddOption(\"Kick\", function() ply:Kick(\"Kicked by admin\") end)\n                    menu:AddOption(\"Ban\", function() ply:Ban(0, \"Banned by admin\") end)\n                    menu:Open()\n                    end})\n                    end\n                return initialOpts\n                end)\n</code></pre></p>"},{"location":"hooks/client/#storageunlockprompt","title":"StorageUnlockPrompt","text":"<p>Purpose</p> <p>Called when storage unlock prompt is shown</p> <p>When Called</p> <p>When a player attempts to unlock a locked storage</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The storage entity being unlocked</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log unlock prompt\nhook.Add(\"StorageUnlockPrompt\", \"MyAddon\", function(entity)\nprint(\"Storage unlock prompt shown for \" .. tostring(entity))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Show custom unlock message\nhook.Add(\"StorageUnlockPrompt\", \"CustomMessage\", function(entity)\nlia.util.notify(\"This storage is locked. You need a key to open it.\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage unlock system\nhook.Add(\"StorageUnlockPrompt\", \"AdvancedStorageUnlock\", function(entity)\nif not IsValid(entity) then return end\n    local client = LocalPlayer()\n    if not IsValid(client) then return end\n        local char = client:getChar()\n        if not char then return end\n            -- Check if player has key\n            local inventory = char:getInv()\n            if inventory then\n                local hasKey = false\n                for _, item in pairs(inventory:getItems()) do\n                    if item.uniqueID == \"storage_key\" then\n                        hasKey = true\n                        break\n                        end\n                    end\n                if hasKey then\n                    lia.util.notify(\"You have a key for this storage. Press E to unlock.\")\n                else\n                    lia.util.notify(\"This storage is locked. You need a storage key to open it.\")\n                    end\n                end\n            -- Check storage type\n            local storageType = entity:getNetVar(\"storageType\", \"normal\")\n            if storageType == \"vault\" then\n                lia.util.notify(\"This is a vault. You need a vault key to open it.\")\n            elseif storageType == \"safe\" then\n                lia.util.notify(\"This is a safe. You need a safe key to open it.\")\n                end\n            -- Check if storage is owned\n            local owner = entity:getNetVar(\"owner\")\n            if owner and owner ~= char:getID() then\n                lia.util.notify(\"This storage belongs to someone else.\")\n                end\n            -- Show unlock options\n            local menu = DermaMenu()\n            menu:AddOption(\"Try to unlock\", function()\n            net.Start(\"liaStorageUnlock\")\n            net.WriteEntity(entity)\n            net.SendToServer()\n            end)\n            menu:AddOption(\"Cancel\", function() end)\n            menu:Open()\n            end)\n</code></pre></p>"},{"location":"hooks/client/#thirdpersontoggled","title":"ThirdPersonToggled","text":"<p>Purpose</p> <p>Called when third person is toggled</p> <p>When Called</p> <p>When third person view is enabled or disabled</p> <p>Parameters</p> <ul> <li><code>newValue</code> (boolean): The new third person state</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log third person toggle\nhook.Add(\"ThirdPersonToggled\", \"MyAddon\", function(newValue)\nprint(\"Third person \" .. (newValue and \"enabled\" or \"disabled\"))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Show notification\nhook.Add(\"ThirdPersonToggled\", \"NotifyToggle\", function(newValue)\nlia.util.notify(\"Third person \" .. (newValue and \"enabled\" or \"disabled\"))\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex third person system\nhook.Add(\"ThirdPersonToggled\", \"AdvancedThirdPerson\", function(newValue)\nlocal client = LocalPlayer()\nif not IsValid(client) then return end\n    -- Update UI\n    if IsValid(lia.gui.thirdPersonSettings) then\n        lia.gui.thirdPersonSettings:SetEnabled(newValue)\n        end\n    -- Save setting\n    lia.data.set(\"thirdPerson\", newValue)\n    -- Notify player\n    lia.util.notify(\"Third person \" .. (newValue and \"enabled\" or \"disabled\"), 3)\n    -- Update camera\n    if newValue then\n        client:SetViewEntity(client)\n    else\n        client:SetViewEntity(client)\n        end\n    -- Log the change\n    lia.log.write(\"third_person_toggle\", {\n    enabled = newValue,\n    timestamp = os.time()\n    })\n    -- Update character model visibility\n    local char = client:getChar()\n    if char then\n        char:setData(\"thirdPerson\", newValue)\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/client/#ticketframe","title":"TicketFrame","text":"<p>Purpose</p> <p>Called to create a ticket frame</p> <p>When Called</p> <p>When displaying a support ticket</p> <p>Parameters</p> <ul> <li><code>requester</code> (Player): The player who requested the ticket</li> <li><code>message</code> (string): The ticket message</li> <li><code>claimed</code> (boolean): Whether the ticket is claimed</li> </ul> <p>Returns</p> <ul> <li>Panel - The ticket frame panel</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create basic ticket frame\nhook.Add(\"TicketFrame\", \"MyAddon\", function(requester, message, claimed)\nlocal frame = vgui.Create(\"DFrame\")\nframe:SetSize(400, 300)\nframe:Center()\nframe:SetTitle(\"Support Ticket\")\nframe:MakePopup()\nreturn frame\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create styled ticket frame\nhook.Add(\"TicketFrame\", \"StyledTicket\", function(requester, message, claimed)\nlocal frame = vgui.Create(\"DFrame\")\nframe:SetSize(500, 400)\nframe:Center()\nframe:SetTitle(\"Support Ticket - \" .. (claimed and \"Claimed\" or \"Open\"))\nframe:MakePopup()\nlocal label = vgui.Create(\"DLabel\", frame)\nlabel:SetText(\"Requester: \" .. requester:Name())\nlabel:Dock(TOP)\nlocal text = vgui.Create(\"DTextEntry\", frame)\ntext:SetText(message)\ntext:SetMultiline(true)\ntext:Dock(FILL)\nreturn frame\nend)\n</code></pre></p> <p>High Complexity: <pre><code>    -- High: Complex ticket frame system\n    hook.Add(\"TicketFrame\", \"AdvancedTicketFrame\", function(requester, message, claimed)\n    local frame = vgui.Create(\"DFrame\")\n    frame:SetSize(600, 500)\n    frame:Center()\n    frame:SetTitle(\"Support Ticket - \" .. (claimed and \"Claimed\" or \"Open\"))\n    frame:MakePopup()\n    -- Header\n    local header = vgui.Create(\"DPanel\", frame)\n    header:Dock(TOP)\n    header:SetHeight(50)\n    local requesterLabel = vgui.Create(\"DLabel\", header)\n    requesterLabel:SetText(\"Requester: \" .. requester:Name())\n    requesterLabel:Dock(LEFT)\n    local statusLabel = vgui.Create(\"DLabel\", header)\n    statusLabel:SetText(\"Status: \" .. (claimed and \"Claimed\" or \"Open\"))\n    statusLabel:Dock(RIGHT)\n    -- Message area\n    local messageArea = vgui.Create(\"DTextEntry\", frame)\n    messageArea:SetText(message)\n    messageArea:SetMultiline(true)\n    messageArea:SetEditable(false)\n    messageArea:Dock(FILL)\n    -- Buttons\n    local buttonPanel = vgui.Create(\"DPanel\", frame)\n    buttonPanel:Dock(BOTTOM)\n    buttonPanel:SetHeight(40)\n    local claimButton = vgui.Create(\"DButton\", buttonPanel)\n    claimButton:SetText(\"Claim Ticket\")\n    claimButton:Dock(LEFT)\n    claimButton:SetWide(100)\n    claimButton.DoClick = function()\n    net.Start(\"liaClaimTicket\")\n    net.WriteEntity(requester)\n    net.SendToServer()\n    end\nlocal closeButton = vgui.Create(\"DButton\", buttonPanel)\ncloseButton:SetText(\"Close\")\ncloseButton:Dock(RIGHT)\ncloseButton:SetWide(100)\ncloseButton.DoClick = function()\nframe:Close()\nend\nreturn frame\nend)\n</code></pre></p>"},{"location":"hooks/client/#tooltipinitialize","title":"TooltipInitialize","text":"<p>Purpose</p> <p>Called to initialize a tooltip</p> <p>When Called</p> <p>When a tooltip is being created</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The tooltip panel</li> <li><code>panel</code> (Panel): The parent panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set basic tooltip properties\nhook.Add(\"TooltipInitialize\", \"MyAddon\", function(self, panel)\nself:SetText(\"Tooltip\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set tooltip based on panel\nhook.Add(\"TooltipInitialize\", \"PanelTooltip\", function(self, panel)\nif panel:GetClassName() == \"DButton\" then\n    self:SetText(\"Click me!\")\nelseif panel:GetClassName() == \"DTextEntry\" then\n    self:SetText(\"Enter text here\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex tooltip system\nhook.Add(\"TooltipInitialize\", \"AdvancedTooltip\", function(self, panel)\nif not IsValid(self) or not IsValid(panel) then return end\n    -- Set tooltip properties\n    self:SetText(\"\")\n    self:SetFont(\"DermaDefault\")\n    self:SetTextColor(Color(255, 255, 255))\n    -- Get panel information\n    local panelClass = panel:GetClassName()\n    local panelText = panel:GetText() or \"\"\n    -- Set tooltip based on panel type\n    if panelClass == \"DButton\" then\n        if panelText == \"Close\" then\n            self:SetText(\"Close this window\")\n        elseif panelText == \"Save\" then\n            self:SetText(\"Save your changes\")\n        else\n            self:SetText(\"Click to interact\")\n            end\n    elseif panelClass == \"DTextEntry\" then\n        self:SetText(\"Enter text in this field\")\n    elseif panelClass == \"DCheckBox\" then\n        self:SetText(\"Toggle this option\")\n    elseif panelClass == \"DComboBox\" then\n        self:SetText(\"Select an option from the dropdown\")\n        end\n    -- Set tooltip position\n    self:SetPos(panel:GetPos())\n    self:SetSize(200, 20)\n    -- Set tooltip delay\n    self:SetDelay(0.5)\n    end)\n</code></pre></p>"},{"location":"hooks/client/#tooltiplayout","title":"TooltipLayout","text":"<p>Purpose</p> <p>Called to layout a tooltip</p> <p>When Called</p> <p>When a tooltip needs to be laid out</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The tooltip panel</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set basic layout\nhook.Add(\"TooltipLayout\", \"MyAddon\", function(self)\nself:SizeToContents()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set layout with constraints\nhook.Add(\"TooltipLayout\", \"ConstrainedLayout\", function(self)\nself:SizeToContents()\nlocal w, h = self:GetSize()\nif w &gt; 300 then\n    self:SetWide(300)\n    end\nif h &gt; 100 then\n    self:SetTall(100)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex tooltip layout system\nhook.Add(\"TooltipLayout\", \"AdvancedTooltipLayout\", function(self)\nif not IsValid(self) then return end\n    -- Get text size\n    self:SizeToContents()\n    local w, h = self:GetSize()\n    local maxWidth = 400\n    local maxHeight = 200\n    -- Constrain width\n    if w &gt; maxWidth then\n        self:SetWide(maxWidth)\n        self:SetWrap(true)\n        end\n    -- Constrain height\n    if h &gt; maxHeight then\n        self:SetTall(maxHeight)\n        self:SetScrollable(true)\n        end\n    -- Position tooltip\n    local x, y = gui.MousePos()\n    local screenW, screenH = ScrW(), ScrH()\n    -- Adjust position if tooltip goes off screen\n    if x + w &gt; screenW then\n        x = screenW - w - 10\n        end\n    if y + h &gt; screenH then\n        y = screenH - h - 10\n        end\n    self:SetPos(x + 10, y + 10)\n    -- Set z position\n    self:SetZPos(1000)\n    -- Set background\n    self:SetBackgroundColor(Color(0, 0, 0, 200))\n    self:SetBorderColor(Color(100, 100, 100))\n    end)\n</code></pre></p>"},{"location":"hooks/client/#tooltippaint","title":"TooltipPaint","text":"<p>Purpose</p> <p>Called to paint a tooltip</p> <p>When Called</p> <p>When a tooltip is being painted</p> <p>Parameters</p> <ul> <li><code>self</code> (Panel): The tooltip panel</li> <li><code>w</code> (number): The width of the tooltip</li> <li><code>h</code> (number): The height of the tooltip</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw basic background\nhook.Add(\"TooltipPaint\", \"MyAddon\", function(self, w, h)\ndraw.RoundedBox(4, 0, 0, w, h, Color(0, 0, 0, 200))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw styled tooltip\nhook.Add(\"TooltipPaint\", \"StyledTooltip\", function(self, w, h)\n-- Background\ndraw.RoundedBox(4, 0, 0, w, h, Color(0, 0, 0, 200))\n-- Border\ndraw.RoundedBox(4, 0, 0, w, h, Color(100, 100, 100, 255))\n-- Text\ndraw.SimpleText(self:GetText(), \"DermaDefault\", w/2, h/2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex tooltip painting system\nhook.Add(\"TooltipPaint\", \"AdvancedTooltipPaint\", function(self, w, h)\nif not IsValid(self) then return end\n    -- Get tooltip data\n    local text = self:GetText() or \"\"\n    local textColor = self:GetTextColor() or Color(255, 255, 255)\n    local bgColor = self:GetBackgroundColor() or Color(0, 0, 0, 200)\n    local borderColor = self:GetBorderColor() or Color(100, 100, 100)\n    -- Draw background with gradient\n    local gradient = Material(\"gui/gradient_up\")\n    surface.SetMaterial(gradient)\n    surface.SetDrawColor(bgColor)\n    surface.DrawTexturedRect(0, 0, w, h)\n    -- Draw border\n    draw.RoundedBox(4, 0, 0, w, h, borderColor)\n    -- Draw inner background\n    draw.RoundedBox(4, 1, 1, w-2, h-2, Color(bgColor.r, bgColor.g, bgColor.b, bgColor.a * 0.8))\n    -- Draw text with shadow\n    local textX, textY = w/2, h/2\n    -- Shadow\n    draw.SimpleText(text, \"DermaDefault\", textX+1, textY+1, Color(0, 0, 0, 100), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)\n    -- Main text\n    draw.SimpleText(text, \"DermaDefault\", textX, textY, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)\n    -- Draw icon if available\n    local icon = self:GetIcon()\n    if icon then\n        surface.SetMaterial(icon)\n        surface.SetDrawColor(Color(255, 255, 255, 200))\n        surface.DrawTexturedRect(5, 5, 16, 16)\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/client/#tryviewmodel","title":"TryViewModel","text":"<p>Purpose</p> <p>Called to try to view a model</p> <p>When Called</p> <p>When attempting to view an entity model</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The entity to view</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log model view attempt\nhook.Add(\"TryViewModel\", \"MyAddon\", function(entity)\nprint(\"Trying to view model: \" .. tostring(entity))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check if entity is valid\nhook.Add(\"TryViewModel\", \"ValidateEntity\", function(entity)\nif IsValid(entity) then\n    local model = entity:GetModel()\n    if model and model ~= \"\" then\n        print(\"Viewing model: \" .. model)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex model viewing system\nhook.Add(\"TryViewModel\", \"AdvancedModelView\", function(entity)\nif not IsValid(entity) then return end\n    local client = LocalPlayer()\n    if not IsValid(client) then return end\n        -- Check if entity is viewable\n        local model = entity:GetModel()\n        if not model or model == \"\" then\n            client:ChatPrint(\"This entity has no model\")\n            return\n            end\n        -- Check distance\n        local distance = client:GetPos():Distance(entity:GetPos())\n        if distance &gt; 200 then\n            client:ChatPrint(\"You are too far away to view this model\")\n            return\n            end\n        -- Check if entity is owned\n        local owner = entity:getNetVar(\"owner\")\n        if owner then\n            local char = client:getChar()\n            if char and owner ~= char:getID() then\n                client:ChatPrint(\"This entity belongs to someone else\")\n                return\n                end\n            end\n        -- Create model view panel\n        local frame = vgui.Create(\"DFrame\")\n        frame:SetSize(400, 300)\n        frame:Center()\n        frame:SetTitle(\"Model Viewer - \" .. entity:GetClass())\n        frame:MakePopup()\n        local modelPanel = vgui.Create(\"DModelPanel\", frame)\n        modelPanel:Dock(FILL)\n        modelPanel:SetModel(model)\n        -- Set up model panel\n        local ent = modelPanel:GetEntity()\n        if ent then\n            ent:SetPos(Vector(0, 0, 0))\n            ent:SetAngles(Angle(0, 0, 0))\n            end\n        -- Add controls\n        local controlPanel = vgui.Create(\"DPanel\", frame)\n        controlPanel:Dock(BOTTOM)\n        controlPanel:SetHeight(50)\n        local rotateButton = vgui.Create(\"DButton\", controlPanel)\n        rotateButton:SetText(\"Rotate\")\n        rotateButton:Dock(LEFT)\n        rotateButton:SetWide(100)\n        rotateButton.DoClick = function()\n        if ent then\n            ent:SetAngles(ent:GetAngles() + Angle(0, 45, 0))\n            end\n        end\n    local closeButton = vgui.Create(\"DButton\", controlPanel)\n    closeButton:SetText(\"Close\")\n    closeButton:Dock(RIGHT)\n    closeButton:SetWide(100)\n    closeButton.DoClick = function()\n    frame:Close()\n    end\nend)\n</code></pre></p>"},{"location":"hooks/client/#vendorexited","title":"VendorExited","text":"<p>Purpose</p> <p>Called when a vendor is exited</p> <p>When Called</p> <p>When a player closes a vendor</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor exit\nhook.Add(\"VendorExited\", \"MyAddon\", function()\nprint(\"Vendor exited\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up vendor data\nhook.Add(\"VendorExited\", \"CleanupVendor\", function()\nlia.vendor.current = nil\nlia.vendor.cache = {}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor exit system\nhook.Add(\"VendorExited\", \"AdvancedVendorExit\", function()\nlocal client = LocalPlayer()\nif not IsValid(client) then return end\n    local char = client:getChar()\n    if not char then return end\n        -- Clean up vendor data\n        lia.vendor.current = nil\n        lia.vendor.cache = {}\n        -- Save vendor interaction data\n        local vendorData = char:getData(\"vendorData\", {})\n        vendorData.lastInteraction = os.time()\n        vendorData.totalInteractions = (vendorData.totalInteractions or 0) + 1\n        char:setData(\"vendorData\", vendorData)\n        -- Close vendor UI\n        if IsValid(lia.gui.vendor) then\n            lia.gui.vendor:Close()\n            end\n        -- Notify player\n        lia.util.notify(\"Vendor closed\", 2)\n        -- Log to database\n        lia.log.write(\"vendor_exit\", {\n        steamid = client:SteamID(),\n        timestamp = os.time()\n        })\n        -- Update character stats\n        local vendorStats = char:getData(\"vendorStats\", {})\n        vendorStats.exits = (vendorStats.exits or 0) + 1\n        char:setData(\"vendorStats\", vendorStats)\n        end)\n</code></pre></p>"},{"location":"hooks/client/#vendorsynchronized","title":"VendorSynchronized","text":"<p>Purpose</p> <p>Called when a vendor is synchronized</p> <p>When Called</p> <p>When vendor data is synced between client and server</p> <p>Parameters</p> <ul> <li><code>vendor</code> (Entity): The vendor entity</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor sync\nhook.Add(\"VendorSynchronized\", \"MyAddon\", function(vendor)\nprint(\"Vendor synchronized: \" .. tostring(vendor))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update vendor UI\nhook.Add(\"VendorSynchronized\", \"UpdateVendorUI\", function(vendor)\nif IsValid(lia.gui.vendor) and lia.gui.vendor.vendor == vendor then\n    lia.gui.vendor:Populate()\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor sync system\nhook.Add(\"VendorSynchronized\", \"AdvancedVendorSync\", function(vendor)\nif not IsValid(vendor) then return end\n    -- Update local vendor cache\n    local vendorID = vendor:EntIndex()\n    lia.vendor.cache = lia.vendor.cache or {}\n    lia.vendor.cache[vendorID] = {\n    name = vendor:getNetVar(\"name\", \"Vendor\"),\n    items = vendor:getNetVar(\"items\", {}),\n    money = vendor:getNetVar(\"money\", 0),\n    lastSync = CurTime()\n    }\n    -- Update UI if vendor panel is open\n    if IsValid(lia.gui.vendor) and lia.gui.vendor.vendor == vendor then\n        lia.gui.vendor:Populate()\n        lia.gui.vendor:UpdateMoney()\n        end\n    -- Notify player\n    local client = LocalPlayer()\n    if client:GetPos():Distance(vendor:GetPos()) &lt; 200 then\n        lia.util.notify(\"Vendor inventory updated\")\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/client/#voicetoggled","title":"VoiceToggled","text":"<p>Purpose</p> <p>Called when voice chat is toggled</p> <p>When Called</p> <p>When voice chat is enabled or disabled</p> <p>Parameters</p> <ul> <li><code>enabled</code> (boolean): Whether voice chat is enabled</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log voice toggle\nhook.Add(\"VoiceToggled\", \"MyAddon\", function(enabled)\nprint(\"Voice chat \" .. (enabled and \"enabled\" or \"disabled\"))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Show notification\nhook.Add(\"VoiceToggled\", \"NotifyVoiceToggle\", function(enabled)\nlia.util.notify(\"Voice chat \" .. (enabled and \"enabled\" or \"disabled\"))\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex voice toggle system\nhook.Add(\"VoiceToggled\", \"AdvancedVoiceToggle\", function(enabled)\n-- Update UI\nif IsValid(lia.gui.voiceSettings) then\n    lia.gui.voiceSettings:SetEnabled(enabled)\n    end\n-- Save setting\nlia.data.set(\"voiceEnabled\", enabled)\n-- Notify player\nlia.util.notify(\"Voice chat \" .. (enabled and \"enabled\" or \"disabled\"), 3)\n-- Update voice icon\nif IsValid(lia.gui.voiceIcon) then\n    lia.gui.voiceIcon:SetVisible(enabled)\n    end\n-- Log the change\nlia.log.write(\"voice_toggle\", {\nenabled = enabled,\ntimestamp = os.time()\n})\nend)\n</code></pre></p>"},{"location":"hooks/client/#weaponcyclesound","title":"WeaponCycleSound","text":"<p>Purpose</p> <p>Called to get the weapon cycle sound</p> <p>When Called</p> <p>When cycling through weapons</p> <p>Returns</p> <ul> <li>string - The sound path</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default sound\nhook.Add(\"WeaponCycleSound\", \"MyAddon\", function()\nreturn \"common/wpn_select.wav\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Return custom sound based on settings\nhook.Add(\"WeaponCycleSound\", \"CustomCycleSound\", function()\nlocal soundEnabled = lia.config.get(\"weaponSounds\", true)\nif not soundEnabled then return \"\" end\n    return \"common/wpn_select.wav\"\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex weapon cycle sound system\nhook.Add(\"WeaponCycleSound\", \"AdvancedCycleSound\", function()\nlocal client = LocalPlayer()\nif not IsValid(client) then return \"common/wpn_select.wav\" end\n    -- Check if sounds are enabled\n    local soundEnabled = lia.config.get(\"weaponSounds\", true)\n    if not soundEnabled then return \"\" end\n        -- Get character-specific sound\n        local char = client:getChar()\n        if char then\n            local faction = char:getFaction()\n            local factionSounds = {\n            [\"police\"] = \"hl1/fvox/blip.wav\",\n            [\"military\"] = \"buttons/button14.wav\",\n            [\"citizen\"] = \"common/wpn_select.wav\"\n            }\n            return factionSounds[faction] or \"common/wpn_select.wav\"\n            end\n        return \"common/wpn_select.wav\"\n        end)\n</code></pre></p>"},{"location":"hooks/client/#weaponselectsound","title":"WeaponSelectSound","text":"<p>Purpose</p> <p>Called to get the weapon select sound</p> <p>When Called</p> <p>When selecting a weapon</p> <p>Returns</p> <ul> <li>string - The sound path</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default sound\nhook.Add(\"WeaponSelectSound\", \"MyAddon\", function()\nreturn \"common/wpn_hudoff.wav\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Return custom sound based on settings\nhook.Add(\"WeaponSelectSound\", \"CustomSelectSound\", function()\nlocal soundEnabled = lia.config.get(\"weaponSounds\", true)\nif not soundEnabled then return \"\" end\n    return \"common/wpn_hudoff.wav\"\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex weapon select sound system\nhook.Add(\"WeaponSelectSound\", \"AdvancedSelectSound\", function()\nlocal client = LocalPlayer()\nif not IsValid(client) then return \"common/wpn_hudoff.wav\" end\n    -- Check if sounds are enabled\n    local soundEnabled = lia.config.get(\"weaponSounds\", true)\n    if not soundEnabled then return \"\" end\n        -- Get character-specific sound\n        local char = client:getChar()\n        if char then\n            local faction = char:getFaction()\n            local factionSounds = {\n            [\"police\"] = \"hl1/fvox/activated.wav\",\n            [\"military\"] = \"buttons/button15.wav\",\n            [\"citizen\"] = \"common/wpn_hudoff.wav\"\n            }\n            return factionSounds[faction] or \"common/wpn_hudoff.wav\"\n            end\n        return \"common/wpn_hudoff.wav\"\n        end)\n</code></pre></p>"},{"location":"hooks/client/#webimagedownloaded","title":"WebImageDownloaded","text":"<p>Purpose</p> <p>Called when a web image is downloaded</p> <p>When Called</p> <p>When an image from a URL is successfully downloaded</p> <p>Parameters</p> <ul> <li><code>url</code> (string): The URL of the image</li> <li><code>material</code> (Material): The downloaded material</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log image download\nhook.Add(\"WebImageDownloaded\", \"MyAddon\", function(url, material)\nprint(\"Image downloaded: \" .. url)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Cache downloaded images\nhook.Add(\"WebImageDownloaded\", \"CacheImages\", function(url, material)\nlia.webImage.cache = lia.webImage.cache or {}\nlia.webImage.cache[url] = material\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex web image system\nhook.Add(\"WebImageDownloaded\", \"AdvancedWebImage\", function(url, material)\n-- Cache the material\nlia.webImage.cache = lia.webImage.cache or {}\nlia.webImage.cache[url] = material\n-- Update any panels waiting for this image\nfor _, panel in ipairs(lia.webImage.waiting[url] or {}) do\n    if IsValid(panel) then\n        panel:SetMaterial(material)\n        panel:InvalidateLayout()\n        end\n    end\n-- Clear waiting list\nlia.webImage.waiting[url] = nil\n-- Log download\nlia.log.write(\"web_image_download\", {\nurl = url,\ntimestamp = os.time()\n})\n-- Notify completion\nhook.Run(\"OnWebImageReady\", url, material)\nend)\n</code></pre></p>"},{"location":"hooks/client/#websounddownloaded","title":"WebSoundDownloaded","text":"<p>Purpose</p> <p>Called when a web sound is downloaded</p> <p>When Called</p> <p>When a sound from a URL is successfully downloaded</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name of the sound</li> <li><code>path</code> (string): The path to the downloaded sound</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log sound download\nhook.Add(\"WebSoundDownloaded\", \"MyAddon\", function(name, path)\nprint(\"Sound downloaded: \" .. name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Cache downloaded sounds\nhook.Add(\"WebSoundDownloaded\", \"CacheSounds\", function(name, path)\nlia.webSound.cache = lia.webSound.cache or {}\nlia.webSound.cache[name] = path\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex web sound system\nhook.Add(\"WebSoundDownloaded\", \"AdvancedWebSound\", function(name, path)\n-- Cache the sound\nlia.webSound.cache = lia.webSound.cache or {}\nlia.webSound.cache[name] = path\n-- Update any sounds waiting for this file\nfor _, soundData in ipairs(lia.webSound.waiting[name] or {}) do\n    if soundData.callback then\n        soundData.callback(path)\n        end\n    end\n-- Clear waiting list\nlia.webSound.waiting[name] = nil\n-- Log download\nlia.log.write(\"web_sound_download\", {\nname = name,\npath = path,\ntimestamp = os.time()\n})\n-- Notify completion\nhook.Run(\"OnWebSoundReady\", name, path)\nend)\n</code></pre></p>"},{"location":"hooks/server/","title":"Server-Side Hooks","text":"<p>Server-side hook system for the Lilia framework.</p> <p>Overview</p> <p>Server-side hooks in the Lilia framework handle game logic, data persistence, player management, and other server-specific functionality. All server hooks follow the standard Garry's Mod hook system and can be overridden or extended by addons and modules.</p>"},{"location":"hooks/server/#addwarning","title":"AddWarning","text":"<p>Purpose</p> <p>Adds a warning to a character's record in the administration system</p> <p>When Called</p> <p>When an admin issues a warning to a player</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The character ID of the warned player</li> <li><code>warned</code> (string): The name of the warned player</li> <li><code>warnedSteamID</code> (string): The Steam ID of the warned player</li> <li><code>timestamp</code> (number): Unix timestamp when the warning was issued</li> <li><code>message</code> (string): The warning message/reason</li> <li><code>warner</code> (string): The name of the admin who issued the warning</li> <li><code>warnerSteamID</code> (string): The Steam ID of the admin who issued the warning</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a basic warning\nhook.Run(\"AddWarning\", charID, playerName, steamID, os.time(), \"Rule violation\", adminName, adminSteamID)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add warning with custom message\nlocal reason = \"Excessive RDM - 3 kills in 5 minutes\"\nlocal timestamp = os.time()\nhook.Run(\"AddWarning\", target:getChar():getID(), target:Nick(), target:SteamID(),\ntimestamp, reason, client:Nick(), client:SteamID())\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add warning with validation and logging\nhook.Add(\"AddWarning\", \"MyAddon\", function(charID, warned, warnedSteamID, timestamp, message, warner, warnerSteamID)\n-- Log the warning to a custom system\nprint(string.format(\"Warning issued: %s warned %s for: %s\", warner, warned, message))\n-- Send notification to other admins\nfor _, admin in ipairs(player.GetAll()) do\n    if admin:IsAdmin() then\n        admin:ChatPrint(string.format(\"[WARNING] %s warned %s: %s\", warner, warned, message))\n    end\nend\n-- Check for warning limits\nlocal warnings = hook.Run(\"GetWarnings\", charID)\nif #warnings &gt;= 3 then\n    -- Auto-kick after 3 warnings\n    local target = player.GetBySteamID(warnedSteamID)\n    if IsValid(target) then\n        target:Kick(\"Too many warnings\")\n    end\nend\nend)\n</code></pre></p>"},{"location":"hooks/server/#adjustcreationdata","title":"AdjustCreationData","text":"<p>Purpose</p> <p>Allows modification of character creation data before the character is created</p> <p>When Called</p> <p>During character creation process, before the character is saved to database</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player creating the character</li> <li><code>data</code> (table): The current character data being created</li> <li><code>newData</code> (table): Additional data to be merged with the character data</li> <li><code>originalData</code> (table): The original character data before any modifications</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add default money to new characters\nhook.Add(\"AdjustCreationData\", \"MyAddon\", function(client, data, newData, originalData)\ndata.money = data.money + 1000 -- Give extra starting money\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Modify character based on faction\nhook.Add(\"AdjustCreationData\", \"FactionBonuses\", function(client, data, newData, originalData)\nif data.faction == \"police\" then\n    data.money = data.money + 500 -- Police get extra money\n    data.desc = data.desc .. \"\\n\\n[Police Officer]\"\nelseif data.faction == \"citizen\" then\n    data.money = data.money + 200 -- Citizens get small bonus\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character creation system with validation\nhook.Add(\"AdjustCreationData\", \"AdvancedCreation\", function(client, data, newData, originalData)\n-- Validate character name\nif string.len(data.name) &lt; 3 then\n    data.name = data.name .. \" Jr.\"\nend\n-- Add faction-specific bonuses\nlocal factionBonuses = {\n[\"police\"] = {money = 1000, items = {\"weapon_pistol\"}},\n[\"medic\"] = {money = 800, items = {\"medkit\"}},\n[\"citizen\"] = {money = 200, items = {}}\n}\nlocal bonus = factionBonuses[data.faction]\nif bonus then\n    data.money = data.money + bonus.money\n    data.startingItems = data.startingItems or {}\n    for _, item in ipairs(bonus.items) do\n        table.insert(data.startingItems, item)\n    end\nend\n-- Add creation timestamp\ndata.creationTime = os.time()\ndata.creationIP = client:IPAddress()\nend)\n</code></pre></p>"},{"location":"hooks/server/#baginventoryready","title":"BagInventoryReady","text":"<p>Purpose</p> <p>Called when a bag item's inventory is ready and accessible</p> <p>When Called</p> <p>When a bag item's inventory is created or restored from database</p> <p>Parameters</p> <ul> <li><code>self</code> (Item): The bag item instance</li> <li><code>inventory</code> (Inventory): The inventory instance that was created/loaded</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log when bag inventory is ready\nhook.Add(\"BagInventoryReady\", \"MyAddon\", function(self, inventory)\nprint(\"Bag inventory ready for item: \" .. self.uniqueID)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add special items to bag inventory\nhook.Add(\"BagInventoryReady\", \"SpecialBags\", function(self, inventory)\nif self.uniqueID == \"magic_bag\" then\n    -- Add a magic item to the bag\n    local magicItem = lia.item.instance(\"magic_crystal\")\n    if magicItem then\n        inventory:add(magicItem)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex bag inventory system with validation\nhook.Add(\"BagInventoryReady\", \"AdvancedBags\", function(self, inventory)\nlocal char = self:getOwner()\nif not char then return end\n    -- Set up faction-specific bag contents\n    local faction = char:getFaction()\n    local bagContents = {\n    [\"police\"] = {\n    {item = \"handcuffs\", quantity = 1},\n    {item = \"police_badge\", quantity = 1},\n    {item = \"radio\", quantity = 1}\n    },\n    [\"medic\"] = {\n    {item = \"medkit\", quantity = 2},\n    {item = \"bandage\", quantity = 5},\n    {item = \"stethoscope\", quantity = 1}\n    },\n    [\"citizen\"] = {\n    {item = \"wallet\", quantity = 1},\n    {item = \"phone\", quantity = 1}\n    }\n    }\n    local contents = bagContents[faction]\n    if contents then\n        for _, content in ipairs(contents) do\n            local item = lia.item.instance(content.item)\n            if item then\n                item:setData(\"quantity\", content.quantity)\n                inventory:add(item)\n                end\n            end\n        end\n    -- Set up access rules based on character data\n    local charLevel = char:getData(\"level\", 1)\n    if charLevel &gt;= 10 then\n        -- High level characters get extra space\n        inventory:setData(\"maxWeight\", inventory:getData(\"maxWeight\", 100) * 1.5)\n        end\n    -- Log the bag creation\n    print(string.format(\"Bag inventory created for %s (Level %d, Faction: %s)\",\n    char:getName(), charLevel, faction))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#baginventoryremoved","title":"BagInventoryRemoved","text":"<p>Purpose</p> <p>Called when a bag item's inventory is removed or destroyed</p> <p>When Called</p> <p>When a bag item is deleted or its inventory is cleaned up</p> <p>Parameters</p> <ul> <li><code>self</code> (Item): The bag item instance</li> <li><code>inv</code> (Inventory): The inventory instance that was removed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log when bag inventory is removed\nhook.Add(\"BagInventoryRemoved\", \"MyAddon\", function(self, inv)\nprint(\"Bag inventory removed for item: \" .. self.uniqueID)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up custom data when bag is removed\nhook.Add(\"BagInventoryRemoved\", \"CleanupBags\", function(self, inv)\nlocal char = self:getOwner()\nif char then\n    char:setData(\"bagCount\", (char:getData(\"bagCount\", 0) - 1))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex cleanup with item recovery\nhook.Add(\"BagInventoryRemoved\", \"AdvancedCleanup\", function(self, inv)\nlocal char = self:getOwner()\nif not char then return end\n    -- Check if bag had valuable items\n    local valuableItems = {}\n    for _, item in pairs(inv:getItems()) do\n        if item.uniqueID == \"gold_bar\" or item.uniqueID == \"diamond\" then\n            table.insert(valuableItems, item)\n            end\n        end\n    -- Transfer valuable items to character inventory\n    if #valuableItems &gt; 0 then\n        local charInv = char:getInv()\n        for _, item in ipairs(valuableItems) do\n            charInv:add(item)\n            end\n        char:getPlayer():ChatPrint(\"Valuable items recovered from destroyed bag!\")\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#cancharbetransfered","title":"CanCharBeTransfered","text":"<p>Purpose</p> <p>Determines if a character can be transferred (alias for CanBeTransfered)</p> <p>When Called</p> <p>When attempting to transfer a character to another faction</p> <p>Parameters</p> <ul> <li><code>targetChar</code> (Character): The character being transferred</li> <li><code>faction</code> (string): The target faction name</li> <li><code>client</code> (Player): The player requesting the transfer</li> </ul> <p>Returns</p> <ul> <li>boolean - True if transfer is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Use same logic as CanBeTransfered\nhook.Add(\"CanCharBeTransfered\", \"MyAddon\", function(targetChar, faction, client)\nreturn hook.Run(\"CanBeTransfered\", targetChar, faction, client)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add additional character-specific checks\nhook.Add(\"CanCharBeTransfered\", \"CharChecks\", function(targetChar, faction, client)\n-- Check if character is banned\nif targetChar:isBanned() then\n    return false\n    end\n-- Check character age\nlocal charAge = targetChar:getData(\"age\", 18)\nif faction == \"police\" and charAge &lt; 21 then\n    return false -- Must be 21+ to be police\n    end\nreturn hook.Run(\"CanBeTransfered\", targetChar, faction, client)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced character transfer system\nhook.Add(\"CanCharBeTransfered\", \"AdvancedCharTransfers\", function(targetChar, faction, client)\nlocal charData = targetChar:getData()\n-- Check character reputation\nlocal reputation = charData.reputation or 0\nif faction == \"police\" and reputation &lt; 50 then\n    client:ChatPrint(\"You need a good reputation to join the police\")\n    return false\n    end\n-- Check for outstanding warrants\nif charData.warrants and #charData.warrants &gt; 0 then\n    client:ChatPrint(\"You have outstanding warrants and cannot transfer\")\n    return false\n    end\n-- Check faction capacity\nlocal factionCount = 0\nfor _, char in pairs(lia.char.getCharacters()) do\n    if char:getFaction() == faction then\n        factionCount = factionCount + 1\n        end\n    end\nlocal maxFactionMembers = {\n[\"police\"] = 10,\n[\"medic\"] = 5,\n[\"mayor\"] = 1\n}\nlocal maxMembers = maxFactionMembers[faction]\nif maxMembers and factionCount &gt;= maxMembers then\n    client:ChatPrint(\"That faction is full\")\n    return false\n    end\nreturn hook.Run(\"CanBeTransfered\", targetChar, faction, client)\nend)\n</code></pre></p>"},{"location":"hooks/server/#candeletechar","title":"CanDeleteChar","text":"<p>Purpose</p> <p>Determines if a character can be deleted</p> <p>When Called</p> <p>When a player attempts to delete a character</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player requesting the deletion</li> <li><code>character</code> (Character): The character to be deleted</li> </ul> <p>Returns</p> <ul> <li>boolean - True if deletion is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all character deletions\nhook.Add(\"CanDeleteChar\", \"MyAddon\", function(client, character)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Prevent deletion of high-level characters\nhook.Add(\"CanDeleteChar\", \"LevelRestrictions\", function(client, character)\nlocal charLevel = character:getData(\"level\", 1)\nif charLevel &gt; 10 then\n    client:ChatPrint(\"You cannot delete characters above level 10\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex deletion validation system\nhook.Add(\"CanDeleteChar\", \"AdvancedDeletion\", function(client, character)\nlocal charMoney = character:getMoney()\nlocal charLevel = character:getData(\"level\", 1)\n-- Check if character has valuable items\nlocal hasValuables = false\nlocal charInv = character:getInv()\nfor _, item in pairs(charInv:getItems()) do\n    if item.uniqueID == \"gold_bar\" or item.uniqueID == \"diamond\" then\n        hasValuables = true\n        break\n        end\n    end\nif hasValuables then\n    client:ChatPrint(\"You must remove all valuable items before deleting this character\")\n    return false\n    end\n-- Check if character is in a faction\nlocal faction = character:getFaction()\nif faction ~= \"citizen\" then\n    client:ChatPrint(\"You must leave your faction before deleting this character\")\n    return false\n    end\n-- Check cooldown\nlocal lastDeletion = client:getData(\"lastCharDeletion\", 0)\nif os.time() - lastDeletion &lt; 86400 then -- 24 hour cooldown\n    client:ChatPrint(\"You must wait 24 hours before deleting another character\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p>"},{"location":"hooks/server/#caninvitetoclass","title":"CanInviteToClass","text":"<p>Purpose</p> <p>Called to check if a player can invite another to a class</p> <p>When Called</p> <p>When attempting to invite a player to a class</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting the invite</li> <li><code>target</code> (Player): The player being invited</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow admins only\nhook.Add(\"CanInviteToClass\", \"MyAddon\", function(client, target)\nreturn client:IsAdmin()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction and rank\nhook.Add(\"CanInviteToClass\", \"ClassInviteCheck\", function(client, target)\nlocal char = client:getChar()\nif not char then return false end\n    local rank = char:getData(\"rank\", 0)\n    return rank &gt;= 3\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex class invitation system\nhook.Add(\"CanInviteToClass\", \"AdvancedClassInvite\", function(client, target)\nlocal char = client:getChar()\nlocal targetChar = target:getChar()\nif not char or not targetChar then return false end\n    -- Check if client has permission\n    local rank = char:getData(\"rank\", 0)\n    if rank &lt; 3 then\n        client:ChatPrint(\"You need rank 3 or higher to invite players\")\n        return false\n        end\n    -- Check if target is in same faction\n    if char:getFaction() ~= targetChar:getFaction() then\n        client:ChatPrint(\"Target must be in your faction\")\n        return false\n        end\n    -- Check cooldown\n    local lastInvite = char:getData(\"lastClassInvite\", 0)\n    if os.time() - lastInvite &lt; 60 then\n        client:ChatPrint(\"Please wait before inviting again\")\n        return false\n        end\n    char:setData(\"lastClassInvite\", os.time())\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#caninvitetofaction","title":"CanInviteToFaction","text":"<p>Purpose</p> <p>Called to check if a player can invite another to a faction</p> <p>When Called</p> <p>When attempting to invite a player to a faction</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting the invite</li> <li><code>target</code> (Player): The player being invited</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow admins only\nhook.Add(\"CanInviteToFaction\", \"MyAddon\", function(client, target)\nreturn client:IsAdmin()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction leader status\nhook.Add(\"CanInviteToFaction\", \"FactionInviteCheck\", function(client, target)\nlocal char = client:getChar()\nif not char then return false end\n    return char:getData(\"factionLeader\", false)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex faction invitation system\nhook.Add(\"CanInviteToFaction\", \"AdvancedFactionInvite\", function(client, target)\nlocal char = client:getChar()\nlocal targetChar = target:getChar()\nif not char or not targetChar then return false end\n    -- Check if client is faction leader\n    if not char:getData(\"factionLeader\", false) then\n        client:ChatPrint(\"Only faction leaders can invite players\")\n        return false\n        end\n    -- Check faction member limit\n    local faction = char:getFaction()\n    local memberCount = 0\n    for _, ply in ipairs(player.GetAll()) do\n        local plyChar = ply:getChar()\n        if plyChar and plyChar:getFaction() == faction then\n            memberCount = memberCount + 1\n            end\n        end\n    local maxMembers = 20\n    if memberCount &gt;= maxMembers then\n        client:ChatPrint(\"Faction is at maximum capacity\")\n        return false\n        end\n    -- Check cooldown\n    local lastInvite = char:getData(\"lastFactionInvite\", 0)\n    if os.time() - lastInvite &lt; 120 then\n        client:ChatPrint(\"Please wait before inviting again\")\n        return false\n        end\n    char:setData(\"lastFactionInvite\", os.time())\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canitembetransfered","title":"CanItemBeTransfered","text":"<p>Purpose</p> <p>Called to check if an item can be transferred between inventories</p> <p>When Called</p> <p>When attempting to move an item from one inventory to another</p> <p>Parameters</p> <ul> <li><code>item</code> (Item): The item being transferred</li> <li><code>fromInventory</code> (Inventory): The source inventory</li> <li><code>toInventory</code> (Inventory): The destination inventory</li> <li><code>client</code> (Player): The player performing the transfer</li> </ul> <p>Returns</p> <ul> <li>boolean - True if transfer is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all transfers\nhook.Add(\"CanItemBeTransfered\", \"MyAddon\", function(item, fromInventory, toInventory, client)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check inventory types\nhook.Add(\"CanItemBeTransfered\", \"InventoryTypeCheck\", function(item, fromInventory, toInventory, client)\n-- Prevent transferring to vendor inventories\nif toInventory.isVendor then\n    return false\n    end\n-- Check if item is transferable\nif item:getData(\"noTransfer\", false) then\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex transfer validation system\nhook.Add(\"CanItemBeTransfered\", \"AdvancedTransferValidation\", function(item, fromInventory, toInventory, client)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check if item is transferable\n    if item:getData(\"noTransfer\", false) then\n        client:ChatPrint(\"This item cannot be transferred\")\n        return false\n        end\n    -- Check inventory types\n    if toInventory.isVendor then\n        client:ChatPrint(\"Cannot transfer items to vendor inventories\")\n        return false\n        end\n    -- Check weight limits\n    local itemWeight = item:getWeight()\n    local currentWeight = toInventory:getWeight()\n    local maxWeight = toInventory:getMaxWeight()\n    if currentWeight + itemWeight &gt; maxWeight then\n        client:ChatPrint(\"Not enough space in destination inventory\")\n        return false\n        end\n    -- Check faction restrictions\n    local itemFaction = item:getData(\"faction\")\n    if itemFaction then\n        local charFaction = char:getFaction()\n        if itemFaction ~= charFaction then\n            client:ChatPrint(\"You cannot transfer faction-restricted items\")\n            return false\n            end\n        end\n    -- Check level requirements\n    local requiredLevel = item:getData(\"requiredLevel\", 1)\n    local charLevel = char:getData(\"level\", 1)\n    if charLevel &lt; requiredLevel then\n        client:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to transfer this item\")\n        return false\n        end\n    -- Check if item is equipped\n    if item:getData(\"equipped\", false) then\n        client:ChatPrint(\"Cannot transfer equipped items\")\n        return false\n        end\n    -- Check for special item restrictions\n    if item.uniqueID == \"weapon_pistol\" then\n        -- Special handling for weapons\n        if not char:hasFlags(\"w\") then\n            client:ChatPrint(\"You need weapon flags to transfer weapons\")\n            return false\n            end\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canperformvendoredit","title":"CanPerformVendorEdit","text":"<p>Purpose</p> <p>Called to check if a player can edit a vendor</p> <p>When Called</p> <p>When attempting to modify vendor settings</p> <p>Parameters</p> <ul> <li><code>self</code> (Entity): The vendor entity</li> <li><code>vendor</code> (table): The vendor data table</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow admins only\nhook.Add(\"CanPerformVendorEdit\", \"MyAddon\", function(self, vendor)\nlocal client = self.activator\nreturn client and client:IsAdmin()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check vendor ownership\nhook.Add(\"CanPerformVendorEdit\", \"VendorEditCheck\", function(self, vendor)\nlocal client = self.activator\nif not client then return false end\n    local char = client:getChar()\n    if not char then return false end\n        local owner = vendor.owner\n        return owner == char:getID() or client:IsAdmin()\n        end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor editing system\nhook.Add(\"CanPerformVendorEdit\", \"AdvancedVendorEdit\", function(self, vendor)\nlocal client = self.activator\nif not client then return false end\n    local char = client:getChar()\n    if not char then return false end\n        -- Admins can always edit\n        if client:IsAdmin() then return true end\n            -- Check vendor ownership\n            local owner = vendor.owner\n            if owner ~= char:getID() then\n                client:ChatPrint(\"You don't own this vendor\")\n                return false\n                end\n            -- Check edit cooldown\n            local lastEdit = char:getData(\"lastVendorEdit\", 0)\n            if os.time() - lastEdit &lt; 30 then\n                client:ChatPrint(\"Please wait before editing again\")\n                return false\n                end\n            char:setData(\"lastVendorEdit\", os.time())\n            return true\n            end)\n</code></pre></p>"},{"location":"hooks/server/#canpersistentity","title":"CanPersistEntity","text":"<p>Purpose</p> <p>Called to check if an entity can be persisted</p> <p>When Called</p> <p>When determining if an entity should be saved across map changes</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The entity to check</li> </ul> <p>Returns</p> <ul> <li>boolean - True to persist, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Persist all props\nhook.Add(\"CanPersistEntity\", \"MyAddon\", function(entity)\nreturn entity:GetClass() == \"prop_physics\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Persist specific entities\nhook.Add(\"CanPersistEntity\", \"EntityPersistCheck\", function(entity)\nlocal persistClasses = {\n[\"prop_physics\"] = true,\n[\"prop_dynamic\"] = true,\n[\"lia_item\"] = true\n}\nreturn persistClasses[entity:GetClass()] or false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entity persistence system\nhook.Add(\"CanPersistEntity\", \"AdvancedEntityPersist\", function(entity)\nif not IsValid(entity) then return false end\n    -- Check entity class\n    local persistClasses = {\n    [\"prop_physics\"] = true,\n    [\"prop_dynamic\"] = true,\n    [\"lia_item\"] = true,\n    [\"lia_vendor\"] = true\n    }\n    if not persistClasses[entity:GetClass()] then\n        return false\n        end\n    -- Check if entity is marked as temporary\n    if entity:getNetVar(\"temporary\", false) then\n        return false\n        end\n    -- Check entity age\n    local spawnTime = entity:getNetVar(\"spawnTime\", 0)\n    if os.time() - spawnTime &lt; 60 then\n        return false\n        end\n    -- Check entity owner\n    local owner = entity:getNetVar(\"owner\")\n    if owner then\n        local ownerPly = player.GetBySteamID(owner)\n        if not IsValid(ownerPly) then\n            return false\n            end\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canpickupmoney","title":"CanPickupMoney","text":"<p>Purpose</p> <p>Called to check if money can be picked up</p> <p>When Called</p> <p>When a player attempts to pick up money</p> <p>Parameters</p> <ul> <li><code>activator</code> (Player): The player trying to pick up money</li> <li><code>self</code> (Entity): The money entity</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all money pickup\nhook.Add(\"CanPickupMoney\", \"MyAddon\", function(activator, self)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check distance and amount\nhook.Add(\"CanPickupMoney\", \"CheckMoneyPickup\", function(activator, self)\nlocal distance = activator:GetPos():Distance(self:GetPos())\nif distance &gt; 100 then\n    return false\n    end\nlocal amount = self:getNetVar(\"amount\", 0)\nif amount &lt;= 0 then\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex money pickup system\nhook.Add(\"CanPickupMoney\", \"AdvancedMoneyPickup\", function(activator, self)\nif not IsValid(activator) or not IsValid(self) then return false end\n    local char = activator:getChar()\n    if not char then return false end\n        -- Check distance\n        local distance = activator:GetPos():Distance(self:GetPos())\n        if distance &gt; 100 then\n            activator:ChatPrint(\"You are too far away to pick up the money\")\n            return false\n            end\n        -- Check amount\n        local amount = self:getNetVar(\"amount\", 0)\n        if amount &lt;= 0 then\n            return false\n            end\n        -- Check if money is owned\n        local owner = self:getNetVar(\"owner\")\n        if owner and owner ~= char:getID() then\n            local ownerChar = lia.char.loaded[owner]\n            if ownerChar and ownerChar:getData(\"alive\", true) then\n                activator:ChatPrint(\"This money belongs to someone else\")\n                return false\n                end\n            end\n        -- Check faction restrictions\n        local faction = char:getFaction()\n        if faction == \"ghost\" then\n            return false\n            end\n        -- Check if player is tied\n        if char:getData(\"tied\", false) then\n            activator:ChatPrint(\"You cannot pick up money while tied\")\n            return false\n            end\n        return true\n        end)\n</code></pre></p>"},{"location":"hooks/server/#canplayeraccessdoor","title":"CanPlayerAccessDoor","text":"<p>Purpose</p> <p>Called to check if a player can access a door</p> <p>When Called</p> <p>When a player attempts to interact with a door</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting access</li> <li><code>self</code> (Entity): The door entity</li> <li><code>access</code> (number): The access level being checked</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all players\nhook.Add(\"CanPlayerAccessDoor\", \"MyAddon\", function(client, self, access)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check door ownership\nhook.Add(\"CanPlayerAccessDoor\", \"DoorAccessCheck\", function(client, self, access)\nlocal char = client:getChar()\nif not char then return false end\n    local owner = self:getNetVar(\"owner\")\n    return owner == char:getID()\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door access system\nhook.Add(\"CanPlayerAccessDoor\", \"AdvancedDoorAccess\", function(client, self, access)\nlocal char = client:getChar()\nif not char then return false end\n    -- Admins can access all doors\n    if client:IsAdmin() then return true end\n        -- Check door ownership\n        local owner = self:getNetVar(\"owner\")\n        if owner == char:getID() then return true end\n            -- Check faction access\n            local allowedFactions = self:getNetVar(\"allowedFactions\", {})\n            if table.HasValue(allowedFactions, char:getFaction()) then\n                return true\n                end\n            -- Check if player has key\n            local doorID = self:getNetVar(\"doorID\")\n            if doorID and char:getInv():hasItem(\"door_key_\" .. doorID) then\n                return true\n                end\n            return false\n            end)\n</code></pre></p>"},{"location":"hooks/server/#canplayeraccessvendor","title":"CanPlayerAccessVendor","text":"<p>Purpose</p> <p>Called to check if a player can access a vendor</p> <p>When Called</p> <p>When a player attempts to interact with a vendor</p> <p>Parameters</p> <ul> <li><code>activator</code> (Player): The player attempting access</li> <li><code>self</code> (Entity): The vendor entity</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all players\nhook.Add(\"CanPlayerAccessVendor\", \"MyAddon\", function(activator, self)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction restrictions\nhook.Add(\"CanPlayerAccessVendor\", \"VendorAccessCheck\", function(activator, self)\nlocal char = activator:getChar()\nif not char then return false end\n    local allowedFactions = self:getNetVar(\"allowedFactions\", {})\n    if #allowedFactions &gt; 0 and not table.HasValue(allowedFactions, char:getFaction()) then\n        return false\n        end\n    return true\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor access system\nhook.Add(\"CanPlayerAccessVendor\", \"AdvancedVendorAccess\", function(activator, self)\nlocal char = activator:getChar()\nif not char then return false end\n    -- Check faction restrictions\n    local allowedFactions = self:getNetVar(\"allowedFactions\", {})\n    if #allowedFactions &gt; 0 and not table.HasValue(allowedFactions, char:getFaction()) then\n        activator:ChatPrint(\"Your faction cannot access this vendor\")\n        return false\n        end\n    -- Check level requirements\n    local requiredLevel = self:getNetVar(\"requiredLevel\", 0)\n    local charLevel = char:getData(\"level\", 1)\n    if charLevel &lt; requiredLevel then\n        activator:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to access this vendor\")\n        return false\n        end\n    -- Check reputation\n    local requiredRep = self:getNetVar(\"requiredReputation\", 0)\n    local charRep = char:getData(\"reputation\", 0)\n    if charRep &lt; requiredRep then\n        activator:ChatPrint(\"You need \" .. requiredRep .. \" reputation to access this vendor\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerchooseweapon","title":"CanPlayerChooseWeapon","text":"<p>Purpose</p> <p>Called to check if a player can choose a weapon</p> <p>When Called</p> <p>When a player attempts to select a weapon</p> <p>Parameters</p> <ul> <li><code>weapon</code> (Weapon): The weapon being chosen</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all weapons\nhook.Add(\"CanPlayerChooseWeapon\", \"MyAddon\", function(weapon)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Restrict specific weapons\nhook.Add(\"CanPlayerChooseWeapon\", \"RestrictWeapons\", function(weapon)\nlocal restrictedWeapons = {\"weapon_crowbar\", \"weapon_stunstick\"}\nreturn not table.HasValue(restrictedWeapons, weapon:GetClass())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex weapon selection system\nhook.Add(\"CanPlayerChooseWeapon\", \"AdvancedWeaponSelection\", function(weapon)\nlocal client = weapon:GetOwner()\nif not IsValid(client) then return false end\n    local char = client:getChar()\n    if not char then return false end\n        -- Check faction restrictions\n        local faction = char:getFaction()\n        local weaponClass = weapon:GetClass()\n        if faction == \"police\" then\n            local policeWeapons = {\"weapon_pistol\", \"weapon_stunstick\"}\n            return table.HasValue(policeWeapons, weaponClass)\n        elseif faction == \"medic\" then\n            local medicWeapons = {\"weapon_medkit\", \"weapon_stunstick\"}\n            return table.HasValue(medicWeapons, weaponClass)\n            end\n        -- Check level requirements\n        local requiredLevel = weapon:getData(\"requiredLevel\", 1)\n        local charLevel = char:getData(\"level\", 1)\n        if charLevel &lt; requiredLevel then\n            return false\n            end\n        -- Check if weapon is broken\n        local durability = weapon:getData(\"durability\", 100)\n        if durability &lt;= 0 then\n            return false\n            end\n        return true\n        end)\n</code></pre></p>"},{"location":"hooks/server/#canplayercreatechar","title":"CanPlayerCreateChar","text":"<p>Purpose</p> <p>Determines if a player can create a new character</p> <p>When Called</p> <p>When a player attempts to create a new character</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player creating the character</li> <li><code>data</code> (table): The character creation data</li> </ul> <p>Returns</p> <ul> <li>boolean - True if creation is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all character creation\nhook.Add(\"CanPlayerCreateChar\", \"MyAddon\", function(client, data)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check character limit\nhook.Add(\"CanPlayerCreateChar\", \"CharLimit\", function(client, data)\nlocal charCount = #client.liaCharList or 0\nlocal maxChars = hook.Run(\"GetMaxPlayerChar\", client) or 5\nif charCount &gt;= maxChars then\n    client:ChatPrint(\"You have reached the maximum number of characters\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character creation validation\nhook.Add(\"CanPlayerCreateChar\", \"AdvancedCreation\", function(client, data)\n-- Check if player is banned\nif client:IsBanned() then\n    client:ChatPrint(\"You are banned and cannot create characters\")\n    return false\n    end\n-- Check character name validity\nlocal name = data.name or \"\"\nif string.len(name) &lt; 3 then\n    client:ChatPrint(\"Character name must be at least 3 characters long\")\n    return false\n    end\nif string.len(name) &gt; 32 then\n    client:ChatPrint(\"Character name must be less than 32 characters\")\n    return false\n    end\n-- Check for inappropriate names\nlocal bannedWords = {\"admin\", \"moderator\", \"staff\", \"test\"}\nfor _, word in ipairs(bannedWords) do\n    if string.find(string.lower(name), string.lower(word)) then\n        client:ChatPrint(\"That name is not allowed\")\n        return false\n        end\n    end\n-- Check faction restrictions\nlocal faction = data.faction\nlocal playerLevel = client:getData(\"level\", 1)\nlocal factionRequirements = {\n[\"police\"] = 5,\n[\"medic\"] = 3,\n[\"mayor\"] = 10\n}\nlocal requiredLevel = factionRequirements[faction]\nif requiredLevel and playerLevel &lt; requiredLevel then\n    client:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to create a \" .. faction .. \" character\")\n    return false\n    end\n-- Check character count\nlocal charCount = #client.liaCharList or 0\nlocal maxChars = hook.Run(\"GetMaxPlayerChar\", client) or 5\nif charCount &gt;= maxChars then\n    client:ChatPrint(\"You have reached the maximum number of characters\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p>"},{"location":"hooks/server/#canplayerdropitem","title":"CanPlayerDropItem","text":"<p>Purpose</p> <p>Called to check if a player can drop an item</p> <p>When Called</p> <p>When a player attempts to drop an item</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to drop the item</li> <li><code>item</code> (Item): The item being dropped</li> </ul> <p>Returns</p> <ul> <li>boolean - True if dropping is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all item drops\nhook.Add(\"CanPlayerDropItem\", \"MyAddon\", function(client, item)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check item restrictions\nhook.Add(\"CanPlayerDropItem\", \"ItemDropCheck\", function(client, item)\n-- Prevent dropping important items\nif item:getData(\"noDrop\", false) then\n    client:ChatPrint(\"This item cannot be dropped\")\n    return false\n    end\n-- Check if item is equipped\nif item:getData(\"equipped\", false) then\n    client:ChatPrint(\"Cannot drop equipped items\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item drop validation system\nhook.Add(\"CanPlayerDropItem\", \"AdvancedDropValidation\", function(client, item)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check if item is droppable\n    if item:getData(\"noDrop\", false) then\n        client:ChatPrint(\"This item cannot be dropped\")\n        return false\n        end\n    -- Check if item is equipped\n    if item:getData(\"equipped\", false) then\n        client:ChatPrint(\"Cannot drop equipped items\")\n        return false\n        end\n    -- Check faction restrictions\n    local itemFaction = item:getData(\"faction\")\n    if itemFaction then\n        local charFaction = char:getFaction()\n        if itemFaction ~= charFaction then\n            client:ChatPrint(\"You cannot drop faction-restricted items\")\n            return false\n            end\n        end\n    -- Check level requirements\n    local requiredLevel = item:getData(\"requiredLevel\", 1)\n    local charLevel = char:getData(\"level\", 1)\n    if charLevel &lt; requiredLevel then\n        client:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to drop this item\")\n        return false\n        end\n    -- Check for special item restrictions\n    if item.uniqueID == \"weapon_pistol\" then\n        -- Special handling for weapons\n        if not char:hasFlags(\"w\") then\n            client:ChatPrint(\"You need weapon flags to drop weapons\")\n            return false\n            end\n    elseif item.uniqueID == \"money\" then\n        -- Special handling for money\n        local amount = item:getData(\"amount\", 0)\n        if amount &gt; 1000 then\n            client:ChatPrint(\"Cannot drop more than $1000 at once\")\n            return false\n            end\n        end\n    -- Check location restrictions\n    local pos = client:GetPos()\n    local restrictedAreas = {\n    {pos = Vector(0, 0, 0), radius = 100}, -- Example restricted area\n    }\n    for _, area in ipairs(restrictedAreas) do\n        if pos:Distance(area.pos) &lt; area.radius then\n            client:ChatPrint(\"Cannot drop items in this area\")\n            return false\n            end\n        end\n    -- Check for admin restrictions\n    if char:getData(\"adminRestricted\", false) then\n        client:ChatPrint(\"You are restricted from dropping items\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerearnsalary","title":"CanPlayerEarnSalary","text":"<p>Purpose</p> <p>Called to check if a player can earn salary</p> <p>When Called</p> <p>When salary payment is being processed</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player being checked</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all players\nhook.Add(\"CanPlayerEarnSalary\", \"MyAddon\", function(client)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check if player is AFK\nhook.Add(\"CanPlayerEarnSalary\", \"SalaryAFKCheck\", function(client)\nlocal isAFK = client:getNetVar(\"afk\", false)\nif isAFK then\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex salary eligibility system\nhook.Add(\"CanPlayerEarnSalary\", \"AdvancedSalaryCheck\", function(client)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check if player is AFK\n    local isAFK = client:getNetVar(\"afk\", false)\n    if isAFK then\n        return false\n        end\n    -- Check minimum playtime\n    local playTime = client:GetUTimeTotalTime()\n    if playTime &lt; 3600 then\n        return false\n        end\n    -- Check faction requirements\n    local faction = char:getFaction()\n    if faction == \"citizen\" then\n        -- Citizens need to be employed\n        if not char:getData(\"employed\", false) then\n            return false\n            end\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerequipitem","title":"CanPlayerEquipItem","text":"<p>Purpose</p> <p>Called to check if a player can equip an item</p> <p>When Called</p> <p>When a player attempts to equip an item</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to equip the item</li> <li><code>item</code> (Item): The item being equipped</li> </ul> <p>Returns</p> <ul> <li>boolean - True if equipping is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all item equips\nhook.Add(\"CanPlayerEquipItem\", \"MyAddon\", function(client, item)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check item type restrictions\nhook.Add(\"CanPlayerEquipItem\", \"ItemEquipCheck\", function(client, item)\n-- Check if item is equippable\nif not item:getData(\"equippable\", false) then\n    client:ChatPrint(\"This item cannot be equipped\")\n    return false\n    end\n-- Check if already equipped\nif item:getData(\"equipped\", false) then\n    client:ChatPrint(\"This item is already equipped\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item equip validation system\nhook.Add(\"CanPlayerEquipItem\", \"AdvancedEquipValidation\", function(client, item)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check if item is equippable\n    if not item:getData(\"equippable\", false) then\n        client:ChatPrint(\"This item cannot be equipped\")\n        return false\n        end\n    -- Check if already equipped\n    if item:getData(\"equipped\", false) then\n        client:ChatPrint(\"This item is already equipped\")\n        return false\n        end\n    -- Check faction restrictions\n    local itemFaction = item:getData(\"faction\")\n    if itemFaction then\n        local charFaction = char:getFaction()\n        if itemFaction ~= charFaction then\n            client:ChatPrint(\"You cannot equip faction-restricted items\")\n            return false\n            end\n        end\n    -- Check level requirements\n    local requiredLevel = item:getData(\"requiredLevel\", 1)\n    local charLevel = char:getData(\"level\", 1)\n    if charLevel &lt; requiredLevel then\n        client:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to equip this item\")\n        return false\n        end\n    -- Check attribute requirements\n    local requiredAttribs = item:getData(\"requiredAttribs\", {})\n    for attr, value in pairs(requiredAttribs) do\n        local charAttr = char:getAttrib(attr, 0)\n        if charAttr &lt; value then\n            client:ChatPrint(\"You need \" .. attr .. \" \" .. value .. \" to equip this item\")\n            return false\n            end\n        end\n    -- Check for conflicting items\n    local itemType = item:getData(\"itemType\")\n    if itemType then\n        local equippedItems = char:getInv():getItems()\n        for _, equippedItem in pairs(equippedItems) do\n            if equippedItem:getData(\"equipped\", false) and equippedItem:getData(\"itemType\") == itemType then\n                client:ChatPrint(\"You already have a \" .. itemType .. \" equipped\")\n                return false\n                end\n            end\n        end\n    -- Check for special item restrictions\n    if item.uniqueID == \"weapon_pistol\" then\n        -- Special handling for weapons\n        if not char:hasFlags(\"w\") then\n            client:ChatPrint(\"You need weapon flags to equip weapons\")\n            return false\n            end\n    elseif item.uniqueID == \"armor_vest\" then\n        -- Special handling for armor\n        local charClass = char:getClass()\n        if charClass == \"citizen\" then\n            client:ChatPrint(\"Citizens cannot equip armor\")\n            return false\n            end\n        end\n    -- Check for admin restrictions\n    if char:getData(\"adminRestricted\", false) then\n        client:ChatPrint(\"You are restricted from equipping items\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerholdobject","title":"CanPlayerHoldObject","text":"<p>Purpose</p> <p>Called to check if a player can hold an object</p> <p>When Called</p> <p>When a player attempts to pick up or hold an entity</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to hold the object</li> <li><code>entity</code> (Entity): The entity being held</li> </ul> <p>Returns</p> <ul> <li>boolean - True if holding is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all object holding\nhook.Add(\"CanPlayerHoldObject\", \"MyAddon\", function(client, entity)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check entity type restrictions\nhook.Add(\"CanPlayerHoldObject\", \"ObjectHoldCheck\", function(client, entity)\n-- Prevent holding certain entity types\nif entity:GetClass() == \"prop_physics\" then\n    return true\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex object holding validation\nhook.Add(\"CanPlayerHoldObject\", \"AdvancedHoldValidation\", function(client, entity)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check entity validity\n    if not IsValid(entity) then return false end\n        -- Check entity class\n        local allowedClasses = {\"prop_physics\", \"prop_physics_multiplayer\"}\n        if not table.HasValue(allowedClasses, entity:GetClass()) then\n            return false\n            end\n        -- Check faction restrictions\n        local faction = char:getFaction()\n        if faction == \"prisoner\" then\n            client:ChatPrint(\"Prisoners cannot hold objects\")\n            return false\n            end\n        -- Check level requirements\n        local charLevel = char:getData(\"level\", 1)\n        if charLevel &lt; 5 then\n            client:ChatPrint(\"You need to be level 5 to hold objects\")\n            return false\n            end\n        return true\n        end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerinteractitem","title":"CanPlayerInteractItem","text":"<p>Purpose</p> <p>Called to check if a player can interact with an item</p> <p>When Called</p> <p>When a player attempts to perform an action on an item</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting the interaction</li> <li><code>action</code> (string): The action being performed</li> <li><code>self</code> (Item): The item being interacted with</li> <li><code>data</code> (table): Additional data for the interaction</li> </ul> <p>Returns</p> <ul> <li>boolean - True if interaction is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all item interactions\nhook.Add(\"CanPlayerInteractItem\", \"MyAddon\", function(client, action, self, data)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check action restrictions\nhook.Add(\"CanPlayerInteractItem\", \"ItemInteractionCheck\", function(client, action, self, data)\n-- Check if action is allowed\nif action == \"use\" then\n    return true\nelseif action == \"drop\" then\n    if self:getData(\"noDrop\", false) then\n        return false\n        end\n    return true\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item interaction validation\nhook.Add(\"CanPlayerInteractItem\", \"AdvancedInteractionValidation\", function(client, action, self, data)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check action restrictions\n    if action == \"use\" then\n        -- Check if item is usable\n        if self:getData(\"noUse\", false) then\n            client:ChatPrint(\"This item cannot be used\")\n            return false\n            end\n    elseif action == \"drop\" then\n        -- Check if item is droppable\n        if self:getData(\"noDrop\", false) then\n            client:ChatPrint(\"This item cannot be dropped\")\n            return false\n            end\n    elseif action == \"equip\" then\n        -- Check if item is equippable\n        if not self:getData(\"equippable\", false) then\n            client:ChatPrint(\"This item cannot be equipped\")\n            return false\n            end\n        end\n    -- Check faction restrictions\n    local itemFaction = self:getData(\"faction\")\n    if itemFaction then\n        local charFaction = char:getFaction()\n        if itemFaction ~= charFaction then\n            client:ChatPrint(\"You cannot interact with faction-restricted items\")\n            return false\n            end\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerjoinclass","title":"CanPlayerJoinClass","text":"<p>Purpose</p> <p>Called to check if a player can join a class</p> <p>When Called</p> <p>When a player attempts to join a specific class</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to join the class</li> <li><code>class</code> (number): The class ID being joined</li> <li><code>info</code> (table): Additional class information</li> </ul> <p>Returns</p> <ul> <li>boolean - True if joining is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all class joins\nhook.Add(\"CanPlayerJoinClass\", \"MyAddon\", function(client, class, info)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction requirements\nhook.Add(\"CanPlayerJoinClass\", \"ClassJoinCheck\", function(client, class, info)\nlocal char = client:getChar()\nif not char then return false end\n    local faction = char:getFaction()\n    if faction == info.faction then\n        return true\n        end\n    return false\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex class join validation\nhook.Add(\"CanPlayerJoinClass\", \"AdvancedClassJoin\", function(client, class, info)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check faction requirements\n    if info.faction and char:getFaction() ~= info.faction then\n        client:ChatPrint(\"You must be in the \" .. info.faction .. \" faction to join this class\")\n        return false\n        end\n    -- Check level requirements\n    if info.level and char:getData(\"level\", 1) &lt; info.level then\n        client:ChatPrint(\"You need to be level \" .. info.level .. \" to join this class\")\n        return false\n        end\n    -- Check flag requirements\n    if info.flags and not char:hasFlags(info.flags) then\n        client:ChatPrint(\"You don't have the required flags to join this class\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerknock","title":"CanPlayerKnock","text":"<p>Purpose</p> <p>Called to check if a player can knock on doors</p> <p>When Called</p> <p>When a player attempts to knock on a door</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to knock</li> </ul> <p>Returns</p> <ul> <li>boolean - True if knocking is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all knocking\nhook.Add(\"CanPlayerKnock\", \"MyAddon\", function(client)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check character status\nhook.Add(\"CanPlayerKnock\", \"KnockCheck\", function(client)\nlocal char = client:getChar()\nif not char then return false end\n    if char:getData(\"unconscious\", false) then\n        return false\n        end\n    return true\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex knock validation\nhook.Add(\"CanPlayerKnock\", \"AdvancedKnockValidation\", function(client)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check if player is unconscious\n    if char:getData(\"unconscious\", false) then\n        client:ChatPrint(\"You cannot knock while unconscious\")\n        return false\n        end\n    -- Check if player is gagged\n    if char:getData(\"gagged\", false) then\n        client:ChatPrint(\"You cannot knock while gagged\")\n        return false\n        end\n    -- Check knock cooldown\n    local lastKnock = char:getData(\"lastKnock\", 0)\n    if os.time() - lastKnock &lt; 2 then\n        client:ChatPrint(\"Please wait before knocking again\")\n        return false\n        end\n    char:setData(\"lastKnock\", os.time())\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerlock","title":"CanPlayerLock","text":"<p>Purpose</p> <p>Called to check if a player can lock a door</p> <p>When Called</p> <p>When a player attempts to lock a door</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to lock the door</li> <li><code>door</code> (Entity): The door entity being locked</li> </ul> <p>Returns</p> <ul> <li>boolean - True if locking is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all door locking\nhook.Add(\"CanPlayerLock\", \"MyAddon\", function(client, door)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check door ownership\nhook.Add(\"CanPlayerLock\", \"DoorLockCheck\", function(client, door)\nlocal owner = door:getNetVar(\"owner\")\nif owner == client:SteamID() then\n    return true\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door lock validation\nhook.Add(\"CanPlayerLock\", \"AdvancedDoorLock\", function(client, door)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check door ownership\n    local owner = door:getNetVar(\"owner\")\n    if owner and owner ~= client:SteamID() then\n        client:ChatPrint(\"You don't own this door\")\n        return false\n        end\n    -- Check if door is lockable\n    if door:getNetVar(\"noLock\", false) then\n        client:ChatPrint(\"This door cannot be locked\")\n        return false\n        end\n    -- Check faction permissions\n    local doorFaction = door:getNetVar(\"faction\")\n    if doorFaction and char:getFaction() ~= doorFaction then\n        client:ChatPrint(\"You don't have permission to lock this door\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayermodifyconfig","title":"CanPlayerModifyConfig","text":"<p>Purpose</p> <p>Called to check if a player can modify configuration</p> <p>When Called</p> <p>When a player attempts to change a config value</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to modify config</li> <li><code>key</code> (string): The configuration key being modified</li> </ul> <p>Returns</p> <ul> <li>boolean - True if modification is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Only allow admins\nhook.Add(\"CanPlayerModifyConfig\", \"MyAddon\", function(client, key)\nreturn client:IsAdmin()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check specific config permissions\nhook.Add(\"CanPlayerModifyConfig\", \"ConfigModCheck\", function(client, key)\nif client:IsSuperAdmin() then\n    return true\nelseif client:IsAdmin() and key ~= \"serverPassword\" then\n    return true\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex config modification validation\nhook.Add(\"CanPlayerModifyConfig\", \"AdvancedConfigMod\", function(client, key)\n-- Super admins can modify anything\nif client:IsSuperAdmin() then\n    return true\n    end\n-- Regular admins have limited access\nif client:IsAdmin() then\n    local restrictedKeys = {\"serverPassword\", \"rconPassword\", \"adminFlags\"}\n    if table.HasValue(restrictedKeys, key) then\n        client:ChatPrint(\"You don't have permission to modify this config\")\n        return false\n        end\n    return true\n    end\n-- Check custom permissions\nlocal char = client:getChar()\nif char and char:hasFlags(\"c\") then\n    return true\n    end\nclient:ChatPrint(\"You don't have permission to modify config\")\nreturn false\nend)\n</code></pre></p>"},{"location":"hooks/server/#canplayeropenscoreboard","title":"CanPlayerOpenScoreboard","text":"<p>Purpose</p> <p>Called to check if a player can open the scoreboard</p> <p>When Called</p> <p>When a player attempts to open the scoreboard</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to open the scoreboard</li> </ul> <p>Returns</p> <ul> <li>boolean - True if opening is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all scoreboard access\nhook.Add(\"CanPlayerOpenScoreboard\", \"MyAddon\", function(client)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check character status\nhook.Add(\"CanPlayerOpenScoreboard\", \"ScoreboardCheck\", function(client)\nlocal char = client:getChar()\nif not char then return false end\n    if char:getData(\"unconscious\", false) then\n        return false\n        end\n    return true\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex scoreboard access validation\nhook.Add(\"CanPlayerOpenScoreboard\", \"AdvancedScoreboardAccess\", function(client)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check if player is unconscious\n    if char:getData(\"unconscious\", false) then\n        return false\n        end\n    -- Check faction restrictions\n    local faction = char:getFaction()\n    if faction == \"prisoner\" then\n        return false\n        end\n    -- Check level requirements\n    if char:getData(\"level\", 1) &lt; 1 then\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerrotateitem","title":"CanPlayerRotateItem","text":"<p>Purpose</p> <p>Called to check if a player can rotate an item in inventory</p> <p>When Called</p> <p>When a player attempts to rotate an item</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to rotate the item</li> <li><code>item</code> (Item): The item being rotated</li> </ul> <p>Returns</p> <ul> <li>boolean - True if rotation is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all item rotation\nhook.Add(\"CanPlayerRotateItem\", \"MyAddon\", function(client, item)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check item properties\nhook.Add(\"CanPlayerRotateItem\", \"RotateCheck\", function(client, item)\n-- Check if item is rotatable\nif item:getData(\"noRotate\", false) then\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item rotation validation\nhook.Add(\"CanPlayerRotateItem\", \"AdvancedRotation\", function(client, item)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check if item is rotatable\n    if item:getData(\"noRotate\", false) then\n        client:ChatPrint(\"This item cannot be rotated\")\n        return false\n        end\n    -- Check if item is equipped\n    if item:getData(\"equipped\", false) then\n        client:ChatPrint(\"Cannot rotate equipped items\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerseelogcategory","title":"CanPlayerSeeLogCategory","text":"<p>Purpose</p> <p>Called to check if a player can see a log category</p> <p>When Called</p> <p>When determining which log categories a player can view</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player checking log access</li> <li><code>k</code> (string): The log category key</li> </ul> <p>Returns</p> <ul> <li>boolean - True if viewing is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow admins to see all logs\nhook.Add(\"CanPlayerSeeLogCategory\", \"MyAddon\", function(client, k)\nreturn client:IsAdmin()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Different permissions for different categories\nhook.Add(\"CanPlayerSeeLogCategory\", \"LogCategoryCheck\", function(client, k)\nif client:IsSuperAdmin() then\n    return true\nelseif client:IsAdmin() and k ~= \"admin\" then\n    return true\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex log category access control\nhook.Add(\"CanPlayerSeeLogCategory\", \"AdvancedLogAccess\", function(client, k)\n-- Super admins see everything\nif client:IsSuperAdmin() then\n    return true\n    end\n-- Regular admins have limited access\nif client:IsAdmin() then\n    local restrictedCategories = {\"admin\", \"system\", \"security\"}\n    if table.HasValue(restrictedCategories, k) then\n        return false\n        end\n    return true\n    end\n-- Check custom permissions\nlocal char = client:getChar()\nif char and char:hasFlags(\"l\") then\n    return true\n    end\nreturn false\nend)\n</code></pre></p>"},{"location":"hooks/server/#canplayerspawnstorage","title":"CanPlayerSpawnStorage","text":"<p>Purpose</p> <p>Called to check if a player can spawn storage entities</p> <p>When Called</p> <p>When a player attempts to spawn a storage container</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to spawn storage</li> <li><code>entity</code> (Entity): The storage entity being spawned</li> <li><code>info</code> (table): Information about the storage entity</li> </ul> <p>Returns</p> <ul> <li>boolean - True if spawning is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all storage spawning\nhook.Add(\"CanPlayerSpawnStorage\", \"MyAddon\", function(client, entity, info)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction permissions\nhook.Add(\"CanPlayerSpawnStorage\", \"StorageSpawnCheck\", function(client, entity, info)\nlocal char = client:getChar()\nif not char then return false end\n    if char:hasFlags(\"s\") then\n        return true\n        end\n    return false\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage spawn validation\nhook.Add(\"CanPlayerSpawnStorage\", \"AdvancedStorageSpawn\", function(client, entity, info)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check storage flags\n    if not char:hasFlags(\"s\") then\n        client:ChatPrint(\"You need storage flags to spawn storage\")\n        return false\n        end\n    -- Check faction restrictions\n    if info.faction and char:getFaction() ~= info.faction then\n        client:ChatPrint(\"You cannot spawn this faction's storage\")\n        return false\n        end\n    -- Check level requirements\n    if info.level and char:getData(\"level\", 1) &lt; info.level then\n        client:ChatPrint(\"You need to be level \" .. info.level .. \" to spawn this storage\")\n        return false\n        end\n    -- Check storage limit\n    local storageCount = char:getData(\"storageCount\", 0)\n    if storageCount &gt;= 5 then\n        client:ChatPrint(\"You have reached the maximum storage limit\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerswitchchar","title":"CanPlayerSwitchChar","text":"<p>Purpose</p> <p>Called to check if a player can switch characters</p> <p>When Called</p> <p>When a player attempts to switch from one character to another</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to switch</li> <li><code>currentChar</code> (Character): The current character</li> <li><code>character</code> (Character): The character being switched to</li> </ul> <p>Returns</p> <ul> <li>boolean - True if switching is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all character switching\nhook.Add(\"CanPlayerSwitchChar\", \"MyAddon\", function(client, currentChar, character)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check switch cooldown\nhook.Add(\"CanPlayerSwitchChar\", \"SwitchCooldown\", function(client, currentChar, character)\nlocal lastSwitch = currentChar:getData(\"lastSwitch\", 0)\nif os.time() - lastSwitch &lt; 300 then -- 5 minute cooldown\n    client:ChatPrint(\"Please wait before switching characters\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character switch validation\nhook.Add(\"CanPlayerSwitchChar\", \"AdvancedCharSwitch\", function(client, currentChar, character)\n-- Check switch cooldown\nlocal lastSwitch = currentChar:getData(\"lastSwitch\", 0)\nif os.time() - lastSwitch &lt; 300 then\n    client:ChatPrint(\"Please wait \" .. (300 - (os.time() - lastSwitch)) .. \" seconds before switching\")\n    return false\n    end\n-- Check if current character is in combat\nif currentChar:getData(\"inCombat\", false) then\n    client:ChatPrint(\"You cannot switch characters while in combat\")\n    return false\n    end\n-- Check if current character is unconscious\nif currentChar:getData(\"unconscious\", false) then\n    client:ChatPrint(\"You cannot switch characters while unconscious\")\n    return false\n    end\n-- Check faction switch limits\nif currentChar:getFaction() ~= character:getFaction() then\n    local factionSwitches = currentChar:getData(\"factionSwitches\", 0)\n    if factionSwitches &gt;= 3 then\n        client:ChatPrint(\"You have reached the maximum faction switch limit\")\n        return false\n        end\n    currentChar:setData(\"factionSwitches\", factionSwitches + 1)\n    end\n-- Update last switch time\ncurrentChar:setData(\"lastSwitch\", os.time())\nreturn true\nend)\n</code></pre></p>"},{"location":"hooks/server/#canplayertakeitem","title":"CanPlayerTakeItem","text":"<p>Purpose</p> <p>Called to check if a player can take an item</p> <p>When Called</p> <p>When a player attempts to take an item from the ground or another source</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to take the item</li> <li><code>item</code> (Item): The item being taken</li> </ul> <p>Returns</p> <ul> <li>boolean - True if taking is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all item takes\nhook.Add(\"CanPlayerTakeItem\", \"MyAddon\", function(client, item)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check item restrictions\nhook.Add(\"CanPlayerTakeItem\", \"ItemTakeCheck\", function(client, item)\n-- Check if item is takeable\nif item:getData(\"noTake\", false) then\n    client:ChatPrint(\"This item cannot be taken\")\n    return false\n    end\n-- Check if item is owned by someone else\nlocal owner = item:getData(\"owner\")\nif owner and owner ~= client:SteamID() then\n    client:ChatPrint(\"This item belongs to someone else\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item take validation system\nhook.Add(\"CanPlayerTakeItem\", \"AdvancedTakeValidation\", function(client, item)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check if item is takeable\n    if item:getData(\"noTake\", false) then\n        client:ChatPrint(\"This item cannot be taken\")\n        return false\n        end\n    -- Check if item is owned by someone else\n    local owner = item:getData(\"owner\")\n    if owner and owner ~= client:SteamID() then\n        client:ChatPrint(\"This item belongs to someone else\")\n        return false\n        end\n    -- Check faction restrictions\n    local itemFaction = item:getData(\"faction\")\n    if itemFaction then\n        local charFaction = char:getFaction()\n        if itemFaction ~= charFaction then\n            client:ChatPrint(\"You cannot take faction-restricted items\")\n            return false\n            end\n        end\n    -- Check level requirements\n    local requiredLevel = item:getData(\"requiredLevel\", 1)\n    local charLevel = char:getData(\"level\", 1)\n    if charLevel &lt; requiredLevel then\n        client:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to take this item\")\n        return false\n        end\n    -- Check weight limits\n    local itemWeight = item:getWeight()\n    local inventory = char:getInv()\n    local currentWeight = inventory:getWeight()\n    local maxWeight = inventory:getMaxWeight()\n    if currentWeight + itemWeight &gt; maxWeight then\n        client:ChatPrint(\"Not enough space in your inventory\")\n        return false\n        end\n    -- Check for special item restrictions\n    if item.uniqueID == \"weapon_pistol\" then\n        -- Special handling for weapons\n        if not char:hasFlags(\"w\") then\n            client:ChatPrint(\"You need weapon flags to take weapons\")\n            return false\n            end\n    elseif item.uniqueID == \"money\" then\n        -- Special handling for money\n        local amount = item:getData(\"amount\", 0)\n        if amount &gt; 10000 then\n            client:ChatPrint(\"Cannot take more than $10,000 at once\")\n            return false\n            end\n        end\n    -- Check location restrictions\n    local pos = client:GetPos()\n    local itemPos = item:getData(\"position\")\n    if itemPos and pos:Distance(itemPos) &gt; 100 then\n        client:ChatPrint(\"Item is too far away\")\n        return false\n        end\n    -- Check for admin restrictions\n    if char:getData(\"adminRestricted\", false) then\n        client:ChatPrint(\"You are restricted from taking items\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerthrowpunch","title":"CanPlayerThrowPunch","text":"<p>Purpose</p> <p>Called to check if a player can throw a punch</p> <p>When Called</p> <p>When a player attempts to punch</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to punch</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all players\nhook.Add(\"CanPlayerThrowPunch\", \"MyAddon\", function(client)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check stamina\nhook.Add(\"CanPlayerThrowPunch\", \"PunchStaminaCheck\", function(client)\nlocal stamina = client:getNetVar(\"stamina\", 100)\nif stamina &lt; 10 then\n    client:ChatPrint(\"Not enough stamina to punch\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex punch system\nhook.Add(\"CanPlayerThrowPunch\", \"AdvancedPunchSystem\", function(client)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check stamina\n    local stamina = client:getNetVar(\"stamina\", 100)\n    if stamina &lt; 10 then\n        client:ChatPrint(\"Not enough stamina to punch\")\n        return false\n        end\n    -- Check cooldown\n    local lastPunch = char:getData(\"lastPunch\", 0)\n    if CurTime() - lastPunch &lt; 1 then\n        return false\n        end\n    -- Check if player is tied\n    if char:getData(\"tied\", false) then\n        return false\n        end\n    char:setData(\"lastPunch\", CurTime())\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayertradewithvendor","title":"CanPlayerTradeWithVendor","text":"<p>Purpose</p> <p>Called to check if a player can trade with a vendor</p> <p>When Called</p> <p>When a player attempts to buy/sell from a vendor</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to trade</li> <li><code>vendor</code> (table): The vendor data</li> <li><code>itemType</code> (string): The item type being traded</li> <li><code>isSellingToVendor</code> (boolean): True if selling, false if buying</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all trades\nhook.Add(\"CanPlayerTradeWithVendor\", \"MyAddon\", function(client, vendor, itemType, isSellingToVendor)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction restrictions\nhook.Add(\"CanPlayerTradeWithVendor\", \"VendorTradeCheck\", function(client, vendor, itemType, isSellingToVendor)\nlocal char = client:getChar()\nif not char then return false end\n    local allowedFactions = vendor.allowedFactions\n    if allowedFactions and not table.HasValue(allowedFactions, char:getFaction()) then\n        client:ChatPrint(\"Your faction cannot trade with this vendor\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor trading system\nhook.Add(\"CanPlayerTradeWithVendor\", \"AdvancedVendorTrade\", function(client, vendor, itemType, isSellingToVendor)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check faction restrictions\n    local allowedFactions = vendor.allowedFactions\n    if allowedFactions and not table.HasValue(allowedFactions, char:getFaction()) then\n        client:ChatPrint(\"Your faction cannot trade with this vendor\")\n        return false\n        end\n    -- Check level requirements\n    local requiredLevel = vendor.requiredLevel or 0\n    local charLevel = char:getData(\"level\", 1)\n    if charLevel &lt; requiredLevel then\n        client:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to trade with this vendor\")\n        return false\n        end\n    -- Check reputation\n    local requiredRep = vendor.requiredReputation or 0\n    local charRep = char:getData(\"reputation\", 0)\n    if charRep &lt; requiredRep then\n        client:ChatPrint(\"You need \" .. requiredRep .. \" reputation to trade with this vendor\")\n        return false\n        end\n    -- Check trade cooldown\n    local lastTrade = char:getData(\"lastVendorTrade\", 0)\n    if os.time() - lastTrade &lt; 5 then\n        client:ChatPrint(\"Please wait before trading again\")\n        return false\n        end\n    char:setData(\"lastVendorTrade\", os.time())\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerunequipitem","title":"CanPlayerUnequipItem","text":"<p>Purpose</p> <p>Called to check if a player can unequip an item</p> <p>When Called</p> <p>When a player attempts to unequip an item</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to unequip the item</li> <li><code>item</code> (Item): The item being unequipped</li> </ul> <p>Returns</p> <ul> <li>boolean - True if unequipping is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all item unequips\nhook.Add(\"CanPlayerUnequipItem\", \"MyAddon\", function(client, item)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check if item is equipped\nhook.Add(\"CanPlayerUnequipItem\", \"ItemUnequipCheck\", function(client, item)\n-- Check if item is equipped\nif not item:getData(\"equipped\", false) then\n    client:ChatPrint(\"This item is not equipped\")\n    return false\n    end\n-- Check if item is unequippable\nif item:getData(\"noUnequip\", false) then\n    client:ChatPrint(\"This item cannot be unequipped\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item unequip validation system\nhook.Add(\"CanPlayerUnequipItem\", \"AdvancedUnequipValidation\", function(client, item)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check if item is equipped\n    if not item:getData(\"equipped\", false) then\n        client:ChatPrint(\"This item is not equipped\")\n        return false\n        end\n    -- Check if item is unequippable\n    if item:getData(\"noUnequip\", false) then\n        client:ChatPrint(\"This item cannot be unequipped\")\n        return false\n        end\n    -- Check faction restrictions\n    local itemFaction = item:getData(\"faction\")\n    if itemFaction then\n        local charFaction = char:getFaction()\n        if itemFaction ~= charFaction then\n            client:ChatPrint(\"You cannot unequip faction-restricted items\")\n            return false\n            end\n        end\n    -- Check level requirements\n    local requiredLevel = item:getData(\"requiredLevel\", 1)\n    local charLevel = char:getData(\"level\", 1)\n    if charLevel &lt; requiredLevel then\n        client:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to unequip this item\")\n        return false\n        end\n    -- Check for special item restrictions\n    if item.uniqueID == \"weapon_pistol\" then\n        -- Special handling for weapons\n        if not char:hasFlags(\"w\") then\n            client:ChatPrint(\"You need weapon flags to unequip weapons\")\n            return false\n            end\n    elseif item.uniqueID == \"armor_vest\" then\n        -- Special handling for armor\n        local charClass = char:getClass()\n        if charClass == \"citizen\" then\n            client:ChatPrint(\"Citizens cannot unequip armor\")\n            return false\n            end\n        end\n    -- Check for admin restrictions\n    if char:getData(\"adminRestricted\", false) then\n        client:ChatPrint(\"You are restricted from unequipping items\")\n        return false\n        end\n    -- Check inventory space\n    local inventory = char:getInv()\n    if inventory:getWeight() + item:getWeight() &gt; inventory:getMaxWeight() then\n        client:ChatPrint(\"Not enough space in your inventory\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerunlock","title":"CanPlayerUnlock","text":"<p>Purpose</p> <p>Called to check if a player can unlock a door</p> <p>When Called</p> <p>When a player attempts to unlock a door</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to unlock the door</li> <li><code>door</code> (Entity): The door entity being unlocked</li> </ul> <p>Returns</p> <ul> <li>boolean - True if unlocking is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all door unlocking\nhook.Add(\"CanPlayerUnlock\", \"MyAddon\", function(client, door)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check door ownership\nhook.Add(\"CanPlayerUnlock\", \"DoorUnlockCheck\", function(client, door)\nlocal owner = door:getNetVar(\"owner\")\nif owner == client:SteamID() then\n    return true\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door unlock validation\nhook.Add(\"CanPlayerUnlock\", \"AdvancedDoorUnlock\", function(client, door)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check door ownership\n    local owner = door:getNetVar(\"owner\")\n    if owner and owner ~= client:SteamID() then\n        client:ChatPrint(\"You don't own this door\")\n        return false\n        end\n    -- Check faction permissions\n    local doorFaction = door:getNetVar(\"faction\")\n    if doorFaction and char:getFaction() ~= doorFaction then\n        client:ChatPrint(\"You don't have permission to unlock this door\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerusechar","title":"CanPlayerUseChar","text":"<p>Purpose</p> <p>Called to check if a player can use a character</p> <p>When Called</p> <p>When a player attempts to load a character</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to use the character</li> <li><code>character</code> (Character): The character being used</li> </ul> <p>Returns</p> <ul> <li>boolean - True if using is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all character usage\nhook.Add(\"CanPlayerUseChar\", \"MyAddon\", function(client, character)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check character ownership\nhook.Add(\"CanPlayerUseChar\", \"CharUseCheck\", function(client, character)\nif character:getSteamID() == client:SteamID() then\n    return true\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character use validation\nhook.Add(\"CanPlayerUseChar\", \"AdvancedCharUse\", function(client, character)\n-- Check character ownership\nif character:getSteamID() ~= client:SteamID() then\n    client:ChatPrint(\"This character doesn't belong to you\")\n    return false\n    end\n-- Check if character is banned\nif character:getData(\"banned\", false) then\n    client:ChatPrint(\"This character is banned\")\n    return false\n    end\n-- Check if character is deleted\nif character:getData(\"deleted\", false) then\n    client:ChatPrint(\"This character has been deleted\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p>"},{"location":"hooks/server/#canplayerusecommand","title":"CanPlayerUseCommand","text":"<p>Purpose</p> <p>Called to check if a player can use a command</p> <p>When Called</p> <p>When a player attempts to execute a command</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to use the command</li> <li><code>command</code> (string): The command being executed</li> </ul> <p>Returns</p> <ul> <li>boolean - True if command use is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all commands\nhook.Add(\"CanPlayerUseCommand\", \"MyAddon\", function(client, command)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check admin commands\nhook.Add(\"CanPlayerUseCommand\", \"CommandCheck\", function(client, command)\nlocal adminCommands = {\"kick\", \"ban\", \"slay\"}\nif table.HasValue(adminCommands, command) then\n    return client:IsAdmin()\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex command permission system\nhook.Add(\"CanPlayerUseCommand\", \"AdvancedCommandPerms\", function(client, command)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check admin commands\n    local adminCommands = {\"kick\", \"ban\", \"slay\", \"bring\", \"goto\"}\n    if table.HasValue(adminCommands, command) then\n        if not client:IsAdmin() then\n            client:ChatPrint(\"You need admin permissions to use this command\")\n            return false\n            end\n        end\n    -- Check faction-specific commands\n    local factionCommands = {\n    [\"police\"] = {\"arrest\", \"warrant\", \"unarrest\"},\n    [\"medic\"] = {\"heal\", \"revive\"}\n    }\n    local faction = char:getFaction()\n    for fac, commands in pairs(factionCommands) do\n        if table.HasValue(commands, command) then\n            if faction ~= fac then\n                client:ChatPrint(\"You need to be in the \" .. fac .. \" faction to use this command\")\n                return false\n                end\n            end\n        end\n    -- Check command cooldowns\n    local lastCommand = char:getData(\"lastCommand_\" .. command, 0)\n    if os.time() - lastCommand &lt; 5 then\n        client:ChatPrint(\"Please wait before using this command again\")\n        return false\n        end\n    char:setData(\"lastCommand_\" .. command, os.time())\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerusedoor","title":"CanPlayerUseDoor","text":"<p>Purpose</p> <p>Called to check if a player can use a door</p> <p>When Called</p> <p>When a player attempts to interact with a door</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to use the door</li> <li><code>door</code> (Entity): The door entity being used</li> </ul> <p>Returns</p> <ul> <li>boolean - True if door use is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all door usage\nhook.Add(\"CanPlayerUseDoor\", \"MyAddon\", function(client, door)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check door ownership\nhook.Add(\"CanPlayerUseDoor\", \"DoorUseCheck\", function(client, door)\nlocal owner = door:getNetVar(\"owner\")\nif owner and owner ~= client:SteamID() then\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door use validation\nhook.Add(\"CanPlayerUseDoor\", \"AdvancedDoorUse\", function(client, door)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check door ownership\n    local owner = door:getNetVar(\"owner\")\n    if owner and owner ~= client:SteamID() then\n        -- Check if door is shared\n        local sharedWith = door:getNetVar(\"sharedWith\", {})\n        if not table.HasValue(sharedWith, client:SteamID()) then\n            client:ChatPrint(\"You don't have permission to use this door\")\n            return false\n            end\n        end\n    -- Check faction permissions\n    local doorFaction = door:getNetVar(\"faction\")\n    if doorFaction and char:getFaction() ~= doorFaction then\n        client:ChatPrint(\"You don't have permission to use this faction's door\")\n        return false\n        end\n    -- Check if door is locked\n    if door:getNetVar(\"locked\", false) then\n        client:ChatPrint(\"This door is locked\")\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#canplayerviewinventory","title":"CanPlayerViewInventory","text":"<p>Purpose</p> <p>Called to check if a player can view inventories</p> <p>When Called</p> <p>When a player attempts to open any inventory</p> <p>Returns</p> <ul> <li>boolean - True if viewing inventories is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all inventory viewing\nhook.Add(\"CanPlayerViewInventory\", \"MyAddon\", function()\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check player status\nhook.Add(\"CanPlayerViewInventory\", \"InventoryViewCheck\", function()\nlocal client = LocalPlayer()\nif not client then return false end\n    local char = client:getChar()\n    if not char then return false end\n        -- Check if player is unconscious\n        if char:getData(\"unconscious\", false) then\n            client:ChatPrint(\"You cannot view inventories while unconscious\")\n            return false\n            end\n        return true\n        end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory view validation system\nhook.Add(\"CanPlayerViewInventory\", \"AdvancedInventoryView\", function()\nlocal client = LocalPlayer()\nif not client then return false end\n    local char = client:getChar()\n    if not char then return false end\n        -- Check if player is unconscious\n        if char:getData(\"unconscious\", false) then\n            client:ChatPrint(\"You cannot view inventories while unconscious\")\n            return false\n            end\n        -- Check if player is dead\n        if client:Health() &lt;= 0 then\n            client:ChatPrint(\"You cannot view inventories while dead\")\n            return false\n            end\n        -- Check if player is gagged\n        if char:getData(\"gagged\", false) then\n            client:ChatPrint(\"You cannot view inventories while gagged\")\n            return false\n            end\n        -- Check if player is muted\n        if char:getData(\"muted\", false) then\n            client:ChatPrint(\"You cannot view inventories while muted\")\n            return false\n            end\n        -- Check for admin restrictions\n        if char:getData(\"adminRestricted\", false) then\n            client:ChatPrint(\"You are restricted from viewing inventories\")\n            return false\n            end\n        -- Check faction restrictions\n        local faction = char:getFaction()\n        if faction == \"prisoner\" then\n            client:ChatPrint(\"Prisoners cannot view inventories\")\n            return false\n            end\n        -- Check level requirements\n        local charLevel = char:getData(\"level\", 1)\n        if charLevel &lt; 1 then\n            client:ChatPrint(\"You need to be level 1 to view inventories\")\n            return false\n            end\n        -- Check for special conditions\n        local pos = client:GetPos()\n        local restrictedAreas = {\n        {pos = Vector(0, 0, 0), radius = 100}, -- Example restricted area\n        }\n        for _, area in ipairs(restrictedAreas) do\n            if pos:Distance(area.pos) &lt; area.radius then\n                client:ChatPrint(\"Cannot view inventories in this area\")\n                return false\n                end\n            end\n        return true\n        end)\n</code></pre></p>"},{"location":"hooks/server/#canrunitemaction","title":"CanRunItemAction","text":"<p>Purpose</p> <p>Called to check if an item action can be run</p> <p>When Called</p> <p>When attempting to execute an item action</p> <p>Parameters</p> <ul> <li><code>itemTable</code> (table): The item table containing the action</li> <li><code>k</code> (string): The action key being executed</li> </ul> <p>Returns</p> <ul> <li>boolean - True if action can be run, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all item actions\nhook.Add(\"CanRunItemAction\", \"MyAddon\", function(itemTable, k)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check action restrictions\nhook.Add(\"CanRunItemAction\", \"ActionCheck\", function(itemTable, k)\n-- Check if action exists\nif not itemTable[k] then\n    return false\n    end\n-- Check if action is disabled\nif itemTable:getData(\"actionDisabled\", false) then\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item action validation\nhook.Add(\"CanRunItemAction\", \"AdvancedActionValidation\", function(itemTable, k)\n-- Check if action exists\nif not itemTable[k] then\n    return false\n    end\n-- Check if action is disabled\nif itemTable:getData(\"actionDisabled\", false) then\n    return false\n    end\n-- Check faction restrictions\nlocal actionFaction = itemTable:getData(\"actionFaction\")\nif actionFaction then\n    local char = LocalPlayer():getChar()\n    if char and char:getFaction() ~= actionFaction then\n        return false\n        end\n    end\n-- Check level requirements\nlocal requiredLevel = itemTable:getData(\"requiredLevel\", 1)\nlocal char = LocalPlayer():getChar()\nif char then\n    local charLevel = char:getData(\"level\", 1)\n    if charLevel &lt; requiredLevel then\n        return false\n        end\n    end\nreturn true\nend)\n</code></pre></p>"},{"location":"hooks/server/#cansavedata","title":"CanSaveData","text":"<p>Purpose</p> <p>Called to check if entity data can be saved</p> <p>When Called</p> <p>When attempting to save entity data to the database</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The entity being saved</li> <li><code>inventory</code> (Inventory): The inventory associated with the entity</li> </ul> <p>Returns</p> <ul> <li>boolean - True if data can be saved, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all data saving\nhook.Add(\"CanSaveData\", \"MyAddon\", function(ent, inventory)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check entity validity\nhook.Add(\"CanSaveData\", \"DataSaveCheck\", function(ent, inventory)\n-- Check if entity is valid\nif not IsValid(ent) then\n    return false\n    end\n-- Check if entity is persistent\nif not ent:getNetVar(\"persistent\", false) then\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data save validation\nhook.Add(\"CanSaveData\", \"AdvancedDataSave\", function(ent, inventory)\n-- Check if entity is valid\nif not IsValid(ent) then\n    return false\n    end\n-- Check if entity is persistent\nif not ent:getNetVar(\"persistent\", false) then\n    return false\n    end\n-- Check if entity has owner\nlocal owner = ent:getNetVar(\"owner\")\nif not owner then\n    return false\n    end\n-- Check if owner is online\nlocal ownerPlayer = player.GetBySteamID(owner)\nif not IsValid(ownerPlayer) then\n    return false\n    end\n-- Check if entity is in valid location\nlocal pos = ent:GetPos()\nif pos.z &lt; -1000 or pos.z &gt; 1000 then\n    return false\n    end\nreturn true\nend)\n</code></pre></p>"},{"location":"hooks/server/#charcleanup","title":"CharCleanUp","text":"<p>Purpose</p> <p>Called when a character is cleaned up</p> <p>When Called</p> <p>When a character is being removed from memory</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character being cleaned up</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character cleanup\nhook.Add(\"CharCleanUp\", \"MyAddon\", function(character)\nprint(\"Character cleaned up: \" .. character:getName())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up character data\nhook.Add(\"CharCleanUp\", \"CharDataCleanup\", function(character)\n-- Clear character data\ncharacter:setData(\"lastCleanup\", os.time())\n-- Clear temporary data\ncharacter:setData(\"tempData\", nil)\ncharacter:setData(\"cachedData\", nil)\nprint(\"Character data cleaned up: \" .. character:getName())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character cleanup system\nhook.Add(\"CharCleanUp\", \"AdvancedCharCleanup\", function(character)\n-- Clear character data\ncharacter:setData(\"lastCleanup\", os.time())\n-- Clear temporary data\ncharacter:setData(\"tempData\", nil)\ncharacter:setData(\"cachedData\", nil)\n-- Clear active effects\ncharacter:setData(\"activeEffects\", {})\n-- Clear active quests\ncharacter:setData(\"activeQuests\", {})\n-- Clear recognition data\ncharacter:setData(\"recognitions\", {})\n-- Clear inventory cache\nlocal inventory = character:getInv()\nif inventory then\n    inventory:setData(\"cachedItems\", nil)\n    end\n-- Clear position data\ncharacter:setData(\"lastPos\", nil)\ncharacter:setData(\"lastAng\", nil)\n-- Log cleanup\nprint(string.format(\"Character %s (ID: %d) cleaned up\",\ncharacter:getName(), character:getID()))\nend)\n</code></pre></p>"},{"location":"hooks/server/#chardeleted","title":"CharDeleted","text":"<p>Purpose</p> <p>Called when a character is deleted</p> <p>When Called</p> <p>When a character is successfully deleted</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose character was deleted</li> <li><code>character</code> (Character): The character that was deleted</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character deletion\nhook.Add(\"CharDeleted\", \"MyAddon\", function(client, character)\nprint(client:Name() .. \" deleted character: \" .. character:getName())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle character deletion effects\nhook.Add(\"CharDeleted\", \"CharDeletionEffects\", function(client, character)\n-- Clear character data\ncharacter:setData(\"deleted\", true)\ncharacter:setData(\"deletionTime\", os.time())\n-- Notify other players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client then\n        ply:ChatPrint(character:getName() .. \" was deleted\")\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character deletion system\nhook.Add(\"CharDeleted\", \"AdvancedCharDeletion\", function(client, character)\n-- Set deletion data\ncharacter:setData(\"deleted\", true)\ncharacter:setData(\"deletionTime\", os.time())\n-- Clear character inventory\nlocal inventory = character:getInv()\nif inventory then\n    local items = inventory:getItems()\n    for _, item in pairs(items) do\n        inventory:remove(item)\n        end\n    end\n-- Clear character money\ncharacter:setMoney(0)\n-- Clear character attributes\nlocal attributes = character:getAttribs()\nfor attr, _ in pairs(attributes) do\n    character:setAttrib(attr, 0)\n    end\n-- Clear character data\ncharacter:setData(\"level\", 1)\ncharacter:setData(\"experience\", 0)\ncharacter:setData(\"activeQuests\", {})\ncharacter:setData(\"activeEffects\", {})\n-- Check for faction-specific effects\nlocal faction = character:getFaction()\nif faction == \"police\" then\n    -- Police character deleted\n    for _, ply in ipairs(player.GetAll()) do\n        local plyChar = ply:getChar()\n        if plyChar and plyChar:getFaction() == \"police\" and ply ~= client then\n            ply:ChatPrint(\"[POLICE] \" .. character:getName() .. \" was deleted\")\n            end\n        end\nelseif faction == \"medic\" then\n    -- Medic character deleted\n    for _, ply in ipairs(player.GetAll()) do\n        local plyChar = ply:getChar()\n        if plyChar and plyChar:getFaction() == \"medic\" and ply ~= client then\n            ply:ChatPrint(\"[MEDICAL] \" .. character:getName() .. \" was deleted\")\n            end\n        end\n    end\n-- Notify other players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client then\n        ply:ChatPrint(character:getName() .. \" was deleted\")\n        end\n    end\n-- Log deletion\nprint(string.format(\"%s deleted character %s (Faction: %s)\",\nclient:Name(), character:getName(), faction))\nend)\n</code></pre></p>"},{"location":"hooks/server/#charforcerecognized","title":"CharForceRecognized","text":"<p>Purpose</p> <p>Called to force character recognition</p> <p>When Called</p> <p>When a character is forced to be recognized</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player being recognized</li> <li><code>range</code> (number): The recognition range</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log forced recognition\nhook.Add(\"CharForceRecognized\", \"MyAddon\", function(ply, range)\nprint(ply:Name() .. \" was force recognized\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle forced recognition effects\nhook.Add(\"CharForceRecognized\", \"ForceRecognitionEffects\", function(ply, range)\nlocal char = ply:getChar()\nif char then\n    -- Set recognition data\n    char:setData(\"forceRecognized\", true)\n    char:setData(\"recognitionTime\", os.time())\n    -- Notify player\n    ply:ChatPrint(\"You have been force recognized\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex force recognition system\nhook.Add(\"CharForceRecognized\", \"AdvancedForceRecognition\", function(ply, range)\nlocal char = ply:getChar()\nif not char then return end\n    -- Set recognition data\n    char:setData(\"forceRecognized\", true)\n    char:setData(\"recognitionTime\", os.time())\n    char:setData(\"recognitionRange\", range)\n    -- Check for faction-specific effects\n    local faction = char:getFaction()\n    if faction == \"police\" then\n        -- Police force recognition\n        for _, target in ipairs(player.GetAll()) do\n            if target ~= ply then\n                local targetChar = target:getChar()\n                if targetChar and targetChar:getFaction() == \"police\" then\n                    target:ChatPrint(\"[POLICE] \" .. char:getName() .. \" was force recognized\")\n                    end\n                end\n            end\n    elseif faction == \"medic\" then\n        -- Medic force recognition\n        for _, target in ipairs(player.GetAll()) do\n            if target ~= ply then\n                local targetChar = target:getChar()\n                if targetChar and targetChar:getFaction() == \"medic\" then\n                    target:ChatPrint(\"[MEDICAL] \" .. char:getName() .. \" was force recognized\")\n                    end\n                end\n            end\n        end\n    -- Notify player\n    ply:ChatPrint(\"You have been force recognized\")\n    -- Log force recognition\n    print(string.format(\"%s was force recognized (Faction: %s, Range: %d)\",\n    ply:Name(), faction, range))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#charhasflags","title":"CharHasFlags","text":"<p>Purpose</p> <p>Called to check if a character has specific flags</p> <p>When Called</p> <p>When checking if a character has certain permissions</p> <p>Parameters</p> <ul> <li><code>self</code> (Character): The character being checked</li> <li><code>flags</code> (string): The flags to check for</li> </ul> <p>Returns</p> <ul> <li>boolean - True if character has flags, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check basic flags\nhook.Add(\"CharHasFlags\", \"MyAddon\", function(self, flags)\nreturn self:getData(\"flags\", \"\"):find(flags) ~= nil\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction-based flags\nhook.Add(\"CharHasFlags\", \"FactionFlags\", function(self, flags)\nlocal faction = self:getFaction()\nlocal factionFlags = {\n[\"police\"] = \"w\",\n[\"medic\"] = \"m\",\n[\"citizen\"] = \"\"\n}\nlocal hasFactionFlags = factionFlags[faction] or \"\"\nreturn hasFactionFlags:find(flags) ~= nil\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex flag checking system\nhook.Add(\"CharHasFlags\", \"AdvancedFlagCheck\", function(self, flags)\n-- Check basic flags\nlocal charFlags = self:getData(\"flags\", \"\")\nif charFlags:find(flags) then\n    return true\n    end\n-- Check faction-based flags\nlocal faction = self:getFaction()\nlocal factionFlags = {\n[\"police\"] = \"w\",\n[\"medic\"] = \"m\",\n[\"citizen\"] = \"\"\n}\nlocal hasFactionFlags = factionFlags[faction] or \"\"\nif hasFactionFlags:find(flags) then\n    return true\n    end\n-- Check level-based flags\nlocal charLevel = self:getData(\"level\", 1)\nif charLevel &gt;= 10 and flags == \"v\" then\n    return true\n    end\n-- Check admin flags\nlocal client = self:getPlayer()\nif client and client:IsAdmin() and flags == \"a\" then\n    return true\n    end\nreturn false\nend)\n</code></pre></p>"},{"location":"hooks/server/#charloaded","title":"CharLoaded","text":"<p>Purpose</p> <p>Called when a character is loaded</p> <p>When Called</p> <p>When a character is successfully loaded from the database</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The ID of the character that was loaded</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character loading\nhook.Add(\"CharLoaded\", \"MyAddon\", function(id)\nprint(\"Character loaded: \" .. id)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle character loading effects\nhook.Add(\"CharLoaded\", \"CharLoadingEffects\", function(id)\nlocal character = lia.char.getByID(id)\nif character then\n    -- Set loading data\n    character:setData(\"loaded\", true)\n    character:setData(\"loadTime\", os.time())\n    print(\"Character \" .. character:getName() .. \" loaded successfully\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character loading system\nhook.Add(\"CharLoaded\", \"AdvancedCharLoading\", function(id)\nlocal character = lia.char.getByID(id)\nif not character then return end\n    -- Set loading data\n    character:setData(\"loaded\", true)\n    character:setData(\"loadTime\", os.time())\n    -- Get character data\n    local name = character:getName()\n    local faction = character:getFaction()\n    local level = character:getData(\"level\", 1)\n    -- Check for faction-specific loading effects\n    if faction == \"police\" then\n        -- Police character loaded\n        for _, ply in ipairs(player.GetAll()) do\n            local plyChar = ply:getChar()\n            if plyChar and plyChar:getFaction() == \"police\" then\n                ply:ChatPrint(\"[POLICE] \" .. name .. \" has joined the force\")\n                end\n            end\n    elseif faction == \"medic\" then\n        -- Medic character loaded\n        for _, ply in ipairs(player.GetAll()) do\n            local plyChar = ply:getChar()\n            if plyChar and plyChar:getFaction() == \"medic\" then\n                ply:ChatPrint(\"[MEDICAL] \" .. name .. \" has joined the medical staff\")\n                end\n            end\n        end\n    -- Check for level-based effects\n    if level &gt;= 10 then\n        print(\"High level character loaded: \" .. name .. \" (Level \" .. level .. \")\")\n        end\n    -- Log character loading\n    print(string.format(\"Character %s (ID: %d, Faction: %s, Level: %d) loaded successfully\",\n    name, id, faction, level))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#charpostsave","title":"CharPostSave","text":"<p>Purpose</p> <p>Called after a character is saved</p> <p>When Called</p> <p>After character data has been saved to the database</p> <p>Parameters</p> <ul> <li><code>self</code> (Character): The character that was saved</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character save\nhook.Add(\"CharPostSave\", \"MyAddon\", function(self)\nprint(\"Character \" .. self:getName() .. \" saved\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update save timestamp\nhook.Add(\"CharPostSave\", \"SaveTimestamp\", function(self)\nself:setData(\"lastSave\", os.time())\nprint(\"Character \" .. self:getName() .. \" saved at \" .. os.date(\"%H:%M:%S\"))\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex post-save handling\nhook.Add(\"CharPostSave\", \"AdvancedPostSave\", function(self)\n-- Update save timestamp\nself:setData(\"lastSave\", os.time())\n-- Increment save count\nlocal saveCount = self:getData(\"saveCount\", 0) + 1\nself:setData(\"saveCount\", saveCount)\n-- Create backup every 10 saves\nif saveCount % 10 == 0 then\n    lia.char.createBackup(self:getID())\n    print(\"Backup created for character \" .. self:getName())\n    end\nprint(string.format(\"Character %s saved (Save #%d)\", self:getName(), saveCount))\nend)\n</code></pre></p>"},{"location":"hooks/server/#charpresave","title":"CharPreSave","text":"<p>Purpose</p> <p>Called before a character is saved</p> <p>When Called</p> <p>Before character data is saved to the database</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character being saved</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character save\nhook.Add(\"CharPreSave\", \"MyAddon\", function(character)\nprint(\"Saving character: \" .. character:getName())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate character data\nhook.Add(\"CharPreSave\", \"SaveValidation\", function(character)\n-- Validate money\nlocal money = character:getMoney()\nif money &lt; 0 then\n    character:setMoney(0)\n    print(\"Fixed negative money for \" .. character:getName())\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex pre-save validation\nhook.Add(\"CharPreSave\", \"AdvancedPreSave\", function(character)\n-- Validate money\nlocal money = character:getMoney()\nif money &lt; 0 then\n    character:setMoney(0)\nelseif money &gt; 1000000 then\n    character:setMoney(1000000)\n    end\n-- Validate attributes\nlocal attributes = character:getAttribs()\nfor attr, value in pairs(attributes) do\n    if value &lt; 0 then\n        character:setAttrib(attr, 0)\n    elseif value &gt; 100 then\n        character:setAttrib(attr, 100)\n        end\n    end\n-- Update save preparation timestamp\ncharacter:setData(\"preSaveTime\", os.time())\nprint(\"Character \" .. character:getName() .. \" validated and ready for save\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#charrestored","title":"CharRestored","text":"<p>Purpose</p> <p>Called when a character is restored</p> <p>When Called</p> <p>When a character is restored from backup or death</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character being restored</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character restoration\nhook.Add(\"CharRestored\", \"MyAddon\", function(character)\nprint(\"Character \" .. character:getName() .. \" restored\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle restoration effects\nhook.Add(\"CharRestored\", \"RestorationEffects\", function(character)\ncharacter:setData(\"restored\", true)\ncharacter:setData(\"restoreTime\", os.time())\nprint(\"Character \" .. character:getName() .. \" restored successfully\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character restoration\nhook.Add(\"CharRestored\", \"AdvancedRestoration\", function(character)\n-- Set restoration data\ncharacter:setData(\"restored\", true)\ncharacter:setData(\"restoreTime\", os.time())\n-- Restore health and stamina\nlocal client = character:getPlayer()\nif client then\n    client:SetHealth(100)\n    client:setNetVar(\"stamina\", 100)\n    end\n-- Clear negative effects\ncharacter:setData(\"unconscious\", false)\ncharacter:setData(\"bleeding\", false)\nprint(\"Character \" .. character:getName() .. \" fully restored\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#chatparsed","title":"ChatParsed","text":"<p>Purpose</p> <p>Called when chat is parsed</p> <p>When Called</p> <p>When a chat message is processed and parsed</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who sent the message</li> <li><code>chatType</code> (string): The type of chat (ic, ooc, etc)</li> <li><code>message</code> (string): The message content</li> <li><code>anonymous</code> (boolean): Whether the message is anonymous</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log parsed chat\nhook.Add(\"ChatParsed\", \"MyAddon\", function(client, chatType, message, anonymous)\nprint(client:Name() .. \" sent \" .. chatType .. \" message: \" .. message)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Filter chat messages\nhook.Add(\"ChatParsed\", \"ChatFilter\", function(client, chatType, message, anonymous)\n-- Filter spam\nif string.len(message) &gt; 500 then\n    client:ChatPrint(\"Message too long\")\n    return false\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex chat parsing\nhook.Add(\"ChatParsed\", \"AdvancedChatParse\", function(client, chatType, message, anonymous)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check for spam\n    local lastMessage = char:getData(\"lastMessage\", \"\")\n    if lastMessage == message then\n        client:ChatPrint(\"Don't spam the same message\")\n        return false\n        end\n    char:setData(\"lastMessage\", message)\n    -- Check message length\n    if string.len(message) &gt; 500 then\n        client:ChatPrint(\"Message too long (max 500 characters)\")\n        return false\n        end\n    -- Log chat\n    lia.log.add(client, \"chat\", chatType, message)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#checkfactionlimitreached","title":"CheckFactionLimitReached","text":"<p>Purpose</p> <p>Called to check if a faction limit has been reached</p> <p>When Called</p> <p>When checking if more players can join a faction</p> <p>Parameters</p> <ul> <li><code>faction</code> (number): The faction ID being checked</li> <li><code>character</code> (Character): The character attempting to join</li> <li><code>client</code> (Player): The player attempting to join</li> </ul> <p>Returns</p> <ul> <li>boolean - True if limit is reached, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: No faction limits\nhook.Add(\"CheckFactionLimitReached\", \"MyAddon\", function(faction, character, client)\nreturn false\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Basic faction limits\nhook.Add(\"CheckFactionLimitReached\", \"FactionLimits\", function(faction, character, client)\nlocal factionData = lia.faction.indices[faction]\nif factionData and factionData.limit then\n    local count = 0\n    for _, ply in ipairs(player.GetAll()) do\n        local char = ply:getChar()\n        if char and char:getFaction() == faction then\n            count = count + 1\n            end\n        end\n    return count &gt;= factionData.limit\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex faction limit system\nhook.Add(\"CheckFactionLimitReached\", \"AdvancedFactionLimits\", function(faction, character, client)\nlocal factionData = lia.faction.indices[faction]\nif not factionData then return false end\n    -- Count current faction members\n    local count = 0\n    for _, ply in ipairs(player.GetAll()) do\n        local char = ply:getChar()\n        if char and char:getFaction() == faction then\n            count = count + 1\n            end\n        end\n    -- Check base limit\n    local limit = factionData.limit or math.huge\n    -- Adjust limit based on server population\n    local playerCount = #player.GetAll()\n    if playerCount &lt; 10 then\n        limit = math.floor(limit * 0.5)\n    elseif playerCount &gt; 50 then\n        limit = math.floor(limit * 1.5)\n        end\n    -- Check if limit is reached\n    if count &gt;= limit then\n        client:ChatPrint(\"Faction limit reached (\" .. count .. \"/\" .. limit .. \")\")\n        return true\n        end\n    return false\n    end)\n</code></pre></p>"},{"location":"hooks/server/#commandran","title":"CommandRan","text":"<p>Purpose</p> <p>Called when a command is executed</p> <p>When Called</p> <p>After a command has been run by a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who ran the command</li> <li><code>command</code> (string): The command that was executed</li> <li><code>arguments</code> (table): The arguments passed to the command</li> <li><code>results</code> (any): The results returned by the command</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log command execution\nhook.Add(\"CommandRan\", \"MyAddon\", function(client, command, arguments, results)\nprint(client:Name() .. \" ran command: \" .. command)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track command usage\nhook.Add(\"CommandRan\", \"CommandUsageTracking\", function(client, command, arguments, results)\nlocal char = client:getChar()\nif char then\n    local commandCount = char:getData(\"commandCount\", 0) + 1\n    char:setData(\"commandCount\", commandCount)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex command execution tracking\nhook.Add(\"CommandRan\", \"AdvancedCommandTracking\", function(client, command, arguments, results)\nlocal char = client:getChar()\nif not char then return end\n    -- Track command usage\n    local commandCount = char:getData(\"commandCount\", 0) + 1\n    char:setData(\"commandCount\", commandCount)\n    -- Track command history\n    local commandHistory = char:getData(\"commandHistory\", {})\n    table.insert(commandHistory, {\n    command = command,\n    arguments = arguments,\n    timestamp = os.time(),\n    results = results\n    })\n    -- Keep only last 50 commands\n    if #commandHistory &gt; 50 then\n        table.remove(commandHistory, 1)\n        end\n    char:setData(\"commandHistory\", commandHistory)\n    -- Log command execution\n    lia.log.add(client, \"command\", command, table.concat(arguments, \" \"))\n    print(string.format(\"%s ran command: %s (Args: %d, Success: %s)\",\n    client:Name(), command, #arguments, tostring(results ~= false)))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#configchanged","title":"ConfigChanged","text":"<p>Purpose</p> <p>Called when a configuration value changes</p> <p>When Called</p> <p>When a config option is modified</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The configuration key that changed</li> <li><code>value</code> (any): The new value</li> <li><code>oldValue</code> (any): The previous value</li> <li><code>client</code> (Player): The player who changed the config (if applicable)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log config changes\nhook.Add(\"ConfigChanged\", \"MyAddon\", function(key, value, oldValue, client)\nprint(\"Config changed: \" .. key .. \" = \" .. tostring(value))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle specific config changes\nhook.Add(\"ConfigChanged\", \"ConfigHandling\", function(key, value, oldValue, client)\nif key == \"maxPlayers\" then\n    game.MaxPlayers = value\nelseif key == \"serverName\" then\n    RunConsoleCommand(\"hostname\", value)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex config change handling\nhook.Add(\"ConfigChanged\", \"AdvancedConfigChange\", function(key, value, oldValue, client)\n-- Log config change\nif client then\n    lia.log.add(client, \"config\", key, tostring(oldValue) .. \" -&gt; \" .. tostring(value))\n    end\n-- Handle specific config changes\nif key == \"maxPlayers\" then\n    game.MaxPlayers = value\n    print(\"Max players updated to: \" .. value)\nelseif key == \"serverName\" then\n    RunConsoleCommand(\"hostname\", value)\n    print(\"Server name updated to: \" .. value)\nelseif key == \"password\" then\n    if value and value ~= \"\" then\n        RunConsoleCommand(\"sv_password\", value)\n        print(\"Server password set\")\n    else\n        RunConsoleCommand(\"sv_password\", \"\")\n        print(\"Server password removed\")\n        end\n    end\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[CONFIG] \" .. key .. \" changed to: \" .. tostring(value))\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#createcharacter","title":"CreateCharacter","text":"<p>Purpose</p> <p>Called when creating a character</p> <p>When Called</p> <p>When a new character is being created</p> <p>Parameters</p> <ul> <li><code>data</code> (table): The character creation data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character creation\nhook.Add(\"CreateCharacter\", \"MyAddon\", function(data)\nprint(\"Creating character: \" .. data.name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add default items\nhook.Add(\"CreateCharacter\", \"DefaultItems\", function(data)\ndata.items = data.items or {}\ntable.insert(data.items, \"wallet\")\ntable.insert(data.items, \"phone\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character creation\nhook.Add(\"CreateCharacter\", \"AdvancedCreation\", function(data)\n-- Add default items\ndata.items = data.items or {}\ntable.insert(data.items, \"wallet\")\ntable.insert(data.items, \"phone\")\n-- Add faction-specific items\nlocal factionItems = {\n[\"police\"] = {\"handcuffs\", \"radio\"},\n[\"medic\"] = {\"medkit\", \"bandage\"}\n}\nlocal items = factionItems[data.faction]\nif items then\n    for _, item in ipairs(items) do\n        table.insert(data.items, item)\n        end\n    end\n-- Set creation timestamp\ndata.createdAt = os.time()\nprint(\"Character \" .. data.name .. \" created with \" .. #data.items .. \" items\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#createdefaultinventory","title":"CreateDefaultInventory","text":"<p>Purpose</p> <p>Called to create a character's default inventory</p> <p>When Called</p> <p>When a new character needs an inventory created</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character receiving the inventory</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log inventory creation\nhook.Add(\"CreateDefaultInventory\", \"MyAddon\", function(character)\nprint(\"Creating inventory for: \" .. character:getName())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set inventory size based on faction\nhook.Add(\"CreateDefaultInventory\", \"FactionInventory\", function(character)\nlocal faction = character:getFaction()\nlocal sizes = {\n[\"police\"] = {w = 8, h = 6},\n[\"medic\"] = {w = 7, h = 5},\n[\"citizen\"] = {w = 6, h = 4}\n}\nlocal size = sizes[faction] or {w = 6, h = 4}\ncharacter:getInv():setSize(size.w, size.h)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory setup\nhook.Add(\"CreateDefaultInventory\", \"AdvancedInventorySetup\", function(character)\nlocal faction = character:getFaction()\n-- Set inventory size based on faction\nlocal sizes = {\n[\"police\"] = {w = 8, h = 6},\n[\"medic\"] = {w = 7, h = 5},\n[\"citizen\"] = {w = 6, h = 4}\n}\nlocal size = sizes[faction] or {w = 6, h = 4}\nlocal inv = character:getInv()\ninv:setSize(size.w, size.h)\n-- Set weight limits\nlocal weights = {\n[\"police\"] = 50,\n[\"medic\"] = 40,\n[\"citizen\"] = 30\n}\ninv:setData(\"maxWeight\", weights[faction] or 30)\n-- Add starting items\nlocal startingItems = {\n[\"police\"] = {\"handcuffs\", \"radio\"},\n[\"medic\"] = {\"medkit\"},\n[\"citizen\"] = {\"wallet\"}\n}\nlocal items = startingItems[faction] or {}\nfor _, itemID in ipairs(items) do\n    local item = lia.item.instance(itemID)\n    if item then\n        inv:add(item)\n        end\n    end\nprint(\"Inventory created for \" .. character:getName() .. \" (\" .. size.w .. \"x\" .. size.h .. \")\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#createsalarytimers","title":"CreateSalaryTimers","text":"<p>Purpose</p> <p>Called to create salary timers</p> <p>When Called</p> <p>When salary system is being initialized</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create basic salary timer\nhook.Add(\"CreateSalaryTimers\", \"MyAddon\", function()\ntimer.Create(\"SalaryTimer\", 300, 0, function()\nfor _, ply in ipairs(player.GetAll()) do\n    local char = ply:getChar()\n    if char then\n        char:giveMoney(100)\n        end\n    end\nend)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Faction-based salary timers\nhook.Add(\"CreateSalaryTimers\", \"FactionSalaryTimers\", function()\ntimer.Create(\"SalaryTimer\", 300, 0, function()\nfor _, ply in ipairs(player.GetAll()) do\n    local char = ply:getChar()\n    if char then\n        local faction = char:getFaction()\n        local salary = 100\n        if faction == \"police\" then\n            salary = 200\n        elseif faction == \"medic\" then\n            salary = 150\n            end\n        char:giveMoney(salary)\n        ply:ChatPrint(\"You received $\" .. salary .. \" salary\")\n        end\n    end\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex salary timer system\nhook.Add(\"CreateSalaryTimers\", \"AdvancedSalaryTimers\", function()\ntimer.Create(\"SalaryTimer\", 300, 0, function()\nfor _, ply in ipairs(player.GetAll()) do\n    local char = ply:getChar()\n    if not char then continue end\n        -- Check if player can earn salary\n        if not hook.Run(\"CanPlayerEarnSalary\", ply) then\n            continue\n            end\n        -- Calculate base salary\n        local faction = char:getFaction()\n        local baseSalary = hook.Run(\"GetSalaryAmount\", ply, faction) or 100\n        -- Apply level bonus\n        local level = char:getData(\"level\", 1)\n        local levelBonus = math.floor(level * 5)\n        -- Apply rank bonus\n        local rank = char:getData(\"rank\", 0)\n        local rankBonus = rank * 25\n        -- Calculate total salary\n        local totalSalary = baseSalary + levelBonus + rankBonus\n        -- Give salary\n        char:giveMoney(totalSalary)\n        ply:ChatPrint(\"You received $\" .. totalSalary .. \" salary\")\n        -- Update statistics\n        local totalEarned = char:getData(\"totalSalaryEarned\", 0)\n        char:setData(\"totalSalaryEarned\", totalEarned + totalSalary)\n        end\n    end)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#databaseconnected","title":"DatabaseConnected","text":"<p>Purpose</p> <p>Called when database is connected</p> <p>When Called</p> <p>When the database connection is established</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log connection\nhook.Add(\"DatabaseConnected\", \"MyAddon\", function()\nprint(\"Database connected\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize tables\nhook.Add(\"DatabaseConnected\", \"DatabaseInit\", function()\nlia.db.query(\"CREATE TABLE IF NOT EXISTS custom_data (id INTEGER PRIMARY KEY, data TEXT)\")\nprint(\"Database connected and tables initialized\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex database initialization\nhook.Add(\"DatabaseConnected\", \"AdvancedDatabaseInit\", function()\n-- Create tables\nlocal tables = {\n\"CREATE TABLE IF NOT EXISTS custom_data (id INTEGER PRIMARY KEY, data TEXT)\",\n\"CREATE TABLE IF NOT EXISTS player_stats (steamid TEXT PRIMARY KEY, kills INTEGER, deaths INTEGER)\",\n\"CREATE TABLE IF NOT EXISTS achievements (id INTEGER PRIMARY KEY, name TEXT, description TEXT)\"\n}\nfor _, query in ipairs(tables) do\n    lia.db.query(query)\n    end\n-- Create indexes\nlia.db.query(\"CREATE INDEX IF NOT EXISTS idx_player_stats_steamid ON player_stats(steamid)\")\nprint(\"Database connected and fully initialized\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#deletecharacter","title":"DeleteCharacter","text":"<p>Purpose</p> <p>Called when a character is deleted</p> <p>When Called</p> <p>When a character deletion is processed</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The character ID being deleted</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log deletion\nhook.Add(\"DeleteCharacter\", \"MyAddon\", function(id)\nprint(\"Character \" .. id .. \" deleted\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up character data\nhook.Add(\"DeleteCharacter\", \"CharacterCleanup\", function(id)\nlia.db.query(\"DELETE FROM character_items WHERE charid = ?\", id)\nlia.db.query(\"DELETE FROM character_stats WHERE charid = ?\", id)\nprint(\"Character \" .. id .. \" deleted and data cleaned up\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character deletion system\nhook.Add(\"DeleteCharacter\", \"AdvancedCharacterDeletion\", function(id)\n-- Clean up character data\nlia.db.query(\"DELETE FROM character_items WHERE charid = ?\", id)\nlia.db.query(\"DELETE FROM character_stats WHERE charid = ?\", id)\nlia.db.query(\"DELETE FROM character_achievements WHERE charid = ?\", id)\n-- Archive character data\nlia.db.query(\"INSERT INTO character_archive SELECT * FROM characters WHERE id = ?\", id)\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"Character \" .. id .. \" has been deleted\")\n        end\n    end\nprint(\"Character \" .. id .. \" deleted and archived\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#discordrelaysend","title":"DiscordRelaySend","text":"<p>Purpose</p> <p>Called to send a Discord relay message</p> <p>When Called</p> <p>When sending a message to Discord</p> <p>Parameters</p> <ul> <li><code>embed</code> (table): The Discord embed data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log Discord send\nhook.Add(\"DiscordRelaySend\", \"MyAddon\", function(embed)\nprint(\"Sending Discord message: \" .. (embed.title or \"No title\"))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add server info to embed\nhook.Add(\"DiscordRelaySend\", \"DiscordServerInfo\", function(embed)\nembed.footer = {\ntext = \"Server: \" .. GetHostName()\n}\nprint(\"Sending Discord message with server info\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex Discord relay system\nhook.Add(\"DiscordRelaySend\", \"AdvancedDiscordRelay\", function(embed)\n-- Add server info\nembed.footer = {\ntext = \"Server: \" .. GetHostName() .. \" | Players: \" .. #player.GetAll()\n}\n-- Add timestamp if not present\nif not embed.timestamp then\n    embed.timestamp = os.date(\"!%Y-%m-%dT%H:%M:%S\")\n    end\n-- Add color based on type\nif not embed.color then\n    if string.find(embed.title or \"\", \"Error\") then\n        embed.color = 16711680 -- Red\n    elseif string.find(embed.title or \"\", \"Warning\") then\n        embed.color = 16776960 -- Yellow\n    else\n        embed.color = 65280 -- Green\n        end\n    end\nprint(\"Sending Discord message: \" .. (embed.title or \"No title\"))\nend)\n</code></pre></p>"},{"location":"hooks/server/#discordrelayunavailable","title":"DiscordRelayUnavailable","text":"<p>Purpose</p> <p>Called when Discord relay is unavailable</p> <p>When Called</p> <p>When Discord relay connection fails</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log unavailability\nhook.Add(\"DiscordRelayUnavailable\", \"MyAddon\", function()\nprint(\"Discord relay is unavailable\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify admins\nhook.Add(\"DiscordRelayUnavailable\", \"DiscordNotify\", function()\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"Discord relay is unavailable\")\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex Discord failover system\nhook.Add(\"DiscordRelayUnavailable\", \"AdvancedDiscordFailover\", function()\n-- Log to file\nfile.Append(\"discord_errors.txt\", os.date() .. \": Discord relay unavailable\\n\")\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[ERROR] Discord relay is unavailable\")\n        end\n    end\n-- Attempt reconnection\ntimer.Simple(60, function()\nprint(\"Attempting to reconnect Discord relay...\")\n-- Reconnection logic here\nend)\nend)\n</code></pre></p>"},{"location":"hooks/server/#discordrelayed","title":"DiscordRelayed","text":"<p>Purpose</p> <p>Called when a message is relayed to Discord</p> <p>When Called</p> <p>After a message is successfully sent to Discord</p> <p>Parameters</p> <ul> <li><code>embed</code> (table): The Discord embed that was sent</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log successful relay\nhook.Add(\"DiscordRelayed\", \"MyAddon\", function(embed)\nprint(\"Message relayed to Discord\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track relay statistics\nhook.Add(\"DiscordRelayed\", \"DiscordStats\", function(embed)\nlocal relayCount = lia.data.get(\"discordRelayCount\", 0)\nlia.data.set(\"discordRelayCount\", relayCount + 1)\nprint(\"Message relayed to Discord (Total: \" .. (relayCount + 1) .. \")\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex Discord relay tracking\nhook.Add(\"DiscordRelayed\", \"AdvancedDiscordTracking\", function(embed)\n-- Update statistics\nlocal relayCount = lia.data.get(\"discordRelayCount\", 0)\nlia.data.set(\"discordRelayCount\", relayCount + 1)\n-- Log to database\nlia.db.query(\"INSERT INTO discord_logs (timestamp, title, description) VALUES (?, ?, ?)\",\nos.time(), embed.title or \"No title\", embed.description or \"No description\")\n-- Track relay types\nlocal relayTypes = lia.data.get(\"discordRelayTypes\", {})\nlocal msgType = embed.title or \"unknown\"\nrelayTypes[msgType] = (relayTypes[msgType] or 0) + 1\nlia.data.set(\"discordRelayTypes\", relayTypes)\nprint(\"Message relayed to Discord: \" .. msgType)\nend)\n</code></pre></p>"},{"location":"hooks/server/#doorenabledtoggled","title":"DoorEnabledToggled","text":"<p>Purpose</p> <p>Called when a door's enabled state is toggled</p> <p>When Called</p> <p>When a door is enabled or disabled</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player toggling the state</li> <li><code>door</code> (Entity): The door entity</li> <li><code>newState</code> (boolean): The new enabled state</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log door state change\nhook.Add(\"DoorEnabledToggled\", \"MyAddon\", function(client, door, newState)\nprint(client:Name() .. \" set door to \" .. (newState and \"enabled\" or \"disabled\"))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify nearby players\nhook.Add(\"DoorEnabledToggled\", \"DoorStateNotify\", function(client, door, newState)\nlocal doorPos = door:GetPos()\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:GetPos():Distance(doorPos) &lt; 500 then\n        ply:ChatPrint(\"A door has been \" .. (newState and \"enabled\" or \"disabled\"))\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door state management\nhook.Add(\"DoorEnabledToggled\", \"AdvancedDoorState\", function(client, door, newState)\n-- Log the change\nprint(client:Name() .. \" set door to \" .. (newState and \"enabled\" or \"disabled\"))\n-- Update door data\ndoor:setNetVar(\"enabled\", newState)\ndoor:setNetVar(\"lastToggled\", os.time())\ndoor:setNetVar(\"lastToggledBy\", client:SteamID())\n-- Notify nearby players\nlocal doorPos = door:GetPos()\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:GetPos():Distance(doorPos) &lt; 500 then\n        ply:ChatPrint(client:Name() .. \" \" .. (newState and \"enabled\" or \"disabled\") .. \" a door\")\n        end\n    end\n-- Log to database\nlia.db.query(\"INSERT INTO door_logs (timestamp, steamid, doorid, action) VALUES (?, ?, ?, ?)\",\nos.time(), client:SteamID(), door:MapCreationID(), newState and \"enabled\" or \"disabled\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#doorhiddentoggled","title":"DoorHiddenToggled","text":"<p>Purpose</p> <p>Called when a door's hidden state is toggled</p> <p>When Called</p> <p>When a door is made hidden or visible</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player toggling the door visibility</li> <li><code>entity</code> (Entity): The door entity</li> <li><code>newState</code> (boolean): The new hidden state</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log door visibility change\nhook.Add(\"DoorHiddenToggled\", \"MyAddon\", function(client, entity, newState)\nprint(client:Name() .. \" toggled door visibility to \" .. tostring(newState))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify nearby players\nhook.Add(\"DoorHiddenToggled\", \"NotifyDoorVisibility\", function(client, entity, newState)\nlocal doorPos = entity:GetPos()\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:GetPos():Distance(doorPos) &lt; 500 then\n        ply:ChatPrint(\"A door has been \" .. (newState and \"hidden\" or \"made visible\"))\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door visibility system\nhook.Add(\"DoorHiddenToggled\", \"AdvancedDoorVisibility\", function(client, entity, newState)\n-- Update door data\nentity:setNetVar(\"hidden\", newState)\nentity:setNetVar(\"lastToggled\", os.time())\nentity:setNetVar(\"lastToggledBy\", client:SteamID())\n-- Log to database\nlia.db.query(\"INSERT INTO door_logs (timestamp, steamid, doorid, action) VALUES (?, ?, ?, ?)\",\nos.time(), client:SteamID(), entity:MapCreationID(), newState and \"hidden\" or \"unhidden\")\n-- Notify nearby players\nlocal doorPos = entity:GetPos()\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:GetPos():Distance(doorPos) &lt; 500 and ply ~= client then\n        ply:ChatPrint(client:Name() .. \" \" .. (newState and \"hid\" or \"unhid\") .. \" a door\")\n        end\n    end\n-- Update door physics\nif newState then\n    entity:SetNoDraw(true)\n    entity:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)\nelse\n    entity:SetNoDraw(false)\n    entity:SetCollisionGroup(COLLISION_GROUP_NONE)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#doorlocktoggled","title":"DoorLockToggled","text":"<p>Purpose</p> <p>Called when a door's lock state is toggled</p> <p>When Called</p> <p>When a door is locked or unlocked</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player toggling the door lock</li> <li><code>door</code> (Entity): The door entity</li> <li><code>state</code> (boolean): True if locked, false if unlocked</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log door lock changes\nhook.Add(\"DoorLockToggled\", \"MyAddon\", function(client, door, state)\nlocal status = state and \"locked\" or \"unlocked\"\nprint(client:Name() .. \" \" .. status .. \" door \" .. door:EntIndex())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track door lock statistics\nhook.Add(\"DoorLockToggled\", \"DoorTracking\", function(client, door, state)\nlocal doorData = door:getNetVar(\"doorData\", {})\ndoorData.lockCount = (doorData.lockCount or 0) + 1\ndoorData.lastLocked = os.time()\ndoor:setNetVar(\"doorData\", doorData)\nlocal char = client:getChar()\nif char then\n    char:setData(\"doorsLocked\", (char:getData(\"doorsLocked\", 0) + 1))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door locking system\nhook.Add(\"DoorLockToggled\", \"AdvancedDoorLocking\", function(client, door, state)\nlocal char = client:getChar()\nif not char then return end\n    -- Check if player has permission to lock doors\n    if not char:hasFlags(\"D\") then\n        client:ChatPrint(\"You don't have permission to lock doors\")\n        return false\n        end\n    -- Check if door is owned by player\n    local doorOwner = door:getNetVar(\"owner\")\n    if doorOwner and doorOwner ~= char:getID() then\n        client:ChatPrint(\"You don't own this door\")\n        return false\n        end\n    -- Check for lock cooldown\n    local lastLock = char:getData(\"lastDoorLock\", 0)\n    local lockCooldown = 5 -- 5 seconds\n    if os.time() - lastLock &lt; lockCooldown then\n        client:ChatPrint(\"Please wait before locking another door\")\n        return false\n        end\n    -- Update door data\n    local doorData = door:getNetVar(\"doorData\", {})\n    doorData.lockCount = (doorData.lockCount or 0) + 1\n    doorData.lastLocked = os.time()\n    doorData.lockedBy = char:getID()\n    door:setNetVar(\"doorData\", doorData)\n    -- Update character statistics\n    char:setData(\"doorsLocked\", (char:getData(\"doorsLocked\", 0) + 1))\n    char:setData(\"lastDoorLock\", os.time())\n    -- Check for achievement\n    local doorsLocked = char:getData(\"doorsLocked\", 0)\n    if doorsLocked &gt;= 100 and not char:getData(\"achievement_locksmith\", false) then\n        char:setData(\"achievement_locksmith\", true)\n        client:ChatPrint(\"Achievement unlocked: Locksmith!\")\n        end\n    -- Notify nearby players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(door:GetPos()) &lt; 500 then\n            local status = state and \"locked\" or \"unlocked\"\n            ply:ChatPrint(client:Name() .. \" \" .. status .. \" a door\")\n            end\n        end\n    -- Log door lock\n    print(string.format(\"%s %s door %s at %s\",\n    client:Name(), state and \"locked\" or \"unlocked\", door:EntIndex(), os.date(\"%Y-%m-%d %H:%M:%S\")))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#doorownabletoggled","title":"DoorOwnableToggled","text":"<p>Purpose</p> <p>Called when a door's ownable status is toggled</p> <p>When Called</p> <p>When a door is set to be ownable or not ownable</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player toggling the ownable status</li> <li><code>door</code> (Entity): The door entity</li> <li><code>newState</code> (boolean): The new ownable state (true = ownable, false = not ownable)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log ownable toggle\nhook.Add(\"DoorOwnableToggled\", \"MyAddon\", function(client, door, newState)\nprint(client:Name() .. \" set door ownable to: \" .. tostring(newState))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle ownable state changes\nhook.Add(\"DoorOwnableToggled\", \"OwnableHandling\", function(client, door, newState)\nlocal doorData = door:getNetVar(\"doorData\", {})\ndoorData.ownable = newState\ndoor:setNetVar(\"doorData\", doorData)\nif not newState then\n    -- Clear owner when door becomes non-ownable\n    door:setNetVar(\"owner\", nil)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ownable toggle system\nhook.Add(\"DoorOwnableToggled\", \"AdvancedOwnableToggle\", function(client, door, newState)\nlocal char = client:getChar()\nif not char then return end\n    -- Update door data\n    local doorData = door:getNetVar(\"doorData\", {})\n    doorData.ownable = newState\n    doorData.ownableChangedBy = char:getID()\n    doorData.ownableChangedAt = os.time()\n    door:setNetVar(\"doorData\", doorData)\n    if not newState then\n        -- Clear owner and related data\n        local owner = door:getNetVar(\"owner\")\n        if owner then\n            door:setNetVar(\"owner\", nil)\n            door:setNetVar(\"locked\", false)\n            door:setNetVar(\"sharedWith\", {})\n            -- Notify previous owner\n            for _, ply in ipairs(player.GetAll()) do\n                if ply:SteamID() == owner then\n                    ply:ChatPrint(\"Your door has been set to non-ownable\")\n                    end\n                end\n            end\n        end\n    -- Notify nearby players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(door:GetPos()) &lt; 500 then\n            ply:ChatPrint(\"Door \" .. door:EntIndex() .. \" is now \" .. (newState and \"ownable\" or \"not ownable\"))\n            end\n        end\n    -- Log ownable toggle\n    print(string.format(\"%s set door %s ownable to: %s\",\n    client:Name(), door:EntIndex(), tostring(newState)))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#doorpriceset","title":"DoorPriceSet","text":"<p>Purpose</p> <p>Called when a door's price is set</p> <p>When Called</p> <p>When a door's purchase/rent price is changed</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player setting the price</li> <li><code>door</code> (Entity): The door entity</li> <li><code>price</code> (number): The new price</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log price change\nhook.Add(\"DoorPriceSet\", \"MyAddon\", function(client, door, price)\nprint(client:Name() .. \" set door price to $\" .. price)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate price range\nhook.Add(\"DoorPriceSet\", \"DoorPriceValidation\", function(client, door, price)\nif price &lt; 0 or price &gt; 10000 then\n    client:ChatPrint(\"Price must be between $0 and $10000\")\n    return false\n    end\ndoor:setNetVar(\"price\", price)\nclient:ChatPrint(\"Door price set to $\" .. price)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door pricing system\nhook.Add(\"DoorPriceSet\", \"AdvancedDoorPricing\", function(client, door, price)\n-- Validate price range\nif price &lt; 0 or price &gt; 10000 then\n    client:ChatPrint(\"Price must be between $0 and $10000\")\n    return false\n    end\n-- Check admin override\nif not client:IsAdmin() then\n    local char = client:getChar()\n    if not char then return false end\n        -- Check door ownership\n        local owner = door:getNetVar(\"owner\")\n        if owner ~= char:getID() then\n            client:ChatPrint(\"You don't own this door\")\n            return false\n            end\n        end\n    -- Set price\n    door:setNetVar(\"price\", price)\n    door:setNetVar(\"priceSetBy\", client:SteamID())\n    door:setNetVar(\"priceSetTime\", os.time())\n    -- Notify nearby players\n    local doorPos = door:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(doorPos) &lt; 500 and ply ~= client then\n            ply:ChatPrint(\"A door's price was set to $\" .. price)\n            end\n        end\n    client:ChatPrint(\"Door price set to $\" .. price)\n    -- Log to database\n    lia.db.query(\"INSERT INTO door_logs (timestamp, steamid, doorid, action, value) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), client:SteamID(), door:MapCreationID(), \"price_set\", price)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#doortitleset","title":"DoorTitleSet","text":"<p>Purpose</p> <p>Called when a door's title is set</p> <p>When Called</p> <p>When a door's display name is changed</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player setting the title</li> <li><code>door</code> (Entity): The door entity</li> <li><code>name</code> (string): The new door title</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log title change\nhook.Add(\"DoorTitleSet\", \"MyAddon\", function(client, door, name)\nprint(client:Name() .. \" set door title to: \" .. name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate title length\nhook.Add(\"DoorTitleSet\", \"DoorTitleValidation\", function(client, door, name)\nif #name &gt; 50 then\n    client:ChatPrint(\"Door title must be 50 characters or less\")\n    return false\n    end\ndoor:setNetVar(\"title\", name)\nclient:ChatPrint(\"Door title set to: \" .. name)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door title system\nhook.Add(\"DoorTitleSet\", \"AdvancedDoorTitle\", function(client, door, name)\n-- Validate title length\nif #name &gt; 50 then\n    client:ChatPrint(\"Door title must be 50 characters or less\")\n    return false\n    end\n-- Filter inappropriate content\nlocal bannedWords = {\"spam\", \"hack\", \"cheat\"}\nfor _, word in ipairs(bannedWords) do\n    if string.find(string.lower(name), string.lower(word)) then\n        client:ChatPrint(\"Door title contains inappropriate content\")\n        return false\n        end\n    end\n-- Check admin override\nif not client:IsAdmin() then\n    local char = client:getChar()\n    if not char then return false end\n        -- Check door ownership\n        local owner = door:getNetVar(\"owner\")\n        if owner ~= char:getID() then\n            client:ChatPrint(\"You don't own this door\")\n            return false\n            end\n        end\n    -- Set title\n    door:setNetVar(\"title\", name)\n    door:setNetVar(\"titleSetBy\", client:SteamID())\n    door:setNetVar(\"titleSetTime\", os.time())\n    -- Notify nearby players\n    local doorPos = door:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(doorPos) &lt; 500 and ply ~= client then\n            ply:ChatPrint(\"A door's title was changed to: \" .. name)\n            end\n        end\n    client:ChatPrint(\"Door title set to: \" .. name)\n    -- Log to database\n    lia.db.query(\"INSERT INTO door_logs (timestamp, steamid, doorid, action, value) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), client:SteamID(), door:MapCreationID(), \"title_set\", name)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#fetchspawns","title":"FetchSpawns","text":"<p>Purpose</p> <p>Called to fetch spawn points</p> <p>When Called</p> <p>When spawn points need to be loaded or refreshed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log spawn fetching\nhook.Add(\"FetchSpawns\", \"MyAddon\", function()\nprint(\"Fetching spawn points\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load spawn points from database\nhook.Add(\"FetchSpawns\", \"SpawnLoading\", function()\nlocal spawns = lia.db.query(\"SELECT * FROM spawns\")\nlia.spawns = spawns\nprint(\"Loaded \" .. #spawns .. \" spawn points\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex spawn point system\nhook.Add(\"FetchSpawns\", \"AdvancedSpawnSystem\", function()\n-- Load spawns from database\nlocal spawns = lia.db.query(\"SELECT * FROM spawns WHERE active = 1\")\n-- Categorize spawns by faction\nlia.spawns = {\npolice = {},\nmedic = {},\ncitizen = {},\ncriminal = {}\n}\nfor _, spawn in ipairs(spawns) do\n    local faction = spawn.faction or \"citizen\"\n    if lia.spawns[faction] then\n        table.insert(lia.spawns[faction], {\n        pos = Vector(spawn.x, spawn.y, spawn.z),\n        ang = Angle(spawn.pitch, spawn.yaw, spawn.roll),\n        name = spawn.name\n        })\n        end\n    end\n-- Log spawn counts\nfor faction, factionSpawns in pairs(lia.spawns) do\n    print(faction .. \" spawns: \" .. #factionSpawns)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#forcerecognizerange","title":"ForceRecognizeRange","text":"<p>Purpose</p> <p>Called to force recognition range</p> <p>When Called</p> <p>When setting the recognition range for a player</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player to set recognition range for</li> <li><code>range</code> (number): The recognition range</li> <li><code>fakeName</code> (string): The fake name to use (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log recognition range setting\nhook.Add(\"ForceRecognizeRange\", \"MyAddon\", function(ply, range, fakeName)\nprint(\"Set recognition range for \" .. ply:Name() .. \": \" .. range)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set recognition data\nhook.Add(\"ForceRecognizeRange\", \"RecognitionRange\", function(ply, range, fakeName)\nlocal char = ply:getChar()\nif char then\n    char:setData(\"recognitionRange\", range)\n    if fakeName then\n        char:setData(\"fakeName\", fakeName)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex recognition range system\nhook.Add(\"ForceRecognizeRange\", \"AdvancedRecognitionRange\", function(ply, range, fakeName)\nlocal char = ply:getChar()\nif not char then return end\n    -- Set recognition range\n    char:setData(\"recognitionRange\", range)\n    char:setData(\"recognitionRangeSet\", os.time())\n    -- Set fake name if provided\n    if fakeName and fakeName ~= \"\" then\n        char:setData(\"fakeName\", fakeName)\n        char:setData(\"usingFakeName\", true)\n    else\n        char:setData(\"fakeName\", nil)\n        char:setData(\"usingFakeName\", false)\n        end\n    -- Notify player\n    ply:ChatPrint(\"Recognition range set to \" .. range .. \" units\")\n    if fakeName then\n        ply:ChatPrint(\"Fake name set to: \" .. fakeName)\n        end\n    -- Log recognition range change\n    print(string.format(\"Recognition range set for %s: %d units (Fake name: %s)\",\n    ply:Name(), range, fakeName or \"None\"))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#getallcaseclaims","title":"GetAllCaseClaims","text":"<p>Purpose</p> <p>Called to get all case claims</p> <p>When Called</p> <p>When retrieving all active case claims</p> <p>Returns</p> <ul> <li>table - Table of all case claims</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return empty claims table\nhook.Add(\"GetAllCaseClaims\", \"MyAddon\", function()\nreturn {}\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load claims from database\nhook.Add(\"GetAllCaseClaims\", \"ClaimsLoading\", function()\nlocal claims = lia.db.query(\"SELECT * FROM case_claims WHERE active = 1\")\nreturn claims or {}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex case claims system\nhook.Add(\"GetAllCaseClaims\", \"AdvancedCaseClaims\", function()\n-- Load claims from database\nlocal claims = lia.db.query(\"SELECT * FROM case_claims WHERE active = 1\")\n-- Process and format claims\nlocal processedClaims = {}\nfor _, claim in ipairs(claims or {}) do\n    local processedClaim = {\n    id = claim.id,\n    caseNumber = claim.case_number,\n    claimant = claim.claimant,\n    amount = claim.amount,\n    status = claim.status,\n    createdAt = claim.created_at,\n    description = claim.description\n    }\n    -- Add claimant character info\n    local char = lia.char.getByID(claim.claimant)\n    if char then\n        processedClaim.claimantName = char:getName()\n        processedClaim.claimantFaction = char:getFaction()\n        end\n    table.insert(processedClaims, processedClaim)\n    end\n-- Sort by creation date\ntable.sort(processedClaims, function(a, b)\nreturn a.createdAt &gt; b.createdAt\nend)\nreturn processedClaims\nend)\n</code></pre></p>"},{"location":"hooks/server/#getattributemax","title":"GetAttributeMax","text":"<p>Purpose</p> <p>Called to get the maximum value for an attribute</p> <p>When Called</p> <p>When calculating attribute limits</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player whose attribute max is being checked</li> <li><code>attrKey</code> (string): The attribute key</li> </ul> <p>Returns</p> <ul> <li>number - The maximum attribute value</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default max\nhook.Add(\"GetAttributeMax\", \"MyAddon\", function(target, attrKey)\nreturn 100\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Attribute-specific maxes\nhook.Add(\"GetAttributeMax\", \"AttributeMaxes\", function(target, attrKey)\nlocal maxes = {\n[\"str\"] = 100,\n[\"dex\"] = 80,\n[\"int\"] = 120\n}\nreturn maxes[attrKey] or 100\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex attribute max system\nhook.Add(\"GetAttributeMax\", \"AdvancedAttributeMax\", function(target, attrKey)\nlocal char = target:getChar()\nif not char then return 100 end\n    -- Base max\n    local baseMax = 100\n    -- Faction bonuses\n    local faction = char:getFaction()\n    if faction == \"warrior\" and attrKey == \"str\" then\n        baseMax = baseMax + 20\n    elseif faction == \"mage\" and attrKey == \"int\" then\n        baseMax = baseMax + 30\n        end\n    -- Level bonuses\n    local level = char:getData(\"level\", 1)\n    baseMax = baseMax + (level * 2)\n    -- Item bonuses\n    local inventory = char:getInv()\n    if inventory then\n        for _, item in pairs(inventory:getItems()) do\n            if item:getData(\"equipped\", false) then\n                local attrBonus = item.attrBonus or {}\n                if attrBonus[attrKey] then\n                    baseMax = baseMax + attrBonus[attrKey]\n                    end\n                end\n            end\n        end\n    return baseMax\n    end)\n</code></pre></p>"},{"location":"hooks/server/#getattributestartingmax","title":"GetAttributeStartingMax","text":"<p>Purpose</p> <p>Called to get the starting maximum for an attribute</p> <p>When Called</p> <p>When a character is created</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player creating the character</li> <li><code>k</code> (string): The attribute key</li> </ul> <p>Returns</p> <ul> <li>number - The starting maximum attribute value</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default starting max\nhook.Add(\"GetAttributeStartingMax\", \"MyAddon\", function(client, k)\nreturn 50\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Attribute-specific starting maxes\nhook.Add(\"GetAttributeStartingMax\", \"AttributeStartingMaxes\", function(client, k)\nlocal startingMaxes = {\n[\"str\"] = 50,\n[\"dex\"] = 40,\n[\"int\"] = 60\n}\nreturn startingMaxes[k] or 50\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex starting attribute system\nhook.Add(\"GetAttributeStartingMax\", \"AdvancedStartingAttributes\", function(client, k)\n-- Base starting max\nlocal baseMax = 50\n-- Check if player has played before\nlocal playTime = client:GetUTimeTotalTime()\nif playTime &gt; 36000 then -- 10 hours\n    baseMax = baseMax + 10\n    end\n-- Check for donator status\nif client:getNetVar(\"donator\", false) then\n    baseMax = baseMax + 5\n    end\n-- Attribute-specific bonuses\nlocal attrBonuses = {\n[\"str\"] = 0,\n[\"dex\"] = -10,\n[\"int\"] = 10\n}\nbaseMax = baseMax + (attrBonuses[k] or 0)\nreturn baseMax\nend)\n</code></pre></p>"},{"location":"hooks/server/#getcharmaxstamina","title":"GetCharMaxStamina","text":"<p>Purpose</p> <p>Gets the maximum stamina for a character</p> <p>When Called</p> <p>When calculating character stamina limits</p> <p>Parameters</p> <ul> <li><code>char</code> (Character): The character to get max stamina for</li> </ul> <p>Returns</p> <ul> <li>number - The maximum stamina value</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default max stamina\nhook.Add(\"GetCharMaxStamina\", \"MyAddon\", function(char)\nreturn 100\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Base stamina on constitution\nhook.Add(\"GetCharMaxStamina\", \"ConstitutionStamina\", function(char)\nlocal con = char:getAttrib(\"con\", 0)\nreturn 100 + (con * 5)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex stamina system\nhook.Add(\"GetCharMaxStamina\", \"AdvancedStamina\", function(char)\nlocal baseStamina = 100\n-- Constitution bonus\nlocal con = char:getAttrib(\"con\", 0)\nlocal conBonus = con * 5\n-- Level bonus\nlocal charLevel = char:getData(\"level\", 1)\nlocal levelBonus = charLevel * 2\n-- Faction bonus\nlocal faction = char:getFaction()\nlocal factionBonuses = {\n[\"police\"] = 20,\n[\"medic\"] = 15,\n[\"athlete\"] = 50,\n[\"citizen\"] = 0\n}\nlocal factionBonus = factionBonuses[faction] or 0\n-- Equipment bonuses\nlocal inventory = char:getInv()\nlocal equipmentBonus = 0\nfor _, item in pairs(inventory:getItems()) do\n    if item:getData(\"equipped\", false) then\n        local staminaBonus = item:getData(\"staminaBonus\", 0)\n        equipmentBonus = equipmentBonus + staminaBonus\n        end\n    end\n-- Perk bonuses\nlocal perks = char:getData(\"perks\", {})\nlocal perkBonus = 0\nfor _, perk in ipairs(perks) do\n    if perk.type == \"stamina\" then\n        perkBonus = perkBonus + perk.value\n        end\n    end\n-- Calculate final stamina\nlocal finalStamina = baseStamina + conBonus + levelBonus + factionBonus + equipmentBonus + perkBonus\n-- Apply debuffs\nlocal debuffs = char:getData(\"debuffs\", {})\nfor _, debuff in ipairs(debuffs) do\n    if debuff.type == \"stamina\" then\n        finalStamina = finalStamina * (1 - debuff.value)\n        end\n    end\nreturn math.max(math.floor(finalStamina), 10) -- Minimum of 10\nend)\n</code></pre></p>"},{"location":"hooks/server/#getdamagescale","title":"GetDamageScale","text":"<p>Purpose</p> <p>Called to get damage scale for a hitgroup</p> <p>When Called</p> <p>When calculating damage to a player</p> <p>Parameters</p> <ul> <li><code>hitgroup</code> (number): The hitgroup that was hit</li> <li><code>dmgInfo</code> (CTakeDamageInfo): The damage info</li> <li><code>damageScale</code> (number): The current damage scale</li> </ul> <p>Returns</p> <ul> <li>number - The modified damage scale</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default scale\nhook.Add(\"GetDamageScale\", \"MyAddon\", function(hitgroup, dmgInfo, damageScale)\nreturn damageScale\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hitgroup-specific scaling\nhook.Add(\"GetDamageScale\", \"HitgroupScaling\", function(hitgroup, dmgInfo, damageScale)\nif hitgroup == HITGROUP_HEAD then\n    return damageScale * 2\nelseif hitgroup == HITGROUP_LEFTLEG or hitgroup == HITGROUP_RIGHTLEG then\n    return damageScale * 0.5\n    end\nreturn damageScale\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex damage scaling system\nhook.Add(\"GetDamageScale\", \"AdvancedDamageScale\", function(hitgroup, dmgInfo, damageScale)\nlocal attacker = dmgInfo:GetAttacker()\nlocal victim = dmgInfo:GetInflictor()\n-- Hitgroup scaling\nif hitgroup == HITGROUP_HEAD then\n    damageScale = damageScale * 2\nelseif hitgroup == HITGROUP_CHEST then\n    damageScale = damageScale * 1.2\nelseif hitgroup == HITGROUP_LEFTLEG or hitgroup == HITGROUP_RIGHTLEG then\n    damageScale = damageScale * 0.5\n    end\n-- Armor scaling\nif IsValid(victim) and victim:IsPlayer() then\n    local char = victim:getChar()\n    if char then\n        local armor = char:getData(\"armor\", 0)\n        if armor &gt; 0 then\n            damageScale = damageScale * (1 - (armor / 200))\n            end\n        end\n    end\nreturn damageScale\nend)\n</code></pre></p>"},{"location":"hooks/server/#getdefaultchardesc","title":"GetDefaultCharDesc","text":"<p>Purpose</p> <p>Called to get default character description</p> <p>When Called</p> <p>When creating a new character</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player creating the character</li> <li><code>factionIndex</code> (number): The faction index</li> <li><code>context</code> (table): Additional context data</li> </ul> <p>Returns</p> <ul> <li>string - The default description</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return generic description\nhook.Add(\"GetDefaultCharDesc\", \"MyAddon\", function(client, factionIndex, context)\nreturn \"A new character\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Faction-specific descriptions\nhook.Add(\"GetDefaultCharDesc\", \"FactionDescriptions\", function(client, factionIndex, context)\nlocal factionDescs = {\n[1] = \"A citizen of the city\",\n[2] = \"A police officer\",\n[3] = \"A medical professional\"\n}\nreturn factionDescs[factionIndex] or \"A new character\"\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex description generation\nhook.Add(\"GetDefaultCharDesc\", \"AdvancedCharDesc\", function(client, factionIndex, context)\nlocal faction = lia.faction.indices[factionIndex]\nif not faction then return \"A new character\" end\n    -- Generate description based on faction and context\n    local desc = \"A \" .. (faction.name or \"character\")\n    if context and context.model then\n        local gender = hook.Run(\"GetModelGender\", context.model) or \"person\"\n        desc = \"A \" .. gender .. \" working as a \" .. (faction.name or \"character\")\n        end\n    return desc\n    end)\n</code></pre></p>"},{"location":"hooks/server/#getdefaultcharname","title":"GetDefaultCharName","text":"<p>Purpose</p> <p>Called to get default character name</p> <p>When Called</p> <p>When creating a new character</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player creating the character</li> <li><code>factionIndex</code> (number): The faction index</li> <li><code>context</code> (table): Additional context data</li> </ul> <p>Returns</p> <ul> <li>string - The default name</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return generic name\nhook.Add(\"GetDefaultCharName\", \"MyAddon\", function(client, factionIndex, context)\nreturn \"John Doe\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Faction-specific names\nhook.Add(\"GetDefaultCharName\", \"FactionNames\", function(client, factionIndex, context)\nlocal factionNames = {\n[1] = \"Citizen #\" .. math.random(1000, 9999),\n[2] = \"Officer \" .. client:Name(),\n[3] = \"Dr. \" .. client:Name()\n}\nreturn factionNames[factionIndex] or \"John Doe\"\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex name generation\nhook.Add(\"GetDefaultCharName\", \"AdvancedCharName\", function(client, factionIndex, context)\nlocal faction = lia.faction.indices[factionIndex]\nif not faction then return \"John Doe\" end\n    -- Generate name based on faction\n    local firstName = client:Name()\n    local lastName = \"Doe\"\n    if faction.uniqueID == \"police\" then\n        return \"Officer \" .. firstName .. \" \" .. lastName\n    elseif faction.uniqueID == \"medic\" then\n        return \"Dr. \" .. firstName .. \" \" .. lastName\n    elseif faction.uniqueID == \"citizen\" then\n        return firstName .. \" \" .. lastName\n        end\n    return firstName .. \" \" .. lastName\n    end)\n</code></pre></p>"},{"location":"hooks/server/#getdefaultinventorysize","title":"GetDefaultInventorySize","text":"<p>Purpose</p> <p>Called to get default inventory size</p> <p>When Called</p> <p>When creating a character's inventory</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player</li> <li><code>char</code> (Character): The character</li> </ul> <p>Returns</p> <ul> <li>table - {width, height} inventory size</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default size\nhook.Add(\"GetDefaultInventorySize\", \"MyAddon\", function(client, char)\nreturn {6, 4}\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Faction-based sizes\nhook.Add(\"GetDefaultInventorySize\", \"FactionInventorySize\", function(client, char)\nlocal faction = char:getFaction()\nif faction == \"police\" then\n    return {8, 6}\nelseif faction == \"medic\" then\n    return {7, 5}\n    end\nreturn {6, 4}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory sizing\nhook.Add(\"GetDefaultInventorySize\", \"AdvancedInventorySize\", function(client, char)\nlocal baseSize = {6, 4}\n-- Faction bonuses\nlocal faction = char:getFaction()\nif faction == \"police\" then\n    baseSize = {8, 6}\nelseif faction == \"medic\" then\n    baseSize = {7, 5}\n    end\n-- Donator bonus\nif client:getNetVar(\"donator\", false) then\n    baseSize[1] = baseSize[1] + 2\n    baseSize[2] = baseSize[2] + 1\n    end\n-- Level bonus\nlocal level = char:getData(\"level\", 1)\nif level &gt;= 10 then\n    baseSize[1] = baseSize[1] + 1\n    end\nif level &gt;= 20 then\n    baseSize[2] = baseSize[2] + 1\n    end\nreturn baseSize\nend)\n</code></pre></p>"},{"location":"hooks/server/#getdefaultinventorytype","title":"GetDefaultInventoryType","text":"<p>Purpose</p> <p>Called to get default inventory type</p> <p>When Called</p> <p>When creating a character's inventory</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character</li> </ul> <p>Returns</p> <ul> <li>string - The inventory type</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default type\nhook.Add(\"GetDefaultInventoryType\", \"MyAddon\", function(character)\nreturn \"grid\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Faction-based types\nhook.Add(\"GetDefaultInventoryType\", \"FactionInventoryType\", function(character)\nlocal faction = character:getFaction()\nif faction == \"police\" then\n    return \"police_grid\"\nelseif faction == \"medic\" then\n    return \"medical_grid\"\n    end\nreturn \"grid\"\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory type system\nhook.Add(\"GetDefaultInventoryType\", \"AdvancedInventoryType\", function(character)\nlocal faction = character:getFaction()\nlocal level = character:getData(\"level\", 1)\n-- Faction-specific types\nif faction == \"police\" then\n    if level &gt;= 10 then\n        return \"police_advanced_grid\"\n        end\n    return \"police_grid\"\nelseif faction == \"medic\" then\n    if level &gt;= 10 then\n        return \"medical_advanced_grid\"\n        end\n    return \"medical_grid\"\n    end\n-- Default type with level progression\nif level &gt;= 20 then\n    return \"advanced_grid\"\n    end\nreturn \"grid\"\nend)\n</code></pre></p>"},{"location":"hooks/server/#getentitysavedata","title":"GetEntitySaveData","text":"<p>Purpose</p> <p>Called to get entity save data</p> <p>When Called</p> <p>When saving entity data to the database</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The entity to get save data for</li> </ul> <p>Returns</p> <ul> <li>table - The save data for the entity</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return basic save data\nhook.Add(\"GetEntitySaveData\", \"MyAddon\", function(ent)\nreturn {\npos = ent:GetPos(),\nang = ent:GetAngles(),\nmodel = ent:GetModel()\n}\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add custom entity data\nhook.Add(\"GetEntitySaveData\", \"EntityData\", function(ent)\nlocal data = {\npos = ent:GetPos(),\nang = ent:GetAngles(),\nmodel = ent:GetModel(),\nclass = ent:GetClass()\n}\n-- Add custom data\nif ent.customData then\n    data.customData = ent.customData\n    end\nreturn data\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entity save data system\nhook.Add(\"GetEntitySaveData\", \"AdvancedEntitySave\", function(ent)\nlocal data = {\npos = ent:GetPos(),\nang = ent:GetAngles(),\nmodel = ent:GetModel(),\nclass = ent:GetClass(),\nhealth = ent:Health(),\nmaxHealth = ent:GetMaxHealth()\n}\n-- Add networked variables\nlocal netVars = ent:getNetVar(\"saveData\", {})\nfor key, value in pairs(netVars) do\n    data[key] = value\n    end\n-- Add custom entity data\nif ent.customData then\n    data.customData = ent.customData\n    end\n-- Add owner information\nlocal owner = ent:getNetVar(\"owner\")\nif owner then\n    data.owner = owner\n    end\n-- Add creation timestamp\ndata.createdAt = ent:getNetVar(\"createdAt\", os.time())\nreturn data\nend)\n</code></pre></p>"},{"location":"hooks/server/#gethandsattackspeed","title":"GetHandsAttackSpeed","text":"<p>Purpose</p> <p>Called to get hands attack speed</p> <p>When Called</p> <p>When calculating unarmed attack speed for a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose attack speed is being calculated</li> </ul> <p>Returns</p> <ul> <li>number - The attack speed multiplier</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default attack speed\nhook.Add(\"GetHandsAttackSpeed\", \"MyAddon\", function(client)\nreturn 1.0\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Base speed on dexterity\nhook.Add(\"GetHandsAttackSpeed\", \"DexteritySpeed\", function(client)\nlocal char = client:getChar()\nif not char then return 1.0 end\n    local dex = char:getAttrib(\"dex\", 0)\n    return 1.0 + (dex * 0.1)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex attack speed system\nhook.Add(\"GetHandsAttackSpeed\", \"AdvancedAttackSpeed\", function(client)\nlocal char = client:getChar()\nif not char then return 1.0 end\n    local baseSpeed = 1.0\n    -- Dexterity bonus\n    local dex = char:getAttrib(\"dex\", 0)\n    local dexBonus = dex * 0.1\n    -- Level bonus\n    local level = char:getData(\"level\", 1)\n    local levelBonus = level * 0.05\n    -- Faction bonus\n    local faction = char:getFaction()\n    local factionBonuses = {\n    [\"athlete\"] = 0.3,\n    [\"police\"] = 0.1,\n    [\"citizen\"] = 0.0\n    }\n    local factionBonus = factionBonuses[faction] or 0.0\n    -- Equipment bonus\n    local equipmentBonus = 0.0\n    local inventory = char:getInv()\n    if inventory then\n        for _, item in pairs(inventory:getItems()) do\n            if item:getData(\"equipped\", false) and item.uniqueID == \"boxing_gloves\" then\n                equipmentBonus = equipmentBonus + 0.2\n                end\n            end\n        end\n    return baseSpeed + dexBonus + levelBonus + factionBonus + equipmentBonus\n    end)\n</code></pre></p>"},{"location":"hooks/server/#getitemdropmodel","title":"GetItemDropModel","text":"<p>Purpose</p> <p>Called to get item drop model</p> <p>When Called</p> <p>When determining the model for a dropped item</p> <p>Parameters</p> <ul> <li><code>itemTable</code> (table): The item table</li> <li><code>self</code> (Item): The item instance</li> </ul> <p>Returns</p> <ul> <li>string - The model path for the dropped item</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default model\nhook.Add(\"GetItemDropModel\", \"MyAddon\", function(itemTable, self)\nreturn itemTable.model or \"models/props_junk/cardboard_box004a.mdl\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use item-specific models\nhook.Add(\"GetItemDropModel\", \"ItemModels\", function(itemTable, self)\nlocal models = {\n[\"weapon_pistol\"] = \"models/weapons/w_pistol.mdl\",\n[\"medkit\"] = \"models/items/medkit.mdl\",\n[\"money\"] = \"models/props/cs_assault/money.mdl\"\n}\nreturn models[itemTable.uniqueID] or itemTable.model or \"models/props_junk/cardboard_box004a.mdl\"\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item model system\nhook.Add(\"GetItemDropModel\", \"AdvancedItemModels\", function(itemTable, self)\n-- Check for custom model in item data\nlocal customModel = self:getData(\"dropModel\")\nif customModel then\n    return customModel\n    end\n-- Check for faction-specific models\nlocal char = self:getOwner()\nif char then\n    local faction = char:getFaction()\n    local factionModels = {\n    [\"police\"] = {\n    [\"weapon_pistol\"] = \"models/weapons/w_pistol_police.mdl\"\n    },\n    [\"medic\"] = {\n    [\"medkit\"] = \"models/items/medkit_advanced.mdl\"\n    }\n    }\n    local factionModel = factionModels[faction] and factionModels[faction][itemTable.uniqueID]\n    if factionModel then\n        return factionModel\n        end\n    end\n-- Check for quality-based models\nlocal quality = self:getData(\"quality\", \"common\")\nlocal qualityModels = {\n[\"rare\"] = itemTable.rareModel,\n[\"epic\"] = itemTable.epicModel,\n[\"legendary\"] = itemTable.legendaryModel\n}\nlocal qualityModel = qualityModels[quality]\nif qualityModel then\n    return qualityModel\n    end\n-- Return default model\nreturn itemTable.model or \"models/props_junk/cardboard_box004a.mdl\"\nend)\n</code></pre></p>"},{"location":"hooks/server/#getitemstackkey","title":"GetItemStackKey","text":"<p>Purpose</p> <p>Called to get item stack key</p> <p>When Called</p> <p>When determining how items should be stacked together</p> <p>Parameters</p> <ul> <li><code>item</code> (Item): The item to get stack key for</li> </ul> <p>Returns</p> <ul> <li>string - The stack key for grouping items</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Use item ID as stack key\nhook.Add(\"GetItemStackKey\", \"MyAddon\", function(item)\nreturn item.uniqueID\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Include item data in stack key\nhook.Add(\"GetItemStackKey\", \"ItemDataStacking\", function(item)\nlocal key = item.uniqueID\n-- Include quality in stack key\nlocal quality = item:getData(\"quality\", \"common\")\nif quality ~= \"common\" then\n    key = key .. \"_\" .. quality\n    end\nreturn key\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item stacking system\nhook.Add(\"GetItemStackKey\", \"AdvancedItemStacking\", function(item)\nlocal key = item.uniqueID\n-- Include quality in stack key\nlocal quality = item:getData(\"quality\", \"common\")\nif quality ~= \"common\" then\n    key = key .. \"_\" .. quality\n    end\n-- Include durability for stackable items\nlocal durability = item:getData(\"durability\")\nif durability then\n    local durabilityTier = math.floor(durability / 20) * 20\n    key = key .. \"_dur\" .. durabilityTier\n    end\n-- Include enchantments\nlocal enchantments = item:getData(\"enchantments\", {})\nif #enchantments &gt; 0 then\n    table.sort(enchantments)\n    key = key .. \"_ench\" .. table.concat(enchantments, \"_\")\n    end\n-- Include custom data\nlocal customData = item:getData(\"stackData\")\nif customData then\n    key = key .. \"_\" .. customData\n    end\nreturn key\nend)\n</code></pre></p>"},{"location":"hooks/server/#getitemstacks","title":"GetItemStacks","text":"<p>Purpose</p> <p>Called to get item stacks in an inventory</p> <p>When Called</p> <p>When retrieving stacked items from an inventory</p> <p>Parameters</p> <ul> <li><code>inventory</code> (Inventory): The inventory to get stacks from</li> </ul> <p>Returns</p> <ul> <li>table - Table of item stacks</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return empty stacks\nhook.Add(\"GetItemStacks\", \"MyAddon\", function(inventory)\nreturn {}\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Group items by ID\nhook.Add(\"GetItemStacks\", \"BasicStacking\", function(inventory)\nlocal stacks = {}\nlocal items = inventory:getItems()\nfor _, item in pairs(items) do\n    local key = item.uniqueID\n    if not stacks[key] then\n        stacks[key] = {}\n        end\n    table.insert(stacks[key], item)\n    end\nreturn stacks\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item stacking system\nhook.Add(\"GetItemStacks\", \"AdvancedStacking\", function(inventory)\nlocal stacks = {}\nlocal items = inventory:getItems()\nfor _, item in pairs(items) do\n    -- Get stack key using the hook\n    local key = hook.Run(\"GetItemStackKey\", item) or item.uniqueID\n    if not stacks[key] then\n        stacks[key] = {\n        items = {},\n        count = 0,\n        totalWeight = 0,\n        stackData = {\n        uniqueID = item.uniqueID,\n        name = item.name,\n        model = item.model\n        }\n        }\n        end\n    table.insert(stacks[key].items, item)\n    stacks[key].count = stacks[key].count + 1\n    stacks[key].totalWeight = stacks[key].totalWeight + item:getWeight()\n    end\n-- Sort stacks by count\nlocal sortedStacks = {}\nfor key, stack in pairs(stacks) do\n    table.insert(sortedStacks, {key = key, data = stack})\n    end\ntable.sort(sortedStacks, function(a, b)\nreturn a.data.count &gt; b.data.count\nend)\nreturn sortedStacks\nend)\n</code></pre></p>"},{"location":"hooks/server/#getmaxplayerchar","title":"GetMaxPlayerChar","text":"<p>Purpose</p> <p>Called to get maximum character count for a player</p> <p>When Called</p> <p>When checking how many characters a player can have</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to check character limit for</li> </ul> <p>Returns</p> <ul> <li>number - The maximum number of characters allowed</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default limit\nhook.Add(\"GetMaxPlayerChar\", \"MyAddon\", function(client)\nreturn 3\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Different limits for different players\nhook.Add(\"GetMaxPlayerChar\", \"PlayerLimits\", function(client)\nif client:IsAdmin() then\n    return 10\nelse\n    return 3\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character limit system\nhook.Add(\"GetMaxPlayerChar\", \"AdvancedCharLimits\", function(client)\nlocal baseLimit = 3\n-- Admin bonus\nif client:IsSuperAdmin() then\n    baseLimit = baseLimit + 5\nelseif client:IsAdmin() then\n    baseLimit = baseLimit + 2\n    end\n-- Donator bonus\nlocal char = client:getChar()\nif char then\n    local donatorLevel = char:getData(\"donatorLevel\", 0)\n    baseLimit = baseLimit + donatorLevel\n    end\n-- Play time bonus\nlocal playTime = client:GetTotalPlayTime()\nlocal hours = playTime / 3600\nif hours &gt;= 100 then\n    baseLimit = baseLimit + 1\nelseif hours &gt;= 500 then\n    baseLimit = baseLimit + 2\nelseif hours &gt;= 1000 then\n    baseLimit = baseLimit + 3\n    end\n-- Faction bonus\nif char then\n    local faction = char:getFaction()\n    local factionBonuses = {\n    [\"police\"] = 1,\n    [\"medic\"] = 1,\n    [\"citizen\"] = 0\n    }\n    baseLimit = baseLimit + (factionBonuses[faction] or 0)\n    end\nreturn math.max(1, baseLimit)\nend)\n</code></pre></p>"},{"location":"hooks/server/#getmaxstartingattributepoints","title":"GetMaxStartingAttributePoints","text":"<p>Purpose</p> <p>Called to get maximum starting attribute points</p> <p>When Called</p> <p>During character creation</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player creating the character</li> <li><code>count</code> (number): The current count</li> </ul> <p>Returns</p> <ul> <li>number - The maximum starting attribute points</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default count\nhook.Add(\"GetMaxStartingAttributePoints\", \"MyAddon\", function(client, count)\nreturn 10\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Playtime-based points\nhook.Add(\"GetMaxStartingAttributePoints\", \"PlaytimePoints\", function(client, count)\nlocal playTime = client:GetUTimeTotalTime()\nif playTime &gt; 36000 then -- 10 hours\n    return 15\n    end\nreturn 10\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex starting points system\nhook.Add(\"GetMaxStartingAttributePoints\", \"AdvancedStartingPoints\", function(client, count)\nlocal basePoints = 10\n-- Playtime bonus\nlocal playTime = client:GetUTimeTotalTime()\nif playTime &gt; 36000 then\n    basePoints = basePoints + 5\n    end\n-- Donator bonus\nif client:getNetVar(\"donator\", false) then\n    basePoints = basePoints + 3\n    end\n-- Achievement bonus\nlocal achievements = client:getNetVar(\"achievements\", {})\nif #achievements &gt;= 10 then\n    basePoints = basePoints + 2\n    end\nreturn basePoints\nend)\n</code></pre></p>"},{"location":"hooks/server/#getmoneymodel","title":"GetMoneyModel","text":"<p>Purpose</p> <p>Called to get money model</p> <p>When Called</p> <p>When spawning money entity</p> <p>Parameters</p> <ul> <li><code>amount</code> (number): The money amount</li> </ul> <p>Returns</p> <ul> <li>string - The model path</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default model\nhook.Add(\"GetMoneyModel\", \"MyAddon\", function(amount)\nreturn \"models/props_lab/box01a.mdl\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Amount-based models\nhook.Add(\"GetMoneyModel\", \"AmountBasedModels\", function(amount)\nif amount &gt;= 1000 then\n    return \"models/props/cs_office/briefcase.mdl\"\nelseif amount &gt;= 100 then\n    return \"models/props_lab/box01a.mdl\"\n    end\nreturn \"models/props_junk/cardboard_box001a.mdl\"\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex money model system\nhook.Add(\"GetMoneyModel\", \"AdvancedMoneyModels\", function(amount)\n-- Different models based on amount tiers\nif amount &gt;= 10000 then\n    return \"models/props/cs_office/briefcase.mdl\"\nelseif amount &gt;= 5000 then\n    return \"models/props_c17/suitcase001a.mdl\"\nelseif amount &gt;= 1000 then\n    return \"models/props_lab/box01a.mdl\"\nelseif amount &gt;= 100 then\n    return \"models/props_junk/cardboard_box002a.mdl\"\nelse\n    return \"models/props_junk/cardboard_box001a.mdl\"\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#getoocdelay","title":"GetOOCDelay","text":"<p>Purpose</p> <p>Called to get OOC chat delay</p> <p>When Called</p> <p>When checking OOC chat cooldown</p> <p>Parameters</p> <ul> <li><code>speaker</code> (Player): The player speaking</li> </ul> <p>Returns</p> <ul> <li>number - The delay in seconds</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default delay\nhook.Add(\"GetOOCDelay\", \"MyAddon\", function(speaker)\nreturn 3\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Admin bypass\nhook.Add(\"GetOOCDelay\", \"AdminOOCBypass\", function(speaker)\nif speaker:IsAdmin() then\n    return 0\n    end\nreturn 3\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex OOC delay system\nhook.Add(\"GetOOCDelay\", \"AdvancedOOCDelay\", function(speaker)\n-- Admins have no delay\nif speaker:IsAdmin() then\n    return 0\n    end\n-- Donators have reduced delay\nif speaker:getNetVar(\"donator\", false) then\n    return 1\n    end\n-- New players have longer delay\nlocal playTime = speaker:GetUTimeTotalTime()\nif playTime &lt; 3600 then -- Less than 1 hour\n    return 5\n    end\nreturn 3\nend)\n</code></pre></p>"},{"location":"hooks/server/#getplaytime","title":"GetPlayTime","text":"<p>Purpose</p> <p>Called to get player playtime</p> <p>When Called</p> <p>When retrieving player playtime</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player</li> </ul> <p>Returns</p> <ul> <li>number - The playtime in seconds</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return UTime playtime\nhook.Add(\"GetPlayTime\", \"MyAddon\", function(client)\nreturn client:GetUTimeTotalTime()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add session time\nhook.Add(\"GetPlayTime\", \"PlayTimeWithSession\", function(client)\nlocal totalTime = client:GetUTimeTotalTime()\nlocal sessionTime = client:GetUTimeSessionTime()\nreturn totalTime + sessionTime\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex playtime tracking\nhook.Add(\"GetPlayTime\", \"AdvancedPlayTime\", function(client)\nlocal char = client:getChar()\nif not char then\n    return client:GetUTimeTotalTime()\n    end\n-- Get character-specific playtime\nlocal charPlayTime = char:getData(\"playTime\", 0)\n-- Add current session time\nlocal sessionStart = char:getData(\"sessionStart\", os.time())\nlocal sessionTime = os.time() - sessionStart\nreturn charPlayTime + sessionTime\nend)\n</code></pre></p>"},{"location":"hooks/server/#getplayerdeathsound","title":"GetPlayerDeathSound","text":"<p>Purpose</p> <p>Called to get player death sound</p> <p>When Called</p> <p>When a player dies</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The dying player</li> <li><code>isFemale</code> (boolean): Whether the player is female</li> </ul> <p>Returns</p> <ul> <li>string - The death sound path</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default sound\nhook.Add(\"GetPlayerDeathSound\", \"MyAddon\", function(client, isFemale)\nreturn \"vo/npc/male01/pain09.wav\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Gender-based sounds\nhook.Add(\"GetPlayerDeathSound\", \"GenderDeathSounds\", function(client, isFemale)\nif isFemale then\n    return \"vo/npc/female01/pain09.wav\"\n    end\nreturn \"vo/npc/male01/pain09.wav\"\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex death sound system\nhook.Add(\"GetPlayerDeathSound\", \"AdvancedDeathSounds\", function(client, isFemale)\nlocal char = client:getChar()\nif not char then\n    return isFemale and \"vo/npc/female01/pain09.wav\" or \"vo/npc/male01/pain09.wav\"\n    end\n-- Faction-specific sounds\nlocal faction = char:getFaction()\nif faction == \"combine\" then\n    return \"npc/combine_soldier/die\" .. math.random(1, 3) .. \".wav\"\nelseif faction == \"zombie\" then\n    return \"npc/zombie/zombie_die\" .. math.random(1, 3) .. \".wav\"\n    end\n-- Gender-based sounds\nif isFemale then\n    return \"vo/npc/female01/pain0\" .. math.random(7, 9) .. \".wav\"\n    end\nreturn \"vo/npc/male01/pain0\" .. math.random(7, 9) .. \".wav\"\nend)\n</code></pre></p>"},{"location":"hooks/server/#getplayerpainsound","title":"GetPlayerPainSound","text":"<p>Purpose</p> <p>Called to get player pain sound</p> <p>When Called</p> <p>When a player takes damage</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player taking damage</li> <li><code>paintype</code> (number): The type of pain</li> <li><code>isFemale</code> (boolean): Whether the player is female</li> </ul> <p>Returns</p> <ul> <li>string - The pain sound path</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default sound\nhook.Add(\"GetPlayerPainSound\", \"MyAddon\", function(client, paintype, isFemale)\nreturn \"vo/npc/male01/pain01.wav\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Gender-based pain sounds\nhook.Add(\"GetPlayerPainSound\", \"GenderPainSounds\", function(client, paintype, isFemale)\nif isFemale then\n    return \"vo/npc/female01/pain0\" .. math.random(1, 6) .. \".wav\"\n    end\nreturn \"vo/npc/male01/pain0\" .. math.random(1, 6) .. \".wav\"\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex pain sound system\nhook.Add(\"GetPlayerPainSound\", \"AdvancedPainSounds\", function(client, paintype, isFemale)\nlocal char = client:getChar()\nif not char then\n    return isFemale and \"vo/npc/female01/pain01.wav\" or \"vo/npc/male01/pain01.wav\"\n    end\n-- Faction-specific sounds\nlocal faction = char:getFaction()\nif faction == \"combine\" then\n    return \"npc/combine_soldier/pain\" .. math.random(1, 3) .. \".wav\"\nelseif faction == \"zombie\" then\n    return \"npc/zombie/zombie_pain\" .. math.random(1, 6) .. \".wav\"\n    end\n-- Pain type-based sounds\nlocal soundNum = 1\nif paintype == 1 then -- Light damage\n    soundNum = math.random(1, 3)\nelseif paintype == 2 then -- Medium damage\n    soundNum = math.random(4, 6)\nelse -- Heavy damage\n    soundNum = math.random(7, 9)\n    end\n-- Gender-based sounds\nif isFemale then\n    return \"vo/npc/female01/pain0\" .. soundNum .. \".wav\"\n    end\nreturn \"vo/npc/male01/pain0\" .. soundNum .. \".wav\"\nend)\n</code></pre></p>"},{"location":"hooks/server/#getplayerpunchdamage","title":"GetPlayerPunchDamage","text":"<p>Purpose</p> <p>Called to get player punch damage</p> <p>When Called</p> <p>When calculating unarmed punch damage for a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose punch damage is being calculated</li> </ul> <p>Returns</p> <ul> <li>number - The punch damage amount</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default punch damage\nhook.Add(\"GetPlayerPunchDamage\", \"MyAddon\", function(client)\nreturn 10\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Base damage on strength\nhook.Add(\"GetPlayerPunchDamage\", \"StrengthDamage\", function(client)\nlocal char = client:getChar()\nif not char then return 10 end\n    local str = char:getAttrib(\"str\", 0)\n    return 10 + (str * 2)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex punch damage system\nhook.Add(\"GetPlayerPunchDamage\", \"AdvancedPunchDamage\", function(client)\nlocal char = client:getChar()\nif not char then return 10 end\n    local baseDamage = 10\n    -- Strength bonus\n    local str = char:getAttrib(\"str\", 0)\n    local strBonus = str * 2\n    -- Level bonus\n    local level = char:getData(\"level\", 1)\n    local levelBonus = level * 0.5\n    -- Faction bonus\n    local faction = char:getFaction()\n    local factionBonuses = {\n    [\"athlete\"] = 5,\n    [\"police\"] = 2,\n    [\"citizen\"] = 0\n    }\n    local factionBonus = factionBonuses[faction] or 0\n    -- Equipment bonus\n    local equipmentBonus = 0\n    local inventory = char:getInv()\n    if inventory then\n        for _, item in pairs(inventory:getItems()) do\n            if item:getData(\"equipped\", false) then\n                if item.uniqueID == \"boxing_gloves\" then\n                    equipmentBonus = equipmentBonus + 5\n                elseif item.uniqueID == \"brass_knuckles\" then\n                    equipmentBonus = equipmentBonus + 8\n                    end\n                end\n            end\n        end\n    return baseDamage + strBonus + levelBonus + factionBonus + equipmentBonus\n    end)\n</code></pre></p>"},{"location":"hooks/server/#getplayerpunchragdolltime","title":"GetPlayerPunchRagdollTime","text":"<p>Purpose</p> <p>Called to get player punch ragdoll time</p> <p>When Called</p> <p>When calculating how long a player stays ragdolled from a punch</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player being punched</li> </ul> <p>Returns</p> <ul> <li>number - The ragdoll time in seconds</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default ragdoll time\nhook.Add(\"GetPlayerPunchRagdollTime\", \"MyAddon\", function(client)\nreturn 3\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Base time on constitution\nhook.Add(\"GetPlayerPunchRagdollTime\", \"ConstitutionRagdoll\", function(client)\nlocal char = client:getChar()\nif not char then return 3 end\n    local con = char:getAttrib(\"con\", 0)\n    return math.max(1, 3 - (con * 0.1))\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ragdoll time system\nhook.Add(\"GetPlayerPunchRagdollTime\", \"AdvancedRagdollTime\", function(client)\nlocal char = client:getChar()\nif not char then return 3 end\n    local baseTime = 3\n    -- Constitution reduces ragdoll time\n    local con = char:getAttrib(\"con\", 0)\n    local conReduction = con * 0.1\n    -- Level reduces ragdoll time\n    local level = char:getData(\"level\", 1)\n    local levelReduction = level * 0.05\n    -- Faction affects ragdoll time\n    local faction = char:getFaction()\n    local factionModifiers = {\n    [\"athlete\"] = -0.5,\n    [\"police\"] = -0.2,\n    [\"citizen\"] = 0,\n    [\"elderly\"] = 0.5\n    }\n    local factionModifier = factionModifiers[faction] or 0\n    -- Equipment affects ragdoll time\n    local equipmentModifier = 0\n    local inventory = char:getInv()\n    if inventory then\n        for _, item in pairs(inventory:getItems()) do\n            if item:getData(\"equipped\", false) then\n                if item.uniqueID == \"armor_vest\" then\n                    equipmentModifier = equipmentModifier + 0.3\n                elseif item.uniqueID == \"helmet\" then\n                    equipmentModifier = equipmentModifier + 0.2\n                    end\n                end\n            end\n        end\n    return math.max(0.5, baseTime - conReduction - levelReduction + factionModifier + equipmentModifier)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#getpriceoverride","title":"GetPriceOverride","text":"<p>Purpose</p> <p>Called to get price override for items</p> <p>When Called</p> <p>When calculating item prices in vendors or trading</p> <p>Parameters</p> <ul> <li><code>self</code> (Entity): The vendor or trading entity</li> <li><code>uniqueID</code> (string): The item unique ID</li> <li><code>price</code> (number): The base price</li> <li><code>isSellingToVendor</code> (boolean): Whether the player is selling to vendor</li> </ul> <p>Returns</p> <ul> <li>number - The overridden price</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return original price\nhook.Add(\"GetPriceOverride\", \"MyAddon\", function(self, uniqueID, price, isSellingToVendor)\nreturn price\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Apply faction discounts\nhook.Add(\"GetPriceOverride\", \"FactionDiscounts\", function(self, uniqueID, price, isSellingToVendor)\nlocal client = self:getNetVar(\"client\")\nif not client then return price end\n    local char = client:getChar()\n    if not char then return price end\n        local faction = char:getFaction()\n        if faction == \"police\" and uniqueID == \"weapon_pistol\" then\n            return price * 0.8 -- 20% discount\n            end\n        return price\n        end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex price override system\nhook.Add(\"GetPriceOverride\", \"AdvancedPriceOverride\", function(self, uniqueID, price, isSellingToVendor)\nlocal client = self:getNetVar(\"client\")\nif not client then return price end\n    local char = client:getChar()\n    if not char then return price end\n        local finalPrice = price\n        -- Faction discounts\n        local faction = char:getFaction()\n        local factionDiscounts = {\n        [\"police\"] = {\n        [\"weapon_pistol\"] = 0.8,\n        [\"handcuffs\"] = 0.5\n        },\n        [\"medic\"] = {\n        [\"medkit\"] = 0.7,\n        [\"bandage\"] = 0.6\n        }\n        }\n        local discounts = factionDiscounts[faction]\n        if discounts and discounts[uniqueID] then\n            finalPrice = finalPrice * discounts[uniqueID]\n            end\n        -- Level discounts\n        local level = char:getData(\"level\", 1)\n        if level &gt;= 10 then\n            finalPrice = finalPrice * 0.95 -- 5% discount\n        elseif level &gt;= 20 then\n            finalPrice = finalPrice * 0.9 -- 10% discount\n            end\n        -- Donator discounts\n        local donatorLevel = char:getData(\"donatorLevel\", 0)\n        if donatorLevel &gt; 0 then\n            finalPrice = finalPrice * (1 - (donatorLevel * 0.1))\n            end\n        -- Selling to vendor penalty\n        if isSellingToVendor then\n            finalPrice = finalPrice * 0.5 -- 50% of original price when selling\n            end\n        return math.max(1, finalPrice)\n        end)\n</code></pre></p>"},{"location":"hooks/server/#getragdolltime","title":"GetRagdollTime","text":"<p>Purpose</p> <p>Called to get ragdoll time</p> <p>When Called</p> <p>When calculating how long an entity stays ragdolled</p> <p>Parameters</p> <ul> <li><code>self</code> (Entity): The ragdoll entity</li> <li><code>time</code> (number): The base ragdoll time</li> </ul> <p>Returns</p> <ul> <li>number - The modified ragdoll time</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return original time\nhook.Add(\"GetRagdollTime\", \"MyAddon\", function(self, time)\nreturn time\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Extend ragdoll time for certain entities\nhook.Add(\"GetRagdollTime\", \"ExtendedRagdoll\", function(self, time)\nif self:GetClass() == \"prop_ragdoll\" then\n    return time * 1.5\n    end\nreturn time\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ragdoll time system\nhook.Add(\"GetRagdollTime\", \"AdvancedRagdollTime\", function(self, time)\nlocal finalTime = time\n-- Check if it's a player ragdoll\nlocal owner = self:getNetVar(\"owner\")\nif owner then\n    local ply = player.GetBySteamID(owner)\n    if IsValid(ply) then\n        local char = ply:getChar()\n        if char then\n            -- Constitution affects ragdoll time\n            local con = char:getAttrib(\"con\", 0)\n            finalTime = finalTime - (con * 0.1)\n            -- Level affects ragdoll time\n            local level = char:getData(\"level\", 1)\n            finalTime = finalTime - (level * 0.05)\n            -- Faction affects ragdoll time\n            local faction = char:getFaction()\n            local factionModifiers = {\n            [\"athlete\"] = -0.5,\n            [\"police\"] = -0.2,\n            [\"citizen\"] = 0,\n            [\"elderly\"] = 0.5\n            }\n            local factionModifier = factionModifiers[faction] or 0\n            finalTime = finalTime + factionModifier\n            end\n        end\n    end\n-- Weather affects ragdoll time\nif GetConVar(\"sv_weather\"):GetBool() then\n    finalTime = finalTime * 1.2\n    end\nreturn math.max(0.5, finalTime)\nend)\n</code></pre></p>"},{"location":"hooks/server/#getsalaryamount","title":"GetSalaryAmount","text":"<p>Purpose</p> <p>Called to get salary amount for a player</p> <p>When Called</p> <p>When calculating salary payment for a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player receiving salary</li> <li><code>faction</code> (string): The player's faction</li> <li><code>class</code> (string): The player's class</li> </ul> <p>Returns</p> <ul> <li>number - The salary amount</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return base salary\nhook.Add(\"GetSalaryAmount\", \"MyAddon\", function(client, faction, class)\nreturn 100\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Different salaries by faction\nhook.Add(\"GetSalaryAmount\", \"FactionSalaries\", function(client, faction, class)\nlocal salaries = {\n[\"police\"] = 200,\n[\"medic\"] = 150,\n[\"citizen\"] = 50\n}\nreturn salaries[faction] or 50\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex salary system\nhook.Add(\"GetSalaryAmount\", \"AdvancedSalary\", function(client, faction, class)\nlocal char = client:getChar()\nif not char then return 0 end\n    local baseSalary = 50\n    -- Faction base salaries\n    local factionSalaries = {\n    [\"police\"] = 200,\n    [\"medic\"] = 150,\n    [\"citizen\"] = 50,\n    [\"criminal\"] = 0\n    }\n    baseSalary = factionSalaries[faction] or 50\n    -- Class bonuses\n    local classBonuses = {\n    [\"officer\"] = 50,\n    [\"sergeant\"] = 100,\n    [\"lieutenant\"] = 150,\n    [\"nurse\"] = 25,\n    [\"doctor\"] = 75\n    }\n    local classBonus = classBonuses[class] or 0\n    -- Level bonus\n    local level = char:getData(\"level\", 1)\n    local levelBonus = level * 10\n    -- Performance bonus\n    local performance = char:getData(\"performance\", 0)\n    local performanceBonus = performance * 5\n    -- Donator bonus\n    local donatorLevel = char:getData(\"donatorLevel\", 0)\n    local donatorBonus = donatorLevel * 25\n    return baseSalary + classBonus + levelBonus + performanceBonus + donatorBonus\n    end)\n</code></pre></p>"},{"location":"hooks/server/#getticketsbyrequester","title":"GetTicketsByRequester","text":"<p>Purpose</p> <p>Called to get tickets by requester</p> <p>When Called</p> <p>When retrieving tickets created by a specific player</p> <p>Parameters</p> <ul> <li><code>steamID</code> (string): The Steam ID of the requester</li> </ul> <p>Returns</p> <ul> <li>table - Table of tickets created by the requester</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return empty tickets\nhook.Add(\"GetTicketsByRequester\", \"MyAddon\", function(steamID)\nreturn {}\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load tickets from database\nhook.Add(\"GetTicketsByRequester\", \"TicketLoading\", function(steamID)\nlocal tickets = lia.db.query(\"SELECT * FROM tickets WHERE requester = ?\", steamID)\nreturn tickets or {}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ticket retrieval system\nhook.Add(\"GetTicketsByRequester\", \"AdvancedTicketRetrieval\", function(steamID)\n-- Load tickets from database\nlocal tickets = lia.db.query(\"SELECT * FROM tickets WHERE requester = ? ORDER BY created_at DESC\", steamID)\nif not tickets then return {} end\n    -- Process tickets\n    local processedTickets = {}\n    for _, ticket in ipairs(tickets) do\n        local processedTicket = {\n        id = ticket.id,\n        title = ticket.title,\n        description = ticket.description,\n        status = ticket.status,\n        priority = ticket.priority,\n        createdAt = ticket.created_at,\n        updatedAt = ticket.updated_at,\n        assignedTo = ticket.assigned_to\n        }\n        -- Add requester character info\n        local requesterChar = lia.char.getByID(ticket.requester)\n        if requesterChar then\n            processedTicket.requesterName = requesterChar:getName()\n            processedTicket.requesterFaction = requesterChar:getFaction()\n            end\n        -- Add assignee character info\n        if ticket.assigned_to then\n            local assigneeChar = lia.char.getByID(ticket.assigned_to)\n            if assigneeChar then\n                processedTicket.assigneeName = assigneeChar:getName()\n                end\n            end\n        table.insert(processedTickets, processedTicket)\n        end\n    return processedTickets\n    end)\n</code></pre></p>"},{"location":"hooks/server/#getvendorsalescale","title":"GetVendorSaleScale","text":"<p>Purpose</p> <p>Called to get vendor sale scale</p> <p>When Called</p> <p>When calculating the sale price multiplier for a vendor</p> <p>Parameters</p> <ul> <li><code>self</code> (Entity): The vendor entity</li> </ul> <p>Returns</p> <ul> <li>number - The sale scale multiplier</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default scale\nhook.Add(\"GetVendorSaleScale\", \"MyAddon\", function(self)\nreturn 1.0\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Different scales for different vendors\nhook.Add(\"GetVendorSaleScale\", \"VendorScales\", function(self)\nlocal vendorType = self:getNetVar(\"vendorType\", \"general\")\nlocal scales = {\n[\"weapon\"] = 0.8,\n[\"medical\"] = 0.9,\n[\"general\"] = 1.0\n}\nreturn scales[vendorType] or 1.0\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor sale scale system\nhook.Add(\"GetVendorSaleScale\", \"AdvancedVendorScale\", function(self)\nlocal baseScale = 1.0\n-- Vendor type affects scale\nlocal vendorType = self:getNetVar(\"vendorType\", \"general\")\nlocal typeScales = {\n[\"weapon\"] = 0.8,\n[\"medical\"] = 0.9,\n[\"food\"] = 1.1,\n[\"general\"] = 1.0\n}\nbaseScale = typeScales[vendorType] or 1.0\n-- Vendor level affects scale\nlocal vendorLevel = self:getNetVar(\"level\", 1)\nlocal levelModifier = 1 + (vendorLevel * 0.1)\n-- Vendor reputation affects scale\nlocal reputation = self:getNetVar(\"reputation\", 0)\nlocal reputationModifier = 1 + (reputation * 0.05)\n-- Time of day affects scale\nlocal hour = tonumber(os.date(\"%H\"))\nlocal timeModifier = 1.0\nif hour &gt;= 6 and hour &lt;= 18 then\n    timeModifier = 1.1 -- Daytime bonus\nelse\n    timeModifier = 0.9 -- Nighttime penalty\n    end\n-- Server population affects scale\nlocal playerCount = #player.GetAll()\nlocal populationModifier = 1 + (playerCount * 0.01)\nreturn baseScale * levelModifier * reputationModifier * timeModifier * populationModifier\nend)\n</code></pre></p>"},{"location":"hooks/server/#getwarnings","title":"GetWarnings","text":"<p>Purpose</p> <p>Called to get warnings for a character</p> <p>When Called</p> <p>When retrieving warnings for a specific character</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The character ID to get warnings for</li> </ul> <p>Returns</p> <ul> <li>table - Table of warnings for the character</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return empty warnings\nhook.Add(\"GetWarnings\", \"MyAddon\", function(charID)\nreturn {}\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load warnings from database\nhook.Add(\"GetWarnings\", \"WarningLoading\", function(charID)\nlocal warnings = lia.db.query(\"SELECT * FROM warnings WHERE char_id = ?\", charID)\nreturn warnings or {}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex warning retrieval system\nhook.Add(\"GetWarnings\", \"AdvancedWarningRetrieval\", function(charID)\n-- Load warnings from database\nlocal warnings = lia.db.query(\"SELECT * FROM warnings WHERE char_id = ? ORDER BY created_at DESC\", charID)\nif not warnings then return {} end\n    -- Process warnings\n    local processedWarnings = {}\n    for _, warning in ipairs(warnings) do\n        local processedWarning = {\n        id = warning.id,\n        charID = warning.char_id,\n        warned = warning.warned,\n        warnedSteamID = warning.warned_steamid,\n        message = warning.message,\n        warner = warning.warner,\n        warnerSteamID = warning.warner_steamid,\n        timestamp = warning.created_at,\n        severity = warning.severity or \"medium\"\n        }\n        -- Add character names\n        local warnedChar = lia.char.getByID(warning.char_id)\n        if warnedChar then\n            processedWarning.warnedName = warnedChar:getName()\n            end\n        local warnerChar = lia.char.getByID(warning.warner)\n        if warnerChar then\n            processedWarning.warnerName = warnerChar:getName()\n            end\n        table.insert(processedWarnings, processedWarning)\n        end\n    return processedWarnings\n    end)\n</code></pre></p>"},{"location":"hooks/server/#getwarningsbyissuer","title":"GetWarningsByIssuer","text":"<p>Purpose</p> <p>Called to get warnings by issuer</p> <p>When Called</p> <p>When retrieving warnings issued by a specific player</p> <p>Parameters</p> <ul> <li><code>steamID</code> (string): The Steam ID of the issuer</li> </ul> <p>Returns</p> <ul> <li>table - Table of warnings issued by the player</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return empty warnings\nhook.Add(\"GetWarningsByIssuer\", \"MyAddon\", function(steamID)\nreturn {}\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load warnings from database\nhook.Add(\"GetWarningsByIssuer\", \"IssuerWarnings\", function(steamID)\nlocal warnings = lia.db.query(\"SELECT * FROM warnings WHERE warner_steamid = ?\", steamID)\nreturn warnings or {}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex warning retrieval by issuer\nhook.Add(\"GetWarningsByIssuer\", \"AdvancedIssuerWarnings\", function(steamID)\n-- Load warnings from database\nlocal warnings = lia.db.query(\"SELECT * FROM warnings WHERE warner_steamid = ? ORDER BY created_at DESC\", steamID)\nif not warnings then return {} end\n    -- Process warnings\n    local processedWarnings = {}\n    for _, warning in ipairs(warnings) do\n        local processedWarning = {\n        id = warning.id,\n        charID = warning.char_id,\n        warned = warning.warned,\n        warnedSteamID = warning.warned_steamid,\n        message = warning.message,\n        warner = warning.warner,\n        warnerSteamID = warning.warner_steamid,\n        timestamp = warning.created_at,\n        severity = warning.severity or \"medium\"\n        }\n        -- Add character names\n        local warnedChar = lia.char.getByID(warning.char_id)\n        if warnedChar then\n            processedWarning.warnedName = warnedChar:getName()\n            processedWarning.warnedFaction = warnedChar:getFaction()\n            end\n        -- Add issuer character info\n        local issuerChar = lia.char.getByID(warning.warner)\n        if issuerChar then\n            processedWarning.issuerName = issuerChar:getName()\n            processedWarning.issuerFaction = issuerChar:getFaction()\n            end\n        table.insert(processedWarnings, processedWarning)\n        end\n    -- Calculate issuer statistics\n    local stats = {\n    totalWarnings = #processedWarnings,\n    recentWarnings = 0,\n    severityCounts = {}\n    }\n    local oneWeekAgo = os.time() - (7 * 24 * 60 * 60)\n    for _, warning in ipairs(processedWarnings) do\n        if warning.timestamp &gt; oneWeekAgo then\n            stats.recentWarnings = stats.recentWarnings + 1\n            end\n        stats.severityCounts[warning.severity] = (stats.severityCounts[warning.severity] or 0) + 1\n        end\n    return processedWarnings, stats\n    end)\n</code></pre></p>"},{"location":"hooks/server/#handleitemtransferrequest","title":"HandleItemTransferRequest","text":"<p>Purpose</p> <p>Called to handle item transfer requests</p> <p>When Called</p> <p>When a player requests to transfer an item</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player making the request</li> <li><code>itemID</code> (string): The ID of the item to transfer</li> <li><code>x</code> (number): The X position in the inventory</li> <li><code>y</code> (number): The Y position in the inventory</li> <li><code>invID</code> (string): The destination inventory ID</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log transfer request\nhook.Add(\"HandleItemTransferRequest\", \"MyAddon\", function(client, itemID, x, y, invID)\nprint(client:Name() .. \" wants to transfer \" .. itemID)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate transfer request\nhook.Add(\"HandleItemTransferRequest\", \"TransferValidation\", function(client, itemID, x, y, invID)\nlocal char = client:getChar()\nif not char then return end\n    local item = lia.item.instance(itemID)\n    if not item then\n        client:ChatPrint(\"Invalid item\")\n        return\n        end\n    -- Check if player owns the item\n    local inventory = char:getInv()\n    if not inventory:hasItem(item) then\n        client:ChatPrint(\"You don't own this item\")\n        return\n        end\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item transfer system\nhook.Add(\"HandleItemTransferRequest\", \"AdvancedItemTransfer\", function(client, itemID, x, y, invID)\nlocal char = client:getChar()\nif not char then return end\n    -- Get source inventory\n    local sourceInventory = char:getInv()\n    if not sourceInventory then return end\n        -- Get destination inventory\n        local destInventory = lia.inventory.getByID(invID)\n        if not destInventory then\n            client:ChatPrint(\"Invalid destination inventory\")\n            return\n            end\n        -- Get item\n        local item = lia.item.instance(itemID)\n        if not item then\n            client:ChatPrint(\"Invalid item\")\n            return\n            end\n        -- Check if player owns the item\n        if not sourceInventory:hasItem(item) then\n            client:ChatPrint(\"You don't own this item\")\n            return\n            end\n        -- Check transfer permissions\n        if not hook.Run(\"CanItemBeTransfered\", item, sourceInventory, destInventory, client) then\n            return\n            end\n        -- Check destination space\n        if not destInventory:canFit(item, x, y) then\n            client:ChatPrint(\"Not enough space in destination inventory\")\n            return\n            end\n        -- Perform transfer\n        sourceInventory:remove(item)\n        destInventory:add(item, x, y)\n        -- Log transfer\n        lia.log.add(client, \"item_transfer\", itemID, \"Transferred to inventory \" .. invID)\n        client:ChatPrint(\"Item transferred successfully\")\n        end)\n</code></pre></p>"},{"location":"hooks/server/#initializestorage","title":"InitializeStorage","text":"<p>Purpose</p> <p>Called to initialize storage</p> <p>When Called</p> <p>When a storage entity is being initialized</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The storage entity</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log storage initialization\nhook.Add(\"InitializeStorage\", \"MyAddon\", function(entity)\nprint(\"Initializing storage: \" .. entity:EntIndex())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set up basic storage data\nhook.Add(\"InitializeStorage\", \"StorageSetup\", function(entity)\nentity:setNetVar(\"storageType\", \"general\")\nentity:setNetVar(\"maxWeight\", 100)\nentity:setNetVar(\"maxItems\", 50)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage initialization system\nhook.Add(\"InitializeStorage\", \"AdvancedStorageInit\", function(entity)\n-- Set storage type\nlocal storageType = entity:getNetVar(\"storageType\", \"general\")\n-- Configure based on storage type\nlocal configs = {\n[\"general\"] = {maxWeight = 100, maxItems = 50, size = {w = 6, h = 4}},\n[\"weapon\"] = {maxWeight = 200, maxItems = 20, size = {w = 4, h = 5}},\n[\"medical\"] = {maxWeight = 50, maxItems = 30, size = {w = 5, h = 6}},\n[\"food\"] = {maxWeight = 30, maxItems = 40, size = {w = 8, h = 5}}\n}\nlocal config = configs[storageType] or configs[\"general\"]\n-- Set storage properties\nentity:setNetVar(\"maxWeight\", config.maxWeight)\nentity:setNetVar(\"maxItems\", config.maxItems)\nentity:setNetVar(\"inventorySize\", config.size)\n-- Set access permissions\nlocal owner = entity:getNetVar(\"owner\")\nif owner then\n    entity:setNetVar(\"accessList\", {owner})\n    end\n-- Initialize inventory\nlocal inventory = lia.inventory.new(entity:EntIndex(), \"storage\")\nif inventory then\n    inventory:setSize(config.size.w, config.size.h)\n    inventory:setData(\"maxWeight\", config.maxWeight)\n    inventory:setData(\"storageType\", storageType)\n    entity:setNetVar(\"inventoryID\", inventory:getID())\n    end\n-- Set creation timestamp\nentity:setNetVar(\"createdAt\", os.time())\nprint(\"Storage initialized: \" .. entity:EntIndex() .. \" (Type: \" .. storageType .. \")\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#inventorydeleted","title":"InventoryDeleted","text":"<p>Purpose</p> <p>Called when an inventory is deleted</p> <p>When Called</p> <p>When an inventory is removed from the system</p> <p>Parameters</p> <ul> <li><code>instance</code> (Inventory): The inventory being deleted</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log inventory deletion\nhook.Add(\"InventoryDeleted\", \"MyAddon\", function(instance)\nprint(\"Inventory deleted: \" .. instance:getID())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up inventory data\nhook.Add(\"InventoryDeleted\", \"CleanupInventory\", function(instance)\n-- Remove from cache\nlia.inventoryCache[instance:getID()] = nil\nprint(\"Inventory deleted and cleaned up: \" .. instance:getID())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory deletion handling\nhook.Add(\"InventoryDeleted\", \"AdvancedInventoryDeletion\", function(instance)\nlocal invID = instance:getID()\n-- Archive inventory data\nlia.db.query(\"INSERT INTO inventory_archive SELECT * FROM inventories WHERE id = ?\", invID)\n-- Clean up related data\nlia.db.query(\"DELETE FROM inventory_items WHERE invid = ?\", invID)\nlia.db.query(\"DELETE FROM inventory_logs WHERE invid = ?\", invID)\n-- Remove from cache\nlia.inventoryCache[invID] = nil\n-- Notify owner\nlocal owner = instance:getOwner()\nif IsValid(owner) then\n    owner:ChatPrint(\"Your inventory has been deleted\")\n    end\n-- Log deletion\nprint(\"Inventory deleted: \" .. invID)\nlia.log.add(\"Inventory \" .. invID .. \" was deleted\", \"inventory\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#inventoryitemadded","title":"InventoryItemAdded","text":"<p>Purpose</p> <p>Called when an item is added to an inventory</p> <p>When Called</p> <p>When an item is placed into an inventory</p> <p>Parameters</p> <ul> <li><code>inventory</code> (Inventory): The inventory receiving the item</li> <li><code>item</code> (Item): The item being added</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item addition\nhook.Add(\"InventoryItemAdded\", \"MyAddon\", function(inventory, item)\nprint(\"Item added: \" .. item.name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update inventory weight\nhook.Add(\"InventoryItemAdded\", \"UpdateInventoryWeight\", function(inventory, item)\nlocal currentWeight = inventory:getData(\"weight\", 0)\nlocal itemWeight = item.weight or 1\ninventory:setData(\"weight\", currentWeight + itemWeight)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item addition handling\nhook.Add(\"InventoryItemAdded\", \"AdvancedItemAddition\", function(inventory, item)\nif SERVER then\n    -- Update inventory weight\n    local currentWeight = inventory:getData(\"weight\", 0)\n    local itemWeight = item.weight or 1\n    inventory:setData(\"weight\", currentWeight + itemWeight)\n    -- Log to database\n    lia.db.query(\"INSERT INTO inventory_logs (timestamp, invid, itemid, action) VALUES (?, ?, ?, ?)\",\n    os.time(), inventory:getID(), item:getID(), \"added\")\n    -- Notify owner\n    local owner = inventory:getOwner()\n    if IsValid(owner) then\n        owner:ChatPrint(\"Added \" .. item.name .. \" to inventory\")\n        end\n    -- Check for set bonuses\n    local items = inventory:getItems()\n    local armorPieces = 0\n    for _, invItem in pairs(items) do\n        if string.find(invItem.uniqueID, \"armor_\") then\n            armorPieces = armorPieces + 1\n            end\n        end\n    if armorPieces &gt;= 3 and IsValid(owner) then\n        local char = owner:getChar()\n        if char then\n            char:setData(\"armorSetBonus\", true)\n            owner:ChatPrint(\"Armor set bonus activated!\")\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#inventoryitemremoved","title":"InventoryItemRemoved","text":"<p>Purpose</p> <p>Called when an item is removed from an inventory</p> <p>When Called</p> <p>When an item is taken out of an inventory</p> <p>Parameters</p> <ul> <li><code>self</code> (Item): The item being removed</li> <li><code>instance</code> (Inventory): The inventory the item is being removed from</li> <li><code>preserveItem</code> (boolean): Whether to preserve the item after removal</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item removal\nhook.Add(\"InventoryItemRemoved\", \"MyAddon\", function(self, instance, preserveItem)\nprint(\"Item removed: \" .. self.name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update inventory weight\nhook.Add(\"InventoryItemRemoved\", \"UpdateWeightOnRemove\", function(self, instance, preserveItem)\nlocal currentWeight = instance:getData(\"weight\", 0)\nlocal itemWeight = self.weight or 1\ninstance:setData(\"weight\", math.max(0, currentWeight - itemWeight))\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item removal handling\nhook.Add(\"InventoryItemRemoved\", \"AdvancedItemRemoval\", function(self, instance, preserveItem)\nif SERVER then\n    -- Update inventory weight\n    local currentWeight = instance:getData(\"weight\", 0)\n    local itemWeight = self.weight or 1\n    instance:setData(\"weight\", math.max(0, currentWeight - itemWeight))\n    -- Log to database\n    lia.db.query(\"INSERT INTO inventory_logs (timestamp, invid, itemid, action) VALUES (?, ?, ?, ?)\",\n    os.time(), instance:getID(), self:getID(), \"removed\")\n    -- Notify owner\n    local owner = instance:getOwner()\n    if IsValid(owner) then\n        owner:ChatPrint(\"Removed \" .. self.name .. \" from inventory\")\n        end\n    -- Check for set bonus removal\n    if string.find(self.uniqueID, \"armor_\") then\n        local items = instance:getItems()\n        local armorPieces = 0\n        for _, invItem in pairs(items) do\n            if string.find(invItem.uniqueID, \"armor_\") and invItem ~= self then\n                armorPieces = armorPieces + 1\n                end\n            end\n        if armorPieces &lt; 3 and IsValid(owner) then\n            local char = owner:getChar()\n            if char and char:getData(\"armorSetBonus\", false) then\n                char:setData(\"armorSetBonus\", false)\n                owner:ChatPrint(\"Armor set bonus deactivated\")\n                end\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#issuitablefortrunk","title":"IsSuitableForTrunk","text":"<p>Purpose</p> <p>Called to check if an entity is suitable for trunk storage</p> <p>When Called</p> <p>When determining if an entity can be used as a trunk/storage</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The entity being checked</li> </ul> <p>Returns</p> <ul> <li>boolean - True if suitable, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Only vehicles are suitable\nhook.Add(\"IsSuitableForTrunk\", \"MyAddon\", function(entity)\nreturn entity:IsVehicle()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Specific entity classes\nhook.Add(\"IsSuitableForTrunk\", \"TrunkEntityCheck\", function(entity)\nlocal suitableClasses = {\n[\"prop_vehicle_jeep\"] = true,\n[\"prop_vehicle_airboat\"] = true,\n[\"prop_physics\"] = true\n}\nreturn suitableClasses[entity:GetClass()] or false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex trunk suitability system\nhook.Add(\"IsSuitableForTrunk\", \"AdvancedTrunkCheck\", function(entity)\nif not IsValid(entity) then return false end\n    -- Check entity class\n    local suitableClasses = {\n    [\"prop_vehicle_jeep\"] = true,\n    [\"prop_vehicle_airboat\"] = true,\n    [\"prop_physics\"] = true\n    }\n    if not suitableClasses[entity:GetClass()] then\n        return false\n        end\n    -- Check if entity has trunk flag\n    if entity:getNetVar(\"hasTrunk\", false) == false then\n        return false\n        end\n    -- Check entity size for props\n    if entity:GetClass() == \"prop_physics\" then\n        local mins, maxs = entity:GetCollisionBounds()\n        local volume = (maxs.x - mins.x) * (maxs.y - mins.y) * (maxs.z - mins.z)\n        if volume &lt; 1000 then -- Too small\n            return false\n            end\n        end\n    -- Check if entity is locked\n    if entity:getNetVar(\"locked\", false) then\n        return false\n        end\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#itemcombine","title":"ItemCombine","text":"<p>Purpose</p> <p>Called when items are combined</p> <p>When Called</p> <p>When a player attempts to combine two items</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player combining items</li> <li><code>item</code> (Item): The first item</li> <li><code>target</code> (Item): The second item being combined with</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all combinations\nhook.Add(\"ItemCombine\", \"MyAddon\", function(client, item, target)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Specific item combinations\nhook.Add(\"ItemCombine\", \"ItemCombinations\", function(client, item, target)\n-- Allow combining weapon parts\nif item.uniqueID == \"weapon_part_a\" and target.uniqueID == \"weapon_part_b\" then\n    -- Create combined weapon\n    local newItem = lia.item.instance(\"weapon_combined\")\n    if newItem then\n        local char = client:getChar()\n        if char then\n            char:getInv():add(newItem)\n            item:remove()\n            target:remove()\n            client:ChatPrint(\"Items combined successfully!\")\n            return true\n            end\n        end\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item combination system\nhook.Add(\"ItemCombine\", \"AdvancedItemCombine\", function(client, item, target)\nlocal char = client:getChar()\nif not char then return false end\n    -- Define combination recipes\n    local recipes = {\n    {items = {\"weapon_part_a\", \"weapon_part_b\"}, result = \"weapon_combined\", skill = 5},\n    {items = {\"metal_ore\", \"metal_ore\"}, result = \"metal_bar\", skill = 3},\n    {items = {\"herb_a\", \"herb_b\"}, result = \"potion_health\", skill = 7}\n    }\n    -- Check each recipe\n    for _, recipe in ipairs(recipes) do\n        local hasItems = (table.HasValue(recipe.items, item.uniqueID) and table.HasValue(recipe.items, target.uniqueID))\n        if hasItems then\n            -- Check skill requirement\n            local craftingSkill = char:getData(\"craftingSkill\", 0)\n            if craftingSkill &lt; recipe.skill then\n                client:ChatPrint(\"You need crafting skill level \" .. recipe.skill .. \" to combine these items\")\n                return false\n                end\n            -- Create result item\n            local newItem = lia.item.instance(recipe.result)\n            if newItem then\n                char:getInv():add(newItem)\n                item:remove()\n                target:remove()\n                -- Grant experience\n                local currentSkill = char:getData(\"craftingSkill\", 0)\n                char:setData(\"craftingSkill\", currentSkill + 1)\n                client:ChatPrint(\"Items combined successfully! Crafting skill increased.\")\n                return true\n                end\n            end\n        end\n    client:ChatPrint(\"These items cannot be combined\")\n    return false\n    end)\n</code></pre></p>"},{"location":"hooks/server/#itemdeleted","title":"ItemDeleted","text":"<p>Purpose</p> <p>Called when an item is deleted</p> <p>When Called</p> <p>When an item is removed from the system</p> <p>Parameters</p> <ul> <li><code>instance</code> (Item): The item being deleted</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item deletion\nhook.Add(\"ItemDeleted\", \"MyAddon\", function(instance)\nprint(\"Item deleted: \" .. instance.name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up item data\nhook.Add(\"ItemDeleted\", \"CleanupItemData\", function(instance)\n-- Remove from cache\nlia.itemCache[instance:getID()] = nil\nprint(\"Item deleted and cleaned up: \" .. instance.name)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item deletion handling\nhook.Add(\"ItemDeleted\", \"AdvancedItemDeletion\", function(instance)\nlocal itemID = instance:getID()\n-- Archive item data\nlia.db.query(\"INSERT INTO item_archive SELECT * FROM items WHERE id = ?\", itemID)\n-- Clean up related data\nlia.db.query(\"DELETE FROM item_data WHERE itemid = ?\", itemID)\nlia.db.query(\"DELETE FROM item_logs WHERE itemid = ?\", itemID)\n-- Remove from cache\nlia.itemCache[itemID] = nil\n-- Notify owner\nlocal owner = instance:getOwner()\nif IsValid(owner) then\n    owner:ChatPrint(instance.name .. \" has been deleted\")\n    end\n-- Log deletion\nprint(\"Item deleted: \" .. instance.name .. \" (ID: \" .. itemID .. \")\")\nlia.log.add(\"Item \" .. instance.name .. \" (\" .. itemID .. \") was deleted\", \"item\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#itemdraggedoutofinventory","title":"ItemDraggedOutOfInventory","text":"<p>Purpose</p> <p>Called when an item is dragged out of inventory</p> <p>When Called</p> <p>When a player drags an item outside the inventory panel</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player dragging the item</li> <li><code>item</code> (Item): The item being dragged</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all drags\nhook.Add(\"ItemDraggedOutOfInventory\", \"MyAddon\", function(client, item)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Prevent dragging equipped items\nhook.Add(\"ItemDraggedOutOfInventory\", \"PreventEquippedDrag\", function(client, item)\nif item:getData(\"equipped\", false) then\n    client:ChatPrint(\"Cannot drag equipped items\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex drag validation\nhook.Add(\"ItemDraggedOutOfInventory\", \"AdvancedDragValidation\", function(client, item)\nlocal char = client:getChar()\nif not char then return false end\n    -- Prevent dragging equipped items\n    if item:getData(\"equipped\", false) then\n        client:ChatPrint(\"Cannot drag equipped items\")\n        return false\n        end\n    -- Prevent dragging bound items\n    if item:getData(\"bound\", false) then\n        local boundTo = item:getData(\"boundTo\")\n        if boundTo == char:getID() then\n            client:ChatPrint(\"This item is bound to you and cannot be dropped\")\n            return false\n            end\n        end\n    -- Prevent dragging quest items\n    if item:getData(\"questItem\", false) then\n        client:ChatPrint(\"Quest items cannot be dropped\")\n        return false\n        end\n    -- Check cooldown\n    local lastDrag = char:getData(\"lastItemDrag\", 0)\n    if CurTime() - lastDrag &lt; 1 then\n        return false\n        end\n    char:setData(\"lastItemDrag\", CurTime())\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#itemfunctioncalled","title":"ItemFunctionCalled","text":"<p>Purpose</p> <p>Called when an item function is called</p> <p>When Called</p> <p>When a player uses an item function</p> <p>Parameters</p> <ul> <li><code>self</code> (Item): The item whose function was called</li> <li><code>method</code> (string): The function name that was called</li> <li><code>client</code> (Player): The player calling the function</li> <li><code>entity</code> (Entity): The entity involved (if any)</li> <li><code>results</code> (table): The results from the function</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log function calls\nhook.Add(\"ItemFunctionCalled\", \"MyAddon\", function(self, method, client, entity, results)\nprint(client:Name() .. \" used \" .. method .. \" on \" .. self.name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track function usage\nhook.Add(\"ItemFunctionCalled\", \"TrackItemUsage\", function(self, method, client, entity, results)\nlocal char = client:getChar()\nif char then\n    local usageCount = char:getData(\"itemUsage_\" .. self.uniqueID, 0)\n    char:setData(\"itemUsage_\" .. self.uniqueID, usageCount + 1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex function tracking system\nhook.Add(\"ItemFunctionCalled\", \"AdvancedFunctionTracking\", function(self, method, client, entity, results)\nlocal char = client:getChar()\nif not char then return end\n    -- Log to database\n    lia.db.query(\"INSERT INTO item_function_logs (timestamp, itemid, method, charid, steamid) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), self:getID(), method, char:getID(), client:SteamID())\n    -- Track usage statistics\n    local usageCount = char:getData(\"itemUsage_\" .. self.uniqueID, 0)\n    char:setData(\"itemUsage_\" .. self.uniqueID, usageCount + 1)\n    -- Check for achievements\n    if usageCount + 1 &gt;= 100 then\n        if not char:getData(\"achievement_itemMaster_\" .. self.uniqueID, false) then\n            char:setData(\"achievement_itemMaster_\" .. self.uniqueID, true)\n            client:ChatPrint(\"Achievement unlocked: Master of \" .. self.name)\n            end\n        end\n    -- Handle specific methods\n    if method == \"use\" then\n        -- Decrease durability\n        local durability = self:getData(\"durability\", 100)\n        self:setData(\"durability\", math.max(0, durability - 1))\n        end\n    -- Notify nearby players\n    if method == \"use\" or method == \"equip\" then\n        for _, ply in ipairs(player.GetAll()) do\n            if ply ~= client and ply:GetPos():Distance(client:GetPos()) &lt; 500 then\n                ply:ChatPrint(client:Name() .. \" used \" .. self.name)\n                end\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#itemtransfered","title":"ItemTransfered","text":"<p>Purpose</p> <p>Called when an item is transferred between inventories</p> <p>When Called</p> <p>When an item is successfully moved from one inventory to another</p> <p>Parameters</p> <ul> <li><code>context</code> (table): The transfer context containing source, destination, item, etc.</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item transfers\nhook.Add(\"ItemTransfered\", \"MyAddon\", function(context)\nprint(\"Item \" .. context.item.uniqueID .. \" transferred\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track transfer statistics\nhook.Add(\"ItemTransfered\", \"TransferTracking\", function(context)\nlocal fromChar = context.fromChar\nlocal toChar = context.toChar\nif fromChar then\n    fromChar:setData(\"itemsTransferredOut\", (fromChar:getData(\"itemsTransferredOut\", 0) + 1))\n    end\nif toChar then\n    toChar:setData(\"itemsTransferredIn\", (toChar:getData(\"itemsTransferredIn\", 0) + 1))\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item transfer system\nhook.Add(\"ItemTransfered\", \"AdvancedTransfers\", function(context)\nlocal fromChar = context.fromChar\nlocal toChar = context.toChar\nlocal item = context.item\nlocal fromInv = context.fromInventory\nlocal toInv = context.toInventory\n-- Update transfer statistics\nif fromChar then\n    fromChar:setData(\"itemsTransferredOut\", (fromChar:getData(\"itemsTransferredOut\", 0) + 1))\n    fromChar:setData(\"lastTransferOut\", os.time())\n    end\nif toChar then\n    toChar:setData(\"itemsTransferredIn\", (toChar:getData(\"itemsTransferredIn\", 0) + 1))\n    toChar:setData(\"lastTransferIn\", os.time())\n    end\n-- Check for transfer limits\nlocal transferLimit = 100 -- Max transfers per hour\nif fromChar then\n    local transfersThisHour = fromChar:getData(\"transfersThisHour\", 0)\n    if transfersThisHour &gt;= transferLimit then\n        fromChar:getPlayer():ChatPrint(\"Transfer limit reached for this hour\")\n        return false\n        end\n    fromChar:setData(\"transfersThisHour\", transfersThisHour + 1)\n    end\n-- Check for valuable item transfers\nlocal itemValue = item:getData(\"value\", 0)\nif itemValue &gt; 1000 then\n    -- Log valuable transfers\n    print(string.format(\"Valuable item %s transferred from %s to %s (Value: $%d)\",\n    item.uniqueID, fromChar and fromChar:getName() or \"Unknown\",\n    toChar and toChar:getName() or \"Unknown\", itemValue))\n    end\n-- Check for faction restrictions\nif fromChar and toChar then\n    local fromFaction = fromChar:getFaction()\n    local toFaction = toChar:getFaction()\n    if fromFaction == \"police\" and toFaction == \"criminal\" then\n        -- Police transferring to criminals - log this\n        print(string.format(\"Suspicious transfer: %s (Police) to %s (Criminal)\",\n        fromChar:getName(), toChar:getName()))\n        end\n    end\n-- Check for quest items\nif item:getData(\"questItem\", false) then\n    local questID = item:getData(\"questID\")\n    if questID and toChar then\n        toChar:setData(\"questProgress\", toChar:getData(\"questProgress\", {})[questID] + 1)\n        toChar:getPlayer():ChatPrint(\"Quest progress updated!\")\n        end\n    end\n-- Check for bound items\nif item:getData(\"bound\", false) then\n    local boundTo = item:getData(\"boundTo\")\n    if boundTo and toChar and boundTo ~= toChar:getID() then\n        toChar:getPlayer():ChatPrint(\"This item is bound to another character\")\n        return false\n        end\n    end\n-- Log transfer\nprint(string.format(\"Item %s transferred from %s to %s\",\nitem.uniqueID, fromChar and fromChar:getName() or \"Unknown\",\ntoChar and toChar:getName() or \"Unknown\"))\nend)\n</code></pre></p>"},{"location":"hooks/server/#keylock","title":"KeyLock","text":"<p>Purpose</p> <p>Called when a key locks an entity</p> <p>When Called</p> <p>When a key is used to lock a door or entity</p> <p>Parameters</p> <ul> <li><code>owner</code> (Player): The player using the key</li> <li><code>entity</code> (Entity): The entity being locked</li> <li><code>time</code> (number): The time taken to lock</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log key lock\nhook.Add(\"KeyLock\", \"MyAddon\", function(owner, entity, time)\nprint(owner:Name() .. \" locked \" .. tostring(entity))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track lock usage\nhook.Add(\"KeyLock\", \"TrackLocks\", function(owner, entity, time)\nlocal char = owner:getChar()\nif not char then return end\n    local locks = char:getData(\"locksUsed\", 0)\n    char:setData(\"locksUsed\", locks + 1)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex key lock system\nhook.Add(\"KeyLock\", \"AdvancedKeyLock\", function(owner, entity, time)\nlocal char = owner:getChar()\nif not char then return end\n    -- Update entity data\n    entity:setNetVar(\"locked\", true)\n    entity:setNetVar(\"lockedBy\", char:getID())\n    entity:setNetVar(\"lockedAt\", os.time())\n    -- Log to database\n    lia.db.query(\"INSERT INTO lock_logs (timestamp, steamid, entityid, action) VALUES (?, ?, ?, ?)\",\n    os.time(), owner:SteamID(), entity:EntIndex(), \"locked\")\n    -- Update character stats\n    local locks = char:getData(\"locksUsed\", 0)\n    char:setData(\"locksUsed\", locks + 1)\n    char:setData(\"lastLockTime\", os.time())\n    -- Notify nearby players\n    local pos = entity:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 and ply ~= owner then\n            ply:ChatPrint(\"You hear a lock clicking nearby\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#keyunlock","title":"KeyUnlock","text":"<p>Purpose</p> <p>Called when a key unlocks an entity</p> <p>When Called</p> <p>When a key is used to unlock a door or entity</p> <p>Parameters</p> <ul> <li><code>owner</code> (Player): The player using the key</li> <li><code>entity</code> (Entity): The entity being unlocked</li> <li><code>time</code> (number): The time taken to unlock</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log key unlock\nhook.Add(\"KeyUnlock\", \"MyAddon\", function(owner, entity, time)\nprint(owner:Name() .. \" unlocked \" .. tostring(entity))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track unlock usage\nhook.Add(\"KeyUnlock\", \"TrackUnlocks\", function(owner, entity, time)\nlocal char = owner:getChar()\nif not char then return end\n    local unlocks = char:getData(\"unlocksUsed\", 0)\n    char:setData(\"unlocksUsed\", unlocks + 1)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex key unlock system\nhook.Add(\"KeyUnlock\", \"AdvancedKeyUnlock\", function(owner, entity, time)\nlocal char = owner:getChar()\nif not char then return end\n    -- Update entity data\n    entity:setNetVar(\"locked\", false)\n    entity:setNetVar(\"unlockedBy\", char:getID())\n    entity:setNetVar(\"unlockedAt\", os.time())\n    -- Log to database\n    lia.db.query(\"INSERT INTO lock_logs (timestamp, steamid, entityid, action) VALUES (?, ?, ?, ?)\",\n    os.time(), owner:SteamID(), entity:EntIndex(), \"unlocked\")\n    -- Update character stats\n    local unlocks = char:getData(\"unlocksUsed\", 0)\n    char:setData(\"unlocksUsed\", unlocks + 1)\n    char:setData(\"lastUnlockTime\", os.time())\n    -- Notify nearby players\n    local pos = entity:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 and ply ~= owner then\n            ply:ChatPrint(\"You hear a lock clicking nearby\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#liliatablesloaded","title":"LiliaTablesLoaded","text":"<p>Purpose</p> <p>Called when Lilia database tables are loaded</p> <p>When Called</p> <p>After database tables are created/loaded</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log tables loaded\nhook.Add(\"LiliaTablesLoaded\", \"MyAddon\", function()\nprint(\"Lilia tables loaded\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create custom tables\nhook.Add(\"LiliaTablesLoaded\", \"CreateCustomTables\", function()\nlia.db.query(\"CREATE TABLE IF NOT EXISTS my_table (id INTEGER PRIMARY KEY, data TEXT)\")\nprint(\"Custom tables created\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex database initialization\nhook.Add(\"LiliaTablesLoaded\", \"AdvancedDatabaseInit\", function()\n-- Create custom tables\nlocal tables = {\n\"CREATE TABLE IF NOT EXISTS my_table (id INTEGER PRIMARY KEY, data TEXT)\",\n\"CREATE TABLE IF NOT EXISTS my_stats (charid INTEGER, stat TEXT, value INTEGER)\",\n\"CREATE TABLE IF NOT EXISTS my_logs (timestamp INTEGER, message TEXT)\"\n}\nfor _, query in ipairs(tables) do\n    lia.db.query(query)\n    end\n-- Create indexes\nlia.db.query(\"CREATE INDEX IF NOT EXISTS idx_my_stats_charid ON my_stats(charid)\")\nprint(\"Custom database tables and indexes created\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#loaddata","title":"LoadData","text":"<p>Purpose</p> <p>Called to load persistent data</p> <p>When Called</p> <p>When data needs to be loaded from storage</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log data load\nhook.Add(\"LoadData\", \"MyAddon\", function()\nprint(\"Loading data\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load custom data\nhook.Add(\"LoadData\", \"LoadCustomData\", function()\nlocal data = lia.data.get(\"myAddonData\", {})\nMyAddon.data = data\nprint(\"Custom data loaded\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data loading system\nhook.Add(\"LoadData\", \"AdvancedDataLoad\", function()\n-- Load custom data\nlocal data = lia.data.get(\"myAddonData\", {})\nMyAddon.data = data\n-- Load from database\nlia.db.query(\"SELECT * FROM my_table\", function(results)\nif results then\n    for _, row in ipairs(results) do\n        MyAddon.ProcessData(row)\n        end\n    end\nend)\n-- Initialize data structures\nMyAddon.playerData = MyAddon.playerData or {}\nMyAddon.sessionData = {}\nprint(\"All data loaded successfully\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#modifycharactermodel","title":"ModifyCharacterModel","text":"<p>Purpose</p> <p>Called to modify a character's model</p> <p>When Called</p> <p>When a character's model is being set</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player</li> <li><code>character</code> (Character): The character whose model is being modified</li> </ul> <p>Returns</p> <ul> <li>string - The modified model path</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default model\nhook.Add(\"ModifyCharacterModel\", \"MyAddon\", function(client, character)\nreturn character:getModel()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Faction-based models\nhook.Add(\"ModifyCharacterModel\", \"FactionModels\", function(client, character)\nlocal faction = character:getFaction()\nif faction == \"police\" then\n    return \"models/player/police.mdl\"\nelseif faction == \"medic\" then\n    return \"models/player/medic.mdl\"\n    end\nreturn character:getModel()\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex model modification system\nhook.Add(\"ModifyCharacterModel\", \"AdvancedModelModification\", function(client, character)\nlocal baseModel = character:getModel()\n-- Check for outfit override\nlocal outfit = character:getData(\"outfit\")\nif outfit then\n    local outfitItem = lia.item.instances[outfit]\n    if outfitItem and outfitItem.model then\n        return outfitItem.model\n        end\n    end\n-- Check faction models\nlocal faction = lia.faction.indices[character:getFaction()]\nif faction and faction.models then\n    local modelIndex = character:getData(\"modelIndex\", 1)\n    if faction.models[modelIndex] then\n        return faction.models[modelIndex]\n        end\n    end\n-- Check for transformation effects\nif character:getData(\"transformed\", false) then\n    local transformModel = character:getData(\"transformModel\")\n    if transformModel then\n        return transformModel\n        end\n    end\nreturn baseModel\nend)\n</code></pre></p>"},{"location":"hooks/server/#onadminsystemloaded","title":"OnAdminSystemLoaded","text":"<p>Purpose</p> <p>Called when admin system is loaded</p> <p>When Called</p> <p>After admin groups and privileges are initialized</p> <p>Parameters</p> <ul> <li><code>groups</code> (table): The admin groups table</li> <li><code>privileges</code> (table): The privileges table</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log admin system load\nhook.Add(\"OnAdminSystemLoaded\", \"MyAddon\", function(groups, privileges)\nprint(\"Admin system loaded\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add custom admin groups\nhook.Add(\"OnAdminSystemLoaded\", \"AddCustomAdminGroups\", function(groups, privileges)\ngroups[\"moderator\"] = {\nname = \"Moderator\",\nimmunity = 50\n}\nprint(\"Custom admin groups added\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex admin system customization\nhook.Add(\"OnAdminSystemLoaded\", \"AdvancedAdminCustomization\", function(groups, privileges)\n-- Add custom admin groups\ngroups[\"moderator\"] = {\nname = \"Moderator\",\nimmunity = 50,\ncolor = Color(0, 200, 0)\n}\ngroups[\"headAdmin\"] = {\nname = \"Head Admin\",\nimmunity = 90,\ncolor = Color(255, 0, 0)\n}\n-- Add custom privileges\nprivileges[\"canManageEvents\"] = {\nname = \"Can Manage Events\",\ndescription = \"Allows managing server events\"\n}\nprivileges[\"canEditVendors\"] = {\nname = \"Can Edit Vendors\",\ndescription = \"Allows editing vendor inventories\"\n}\nprint(\"Admin system customized with new groups and privileges\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#oncharattribboosted","title":"OnCharAttribBoosted","text":"<p>Purpose</p> <p>Called when a character attribute is boosted</p> <p>When Called</p> <p>When a character's attribute is increased</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character whose attribute was boosted</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log attribute boost\nhook.Add(\"OnCharAttribBoosted\", \"MyAddon\", function(character)\nprint(character:getName() .. \" boosted an attribute\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track attribute boosts\nhook.Add(\"OnCharAttribBoosted\", \"TrackAttributeBoosts\", function(character)\nlocal boosts = character:getData(\"attributeBoosts\", 0)\ncharacter:setData(\"attributeBoosts\", boosts + 1)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex attribute boost system\nhook.Add(\"OnCharAttribBoosted\", \"AdvancedAttributeBoost\", function(character)\nlocal boosts = character:getData(\"attributeBoosts\", 0)\ncharacter:setData(\"attributeBoosts\", boosts + 1)\n-- Log to database\nlia.db.query(\"INSERT INTO attribute_logs (timestamp, charid, action) VALUES (?, ?, ?)\",\nos.time(), character:getID(), \"boosted\")\n-- Notify player\nlocal client = character:getPlayer()\nif IsValid(client) then\n    client:ChatPrint(\"Attribute boosted! Total boosts: \" .. (boosts + 1))\n    end\n-- Check for achievements\nif boosts + 1 &gt;= 50 then\n    if not character:getData(\"achievement_attributeMaster\", false) then\n        character:setData(\"achievement_attributeMaster\", true)\n        if IsValid(client) then\n            client:ChatPrint(\"Achievement unlocked: Attribute Master!\")\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#oncharattribupdated","title":"OnCharAttribUpdated","text":"<p>Purpose</p> <p>Called when a character attribute is updated</p> <p>When Called</p> <p>When a character's attribute value changes</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player</li> <li><code>character</code> (Character): The character</li> <li><code>key</code> (string): The attribute key</li> <li><code>newValue</code> (number): The new attribute value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log attribute updates\nhook.Add(\"OnCharAttribUpdated\", \"MyAddon\", function(client, character, key, newValue)\nprint(character:getName() .. \" \" .. key .. \" updated to \" .. newValue)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track attribute changes\nhook.Add(\"OnCharAttribUpdated\", \"TrackAttributeChanges\", function(client, character, key, newValue)\nlocal changes = character:getData(\"attributeChanges\", {})\nchanges[key] = (changes[key] or 0) + 1\ncharacter:setData(\"attributeChanges\", changes)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex attribute tracking system\nhook.Add(\"OnCharAttribUpdated\", \"AdvancedAttributeTracking\", function(client, character, key, newValue)\n-- Log to database\nlia.db.query(\"INSERT INTO attribute_logs (timestamp, charid, attribute, value) VALUES (?, ?, ?, ?)\",\nos.time(), character:getID(), key, newValue)\n-- Track changes\nlocal changes = character:getData(\"attributeChanges\", {})\nchanges[key] = (changes[key] or 0) + 1\ncharacter:setData(\"attributeChanges\", changes)\n-- Notify player\nclient:ChatPrint(key .. \" updated to \" .. newValue)\n-- Apply attribute effects\nif key == \"str\" then\n    -- Strength affects melee damage\n    local damageBonus = newValue * 0.5\n    character:setData(\"meleeDamageBonus\", damageBonus)\nelseif key == \"end\" then\n    -- Endurance affects max health\n    local healthBonus = newValue * 2\n    client:SetMaxHealth(100 + healthBonus)\nelseif key == \"agi\" then\n    -- Agility affects movement speed\n    local speedBonus = 1 + (newValue * 0.01)\n    client:SetRunSpeed(250 * speedBonus)\n    client:SetWalkSpeed(100 * speedBonus)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#oncharcreated","title":"OnCharCreated","text":"<p>Purpose</p> <p>Called when a character is created</p> <p>When Called</p> <p>When a new character is successfully created</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who created the character</li> <li><code>character</code> (Character): The character that was created</li> <li><code>originalData</code> (table): The original character data before any modifications</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character creation\nhook.Add(\"OnCharCreated\", \"MyAddon\", function(client, character, originalData)\nprint(client:Name() .. \" created character: \" .. character:getName())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set up new character bonuses\nhook.Add(\"OnCharCreated\", \"NewCharBonuses\", function(client, character, originalData)\n-- Give starting money bonus\nlocal bonusMoney = 500\ncharacter:setMoney(character:getMoney() + bonusMoney)\n-- Give starting items\nlocal startingItems = {\"wallet\", \"phone\", \"id_card\"}\nfor _, itemID in ipairs(startingItems) do\n    local item = lia.item.instance(itemID)\n    if item then\n        character:getInv():add(item)\n        end\n    end\nclient:ChatPrint(\"Welcome! You received starting bonuses.\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character creation system\nhook.Add(\"OnCharCreated\", \"AdvancedCreation\", function(client, character, originalData)\nlocal faction = character:getFaction()\n-- Set up faction-specific starting equipment\nlocal factionEquipment = {\n[\"police\"] = {\nitems = {\"police_badge\", \"handcuffs\", \"radio\"},\nmoney = 1000,\nattributes = {str = 5, con = 4, dex = 3}\n},\n[\"medic\"] = {\nitems = {\"medkit\", \"stethoscope\", \"bandage\"},\nmoney = 800,\nattributes = {int = 6, wis = 5, con = 4}\n},\n[\"citizen\"] = {\nitems = {\"wallet\", \"phone\"},\nmoney = 500,\nattributes = {str = 3, con = 3, dex = 3}\n}\n}\nlocal equipment = factionEquipment[faction]\nif equipment then\n    -- Give faction-specific money\n    character:setMoney(character:getMoney() + equipment.money)\n    -- Give faction-specific items\n    for _, itemID in ipairs(equipment.items) do\n        local item = lia.item.instance(itemID)\n        if item then\n            character:getInv():add(item)\n            end\n        end\n    -- Set faction-specific attributes\n    for attr, value in pairs(equipment.attributes) do\n        character:setAttrib(attr, value)\n        end\n    end\n-- Set up character data\ncharacter:setData(\"creationTime\", os.time())\ncharacter:setData(\"creationIP\", client:IPAddress())\ncharacter:setData(\"level\", 1)\ncharacter:setData(\"experience\", 0)\n-- Send welcome message\nclient:ChatPrint(\"Character created successfully! Welcome to the server.\")\n-- Log creation\nprint(string.format(\"%s created %s character: %s\",\nclient:Name(), faction, character:getName()))\nend)\n</code></pre></p>"},{"location":"hooks/server/#onchardelete","title":"OnCharDelete","text":"<p>Purpose</p> <p>Called when a character is deleted</p> <p>When Called</p> <p>When a character is successfully deleted</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who deleted the character</li> <li><code>id</code> (number): The ID of the character that was deleted</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character deletion\nhook.Add(\"OnCharDelete\", \"MyAddon\", function(client, id)\nprint(client:Name() .. \" deleted character ID: \" .. id)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track deletion statistics\nhook.Add(\"OnCharDelete\", \"DeletionTracking\", function(client, id)\nlocal char = client:getChar()\nif char then\n    char:setData(\"charactersDeleted\", (char:getData(\"charactersDeleted\", 0) + 1))\n    char:setData(\"lastCharDelete\", os.time())\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character deletion system\nhook.Add(\"OnCharDelete\", \"AdvancedDeletion\", function(client, id)\nlocal char = client:getChar()\nif not char then return end\n    -- Update deletion statistics\n    char:setData(\"charactersDeleted\", (char:getData(\"charactersDeleted\", 0) + 1))\n    char:setData(\"lastCharDelete\", os.time())\n    -- Check for deletion cooldown\n    local lastDelete = char:getData(\"lastCharDelete\", 0)\n    local deleteCooldown = 3600 -- 1 hour\n    if os.time() - lastDelete &lt; deleteCooldown then\n        client:ChatPrint(\"You must wait before deleting another character\")\n        return false\n        end\n    -- Check for valuable items\n    local charInv = char:getInv()\n    local valuableItems = {}\n    for _, item in pairs(charInv:getItems()) do\n        if item:getData(\"value\", 0) &gt; 1000 then\n            table.insert(valuableItems, item)\n            end\n        end\n    if #valuableItems &gt; 0 then\n        client:ChatPrint(\"Warning: You have valuable items. Are you sure you want to delete this character?\")\n        return false\n        end\n    -- Check for faction restrictions\n    local faction = char:getFaction()\n    if faction ~= \"citizen\" then\n        client:ChatPrint(\"You must leave your faction before deleting this character\")\n        return false\n        end\n    -- Check for active quests\n    local activeQuests = char:getData(\"activeQuests\", {})\n    if #activeQuests &gt; 0 then\n        client:ChatPrint(\"You have active quests. Complete them before deleting this character\")\n        return false\n        end\n    -- Log deletion\n    print(string.format(\"%s deleted character ID %d (Faction: %s)\",\n    client:Name(), id, faction))\n    -- Notify admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() and ply ~= client then\n            ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" deleted character ID \" .. id)\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onchardisconnect","title":"OnCharDisconnect","text":"<p>Purpose</p> <p>Called when a character disconnects</p> <p>When Called</p> <p>When a player disconnects while having a character loaded</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who disconnected</li> <li><code>character</code> (Character): The character that was loaded when disconnecting</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character disconnect\nhook.Add(\"OnCharDisconnect\", \"MyAddon\", function(client, character)\nprint(client:Name() .. \" disconnected with character: \" .. character:getName())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save character data on disconnect\nhook.Add(\"OnCharDisconnect\", \"CharDisconnectSave\", function(client, character)\n-- Save character position\ncharacter:setData(\"lastPos\", client:GetPos())\ncharacter:setData(\"lastAng\", client:GetAngles())\n-- Save character health and armor\ncharacter:setData(\"lastHealth\", client:Health())\ncharacter:setData(\"lastArmor\", client:Armor())\n-- Save disconnect time\ncharacter:setData(\"lastDisconnect\", os.time())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character disconnect system\nhook.Add(\"OnCharDisconnect\", \"AdvancedCharDisconnect\", function(client, character)\n-- Save character state\ncharacter:setData(\"lastPos\", client:GetPos())\ncharacter:setData(\"lastAng\", client:GetAngles())\ncharacter:setData(\"lastHealth\", client:Health())\ncharacter:setData(\"lastArmor\", client:Armor())\ncharacter:setData(\"lastDisconnect\", os.time())\n-- Save inventory state\nlocal inventory = character:getInv()\nif inventory then\n    character:setData(\"inventoryState\", inventory:getData())\n    end\n-- Save character money\ncharacter:setData(\"lastMoney\", character:getMoney())\n-- Save character attributes\nlocal attributes = character:getAttribs()\ncharacter:setData(\"lastAttributes\", attributes)\n-- Save character data\nlocal charData = character:getData()\ncharacter:setData(\"lastCharData\", charData)\n-- Check for active effects\nlocal activeEffects = character:getData(\"activeEffects\", {})\nif #activeEffects &gt; 0 then\n    -- Pause active effects\n    for _, effect in ipairs(activeEffects) do\n        effect.paused = true\n        effect.pauseTime = os.time()\n        end\n    character:setData(\"activeEffects\", activeEffects)\n    end\n-- Check for active quests\nlocal activeQuests = character:getData(\"activeQuests\", {})\nif #activeQuests &gt; 0 then\n    -- Pause active quests\n    for _, quest in ipairs(activeQuests) do\n        quest.paused = true\n        quest.pauseTime = os.time()\n        end\n    character:setData(\"activeQuests\", activeQuests)\n    end\n-- Notify other players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client then\n        ply:ChatPrint(character:getName() .. \" has disconnected\")\n        end\n    end\n-- Log disconnect\nprint(string.format(\"%s disconnected with character %s (Faction: %s)\",\nclient:Name(), character:getName(), character:getFaction()))\nend)\n</code></pre></p>"},{"location":"hooks/server/#oncharfallover","title":"OnCharFallover","text":"<p>Purpose</p> <p>Called when a character falls over</p> <p>When Called</p> <p>When a character is knocked down/ragdolled</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character falling over</li> <li><code>client</code> (Player): The player</li> <li><code>ragdoll</code> (Entity): The ragdoll entity created</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log fallover\nhook.Add(\"OnCharFallover\", \"MyAddon\", function(character, client, ragdoll)\nprint(character:getName() .. \" fell over\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set ragdoll data\nhook.Add(\"OnCharFallover\", \"SetRagdollData\", function(character, client, ragdoll)\nragdoll:setNetVar(\"charID\", character:getID())\nragdoll:setNetVar(\"fallTime\", os.time())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex fallover system\nhook.Add(\"OnCharFallover\", \"AdvancedFallover\", function(character, client, ragdoll)\n-- Set ragdoll data\nragdoll:setNetVar(\"charID\", character:getID())\nragdoll:setNetVar(\"fallTime\", os.time())\nragdoll:setNetVar(\"charName\", character:getName())\n-- Track fallover count\nlocal fallCount = character:getData(\"fallCount\", 0)\ncharacter:setData(\"fallCount\", fallCount + 1)\n-- Apply faction-specific effects\nlocal faction = character:getFaction()\nif faction == \"police\" then\n    -- Police get up faster\n    timer.Simple(5, function()\n    if IsValid(ragdoll) and IsValid(client) then\n        client:SetRagdolled(false)\n        end\n    end)\n    end\n-- Notify nearby players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client and ply:GetPos():Distance(client:GetPos()) &lt; 500 then\n        ply:ChatPrint(character:getName() .. \" fell over\")\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#oncharflagsgiven","title":"OnCharFlagsGiven","text":"<p>Purpose</p> <p>Called when flags are given to a character</p> <p>When Called</p> <p>When a character receives new flags</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player receiving flags</li> <li><code>self</code> (Character): The character receiving flags</li> <li><code>addedFlags</code> (string): The flags that were added</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log flags given\nhook.Add(\"OnCharFlagsGiven\", \"MyAddon\", function(ply, self, addedFlags)\nprint(self:getName() .. \" received flags: \" .. addedFlags)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track flag changes\nhook.Add(\"OnCharFlagsGiven\", \"TrackFlagChanges\", function(ply, self, addedFlags)\nlocal flagHistory = self:getData(\"flagHistory\", {})\ntable.insert(flagHistory, {action = \"given\", flags = addedFlags, time = os.time()})\nself:setData(\"flagHistory\", flagHistory)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex flag management system\nhook.Add(\"OnCharFlagsGiven\", \"AdvancedFlagManagement\", function(ply, self, addedFlags)\n-- Log to database\nlia.db.query(\"INSERT INTO flag_logs (timestamp, charid, action, flags) VALUES (?, ?, ?, ?)\",\nos.time(), self:getID(), \"given\", addedFlags)\n-- Track flag history\nlocal flagHistory = self:getData(\"flagHistory\", {})\ntable.insert(flagHistory, {action = \"given\", flags = addedFlags, time = os.time()})\nself:setData(\"flagHistory\", flagHistory)\n-- Notify player\nply:ChatPrint(\"You received flags: \" .. addedFlags)\n-- Apply flag-specific effects\nfor i = 1, #addedFlags do\n    local flag = addedFlags:sub(i, i)\n    if flag == \"v\" then\n        -- VIP flag\n        ply:ChatPrint(\"You are now a VIP!\")\n    elseif flag == \"a\" then\n        -- Admin flag\n        ply:ChatPrint(\"You now have admin privileges!\")\n        end\n    end\n-- Notify admins\nfor _, admin in ipairs(player.GetAll()) do\n    if admin:IsAdmin() and admin ~= ply then\n        admin:ChatPrint(\"[FLAGS] \" .. self:getName() .. \" received flags: \" .. addedFlags)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#oncharflagstaken","title":"OnCharFlagsTaken","text":"<p>Purpose</p> <p>Called when flags are taken from a character</p> <p>When Called</p> <p>When a character loses flags</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player losing flags</li> <li><code>self</code> (Character): The character losing flags</li> <li><code>removedFlags</code> (string): The flags that were removed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log flags taken\nhook.Add(\"OnCharFlagsTaken\", \"MyAddon\", function(ply, self, removedFlags)\nprint(self:getName() .. \" lost flags: \" .. removedFlags)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track flag removals\nhook.Add(\"OnCharFlagsTaken\", \"TrackFlagRemovals\", function(ply, self, removedFlags)\nlocal flagHistory = self:getData(\"flagHistory\", {})\ntable.insert(flagHistory, {action = \"taken\", flags = removedFlags, time = os.time()})\nself:setData(\"flagHistory\", flagHistory)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex flag removal system\nhook.Add(\"OnCharFlagsTaken\", \"AdvancedFlagRemoval\", function(ply, self, removedFlags)\n-- Log to database\nlia.db.query(\"INSERT INTO flag_logs (timestamp, charid, action, flags) VALUES (?, ?, ?, ?)\",\nos.time(), self:getID(), \"taken\", removedFlags)\n-- Track flag history\nlocal flagHistory = self:getData(\"flagHistory\", {})\ntable.insert(flagHistory, {action = \"taken\", flags = removedFlags, time = os.time()})\nself:setData(\"flagHistory\", flagHistory)\n-- Notify player\nply:ChatPrint(\"You lost flags: \" .. removedFlags)\n-- Remove flag-specific effects\nfor i = 1, #removedFlags do\n    local flag = removedFlags:sub(i, i)\n    if flag == \"v\" then\n        -- VIP flag removed\n        ply:ChatPrint(\"Your VIP status has been revoked\")\n    elseif flag == \"a\" then\n        -- Admin flag removed\n        ply:ChatPrint(\"Your admin privileges have been revoked\")\n        end\n    end\n-- Notify admins\nfor _, admin in ipairs(player.GetAll()) do\n    if admin:IsAdmin() and admin ~= ply then\n        admin:ChatPrint(\"[FLAGS] \" .. self:getName() .. \" lost flags: \" .. removedFlags)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onchargetup","title":"OnCharGetup","text":"<p>Purpose</p> <p>Called when a character gets up from being unconscious</p> <p>When Called</p> <p>When a character regains consciousness or is revived</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player whose character got up</li> <li><code>entity</code> (Entity): The ragdoll entity that was removed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character getup\nhook.Add(\"OnCharGetup\", \"MyAddon\", function(target, entity)\nprint(target:Name() .. \" got up\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle getup effects\nhook.Add(\"OnCharGetup\", \"GetupEffects\", function(target, entity)\nlocal char = target:getChar()\nif char then\n    -- Clear unconscious status\n    char:setData(\"unconscious\", false)\n    char:setData(\"getupTime\", os.time())\n    -- Restore some health\n    local currentHealth = target:Health()\n    local maxHealth = target:GetMaxHealth()\n    target:SetHealth(math.min(currentHealth + 25, maxHealth))\n    target:ChatPrint(\"You have regained consciousness\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex getup system\nhook.Add(\"OnCharGetup\", \"AdvancedGetup\", function(target, entity)\nlocal char = target:getChar()\nif not char then return end\n    -- Clear unconscious status\n    char:setData(\"unconscious\", false)\n    char:setData(\"getupTime\", os.time())\n    char:setData(\"revivalTime\", nil)\n    -- Restore health based on faction\n    local faction = char:getFaction()\n    local healthRestore = {\n    [\"police\"] = 50,\n    [\"medic\"] = 75,\n    [\"citizen\"] = 25\n    }\n    local restoreAmount = healthRestore[faction] or 25\n    local currentHealth = target:Health()\n    local maxHealth = target:GetMaxHealth()\n    target:SetHealth(math.min(currentHealth + restoreAmount, maxHealth))\n    -- Restore stamina\n    local currentStamina = target:getNetVar(\"stamina\", 100)\n    target:setNetVar(\"stamina\", math.min(currentStamina + 50, 100))\n    -- Resume active effects\n    local activeEffects = char:getData(\"activeEffects\", {})\n    for _, effect in ipairs(activeEffects) do\n        if effect.paused then\n            effect.paused = false\n            effect.pauseTime = nil\n            end\n        end\n    char:setData(\"activeEffects\", activeEffects)\n    -- Resume active quests\n    local activeQuests = char:getData(\"activeQuests\", {})\n    for _, quest in ipairs(activeQuests) do\n        if quest.paused then\n            quest.paused = false\n            quest.pauseTime = nil\n            end\n        end\n    char:setData(\"activeQuests\", activeQuests)\n    -- Check for revival achievements\n    local revivals = char:getData(\"revivals\", 0) + 1\n    char:setData(\"revivals\", revivals)\n    if revivals &gt;= 10 and not char:getData(\"achievement_survivor\", false) then\n        char:setData(\"achievement_survivor\", true)\n        target:ChatPrint(\"Achievement unlocked: Survivor!\")\n        end\n    -- Notify nearby players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(target:GetPos()) &lt; 500 then\n            ply:ChatPrint(char:getName() .. \" has regained consciousness\")\n            end\n        end\n    -- Log getup\n    print(string.format(\"%s got up (Faction: %s, Health: %d)\",\n    char:getName(), faction, target:Health()))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#oncharkick","title":"OnCharKick","text":"<p>Purpose</p> <p>Called when a character is kicked</p> <p>When Called</p> <p>When a character is kicked from the server</p> <p>Parameters</p> <ul> <li><code>self</code> (Character): The character being kicked</li> <li><code>client</code> (Player): The player being kicked</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character kick\nhook.Add(\"OnCharKick\", \"MyAddon\", function(self, client)\nprint(self:getName() .. \" was kicked\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle kick effects\nhook.Add(\"OnCharKick\", \"KickEffects\", function(self, client)\n-- Save character data\nself:setData(\"lastKick\", os.time())\nself:setData(\"kickCount\", (self:getData(\"kickCount\", 0) + 1))\n-- Notify other players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client then\n        ply:ChatPrint(self:getName() .. \" was kicked from the server\")\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex kick system\nhook.Add(\"OnCharKick\", \"AdvancedKick\", function(self, client)\n-- Save character data\nself:setData(\"lastKick\", os.time())\nself:setData(\"kickCount\", (self:getData(\"kickCount\", 0) + 1))\n-- Save character state\nself:setData(\"lastPos\", client:GetPos())\nself:setData(\"lastAng\", client:GetAngles())\nself:setData(\"lastHealth\", client:Health())\nself:setData(\"lastArmor\", client:Armor())\n-- Save inventory state\nlocal inventory = self:getInv()\nif inventory then\n    self:setData(\"inventoryState\", inventory:getData())\n    end\n-- Check for kick reasons\nlocal kickReason = client:getData(\"kickReason\", \"Unknown\")\nself:setData(\"lastKickReason\", kickReason)\n-- Check for faction-specific effects\nlocal faction = self:getFaction()\nif faction == \"police\" then\n    -- Police get backup call\n    for _, ply in ipairs(player.GetAll()) do\n        local plyChar = ply:getChar()\n        if plyChar and plyChar:getFaction() == \"police\" then\n            ply:ChatPrint(\"[BACKUP] \" .. self:getName() .. \" was kicked! Reason: \" .. kickReason)\n            end\n        end\nelseif faction == \"medic\" then\n    -- Medics get medical alert\n    for _, ply in ipairs(player.GetAll()) do\n        local plyChar = ply:getChar()\n        if plyChar and plyChar:getFaction() == \"medic\" then\n            ply:ChatPrint(\"[MEDICAL] \" .. self:getName() .. \" was kicked! Reason: \" .. kickReason)\n            end\n        end\n    end\n-- Check for active quests\nlocal activeQuests = self:getData(\"activeQuests\", {})\nfor _, quest in ipairs(activeQuests) do\n    if quest.type == \"survival\" then\n        quest.failed = true\n        quest.failTime = os.time()\n        end\n    end\n-- Check for active effects\nlocal activeEffects = self:getData(\"activeEffects\", {})\nfor _, effect in ipairs(activeEffects) do\n    effect.paused = true\n    effect.pauseTime = os.time()\n    end\n-- Notify other players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client then\n        ply:ChatPrint(self:getName() .. \" was kicked from the server\")\n        end\n    end\n-- Log kick\nprint(string.format(\"%s was kicked (Faction: %s, Reason: %s)\",\nself:getName(), faction, kickReason))\nend)\n</code></pre></p>"},{"location":"hooks/server/#oncharnetvarchanged","title":"OnCharNetVarChanged","text":"<p>Purpose</p> <p>Called when a character's network variable changes</p> <p>When Called</p> <p>When a character's networked data is modified</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character whose variable changed</li> <li><code>key</code> (string): The name of the variable that changed</li> <li><code>oldVar</code> (any): The previous value of the variable</li> <li><code>value</code> (any): The new value of the variable</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log network variable changes\nhook.Add(\"OnCharNetVarChanged\", \"MyAddon\", function(character, key, oldVar, value)\nprint(character:getName() .. \" netvar changed: \" .. key .. \" = \" .. tostring(value))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track specific variable changes\nhook.Add(\"OnCharNetVarChanged\", \"NetVarTracking\", function(character, key, oldVar, value)\nif key == \"health\" then\n    local client = character:getPlayer()\n    if client then\n        client:ChatPrint(\"Health changed from \" .. oldVar .. \" to \" .. value)\n        end\nelseif key == \"money\" then\n    local client = character:getPlayer()\n    if client then\n        client:ChatPrint(\"Money changed from $\" .. oldVar .. \" to $\" .. value)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex network variable system\nhook.Add(\"OnCharNetVarChanged\", \"AdvancedNetVar\", function(character, key, oldVar, value)\nlocal client = character:getPlayer()\nif not client then return end\n    -- Track variable change history\n    local changeHistory = character:getData(\"netVarHistory\", {})\n    changeHistory[key] = changeHistory[key] or {}\n    table.insert(changeHistory[key], {\n    oldValue = oldVar,\n    newValue = value,\n    timestamp = os.time()\n    })\n    -- Keep only last 10 changes per variable\n    if #changeHistory[key] &gt; 10 then\n        table.remove(changeHistory[key], 1)\n        end\n    character:setData(\"netVarHistory\", changeHistory)\n    -- Handle specific variable changes\n    if key == \"health\" then\n        -- Health change effects\n        if value &lt;= 0 and oldVar &gt; 0 then\n            -- Character died\n            hook.Run(\"OnCharacterDeath\", character)\n        elseif value &gt; 0 and oldVar &lt;= 0 then\n            -- Character revived\n            hook.Run(\"OnCharacterRevive\", character)\n            end\n        -- Notify nearby players of health change\n        for _, ply in ipairs(player.GetAll()) do\n            if ply:GetPos():Distance(client:GetPos()) &lt; 500 then\n                ply:ChatPrint(character:getName() .. \"'s health: \" .. value .. \"/\" .. client:GetMaxHealth())\n                end\n            end\n    elseif key == \"money\" then\n        -- Money change effects\n        local difference = value - oldVar\n        if difference &gt; 0 then\n            client:ChatPrint(\"You gained $\" .. difference)\n        elseif difference &lt; 0 then\n            client:ChatPrint(\"You lost $\" .. math.abs(difference))\n            end\n        -- Check for money milestones\n        if value &gt;= 10000 and oldVar &lt; 10000 then\n            client:ChatPrint(\"Congratulations! You've reached $10,000!\")\n        elseif value &gt;= 100000 and oldVar &lt; 100000 then\n            client:ChatPrint(\"Congratulations! You've reached $100,000!\")\n            end\n    elseif key == \"level\" then\n        -- Level change effects\n        if value &gt; oldVar then\n            hook.Run(\"OnPlayerLevelUp\", client, oldVar, value)\n            end\n    elseif key == \"faction\" then\n        -- Faction change effects\n        client:SetTeam(value)\n        client:ChatPrint(\"Faction changed to: \" .. value)\n        -- Notify other players\n        for _, ply in ipairs(player.GetAll()) do\n            if ply ~= client then\n                ply:ChatPrint(character:getName() .. \" joined faction: \" .. value)\n                end\n            end\n        end\n    -- Log significant changes\n    if math.abs(value - oldVar) &gt; 100 or key == \"faction\" then\n        print(string.format(\"%s netvar changed: %s from %s to %s\",\n        character:getName(), key, tostring(oldVar), tostring(value)))\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#oncharpermakilled","title":"OnCharPermakilled","text":"<p>Purpose</p> <p>Called when a character is permanently killed</p> <p>When Called</p> <p>When a character is permanently removed from the game</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character being permanently killed</li> <li><code>client</code> (Player): The player whose character was killed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log permanent character death\nhook.Add(\"OnCharPermakilled\", \"MyAddon\", function(character, client)\nprint(character:getName() .. \" was permanently killed\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle permanent death effects\nhook.Add(\"OnCharPermakilled\", \"PermaDeathEffects\", function(character, client)\n-- Clear character data\ncharacter:setData(\"permaKilled\", true)\ncharacter:setData(\"permaKillTime\", os.time())\n-- Notify other players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client then\n        ply:ChatPrint(character:getName() .. \" was permanently killed\")\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex permanent death system\nhook.Add(\"OnCharPermakilled\", \"AdvancedPermaDeath\", function(character, client)\n-- Set permanent death data\ncharacter:setData(\"permaKilled\", true)\ncharacter:setData(\"permaKillTime\", os.time())\ncharacter:setData(\"permaKillReason\", \"Unknown\")\n-- Clear character inventory\nlocal inventory = character:getInv()\nif inventory then\n    local items = inventory:getItems()\n    for _, item in pairs(items) do\n        inventory:remove(item)\n        end\n    end\n-- Clear character money\ncharacter:setMoney(0)\n-- Clear character attributes\nlocal attributes = character:getAttribs()\nfor attr, _ in pairs(attributes) do\n    character:setAttrib(attr, 0)\n    end\n-- Clear character data\ncharacter:setData(\"level\", 1)\ncharacter:setData(\"experience\", 0)\ncharacter:setData(\"activeQuests\", {})\ncharacter:setData(\"activeEffects\", {})\n-- Check for faction-specific effects\nlocal faction = character:getFaction()\nif faction == \"police\" then\n    -- Police get backup call\n    for _, ply in ipairs(player.GetAll()) do\n        local plyChar = ply:getChar()\n        if plyChar and plyChar:getFaction() == \"police\" then\n            ply:ChatPrint(\"[BACKUP] \" .. character:getName() .. \" was permanently killed!\")\n            end\n        end\nelseif faction == \"medic\" then\n    -- Medics get medical alert\n    for _, ply in ipairs(player.GetAll()) do\n        local plyChar = ply:getChar()\n        if plyChar and plyChar:getFaction() == \"medic\" then\n            ply:ChatPrint(\"[MEDICAL] \" .. character:getName() .. \" was permanently killed!\")\n            end\n        end\n    end\n-- Check for active quests\nlocal activeQuests = character:getData(\"activeQuests\", {})\nfor _, quest in ipairs(activeQuests) do\n    quest.failed = true\n    quest.failTime = os.time()\n    quest.failReason = \"Character permanently killed\"\n    end\n-- Check for active effects\nlocal activeEffects = character:getData(\"activeEffects\", {})\nfor _, effect in ipairs(activeEffects) do\n    effect.paused = true\n    effect.pauseTime = os.time()\n    end\n-- Notify other players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client then\n        ply:ChatPrint(character:getName() .. \" was permanently killed\")\n        end\n    end\n-- Log permanent death\nprint(string.format(\"%s was permanently killed (Faction: %s, Level: %d)\",\ncharacter:getName(), faction, character:getData(\"level\", 1)))\nend)\n</code></pre></p>"},{"location":"hooks/server/#oncharrecognized","title":"OnCharRecognized","text":"<p>Purpose</p> <p>Called when a character recognizes another character</p> <p>When Called</p> <p>When a character successfully identifies another character</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player doing the recognizing</li> <li><code>target</code> (Player): The player being recognized</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character recognition\nhook.Add(\"OnCharRecognized\", \"MyAddon\", function(client, target)\nprint(client:Name() .. \" recognized \" .. target:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle recognition effects\nhook.Add(\"OnCharRecognized\", \"RecognitionEffects\", function(client, target)\nlocal clientChar = client:getChar()\nlocal targetChar = target:getChar()\nif clientChar and targetChar then\n    -- Add recognition data\n    local recognitions = clientChar:getData(\"recognitions\", {})\n    recognitions[targetChar:getID()] = os.time()\n    clientChar:setData(\"recognitions\", recognitions)\n    client:ChatPrint(\"You recognized \" .. targetChar:getName())\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex recognition system\nhook.Add(\"OnCharRecognized\", \"AdvancedRecognition\", function(client, target)\nlocal clientChar = client:getChar()\nlocal targetChar = target:getChar()\nif not clientChar or not targetChar then return end\n    -- Add recognition data\n    local recognitions = clientChar:getData(\"recognitions\", {})\n    recognitions[targetChar:getID()] = {\n    timestamp = os.time(),\n    location = client:GetPos(),\n    faction = targetChar:getFaction()\n    }\n    clientChar:setData(\"recognitions\", recognitions)\n    -- Check for faction-specific recognition\n    local clientFaction = clientChar:getFaction()\n    local targetFaction = targetChar:getFaction()\n    if clientFaction == \"police\" and targetFaction == \"criminal\" then\n        -- Police recognizing criminal\n        client:ChatPrint(\"You recognized criminal: \" .. targetChar:getName())\n        -- Notify other police\n        for _, ply in ipairs(player.GetAll()) do\n            local plyChar = ply:getChar()\n            if plyChar and plyChar:getFaction() == \"police\" and ply ~= client then\n                ply:ChatPrint(\"[POLICE] \" .. clientChar:getName() .. \" recognized criminal: \" .. targetChar:getName())\n                end\n            end\n    elseif clientFaction == \"criminal\" and targetFaction == \"police\" then\n        -- Criminal recognizing police\n        client:ChatPrint(\"You recognized police officer: \" .. targetChar:getName())\n        -- Notify other criminals\n        for _, ply in ipairs(player.GetAll()) do\n            local plyChar = ply:getChar()\n            if plyChar and plyChar:getFaction() == \"criminal\" and ply ~= client then\n                ply:ChatPrint(\"[CRIMINAL] \" .. clientChar:getName() .. \" recognized police: \" .. targetChar:getName())\n                end\n            end\n    else\n        -- General recognition\n        client:ChatPrint(\"You recognized \" .. targetChar:getName())\n        end\n    -- Check for recognition achievements\n    local recognitionCount = clientChar:getData(\"recognitionCount\", 0) + 1\n    clientChar:setData(\"recognitionCount\", recognitionCount)\n    if recognitionCount &gt;= 50 and not clientChar:getData(\"achievement_recognizer\", false) then\n        clientChar:setData(\"achievement_recognizer\", true)\n        client:ChatPrint(\"Achievement unlocked: Recognizer!\")\n        end\n    -- Check for faction recognition achievements\n    local factionRecognitions = clientChar:getData(\"factionRecognitions\", {})\n    factionRecognitions[targetFaction] = (factionRecognitions[targetFaction] or 0) + 1\n    clientChar:setData(\"factionRecognitions\", factionRecognitions)\n    if factionRecognitions[targetFaction] &gt;= 10 and not clientChar:getData(\"achievement_faction_recognizer\", false) then\n        clientChar:setData(\"achievement_faction_recognizer\", true)\n        client:ChatPrint(\"Achievement unlocked: Faction Recognizer!\")\n        end\n    -- Log recognition\n    print(string.format(\"%s recognized %s (Factions: %s -&gt; %s)\",\n    clientChar:getName(), targetChar:getName(), clientFaction, targetFaction))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onchartradevendor","title":"OnCharTradeVendor","text":"<p>Purpose</p> <p>Called when a character trades with a vendor</p> <p>When Called</p> <p>When a character buys or sells items to/from a vendor</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player trading with the vendor</li> <li><code>vendor</code> (Entity): The vendor entity</li> <li><code>item</code> (Item): The item being traded</li> <li><code>isSellingToVendor</code> (boolean): True if selling to vendor, false if buying</li> <li><code>character</code> (Character): The character doing the trading</li> <li><code>itemType</code> (string): The type of item being traded</li> <li><code>isFailed</code> (boolean): Whether the trade failed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor trades\nhook.Add(\"OnCharTradeVendor\", \"MyAddon\", function(client, vendor, item, isSellingToVendor, character, itemType, isFailed)\nlocal action = isSellingToVendor and \"sold\" or \"bought\"\nprint(character:getName() .. \" \" .. action .. \" \" .. item.uniqueID .. \" from vendor\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track trade statistics\nhook.Add(\"OnCharTradeVendor\", \"TradeTracking\", function(client, vendor, item, isSellingToVendor, character, itemType, isFailed)\nif not isFailed then\n    local trades = character:getData(\"vendorTrades\", 0) + 1\n    character:setData(\"vendorTrades\", trades)\n    local action = isSellingToVendor and \"sold\" or \"bought\"\n    client:ChatPrint(\"You \" .. action .. \" \" .. item.uniqueID .. \" from vendor\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor trading system\nhook.Add(\"OnCharTradeVendor\", \"AdvancedVendorTrading\", function(client, vendor, item, isSellingToVendor, character, itemType, isFailed)\nif isFailed then\n    client:ChatPrint(\"Trade failed!\")\n    return\n    end\n-- Update trade statistics\nlocal trades = character:getData(\"vendorTrades\", 0) + 1\ncharacter:setData(\"vendorTrades\", trades)\n-- Update vendor statistics\nlocal vendorData = vendor:getNetVar(\"vendorData\", {})\nvendorData.tradeCount = (vendorData.tradeCount or 0) + 1\nvendorData.lastTrade = os.time()\nvendor:setNetVar(\"vendorData\", vendorData)\n-- Check for trade achievements\nif trades &gt;= 100 and not character:getData(\"achievement_trader\", false) then\n    character:setData(\"achievement_trader\", true)\n    client:ChatPrint(\"Achievement unlocked: Trader!\")\n    end\n-- Check for faction-specific trading\nlocal faction = character:getFaction()\nif faction == \"police\" and isSellingToVendor then\n    -- Police selling items - check for contraband\n    if itemType == \"weapon\" or itemType == \"drug\" then\n        client:ChatPrint(\"Warning: Selling contraband as police officer!\")\n        -- Notify other police\n        for _, ply in ipairs(player.GetAll()) do\n            local plyChar = ply:getChar()\n            if plyChar and plyChar:getFaction() == \"police\" and ply ~= client then\n                ply:ChatPrint(\"[POLICE] \" .. character:getName() .. \" sold contraband: \" .. item.uniqueID)\n                end\n            end\n        end\nelseif faction == \"criminal\" and not isSellingToVendor then\n    -- Criminal buying items - check for weapons\n    if itemType == \"weapon\" then\n        client:ChatPrint(\"You purchased a weapon from the vendor\")\n        -- Notify other criminals\n        for _, ply in ipairs(player.GetAll()) do\n            local plyChar = ply:getChar()\n            if plyChar and plyChar:getFaction() == \"criminal\" and ply ~= client then\n                ply:ChatPrint(\"[CRIMINAL] \" .. character:getName() .. \" bought weapon: \" .. item.uniqueID)\n                end\n            end\n        end\n    end\n-- Check for bulk trading\nlocal recentTrades = character:getData(\"recentTrades\", {})\ntable.insert(recentTrades, os.time())\n-- Remove trades older than 1 hour\nlocal cutoff = os.time() - 3600\nfor i = #recentTrades, 1, -1 do\n    if recentTrades[i] &lt; cutoff then\n        table.remove(recentTrades, i)\n        end\n    end\ncharacter:setData(\"recentTrades\", recentTrades)\n-- Check for bulk trading achievement\nif #recentTrades &gt;= 20 and not character:getData(\"achievement_bulk_trader\", false) then\n    character:setData(\"achievement_bulk_trader\", true)\n    client:ChatPrint(\"Achievement unlocked: Bulk Trader!\")\n    end\n-- Log trade\nlocal action = isSellingToVendor and \"sold\" or \"bought\"\nprint(string.format(\"%s %s %s from vendor %s (Faction: %s)\",\ncharacter:getName(), action, item.uniqueID, vendor:EntIndex(), faction))\nend)\n</code></pre></p>"},{"location":"hooks/server/#oncharvarchanged","title":"OnCharVarChanged","text":"<p>Purpose</p> <p>Called when a character's variable changes</p> <p>When Called</p> <p>When a character's data variable is modified</p> <p>Parameters</p> <ul> <li><code>character</code> (Character): The character whose variable changed</li> <li><code>varName</code> (string): The name of the variable that changed</li> <li><code>oldVar</code> (any): The previous value of the variable</li> <li><code>newVar</code> (any): The new value of the variable</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log variable changes\nhook.Add(\"OnCharVarChanged\", \"MyAddon\", function(character, varName, oldVar, newVar)\nprint(character:getName() .. \" var changed: \" .. varName .. \" = \" .. tostring(newVar))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track specific variable changes\nhook.Add(\"OnCharVarChanged\", \"VarTracking\", function(character, varName, oldVar, newVar)\nif varName == \"level\" then\n    local client = character:getPlayer()\n    if client then\n        client:ChatPrint(\"Level changed from \" .. oldVar .. \" to \" .. newVar)\n        end\nelseif varName == \"money\" then\n    local client = character:getPlayer()\n    if client then\n        local difference = newVar - oldVar\n        if difference &gt; 0 then\n            client:ChatPrint(\"You gained $\" .. difference)\n        elseif difference &lt; 0 then\n            client:ChatPrint(\"You lost $\" .. math.abs(difference))\n            end\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex variable change system\nhook.Add(\"OnCharVarChanged\", \"AdvancedVarChange\", function(character, varName, oldVar, newVar)\nlocal client = character:getPlayer()\nif not client then return end\n    -- Track variable change history\n    local changeHistory = character:getData(\"varHistory\", {})\n    changeHistory[varName] = changeHistory[varName] or {}\n    table.insert(changeHistory[varName], {\n    oldValue = oldVar,\n    newValue = newVar,\n    timestamp = os.time()\n    })\n    -- Keep only last 20 changes per variable\n    if #changeHistory[varName] &gt; 20 then\n        table.remove(changeHistory[varName], 1)\n        end\n    character:setData(\"varHistory\", changeHistory)\n    -- Handle specific variable changes\n    if varName == \"level\" then\n        -- Level change effects\n        if newVar &gt; oldVar then\n            hook.Run(\"OnPlayerLevelUp\", client, oldVar, newVar)\n            end\n    elseif varName == \"money\" then\n        -- Money change effects\n        local difference = newVar - oldVar\n        if difference &gt; 0 then\n            client:ChatPrint(\"You gained $\" .. difference)\n        elseif difference &lt; 0 then\n            client:ChatPrint(\"You lost $\" .. math.abs(difference))\n            end\n        -- Check for money milestones\n        if newVar &gt;= 10000 and oldVar &lt; 10000 then\n            client:ChatPrint(\"Congratulations! You've reached $10,000!\")\n        elseif newVar &gt;= 100000 and oldVar &lt; 100000 then\n            client:ChatPrint(\"Congratulations! You've reached $100,000!\")\n            end\n    elseif varName == \"faction\" then\n        -- Faction change effects\n        client:SetTeam(newVar)\n        client:ChatPrint(\"Faction changed to: \" .. newVar)\n        -- Notify other players\n        for _, ply in ipairs(player.GetAll()) do\n            if ply ~= client then\n                ply:ChatPrint(character:getName() .. \" joined faction: \" .. newVar)\n                end\n            end\n    elseif varName == \"health\" then\n        -- Health change effects\n        if newVar &lt;= 0 and oldVar &gt; 0 then\n            -- Character died\n            hook.Run(\"OnCharacterDeath\", character)\n        elseif newVar &gt; 0 and oldVar &lt;= 0 then\n            -- Character revived\n            hook.Run(\"OnCharacterRevive\", character)\n            end\n    elseif varName == \"stamina\" then\n        -- Stamina change effects\n        if newVar &lt;= 0 and oldVar &gt; 0 then\n            -- Stamina depleted\n            hook.Run(\"PlayerStaminaDepleted\", client)\n        elseif newVar &gt; 0 and oldVar &lt;= 0 then\n            -- Stamina restored\n            hook.Run(\"PlayerStaminaGained\", client)\n            end\n        end\n    -- Log significant changes\n    if math.abs(newVar - oldVar) &gt; 100 or varName == \"faction\" or varName == \"level\" then\n        print(string.format(\"%s var changed: %s from %s to %s\",\n        character:getName(), varName, tostring(oldVar), tostring(newVar)))\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#oncheatercaught","title":"OnCheaterCaught","text":"<p>Purpose</p> <p>Called when a cheater is caught</p> <p>When Called</p> <p>When anti-cheat systems detect cheating behavior</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who was caught cheating</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log cheater detection\nhook.Add(\"OnCheaterCaught\", \"MyAddon\", function(client)\nprint(\"Cheater caught: \" .. client:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle cheater punishment\nhook.Add(\"OnCheaterCaught\", \"CheaterPunishment\", function(client)\n-- Kick the cheater\nclient:Kick(\"Cheating detected\")\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[ADMIN] Cheater caught: \" .. client:Name())\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex anti-cheat system\nhook.Add(\"OnCheaterCaught\", \"AdvancedAntiCheat\", function(client)\n-- Get cheater data\nlocal char = client:getChar()\nlocal steamID = client:SteamID()\nlocal ip = client:IPAddress()\n-- Log cheater information\nprint(string.format(\"Cheater caught: %s (SteamID: %s, IP: %s)\",\nclient:Name(), steamID, ip))\n-- Add to cheater database\nlocal cheaterData = {\nname = client:Name(),\nsteamID = steamID,\nip = ip,\ntimestamp = os.time(),\ncharID = char and char:getID() or 0\n}\n-- Store cheater data\nlia.data.set(\"cheaters\", steamID, cheaterData)\n-- Kick the cheater\nclient:Kick(\"Cheating detected - You have been banned\")\n-- Notify all admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[ADMIN] Cheater caught: \" .. client:Name())\n        ply:ChatPrint(\"[ADMIN] SteamID: \" .. steamID)\n        ply:ChatPrint(\"[ADMIN] IP: \" .. ip)\n        end\n    end\n-- Log to file\nlocal logFile = \"cheaters.txt\"\nlocal logData = string.format(\"[%s] %s (SteamID: %s, IP: %s)\\n\",\nos.date(\"%Y-%m-%d %H:%M:%S\"), client:Name(), steamID, ip)\n-- Write to log file\nfile.Append(logFile, logData)\n-- Check for repeat offenders\nlocal cheaterHistory = lia.data.get(\"cheaterHistory\", {})\ncheaterHistory[steamID] = (cheaterHistory[steamID] or 0) + 1\nlia.data.set(\"cheaterHistory\", cheaterHistory)\nif cheaterHistory[steamID] &gt;= 3 then\n    -- Repeat offender\n    print(string.format(\"Repeat cheater: %s (SteamID: %s) - %d offenses\",\n    client:Name(), steamID, cheaterHistory[steamID]))\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#oncheaterstatuschanged","title":"OnCheaterStatusChanged","text":"<p>Purpose</p> <p>Called when a cheater's status changes</p> <p>When Called</p> <p>When a player's cheater status is modified</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose status changed</li> <li><code>target</code> (Player): The target player (if applicable)</li> <li><code>status</code> (string): The new cheater status</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log cheater status changes\nhook.Add(\"OnCheaterStatusChanged\", \"MyAddon\", function(client, target, status)\nprint(client:Name() .. \" cheater status changed to: \" .. status)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle status change effects\nhook.Add(\"OnCheaterStatusChanged\", \"StatusChangeEffects\", function(client, target, status)\nif status == \"banned\" then\n    client:Kick(\"You have been banned for cheating\")\nelseif status == \"warned\" then\n    client:ChatPrint(\"Warning: Cheating behavior detected\")\nelseif status == \"cleared\" then\n    client:ChatPrint(\"Your cheater status has been cleared\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex cheater status system\nhook.Add(\"OnCheaterStatusChanged\", \"AdvancedCheaterStatus\", function(client, target, status)\nlocal char = client:getChar()\nif not char then return end\n    -- Update cheater status\n    char:setData(\"cheaterStatus\", status)\n    char:setData(\"statusChangeTime\", os.time())\n    -- Handle status-specific effects\n    if status == \"banned\" then\n        -- Ban the player\n        client:Kick(\"You have been banned for cheating\")\n        -- Add to ban database\n        local banData = {\n        steamID = client:SteamID(),\n        name = client:Name(),\n        reason = \"Cheating\",\n        timestamp = os.time(),\n        admin = target and target:Name() or \"System\"\n        }\n        lia.data.set(\"bans\", client:SteamID(), banData)\n        -- Notify admins\n        for _, ply in ipairs(player.GetAll()) do\n            if ply:IsAdmin() then\n                ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" has been banned for cheating\")\n                end\n            end\n    elseif status == \"warned\" then\n        -- Warn the player\n        client:ChatPrint(\"Warning: Cheating behavior detected\")\n        -- Add warning to character\n        local warnings = char:getData(\"warnings\", 0) + 1\n        char:setData(\"warnings\", warnings)\n        -- Check for warning limits\n        if warnings &gt;= 3 then\n            client:Kick(\"You have received too many warnings\")\n            end\n        -- Notify admins\n        for _, ply in ipairs(player.GetAll()) do\n            if ply:IsAdmin() then\n                ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" has been warned for cheating\")\n                end\n            end\n    elseif status == \"cleared\" then\n        -- Clear cheater status\n        client:ChatPrint(\"Your cheater status has been cleared\")\n        -- Clear warnings\n        char:setData(\"warnings\", 0)\n        -- Notify admins\n        for _, ply in ipairs(player.GetAll()) do\n            if ply:IsAdmin() then\n                ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" cheater status has been cleared\")\n                end\n            end\n        end\n    -- Log status change\n    print(string.format(\"Cheater status changed: %s -&gt; %s (Admin: %s)\",\n    client:Name(), status, target and target:Name() or \"System\"))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#oncreateplayerragdoll","title":"OnCreatePlayerRagdoll","text":"<p>Purpose</p> <p>Called when creating a player ragdoll</p> <p>When Called</p> <p>When a player ragdoll is being created</p> <p>Parameters</p> <ul> <li><code>self</code> (Player): The player whose ragdoll is being created</li> <li><code>entity</code> (Entity): The ragdoll entity</li> <li><code>isDead</code> (boolean): Whether the player is dead</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log ragdoll creation\nhook.Add(\"OnCreatePlayerRagdoll\", \"MyAddon\", function(self, entity, isDead)\nprint(self:Name() .. \" ragdoll created\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set up ragdoll data\nhook.Add(\"OnCreatePlayerRagdoll\", \"RagdollSetup\", function(self, entity, isDead)\nentity:setNetVar(\"owner\", self:SteamID())\nentity:setNetVar(\"isDead\", isDead)\nentity:setNetVar(\"deathTime\", os.time())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ragdoll creation system\nhook.Add(\"OnCreatePlayerRagdoll\", \"AdvancedRagdollCreation\", function(self, entity, isDead)\nlocal char = self:getChar()\nif not char then return end\n    -- Set up ragdoll data\n    entity:setNetVar(\"owner\", self:SteamID())\n    entity:setNetVar(\"isDead\", isDead)\n    entity:setNetVar(\"deathTime\", os.time())\n    entity:setNetVar(\"charID\", char:getID())\n    entity:setNetVar(\"charName\", char:getName())\n    entity:setNetVar(\"faction\", char:getFaction())\n    -- Set up ragdoll appearance\n    entity:SetModel(self:GetModel())\n    entity:SetSkin(self:GetSkin())\n    -- Set up bodygroups\n    for i = 0, self:GetNumBodyGroups() - 1 do\n        entity:SetBodygroup(i, self:GetBodygroup(i))\n        end\n    -- Set up ragdoll position and angles\n    entity:SetPos(self:GetPos())\n    entity:SetAngles(self:GetAngles())\n    -- Apply faction-specific effects\n    local faction = char:getFaction()\n    if faction == \"police\" then\n        entity:SetColor(Color(0, 0, 255, 200))\n    elseif faction == \"medic\" then\n        entity:SetColor(Color(255, 255, 255, 200))\n        end\n    -- Set up ragdoll physics\n    local phys = entity:GetPhysicsObject()\n    if IsValid(phys) then\n        phys:SetVelocity(self:GetVelocity())\n        end\n    -- Log ragdoll creation\n    print(string.format(\"Ragdoll created for %s (Faction: %s, Dead: %s)\",\n    self:Name(), faction, tostring(isDead)))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#ondataset","title":"OnDataSet","text":"<p>Purpose</p> <p>Called when data is set</p> <p>When Called</p> <p>When persistent data is being saved</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The data key</li> <li><code>value</code> (any): The data value</li> <li><code>gamemode</code> (string): The gamemode name</li> <li><code>map</code> (string): The map name</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log data setting\nhook.Add(\"OnDataSet\", \"MyAddon\", function(key, value, gamemode, map)\nprint(\"Data set: \" .. key .. \" = \" .. tostring(value))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate data before saving\nhook.Add(\"OnDataSet\", \"DataValidation\", function(key, value, gamemode, map)\nif key == \"playerMoney\" and type(value) ~= \"number\" then\n    print(\"Invalid money value: \" .. tostring(value))\n    return false\n    end\nif key == \"playerLevel\" and (value &lt; 1 or value &gt; 100) then\n    print(\"Invalid level value: \" .. tostring(value))\n    return false\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data management system\nhook.Add(\"OnDataSet\", \"AdvancedDataManagement\", function(key, value, gamemode, map)\n-- Log data changes\nprint(string.format(\"Data set: %s = %s (Gamemode: %s, Map: %s)\",\nkey, tostring(value), gamemode, map))\n-- Validate data types\nlocal dataTypes = {\n[\"playerMoney\"] = \"number\",\n[\"playerLevel\"] = \"number\",\n[\"playerName\"] = \"string\",\n[\"playerFaction\"] = \"string\"\n}\nlocal expectedType = dataTypes[key]\nif expectedType and type(value) ~= expectedType then\n    print(\"Type mismatch for \" .. key .. \": expected \" .. expectedType .. \", got \" .. type(value))\n    return false\n    end\n-- Validate value ranges\nif key == \"playerMoney\" and (value &lt; 0 or value &gt; 1000000) then\n    print(\"Money value out of range: \" .. value)\n    return false\n    end\nif key == \"playerLevel\" and (value &lt; 1 or value &gt; 100) then\n    print(\"Level value out of range: \" .. value)\n    return false\n    end\n-- Update data cache\nlia.dataCache = lia.dataCache or {}\nlia.dataCache[key] = {\nvalue = value,\ntimestamp = os.time(),\ngamemode = gamemode,\nmap = map\n}\n-- Notify admins of important changes\nlocal importantKeys = {\"playerMoney\", \"playerLevel\", \"playerFaction\"}\nif table.HasValue(importantKeys, key) then\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() then\n            ply:ChatPrint(\"[DATA] \" .. key .. \" set to \" .. tostring(value))\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#ondatabaseloaded","title":"OnDatabaseLoaded","text":"<p>Purpose</p> <p>Called when the database has finished loading all data</p> <p>When Called</p> <p>After all database operations and data loading is complete</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log database loaded\nhook.Add(\"OnDatabaseLoaded\", \"MyAddon\", function()\nprint(\"Database loading complete\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize addon after DB load\nhook.Add(\"OnDatabaseLoaded\", \"InitAfterDB\", function()\nMyAddon:Initialize()\nprint(\"Addon initialized after database load\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex post-database initialization\nhook.Add(\"OnDatabaseLoaded\", \"AdvancedPostDBInit\", function()\n-- Load all cached data\nlia.data.get(\"allData\", {}, function(data)\nMyAddon.cache = data\nend)\n-- Initialize player statistics\nfor _, ply in ipairs(player.GetAll()) do\n    local char = ply:getChar()\n    if char then\n        char:loadStats()\n        end\n    end\n-- Start background processes\ntimer.Create(\"DataSync\", 300, 0, function()\nMyAddon:SyncData()\nend)\nprint(\"All systems initialized after database load\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#onentityloaded","title":"OnEntityLoaded","text":"<p>Purpose</p> <p>Called when an entity is loaded from the database</p> <p>When Called</p> <p>When an entity is restored from saved data</p> <p>Parameters</p> <ul> <li><code>createdEnt</code> (Entity): The entity that was created</li> <li><code>data</code> (table): The saved entity data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log entity loading\nhook.Add(\"OnEntityLoaded\", \"MyAddon\", function(createdEnt, data)\nprint(\"Entity loaded: \" .. tostring(createdEnt))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track loaded entities\nhook.Add(\"OnEntityLoaded\", \"TrackEntities\", function(createdEnt, data)\nMyAddon.loadedEntities = MyAddon.loadedEntities or {}\ntable.insert(MyAddon.loadedEntities, {\nentity = createdEnt,\nclass = createdEnt:GetClass(),\ntime = os.time()\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entity loading handling\nhook.Add(\"OnEntityLoaded\", \"AdvancedEntityLoading\", function(createdEnt, data)\n-- Log entity loading\nlia.log.write(\"entity_loaded\", {\nclass = createdEnt:GetClass(),\nposition = createdEnt:GetPos(),\ntimestamp = os.time()\n})\n-- Restore custom data\nif data.customData then\n    createdEnt:SetCustomData(data.customData)\n    end\n-- Setup entity-specific behavior\nif createdEnt:GetClass() == \"lia_item\" then\n    createdEnt:SetupItemData(data.itemData)\n    end\n-- Notify entity of loading\nif createdEnt.OnLoaded then\n    createdEnt:OnLoaded(data)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onentitypersistupdated","title":"OnEntityPersistUpdated","text":"<p>Purpose</p> <p>Called when an entity's persistent data is updated</p> <p>When Called</p> <p>When an entity's save data is modified</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The entity being updated</li> <li><code>data</code> (table): The updated persistent data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log entity updates\nhook.Add(\"OnEntityPersistUpdated\", \"MyAddon\", function(ent, data)\nprint(\"Entity data updated: \" .. tostring(ent))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track entity changes\nhook.Add(\"OnEntityPersistUpdated\", \"TrackEntityChanges\", function(ent, data)\nMyAddon.entityChanges = MyAddon.entityChanges or {}\ntable.insert(MyAddon.entityChanges, {\nentity = ent,\ndata = data,\ntime = os.time()\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entity update handling\nhook.Add(\"OnEntityPersistUpdated\", \"AdvancedEntityUpdate\", function(ent, data)\n-- Log entity update\nlia.log.write(\"entity_persist_updated\", {\nclass = ent:GetClass(),\nposition = ent:GetPos(),\ndata = util.TableToJSON(data),\ntimestamp = os.time()\n})\n-- Validate data integrity\nif data.position and not data.position.x then\n    print(\"Warning: Invalid position data for entity \" .. tostring(ent))\n    end\n-- Update entity-specific data\nif ent.OnPersistDataUpdated then\n    ent:OnPersistDataUpdated(data)\n    end\n-- Sync to clients if needed\nif data.syncToClients then\n    net.Start(\"liaEntityDataUpdate\")\n    net.WriteEntity(ent)\n    net.WriteTable(data)\n    net.Broadcast()\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onentitypersisted","title":"OnEntityPersisted","text":"<p>Purpose</p> <p>Called when an entity is persisted to the database</p> <p>When Called</p> <p>When an entity's data is saved to the database</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The entity being saved</li> <li><code>entData</code> (table): The entity data being saved</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log entity persistence\nhook.Add(\"OnEntityPersisted\", \"MyAddon\", function(ent, entData)\nprint(\"Entity persisted: \" .. tostring(ent))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track entity saves\nhook.Add(\"OnEntityPersisted\", \"TrackEntitySaves\", function(ent, entData)\nMyAddon.savedEntities = MyAddon.savedEntities or {}\ntable.insert(MyAddon.savedEntities, {\nentity = ent,\nclass = ent:GetClass(),\ntime = os.time()\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entity persistence handling\nhook.Add(\"OnEntityPersisted\", \"AdvancedEntityPersistence\", function(ent, entData)\n-- Log entity persistence\nlia.log.write(\"entity_persisted\", {\nclass = ent:GetClass(),\nposition = ent:GetPos(),\ndata = util.TableToJSON(entData),\ntimestamp = os.time()\n})\n-- Validate data before saving\nif not entData.position or not entData.angles then\n    print(\"Warning: Incomplete entity data for \" .. tostring(ent))\n    end\n-- Add custom persistence data\nif ent.GetCustomPersistenceData then\n    entData.customData = ent:GetCustomPersistenceData()\n    end\n-- Update entity statistics\nlocal stats = lia.data.get(\"entityStats\", {})\nstats[ent:GetClass()] = (stats[ent:GetClass()] or 0) + 1\nlia.data.set(\"entityStats\", stats)\nend)\n</code></pre></p>"},{"location":"hooks/server/#onitemadded","title":"OnItemAdded","text":"<p>Purpose</p> <p>Called when an item is added to an inventory</p> <p>When Called</p> <p>When an item is successfully added to any inventory</p> <p>Parameters</p> <ul> <li><code>owner</code> (Player|Character): The owner of the inventory</li> <li><code>item</code> (Item): The item that was added</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item additions\nhook.Add(\"OnItemAdded\", \"MyAddon\", function(owner, item)\nprint(\"Item \" .. item.uniqueID .. \" added to inventory\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle special item effects\nhook.Add(\"OnItemAdded\", \"ItemEffects\", function(owner, item)\nlocal char = owner:getChar()\nif not char then return end\n    if item.uniqueID == \"health_potion\" then\n        char:setData(\"healthBonus\", (char:getData(\"healthBonus\", 0) + 10))\n    elseif item.uniqueID == \"stamina_boost\" then\n        char:setData(\"staminaBonus\", (char:getData(\"staminaBonus\", 0) + 5))\n        end\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item management system\nhook.Add(\"OnItemAdded\", \"AdvancedItems\", function(owner, item)\nlocal char = owner:getChar()\nif not char then return end\n    local client = char:getPlayer()\n    if not IsValid(client) then return end\n        -- Check for set bonuses\n        local inventory = char:getInv()\n        local items = inventory:getItems()\n        -- Check for armor set\n        local armorPieces = 0\n        for _, invItem in pairs(items) do\n            if string.find(invItem.uniqueID, \"armor_\") then\n                armorPieces = armorPieces + 1\n                end\n            end\n        if armorPieces &gt;= 3 then\n            char:setData(\"armorSetBonus\", true)\n            client:ChatPrint(\"Armor set bonus activated!\")\n            end\n        -- Check for weapon upgrades\n        if item.uniqueID == \"weapon_upgrade\" then\n            local weapon = inventory:hasItem(\"weapon_pistol\")\n            if weapon then\n                weapon:setData(\"damage\", (weapon:getData(\"damage\", 10) + 5))\n                client:ChatPrint(\"Weapon upgraded!\")\n                end\n            end\n        -- Check for quest items\n        if item:getData(\"questItem\", false) then\n            local questID = item:getData(\"questID\")\n            if questID then\n                char:setData(\"questProgress\", char:getData(\"questProgress\", {})[questID] + 1)\n                client:ChatPrint(\"Quest progress updated!\")\n                end\n            end\n        -- Update inventory weight\n        local itemWeight = item:getData(\"weight\", 1)\n        local currentWeight = char:getData(\"currentWeight\", 0)\n        char:setData(\"currentWeight\", currentWeight + itemWeight)\n        end)\n</code></pre></p>"},{"location":"hooks/server/#onitemcreated","title":"OnItemCreated","text":"<p>Purpose</p> <p>Called when an item instance is created</p> <p>When Called</p> <p>When a new item instance is created from an item table</p> <p>Parameters</p> <ul> <li><code>itemTable</code> (table): The item table definition</li> <li><code>self</code> (Item): The item instance being created</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item creation\nhook.Add(\"OnItemCreated\", \"MyAddon\", function(itemTable, self)\nprint(\"Item created: \" .. itemTable.uniqueID)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set up item-specific data\nhook.Add(\"OnItemCreated\", \"ItemSetup\", function(itemTable, self)\nif itemTable.uniqueID == \"weapon_pistol\" then\n    self:setData(\"ammo\", 12)\n    self:setData(\"damage\", 25)\nelseif itemTable.uniqueID == \"health_potion\" then\n    self:setData(\"healAmount\", 50)\n    self:setData(\"uses\", 3)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item creation system\nhook.Add(\"OnItemCreated\", \"AdvancedItemCreation\", function(itemTable, self)\nlocal char = self:getOwner()\nif not char then return end\n    -- Set up item quality\n    local quality = self:getData(\"quality\", \"common\")\n    local qualityMultipliers = {\n    [\"common\"] = 1.0,\n    [\"uncommon\"] = 1.2,\n    [\"rare\"] = 1.5,\n    [\"epic\"] = 2.0,\n    [\"legendary\"] = 3.0\n    }\n    local multiplier = qualityMultipliers[quality] or 1.0\n    -- Apply quality bonuses\n    if itemTable.uniqueID == \"weapon_pistol\" then\n        local baseDamage = 25\n        self:setData(\"damage\", math.floor(baseDamage * multiplier))\n        self:setData(\"durability\", math.floor(100 * multiplier))\n    elseif itemTable.uniqueID == \"armor_vest\" then\n        local baseProtection = 10\n        self:setData(\"protection\", math.floor(baseProtection * multiplier))\n        self:setData(\"durability\", math.floor(200 * multiplier))\n        end\n    -- Set up item level\n    local itemLevel = self:getData(\"level\", 1)\n    if itemLevel &gt; 1 then\n        local levelBonus = (itemLevel - 1) * 0.1\n        local currentValue = self:getData(\"value\", 100)\n        self:setData(\"value\", math.floor(currentValue * (1 + levelBonus)))\n        end\n    -- Set up item enchantments\n    local enchantments = self:getData(\"enchantments\", {})\n    if #enchantments &gt; 0 then\n        for _, enchant in ipairs(enchantments) do\n            if enchant.type == \"fire\" then\n                self:setData(\"fireDamage\", (self:getData(\"fireDamage\", 0) + enchant.value))\n            elseif enchant.type == \"ice\" then\n                self:setData(\"iceDamage\", (self:getData(\"iceDamage\", 0) + enchant.value))\n                end\n            end\n        end\n    -- Set up item binding\n    if self:getData(\"bindOnPickup\", false) then\n        self:setData(\"boundTo\", char:getID())\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onitemspawned","title":"OnItemSpawned","text":"<p>Purpose</p> <p>Called when an item entity is spawned in the world</p> <p>When Called</p> <p>When an item is dropped or spawned as a world entity</p> <p>Parameters</p> <ul> <li><code>self</code> (Entity): The item entity that was spawned</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item spawning\nhook.Add(\"OnItemSpawned\", \"MyAddon\", function(self)\nprint(\"Item spawned: \" .. self:GetItem().uniqueID)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set up item physics\nhook.Add(\"OnItemSpawned\", \"ItemPhysics\", function(self)\nlocal item = self:GetItem()\nif item.uniqueID == \"heavy_box\" then\n    self:SetPhysicsAttacker(self:GetOwner(), 10)\n    self:GetPhysicsObject():SetMass(100)\nelseif item.uniqueID == \"fragile_item\" then\n    self:SetPhysicsAttacker(self:GetOwner(), 5)\n    self:GetPhysicsObject():SetMass(1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item spawning system\nhook.Add(\"OnItemSpawned\", \"AdvancedItemSpawning\", function(self)\nlocal item = self:GetItem()\nif not item then return end\n    -- Set up item glow effects\n    if item:getData(\"glow\", false) then\n        self:SetMaterial(\"models/effects/comball_tape\")\n        self:SetColor(Color(255, 255, 0, 255))\n        end\n    -- Set up item size\n    local scale = item:getData(\"scale\", 1.0)\n    if scale ~= 1.0 then\n        self:SetModelScale(scale)\n        end\n    -- Set up item physics\n    local physics = self:GetPhysicsObject()\n    if IsValid(physics) then\n        local weight = item:getData(\"weight\", 1)\n        physics:SetMass(weight * 10)\n        -- Set up friction\n        local friction = item:getData(\"friction\", 0.5)\n        physics:SetMaterial(\"friction_\" .. friction)\n        end\n    -- Set up item lifetime\n    local lifetime = item:getData(\"lifetime\", 0)\n    if lifetime &gt; 0 then\n        timer.Simple(lifetime, function()\n        if IsValid(self) then\n            self:Remove()\n            end\n        end)\n        end\n    -- Set up item protection\n    if item:getData(\"protected\", false) then\n        self:SetCollisionGroup(COLLISION_GROUP_WORLD)\n        self:SetSolid(SOLID_VPHYSICS)\n        end\n    -- Set up item sound\n    local sound = item:getData(\"dropSound\")\n    if sound then\n        self:EmitSound(sound)\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onloadtables","title":"OnLoadTables","text":"<p>Purpose</p> <p>Called when database tables are being loaded</p> <p>When Called</p> <p>During database initialization when tables are loaded</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log table loading\nhook.Add(\"OnLoadTables\", \"MyAddon\", function()\nprint(\"Database tables are being loaded\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize custom tables\nhook.Add(\"OnLoadTables\", \"InitCustomTables\", function()\nlia.db.query(\"CREATE TABLE IF NOT EXISTS custom_data (id INT PRIMARY KEY, data TEXT)\")\nprint(\"Custom tables initialized\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex table initialization and migration\nhook.Add(\"OnLoadTables\", \"AdvancedTableSetup\", function()\n-- Create custom tables\nlia.db.query(\"CREATE TABLE IF NOT EXISTS player_stats (steamid VARCHAR(255) PRIMARY KEY, kills INT, deaths INT, playtime INT)\")\n-- Check for table migrations\nlia.db.query(\"SELECT * FROM information_schema.columns WHERE table_name = 'player_stats' AND column_name = 'score'\", function(data)\nif not data or #data == 0 then\n    lia.db.query(\"ALTER TABLE player_stats ADD COLUMN score INT DEFAULT 0\")\n    print(\"Migrated player_stats table\")\n    end\nend)\nend)\n</code></pre></p>"},{"location":"hooks/server/#onoocmessagesent","title":"OnOOCMessageSent","text":"<p>Purpose</p> <p>Called when a player sends an OOC (Out of Character) message</p> <p>When Called</p> <p>When a player sends a message in OOC chat</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player sending the message</li> <li><code>message</code> (string): The OOC message text</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log OOC messages\nhook.Add(\"OnOOCMessageSent\", \"MyAddon\", function(client, message)\nprint(client:Name() .. \" sent OOC: \" .. message)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Filter OOC messages\nhook.Add(\"OnOOCMessageSent\", \"OOCFiltering\", function(client, message)\nlocal char = client:getChar()\nif not char then\n    client:ChatPrint(\"You need a character to use OOC chat\")\n    return false\n    end\n-- Check if player is muted\nif char:getData(\"muted\", false) then\n    client:ChatPrint(\"You are muted and cannot send OOC messages\")\n    return false\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex OOC system\nhook.Add(\"OnOOCMessageSent\", \"AdvancedOOC\", function(client, message)\nlocal char = client:getChar()\nif not char then\n    client:ChatPrint(\"You need a character to use OOC chat\")\n    return false\n    end\n-- Check if player is muted\nif char:getData(\"muted\", false) then\n    client:ChatPrint(\"You are muted and cannot send OOC messages\")\n    return false\n    end\n-- Check if player is gagged\nif char:getData(\"gagged\", false) then\n    client:ChatPrint(\"You are gagged and cannot send OOC messages\")\n    return false\n    end\n-- Check faction restrictions\nlocal faction = char:getFaction()\nif faction == \"police\" then\n    client:ChatPrint(\"Police officers cannot use OOC chat\")\n    return false\n    end\n-- Check for spam protection\nlocal lastOOC = char:getData(\"lastOOC\", 0)\nlocal oocCooldown = 5 -- 5 second cooldown for OOC\nif os.time() - lastOOC &lt; oocCooldown then\n    client:ChatPrint(\"Please wait before sending another OOC message\")\n    return false\n    end\n-- Check message length\nif string.len(message) &gt; 200 then\n    client:ChatPrint(\"OOC message too long (max 200 characters)\")\n    return false\n    end\n-- Check for inappropriate content\nlocal bannedWords = {\"spam\", \"hack\", \"cheat\", \"exploit\"}\nfor _, word in ipairs(bannedWords) do\n    if string.find(string.lower(message), string.lower(word)) then\n        client:ChatPrint(\"Your OOC message was blocked for inappropriate content\")\n        return false\n        end\n    end\n-- Update last OOC time\nchar:setData(\"lastOOC\", os.time())\n-- Check for admin commands\nif string.sub(message, 1, 1) == \"!\" then\n    local command = string.sub(message, 2)\n    if command == \"admin\" then\n        -- Admin command\n        client:ChatPrint(\"Admin command executed\")\n        return false\n        end\n    end\n-- Log OOC message\nprint(string.format(\"[OOC] %s: %s\", client:Name(), message))\n-- Notify admins of OOC usage\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() and ply ~= client then\n        ply:ChatPrint(\"[OOC] \" .. client:Name() .. \": \" .. message)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onpac3parttransfered","title":"OnPAC3PartTransfered","text":"<p>Purpose</p> <p>Called when a PAC3 part is transferred</p> <p>When Called</p> <p>When a PAC3 part is moved between players or inventories</p> <p>Parameters</p> <ul> <li><code>part</code> (table): The PAC3 part data being transferred</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log PAC3 part transfer\nhook.Add(\"OnPAC3PartTransfered\", \"MyAddon\", function(part)\nprint(\"PAC3 part transferred: \" .. (part.name or \"Unknown\"))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track PAC3 transfers\nhook.Add(\"OnPAC3PartTransfered\", \"TrackPAC3Transfers\", function(part)\nMyAddon.pac3Transfers = MyAddon.pac3Transfers or {}\ntable.insert(MyAddon.pac3Transfers, {\npart = part,\ntime = os.time()\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex PAC3 part transfer handling\nhook.Add(\"OnPAC3PartTransfered\", \"AdvancedPAC3Transfer\", function(part)\n-- Log PAC3 transfer\nlia.log.write(\"pac3_part_transferred\", {\npartName = part.name,\npartID = part.id,\ntimestamp = os.time()\n})\n-- Validate part data\nif not part.id or not part.name then\n    print(\"Warning: Invalid PAC3 part data\")\n    return\n    end\n-- Update part statistics\nlocal stats = lia.data.get(\"pac3Stats\", {transfers = 0})\nstats.transfers = stats.transfers + 1\nlia.data.set(\"pac3Stats\", stats)\n-- Notify relevant players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:HasPAC3Part(part.id) then\n        ply:ChatPrint(\"PAC3 part \" .. part.name .. \" has been transferred\")\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onpickupmoney","title":"OnPickupMoney","text":"<p>Purpose</p> <p>Called when a player picks up money</p> <p>When Called</p> <p>When a player collects money from the ground</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player picking up money</li> <li><code>moneyEntity</code> (Entity): The money entity being picked up</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log money pickup\nhook.Add(\"OnPickupMoney\", \"MyAddon\", function(client, moneyEntity)\nprint(client:Name() .. \" picked up money\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track money pickups\nhook.Add(\"OnPickupMoney\", \"TrackMoneyPickups\", function(client, moneyEntity)\nlocal char = client:getChar()\nif char then\n    local amount = moneyEntity:GetMoneyAmount()\n    local pickups = char:getData(\"moneyPickups\", 0)\n    char:setData(\"moneyPickups\", pickups + amount)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex money pickup handling\nhook.Add(\"OnPickupMoney\", \"AdvancedMoneyPickup\", function(client, moneyEntity)\nlocal char = client:getChar()\nif not char then return end\n    local amount = moneyEntity:GetMoneyAmount()\n    -- Log money pickup\n    lia.log.write(\"money_pickup\", {\n    player = client:SteamID(),\n    amount = amount,\n    position = moneyEntity:GetPos(),\n    timestamp = os.time()\n    })\n    -- Update player statistics\n    local stats = char:getData(\"moneyStats\", {pickedUp = 0, totalAmount = 0})\n    stats.pickedUp = stats.pickedUp + 1\n    stats.totalAmount = stats.totalAmount + amount\n    char:setData(\"moneyStats\", stats)\n    -- Check for achievement\n    if stats.totalAmount &gt;= 10000 then\n        hook.Run(\"PlayerEarnedAchievement\", client, \"money_collector\")\n        end\n    -- Notify player\n    client:ChatPrint(\"You picked up \" .. lia.currency.get(amount))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onplayerdropweapon","title":"OnPlayerDropWeapon","text":"<p>Purpose</p> <p>Called when a player drops a weapon</p> <p>When Called</p> <p>When a player drops a weapon from their inventory</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player dropping the weapon</li> <li><code>weapon</code> (Weapon): The weapon being dropped</li> <li><code>entity</code> (Entity): The weapon entity created</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log weapon drops\nhook.Add(\"OnPlayerDropWeapon\", \"MyAddon\", function(client, weapon, entity)\nprint(client:Name() .. \" dropped weapon: \" .. weapon:GetClass())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track weapon drop statistics\nhook.Add(\"OnPlayerDropWeapon\", \"WeaponTracking\", function(client, weapon, entity)\nlocal char = client:getChar()\nif char then\n    char:setData(\"weaponsDropped\", (char:getData(\"weaponsDropped\", 0) + 1))\n    char:setData(\"lastWeaponDrop\", os.time())\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex weapon drop system\nhook.Add(\"OnPlayerDropWeapon\", \"AdvancedWeaponDrop\", function(client, weapon, entity)\nlocal char = client:getChar()\nif not char then return end\n    -- Check if weapon is bound\n    if weapon:getData(\"bound\", false) then\n        local boundTo = weapon:getData(\"boundTo\")\n        if boundTo == char:getID() then\n            client:ChatPrint(\"This weapon is bound to you and cannot be dropped\")\n            return false\n            end\n        end\n    -- Check faction restrictions\n    local faction = char:getFaction()\n    if faction == \"police\" and weapon:GetClass() == \"weapon_pistol\" then\n        client:ChatPrint(\"Police officers cannot drop their service weapon\")\n        return false\n        end\n    -- Check if weapon is valuable\n    local weaponValue = weapon:getData(\"value\", 0)\n    if weaponValue &gt; 1000 then\n        -- Valuable weapon - require confirmation\n        client:ChatPrint(\"Warning: This is a valuable weapon. Are you sure you want to drop it?\")\n        end\n    -- Update weapon drop statistics\n    char:setData(\"weaponsDropped\", (char:getData(\"weaponsDropped\", 0) + 1))\n    char:setData(\"lastWeaponDrop\", os.time())\n    -- Set weapon entity data\n    entity:setNetVar(\"droppedBy\", char:getID())\n    entity:setNetVar(\"droppedTime\", os.time())\n    entity:setNetVar(\"weaponClass\", weapon:GetClass())\n    -- Set weapon entity lifetime\n    local lifetime = 600 -- 10 minutes\n    entity:setNetVar(\"lifetime\", lifetime)\n    -- Start weapon cleanup timer\n    timer.Simple(lifetime, function()\n    if IsValid(entity) then\n        entity:Remove()\n        end\n    end)\n    -- Check for achievement\n    local weaponsDropped = char:getData(\"weaponsDropped\", 0)\n    if weaponsDropped &gt;= 50 and not char:getData(\"achievement_weapon_dropper\", false) then\n        char:setData(\"achievement_weapon_dropper\", true)\n        client:ChatPrint(\"Achievement unlocked: Weapon Dropper!\")\n        end\n    -- Notify nearby players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(client:GetPos()) &lt; 500 then\n            ply:ChatPrint(client:Name() .. \" dropped a weapon\")\n            end\n        end\n    -- Log weapon drop\n    print(string.format(\"%s dropped weapon %s (Value: $%d)\",\n    client:Name(), weapon:GetClass(), weaponValue))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onplayerentersequence","title":"OnPlayerEnterSequence","text":"<p>Purpose</p> <p>Called when a player enters a sequence</p> <p>When Called</p> <p>When a player starts a sequence (animation)</p> <p>Parameters</p> <ul> <li><code>self</code> (Player): The player entering the sequence</li> <li><code>sequenceName</code> (string): The name of the sequence</li> <li><code>callback</code> (function): The callback function to call when sequence ends</li> <li><code>time</code> (number): The duration of the sequence</li> <li><code>noFreeze</code> (boolean): Whether the player should be frozen during sequence</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log sequence entry\nhook.Add(\"OnPlayerEnterSequence\", \"MyAddon\", function(self, sequenceName, callback, time, noFreeze)\nprint(self:Name() .. \" entered sequence: \" .. sequenceName)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track sequence usage\nhook.Add(\"OnPlayerEnterSequence\", \"SequenceTracking\", function(self, sequenceName, callback, time, noFreeze)\nlocal char = self:getChar()\nif char then\n    char:setData(\"sequencesUsed\", (char:getData(\"sequencesUsed\", 0) + 1))\n    char:setData(\"lastSequence\", os.time())\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex sequence system\nhook.Add(\"OnPlayerEnterSequence\", \"AdvancedSequence\", function(self, sequenceName, callback, time, noFreeze)\nlocal char = self:getChar()\nif not char then return end\n    -- Check if player is already in a sequence\n    if char:getData(\"inSequence\", false) then\n        self:ChatPrint(\"You are already performing an action\")\n        return false\n        end\n    -- Check faction restrictions\n    local faction = char:getFaction()\n    local restrictedSequences = {\n    [\"police\"] = {\"dance\", \"sit\"},\n    [\"medic\"] = {\"dance\"},\n    [\"citizen\"] = {}\n    }\n    local restricted = restrictedSequences[faction] or {}\n    if table.HasValue(restricted, sequenceName) then\n        self:ChatPrint(\"Your faction cannot perform this action\")\n        return false\n        end\n    -- Check level requirements\n    local sequenceRequirements = {\n    [\"dance\"] = 5,\n    [\"sit\"] = 1,\n    [\"wave\"] = 1\n    }\n    local requiredLevel = sequenceRequirements[sequenceName]\n    if requiredLevel then\n        local charLevel = char:getData(\"level\", 1)\n        if charLevel &lt; requiredLevel then\n            self:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to perform this action\")\n            return false\n            end\n        end\n    -- Set sequence data\n    char:setData(\"inSequence\", true)\n    char:setData(\"currentSequence\", sequenceName)\n    char:setData(\"sequenceStartTime\", os.time())\n    -- Update sequence statistics\n    char:setData(\"sequencesUsed\", (char:getData(\"sequencesUsed\", 0) + 1))\n    char:setData(\"lastSequence\", os.time())\n    -- Check for achievement\n    local sequencesUsed = char:getData(\"sequencesUsed\", 0)\n    if sequencesUsed &gt;= 100 and not char:getData(\"achievement_performer\", false) then\n        char:setData(\"achievement_performer\", true)\n        self:ChatPrint(\"Achievement unlocked: Performer!\")\n        end\n    -- Set up sequence end callback\n    timer.Simple(time, function()\n    if IsValid(self) and char:getData(\"inSequence\", false) then\n        char:setData(\"inSequence\", false)\n        char:setData(\"currentSequence\", nil)\n        if callback then\n            callback()\n            end\n        end\n    end)\n    -- Notify nearby players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(self:GetPos()) &lt; 500 then\n            ply:ChatPrint(self:Name() .. \" is performing: \" .. sequenceName)\n            end\n        end\n    -- Log sequence entry\n    print(string.format(\"%s entered sequence %s (Duration: %d seconds)\",\n    self:Name(), sequenceName, time))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onplayerinteractitem","title":"OnPlayerInteractItem","text":"<p>Purpose</p> <p>Called when a player interacts with an item</p> <p>When Called</p> <p>When a player uses an item or performs an action on it</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player interacting with the item</li> <li><code>action</code> (string): The action being performed</li> <li><code>self</code> (Item): The item being interacted with</li> <li><code>result</code> (any): The result of the interaction</li> <li><code>data</code> (table): Additional data for the interaction</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item interactions\nhook.Add(\"OnPlayerInteractItem\", \"MyAddon\", function(client, action, self, result, data)\nprint(client:Name() .. \" used \" .. self.uniqueID .. \" with action \" .. action)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle special item effects\nhook.Add(\"OnPlayerInteractItem\", \"ItemEffects\", function(client, action, self, result, data)\nif action == \"use\" then\n    if self.uniqueID == \"health_potion\" then\n        local healAmount = self:getData(\"healAmount\", 50)\n        client:SetHealth(math.min(client:Health() + healAmount, client:GetMaxHealth()))\n        client:ChatPrint(\"You healed for \" .. healAmount .. \" HP\")\n    elseif self.uniqueID == \"stamina_boost\" then\n        local boostAmount = self:getData(\"boostAmount\", 25)\n        local currentStamina = client:getNetVar(\"stamina\", 100)\n        client:setNetVar(\"stamina\", math.min(currentStamina + boostAmount, 100))\n        client:ChatPrint(\"You gained \" .. boostAmount .. \" stamina\")\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item interaction system\nhook.Add(\"OnPlayerInteractItem\", \"AdvancedItemInteractions\", function(client, action, self, result, data)\nlocal char = client:getChar()\nif not char then return end\n    if action == \"use\" then\n        -- Handle consumable items\n        if self.uniqueID == \"health_potion\" then\n            local healAmount = self:getData(\"healAmount\", 50)\n            local charLevel = char:getData(\"level\", 1)\n            healAmount = healAmount * (1 + charLevel * 0.1) -- 10% bonus per level\n            client:SetHealth(math.min(client:Health() + healAmount, client:GetMaxHealth()))\n            client:ChatPrint(\"You healed for \" .. math.floor(healAmount) .. \" HP\")\n            -- Consume the item\n            local uses = self:getData(\"uses\", 1) - 1\n            if uses &lt;= 0 then\n                char:getInv():remove(self)\n            else\n                self:setData(\"uses\", uses)\n                end\n        elseif self.uniqueID == \"weapon_upgrade\" then\n            -- Upgrade weapon\n            local weapon = char:getInv():hasItem(\"weapon_pistol\")\n            if weapon then\n                local currentDamage = weapon:getData(\"damage\", 25)\n                weapon:setData(\"damage\", currentDamage + 5)\n                client:ChatPrint(\"Weapon upgraded! Damage increased by 5\")\n                char:getInv():remove(self)\n            else\n                client:ChatPrint(\"You need a weapon to upgrade\")\n                end\n        elseif self.uniqueID == \"teleport_scroll\" then\n            -- Teleport to spawn\n            local spawns = lia.util.getSpawns()\n            if #spawns &gt; 0 then\n                local spawn = spawns[math.random(#spawns)]\n                client:SetPos(spawn.pos)\n                client:SetAngles(spawn.ang)\n                client:ChatPrint(\"You teleported to spawn\")\n                char:getInv():remove(self)\n                end\n            end\n    elseif action == \"examine\" then\n        -- Show item details\n        local itemData = {\n        name = self.name,\n        description = self.description,\n        value = self:getData(\"value\", 0),\n        weight = self:getData(\"weight\", 1),\n        durability = self:getData(\"durability\", 100)\n        }\n        client:ChatPrint(\"Item: \" .. itemData.name)\n        client:ChatPrint(\"Description: \" .. itemData.description)\n        client:ChatPrint(\"Value: $\" .. itemData.value)\n        client:ChatPrint(\"Weight: \" .. itemData.weight .. \"kg\")\n        client:ChatPrint(\"Durability: \" .. itemData.durability .. \"%\")\n    elseif action == \"repair\" then\n        -- Repair item\n        local currentDurability = self:getData(\"durability\", 100)\n        if currentDurability &lt; 100 then\n            local repairAmount = math.min(50, 100 - currentDurability)\n            self:setData(\"durability\", currentDurability + repairAmount)\n            client:ChatPrint(\"Item repaired! Durability increased by \" .. repairAmount .. \"%\")\n        else\n            client:ChatPrint(\"Item is already at full durability\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onplayerjoinclass","title":"OnPlayerJoinClass","text":"<p>Purpose</p> <p>Called when a player joins a class</p> <p>When Called</p> <p>When a player successfully joins a new class</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player joining the class</li> <li><code>class</code> (string): The class being joined</li> <li><code>oldClass</code> (string): The previous class (if any)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log class changes\nhook.Add(\"OnPlayerJoinClass\", \"MyAddon\", function(client, class, oldClass)\nprint(client:Name() .. \" joined class: \" .. class)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Give class-specific bonuses\nhook.Add(\"OnPlayerJoinClass\", \"ClassBonuses\", function(client, class, oldClass)\nlocal char = client:getChar()\nif not char then return end\n    if class == \"police_officer\" then\n        char:setData(\"authority\", 5)\n        char:setData(\"salary\", 1000)\n    elseif class == \"medic\" then\n        char:setData(\"healingBonus\", 1.5)\n        char:setData(\"salary\", 800)\n    elseif class == \"citizen\" then\n        char:setData(\"authority\", 0)\n        char:setData(\"salary\", 500)\n        end\n    client:ChatPrint(\"Class bonuses applied!\")\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex class system\nhook.Add(\"OnPlayerJoinClass\", \"AdvancedClasses\", function(client, class, oldClass)\nlocal char = client:getChar()\nif not char then return end\n    -- Remove old class bonuses\n    if oldClass then\n        local oldBonuses = {\n        [\"police_officer\"] = {\"authority\", \"salary\"},\n        [\"medic\"] = {\"healingBonus\", \"medicalKnowledge\"},\n        [\"engineer\"] = {\"repairBonus\", \"technicalSkill\"}\n        }\n        local bonuses = oldBonuses[oldClass]\n        if bonuses then\n            for _, bonus in ipairs(bonuses) do\n                char:setData(bonus, 0)\n                end\n            end\n        end\n    -- Apply new class bonuses\n    local classBonuses = {\n    [\"police_officer\"] = {\n    authority = 5,\n    salary = 1000,\n    items = {\"police_badge\", \"handcuffs\", \"radio\"}\n    },\n    [\"medic\"] = {\n    healingBonus = 1.5,\n    medicalKnowledge = 10,\n    salary = 800,\n    items = {\"medkit\", \"stethoscope\", \"bandage\"}\n    },\n    [\"engineer\"] = {\n    repairBonus = 2.0,\n    technicalSkill = 15,\n    salary = 900,\n    items = {\"wrench\", \"screwdriver\", \"multitool\"}\n    }\n    }\n    local bonuses = classBonuses[class]\n    if bonuses then\n        -- Apply stat bonuses\n        for stat, value in pairs(bonuses) do\n            if stat ~= \"items\" then\n                char:setData(stat, value)\n                end\n            end\n        -- Give class items\n        if bonuses.items then\n            local inventory = char:getInv()\n            for _, itemID in ipairs(bonuses.items) do\n                local item = lia.item.instance(itemID)\n                if item then\n                    inventory:add(item)\n                    end\n                end\n            end\n        end\n    -- Update character appearance\n    hook.Run(\"SetupPlayerModel\", client, char)\n    -- Notify other players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply ~= client then\n            ply:ChatPrint(client:Name() .. \" joined the \" .. class .. \" class\")\n            end\n        end\n    -- Log class change\n    print(string.format(\"%s joined class %s (was %s)\",\n    client:Name(), class, oldClass or \"none\"))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onplayerleavesequence","title":"OnPlayerLeaveSequence","text":"<p>Purpose</p> <p>Called when a player leaves a sequence</p> <p>When Called</p> <p>When a player finishes or exits a sequence</p> <p>Parameters</p> <ul> <li><code>self</code> (Player): The player leaving the sequence</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log sequence exit\nhook.Add(\"OnPlayerLeaveSequence\", \"MyAddon\", function(self)\nprint(self:Name() .. \" left sequence\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track sequence completion\nhook.Add(\"OnPlayerLeaveSequence\", \"SequenceTracking\", function(self)\nlocal char = self:getChar()\nif char then\n    char:setData(\"sequencesCompleted\", (char:getData(\"sequencesCompleted\", 0) + 1))\n    char:setData(\"lastSequenceEnd\", os.time())\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex sequence exit system\nhook.Add(\"OnPlayerLeaveSequence\", \"AdvancedSequenceExit\", function(self)\nlocal char = self:getChar()\nif not char then return end\n    -- Get sequence data\n    local currentSequence = char:getData(\"currentSequence\")\n    local sequenceStartTime = char:getData(\"sequenceStartTime\", 0)\n    local sequenceDuration = os.time() - sequenceStartTime\n    -- Update sequence statistics\n    char:setData(\"sequencesCompleted\", (char:getData(\"sequencesCompleted\", 0) + 1))\n    char:setData(\"lastSequenceEnd\", os.time())\n    char:setData(\"totalSequenceTime\", (char:getData(\"totalSequenceTime\", 0) + sequenceDuration))\n    -- Clear sequence data\n    char:setData(\"inSequence\", false)\n    char:setData(\"currentSequence\", nil)\n    char:setData(\"sequenceStartTime\", nil)\n    -- Check for achievement\n    local sequencesCompleted = char:getData(\"sequencesCompleted\", 0)\n    if sequencesCompleted &gt;= 50 and not char:getData(\"achievement_sequence_master\", false) then\n        char:setData(\"achievement_sequence_master\", true)\n        self:ChatPrint(\"Achievement unlocked: Sequence Master!\")\n        end\n    -- Check for sequence-specific achievements\n    if currentSequence == \"dance\" then\n        local danceCount = char:getData(\"danceCount\", 0) + 1\n        char:setData(\"danceCount\", danceCount)\n        if danceCount &gt;= 20 and not char:getData(\"achievement_dancer\", false) then\n            char:setData(\"achievement_dancer\", true)\n            self:ChatPrint(\"Achievement unlocked: Dancer!\")\n            end\n    elseif currentSequence == \"sit\" then\n        local sitCount = char:getData(\"sitCount\", 0) + 1\n        char:setData(\"sitCount\", sitCount)\n        if sitCount &gt;= 10 and not char:getData(\"achievement_sitter\", false) then\n            char:setData(\"achievement_sitter\", true)\n            self:ChatPrint(\"Achievement unlocked: Sitter!\")\n            end\n        end\n    -- Check for sequence duration achievements\n    if sequenceDuration &gt;= 60 then -- 1 minute\n        local longSequences = char:getData(\"longSequences\", 0) + 1\n        char:setData(\"longSequences\", longSequences)\n        if longSequences &gt;= 10 and not char:getData(\"achievement_patient\", false) then\n            char:setData(\"achievement_patient\", true)\n            self:ChatPrint(\"Achievement unlocked: Patient!\")\n            end\n        end\n    -- Notify nearby players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(self:GetPos()) &lt; 500 then\n            ply:ChatPrint(self:Name() .. \" finished performing: \" .. (currentSequence or \"action\"))\n            end\n        end\n    -- Log sequence exit\n    print(string.format(\"%s left sequence %s (Duration: %d seconds)\",\n    self:Name(), currentSequence or \"unknown\", sequenceDuration))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onplayerloststackitem","title":"OnPlayerLostStackItem","text":"<p>Purpose</p> <p>Called when a player loses a stack item</p> <p>When Called</p> <p>When a player's stack item is removed or lost</p> <p>Parameters</p> <ul> <li><code>itemTypeOrItem</code> (string/Item): The item type or item instance that was lost</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log stack item loss\nhook.Add(\"OnPlayerLostStackItem\", \"MyAddon\", function(itemTypeOrItem)\nprint(\"Player lost stack item: \" .. tostring(itemTypeOrItem))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track stack item losses\nhook.Add(\"OnPlayerLostStackItem\", \"TrackStackLosses\", function(itemTypeOrItem)\nMyAddon.stackLosses = MyAddon.stackLosses or {}\nlocal itemType = type(itemTypeOrItem) == \"string\" and itemTypeOrItem or itemTypeOrItem.uniqueID\nMyAddon.stackLosses[itemType] = (MyAddon.stackLosses[itemType] or 0) + 1\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex stack item loss handling\nhook.Add(\"OnPlayerLostStackItem\", \"AdvancedStackLoss\", function(itemTypeOrItem)\nlocal itemType = type(itemTypeOrItem) == \"string\" and itemTypeOrItem or itemTypeOrItem.uniqueID\n-- Log stack item loss\nlia.log.write(\"stack_item_lost\", {\nitemType = itemType,\ntimestamp = os.time()\n})\n-- Find all players who had this item\nfor _, ply in ipairs(player.GetAll()) do\n    local char = ply:getChar()\n    if char then\n        local inventory = char:getInv()\n        if inventory then\n            for _, item in pairs(inventory:getItems()) do\n                if item.uniqueID == itemType then\n                    -- Notify player\n                    ply:ChatPrint(\"You lost a stack item: \" .. item.name)\n                    end\n                end\n            end\n        end\n    end\n-- Update global statistics\nlocal stats = lia.data.get(\"stackStats\", {lost = 0})\nstats.lost = stats.lost + 1\nlia.data.set(\"stackStats\", stats)\nend)\n</code></pre></p>"},{"location":"hooks/server/#onplayerobserve","title":"OnPlayerObserve","text":"<p>Purpose</p> <p>Called when a player enters or exits observer mode</p> <p>When Called</p> <p>When a player starts or stops observing</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player entering/exiting observer mode</li> <li><code>state</code> (boolean): True if entering observer mode, false if exiting</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log observer mode changes\nhook.Add(\"OnPlayerObserve\", \"MyAddon\", function(client, state)\nif state then\n    print(client:Name() .. \" entered observer mode\")\nelse\n    print(client:Name() .. \" exited observer mode\")\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle observer mode restrictions\nhook.Add(\"OnPlayerObserve\", \"ObserverRestrictions\", function(client, state)\nif state then\n    -- Hide player when observing\n    client:SetNoDraw(true)\n    client:SetNotSolid(true)\n    client:SetMoveType(MOVETYPE_NOCLIP)\n    -- Notify other players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply ~= client then\n            ply:ChatPrint(client:Name() .. \" is now observing\")\n            end\n        end\nelse\n    -- Restore player when exiting observer mode\n    client:SetNoDraw(false)\n    client:SetNotSolid(false)\n    client:SetMoveType(MOVETYPE_WALK)\n    -- Notify other players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply ~= client then\n            ply:ChatPrint(client:Name() .. \" is no longer observing\")\n            end\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex observer mode system\nhook.Add(\"OnPlayerObserve\", \"AdvancedObserver\", function(client, state)\nlocal char = client:getChar()\nif not char then return end\n    if state then\n        -- Check if player has permission to observe\n        if not client:IsAdmin() and not char:hasFlags(\"O\") then\n            client:ChatPrint(\"You don't have permission to observe\")\n            return\n            end\n        -- Store original position\n        char:setData(\"observePos\", client:GetPos())\n        char:setData(\"observeAng\", client:GetAngles())\n        -- Set up observer mode\n        client:SetNoDraw(true)\n        client:SetNotSolid(true)\n        client:SetMoveType(MOVETYPE_NOCLIP)\n        client:SetHealth(1)\n        client:SetMaxHealth(1)\n        -- Set observer target\n        local target = char:getData(\"observeTarget\")\n        if target and IsValid(target) then\n            client:SetObserverTarget(target)\n            end\n        -- Notify admins\n        for _, ply in ipairs(player.GetAll()) do\n            if ply:IsAdmin() and ply ~= client then\n                ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" entered observer mode\")\n                end\n            end\n        -- Log observer mode\n        print(string.format(\"%s entered observer mode at %s\",\n        client:Name(), os.date(\"%Y-%m-%d %H:%M:%S\")))\n    else\n        -- Restore player\n        client:SetNoDraw(false)\n        client:SetNotSolid(false)\n        client:SetMoveType(MOVETYPE_WALK)\n        client:SetHealth(100)\n        client:SetMaxHealth(100)\n        -- Restore position if available\n        local observePos = char:getData(\"observePos\")\n        local observeAng = char:getData(\"observeAng\")\n        if observePos and observeAng then\n            client:SetPos(observePos)\n            client:SetAngles(observeAng)\n            end\n        -- Clear observer data\n        char:setData(\"observePos\", nil)\n        char:setData(\"observeAng\", nil)\n        char:setData(\"observeTarget\", nil)\n        -- Notify admins\n        for _, ply in ipairs(player.GetAll()) do\n            if ply:IsAdmin() and ply ~= client then\n                ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" exited observer mode\")\n                end\n            end\n        -- Log observer mode exit\n        print(string.format(\"%s exited observer mode at %s\",\n        client:Name(), os.date(\"%Y-%m-%d %H:%M:%S\")))\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onplayerpurchasedoor","title":"OnPlayerPurchaseDoor","text":"<p>Purpose</p> <p>Called when a player purchases a door</p> <p>When Called</p> <p>When a player successfully buys a door</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player purchasing the door</li> <li><code>door</code> (Entity): The door being purchased</li> <li><code>price</code> (number): The price paid for the door</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log door purchases\nhook.Add(\"OnPlayerPurchaseDoor\", \"MyAddon\", function(client, door, price)\nprint(client:Name() .. \" purchased door for $\" .. price)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle door purchase bonuses\nhook.Add(\"OnPlayerPurchaseDoor\", \"DoorBonuses\", function(client, door, price)\nlocal char = client:getChar()\nif not char then return end\n    -- Give purchase bonus\n    local bonus = math.floor(price * 0.1) -- 10% bonus\n    char:setMoney(char:getMoney() + bonus)\n    -- Set door ownership\n    door:setNetVar(\"owner\", char:getID())\n    door:setNetVar(\"purchaseTime\", os.time())\n    client:ChatPrint(\"Door purchased! You received a $\" .. bonus .. \" bonus\")\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door purchase system\nhook.Add(\"OnPlayerPurchaseDoor\", \"AdvancedDoorPurchases\", function(client, door, price)\nlocal char = client:getChar()\nif not char then return end\n    -- Set up door ownership\n    door:setNetVar(\"owner\", char:getID())\n    door:setNetVar(\"purchaseTime\", os.time())\n    door:setNetVar(\"purchasePrice\", price)\n    -- Give door key\n    local key = lia.item.instance(\"door_key\")\n    if key then\n        key:setData(\"doorID\", door:EntIndex())\n        key:setData(\"doorName\", door:getNetVar(\"doorData\", {}).title or \"Door\")\n        char:getInv():add(key)\n        end\n    -- Check for bulk purchase discount\n    local ownedDoors = 0\n    for _, ent in ipairs(ents.GetAll()) do\n        if IsValid(ent) and ent.IsDoor and ent:getNetVar(\"owner\") == char:getID() then\n            ownedDoors = ownedDoors + 1\n            end\n        end\n    if ownedDoors &gt;= 5 then\n        local discount = math.floor(price * 0.2) -- 20% discount\n        char:setMoney(char:getMoney() + discount)\n        client:ChatPrint(\"Bulk purchase discount: $\" .. discount)\n        end\n    -- Update character statistics\n    char:setData(\"doorsOwned\", (char:getData(\"doorsOwned\", 0) + 1))\n    char:setData(\"totalSpent\", (char:getData(\"totalSpent\", 0) + price))\n    -- Check for achievement\n    if char:getData(\"doorsOwned\", 0) &gt;= 10 then\n        char:setData(\"achievement_landlord\", true)\n        client:ChatPrint(\"Achievement unlocked: Landlord!\")\n        end\n    -- Notify nearby players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(door:GetPos()) &lt; 500 then\n            ply:ChatPrint(client:Name() .. \" purchased a door for $\" .. price)\n            end\n        end\n    -- Log purchase\n    print(string.format(\"%s purchased door %s for $%d\",\n    client:Name(), door:EntIndex(), price))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onplayerswitchclass","title":"OnPlayerSwitchClass","text":"<p>Purpose</p> <p>Called when a player switches classes</p> <p>When Called</p> <p>When a player successfully changes their class</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player switching classes</li> <li><code>class</code> (string): The new class being switched to</li> <li><code>oldClass</code> (string): The previous class</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log class switches\nhook.Add(\"OnPlayerSwitchClass\", \"MyAddon\", function(client, class, oldClass)\nprint(client:Name() .. \" switched from \" .. oldClass .. \" to \" .. class)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle class switch bonuses\nhook.Add(\"OnPlayerSwitchClass\", \"ClassSwitchBonuses\", function(client, class, oldClass)\nlocal char = client:getChar()\nif not char then return end\n    -- Give switch bonus\n    local switchBonus = 100\n    char:setMoney(char:getMoney() + switchBonus)\n    client:ChatPrint(\"Class switch bonus: $\" .. switchBonus)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex class switching system\nhook.Add(\"OnPlayerSwitchClass\", \"AdvancedClassSwitching\", function(client, class, oldClass)\nlocal char = client:getChar()\nif not char then return end\n    -- Remove old class bonuses\n    if oldClass then\n        local oldBonuses = {\n        [\"police_officer\"] = {\"authority\", \"salary\"},\n        [\"medic\"] = {\"healingBonus\", \"medicalKnowledge\"},\n        [\"engineer\"] = {\"repairBonus\", \"technicalSkill\"}\n        }\n        local bonuses = oldBonuses[oldClass]\n        if bonuses then\n            for _, bonus in ipairs(bonuses) do\n                char:setData(bonus, 0)\n                end\n            end\n        end\n    -- Apply new class bonuses\n    local classBonuses = {\n    [\"police_officer\"] = {\n    authority = 5,\n    salary = 1000,\n    items = {\"police_badge\", \"handcuffs\", \"radio\"}\n    },\n    [\"medic\"] = {\n    healingBonus = 1.5,\n    medicalKnowledge = 10,\n    salary = 800,\n    items = {\"medkit\", \"stethoscope\", \"bandage\"}\n    },\n    [\"engineer\"] = {\n    repairBonus = 2.0,\n    technicalSkill = 15,\n    salary = 900,\n    items = {\"wrench\", \"screwdriver\", \"multitool\"}\n    }\n    }\n    local bonuses = classBonuses[class]\n    if bonuses then\n        -- Apply stat bonuses\n        for stat, value in pairs(bonuses) do\n            if stat ~= \"items\" then\n                char:setData(stat, value)\n                end\n            end\n        -- Give class items\n        if bonuses.items then\n            local inventory = char:getInv()\n            for _, itemID in ipairs(bonuses.items) do\n                local item = lia.item.instance(itemID)\n                if item then\n                    inventory:add(item)\n                    end\n                end\n            end\n        end\n    -- Update character appearance\n    hook.Run(\"SetupPlayerModel\", client, char)\n    -- Check for class switch cooldown\n    local lastSwitch = char:getData(\"lastClassSwitch\", 0)\n    local switchCooldown = 3600 -- 1 hour\n    if os.time() - lastSwitch &lt; switchCooldown then\n        client:ChatPrint(\"You must wait before switching classes again\")\n        return false\n        end\n    -- Update switch time\n    char:setData(\"lastClassSwitch\", os.time())\n    -- Check for achievement\n    local classSwitches = char:getData(\"classSwitches\", 0) + 1\n    char:setData(\"classSwitches\", classSwitches)\n    if classSwitches &gt;= 10 and not char:getData(\"achievement_class_hopper\", false) then\n        char:setData(\"achievement_class_hopper\", true)\n        client:ChatPrint(\"Achievement unlocked: Class Hopper!\")\n        end\n    -- Notify other players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply ~= client then\n            ply:ChatPrint(client:Name() .. \" switched to \" .. class .. \" class\")\n            end\n        end\n    -- Log class switch\n    print(string.format(\"%s switched from %s to %s class\",\n    client:Name(), oldClass or \"none\", class))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onrequestitemtransfer","title":"OnRequestItemTransfer","text":"<p>Purpose</p> <p>Called when an item transfer is requested</p> <p>When Called</p> <p>When a request is made to transfer an item to another inventory</p> <p>Parameters</p> <ul> <li><code>item</code> (Item): The item being transferred</li> <li><code>targetInventory</code> (Inventory): The target inventory</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item transfer requests\nhook.Add(\"OnRequestItemTransfer\", \"MyAddon\", function(item, targetInventory)\nprint(\"Item transfer requested: \" .. item.name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track transfer requests\nhook.Add(\"OnRequestItemTransfer\", \"TrackTransferRequests\", function(item, targetInventory)\nMyAddon.transferRequests = MyAddon.transferRequests or {}\ntable.insert(MyAddon.transferRequests, {\nitem = item.uniqueID,\ntarget = targetInventory:getID(),\ntime = os.time()\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex transfer request handling\nhook.Add(\"OnRequestItemTransfer\", \"AdvancedTransferRequest\", function(item, targetInventory)\n-- Log transfer request\nlia.log.write(\"item_transfer_request\", {\nitem = item.uniqueID,\nfrom = item:getInventory():getID(),\nto = targetInventory:getID(),\ntimestamp = os.time()\n})\n-- Check transfer restrictions\nlocal owner = item:getOwner()\nif owner then\n    local char = owner:getChar()\n    if char then\n        local transferCount = char:getData(\"transferCount\", 0)\n        char:setData(\"transferCount\", transferCount + 1)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onsalaryadjust","title":"OnSalaryAdjust","text":"<p>Purpose</p> <p>Called when a player's salary is adjusted</p> <p>When Called</p> <p>When a player's salary amount is modified</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose salary is being adjusted</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log salary adjustments\nhook.Add(\"OnSalaryAdjust\", \"MyAddon\", function(client)\nprint(client:Name() .. \"'s salary was adjusted\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track salary changes\nhook.Add(\"OnSalaryAdjust\", \"TrackSalaryChanges\", function(client)\nlocal char = client:getChar()\nif char then\n    local history = char:getData(\"salaryHistory\", {})\n    table.insert(history, {\n    time = os.time(),\n    action = \"adjusted\"\n    })\n    char:setData(\"salaryHistory\", history)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex salary adjustment tracking\nhook.Add(\"OnSalaryAdjust\", \"AdvancedSalaryAdjustment\", function(client)\nlocal char = client:getChar()\nif not char then return end\n    -- Log salary adjustment\n    lia.log.write(\"salary_adjust\", {\n    player = client:SteamID(),\n    character = char:getID(),\n    faction = char:getFaction(),\n    class = char:getClass(),\n    timestamp = os.time()\n    })\n    -- Update salary statistics\n    local stats = char:getData(\"salaryStats\", {adjustments = 0})\n    stats.adjustments = stats.adjustments + 1\n    stats.lastAdjustment = os.time()\n    char:setData(\"salaryStats\", stats)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onsalarygiven","title":"OnSalaryGiven","text":"<p>Purpose</p> <p>Called when a player receives their salary</p> <p>When Called</p> <p>When salary is paid to a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player receiving the salary</li> <li><code>char</code> (Character): The character receiving the salary</li> <li><code>pay</code> (number): The amount of salary paid</li> <li><code>faction</code> (number): The faction ID</li> <li><code>class</code> (number): The class ID</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log salary payments\nhook.Add(\"OnSalaryGiven\", \"MyAddon\", function(client, char, pay, faction, class)\nprint(client:Name() .. \" received salary: \" .. pay)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track salary payments\nhook.Add(\"OnSalaryGiven\", \"TrackSalaryPayments\", function(client, char, pay, faction, class)\nlocal history = char:getData(\"salaryHistory\", {})\ntable.insert(history, {\namount = pay,\ntime = os.time(),\nfaction = faction,\nclass = class\n})\nchar:setData(\"salaryHistory\", history)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex salary payment tracking\nhook.Add(\"OnSalaryGiven\", \"AdvancedSalaryTracking\", function(client, char, pay, faction, class)\n-- Log salary payment\nlia.log.write(\"salary_given\", {\nplayer = client:SteamID(),\ncharacter = char:getID(),\namount = pay,\nfaction = faction,\nclass = class,\ntimestamp = os.time()\n})\n-- Update salary statistics\nlocal stats = char:getData(\"salaryStats\", {total = 0, count = 0})\nstats.total = stats.total + pay\nstats.count = stats.count + 1\nstats.lastPayment = os.time()\nchar:setData(\"salaryStats\", stats)\n-- Notify player\nclient:ChatPrint(\"You received your salary: \" .. lia.currency.get(pay))\nend)\n</code></pre></p>"},{"location":"hooks/server/#onsaveditemloaded","title":"OnSavedItemLoaded","text":"<p>Purpose</p> <p>Called when saved items are loaded</p> <p>When Called</p> <p>When items are loaded from the database</p> <p>Parameters</p> <ul> <li><code>loadedItems</code> (table): Table of items that were loaded</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log loaded items\nhook.Add(\"OnSavedItemLoaded\", \"MyAddon\", function(loadedItems)\nprint(\"Loaded \" .. table.Count(loadedItems) .. \" items\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track loaded items\nhook.Add(\"OnSavedItemLoaded\", \"TrackLoadedItems\", function(loadedItems)\nMyAddon.loadedItems = MyAddon.loadedItems or {}\nfor _, item in pairs(loadedItems) do\n    table.insert(MyAddon.loadedItems, {\n    uniqueID = item.uniqueID,\n    loaded = os.time()\n    })\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item loading management\nhook.Add(\"OnSavedItemLoaded\", \"AdvancedItemLoading\", function(loadedItems)\n-- Log item loading\nlia.log.write(\"items_loaded\", {\ncount = table.Count(loadedItems),\ntimestamp = os.time()\n})\n-- Validate loaded items\nfor _, item in pairs(loadedItems) do\n    if not item:isValid() then\n        print(\"Warning: Invalid item loaded: \" .. (item.uniqueID or \"Unknown\"))\n        end\n    end\n-- Update item statistics\nMyAddon.itemStats = MyAddon.itemStats or {}\nfor _, item in pairs(loadedItems) do\n    MyAddon.itemStats[item.uniqueID] = (MyAddon.itemStats[item.uniqueID] or 0) + 1\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onserverlog","title":"OnServerLog","text":"<p>Purpose</p> <p>Called when a server log entry is created</p> <p>When Called</p> <p>When a log message is written to the server log</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player associated with the log (can be nil)</li> <li><code>logType</code> (string): The type of log entry</li> <li><code>logString</code> (string): The log message</li> <li><code>category</code> (string): The log category</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Print server logs\nhook.Add(\"OnServerLog\", \"MyAddon\", function(client, logType, logString, category)\nprint(\"[\" .. logType .. \"] \" .. logString)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Filter and store logs\nhook.Add(\"OnServerLog\", \"FilterLogs\", function(client, logType, logString, category)\nif category == \"admin\" then\n    MyAddon.adminLogs = MyAddon.adminLogs or {}\n    table.insert(MyAddon.adminLogs, {\n    type = logType,\n    message = logString,\n    player = client and client:SteamID() or \"Server\",\n    time = os.time()\n    })\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex log management\nhook.Add(\"OnServerLog\", \"AdvancedLogManagement\", function(client, logType, logString, category)\n-- Store log in database\nlia.db.query(\"INSERT INTO server_logs (player, type, message, category, timestamp) VALUES (?, ?, ?, ?, ?)\",\nclient and client:SteamID() or \"Server\",\nlogType,\nlogString,\ncategory,\nos.time()\n)\n-- Send to external logging service\nif category == \"critical\" then\n    http.Post(\"https://logging-service.com/api/log\", {\n    type = logType,\n    message = logString,\n    server = game.GetIPAddress()\n    })\n    end\n-- Notify admins of important logs\nif category == \"admin\" or category == \"critical\" then\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() then\n            ply:ChatPrint(\"[LOG] \" .. logString)\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onticketclaimed","title":"OnTicketClaimed","text":"<p>Purpose</p> <p>Called when a support ticket is claimed by an admin</p> <p>When Called</p> <p>When an admin claims a support ticket</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The admin claiming the ticket</li> <li><code>requester</code> (Player): The player who created the ticket</li> <li><code>ticketMessage</code> (string): The ticket message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log ticket claims\nhook.Add(\"OnTicketClaimed\", \"MyAddon\", function(client, requester, ticketMessage)\nprint(client:Name() .. \" claimed ticket from \" .. requester:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track ticket claims\nhook.Add(\"OnTicketClaimed\", \"TrackTicketClaims\", function(client, requester, ticketMessage)\nlocal char = client:getChar()\nif char then\n    local claims = char:getData(\"ticketsClaimed\", 0)\n    char:setData(\"ticketsClaimed\", claims + 1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ticket claim handling\nhook.Add(\"OnTicketClaimed\", \"AdvancedTicketClaim\", function(client, requester, ticketMessage)\n-- Log ticket claim\nlia.log.write(\"ticket_claimed\", {\nadmin = client:SteamID(),\nrequester = requester:SteamID(),\nmessage = ticketMessage,\ntimestamp = os.time()\n})\n-- Notify both parties\nclient:ChatPrint(\"You claimed the ticket from \" .. requester:Name())\nrequester:ChatPrint(client:Name() .. \" is handling your ticket\")\n-- Update ticket statistics\nlocal char = client:getChar()\nif char then\n    local stats = char:getData(\"ticketStats\", {claimed = 0, resolved = 0})\n    stats.claimed = stats.claimed + 1\n    char:setData(\"ticketStats\", stats)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onticketclosed","title":"OnTicketClosed","text":"<p>Purpose</p> <p>Called when a support ticket is closed</p> <p>When Called</p> <p>When a support ticket is resolved and closed</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The admin closing the ticket</li> <li><code>requester</code> (Player): The player who created the ticket</li> <li><code>ticketMessage</code> (string): The ticket message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log ticket closures\nhook.Add(\"OnTicketClosed\", \"MyAddon\", function(client, requester, ticketMessage)\nprint(client:Name() .. \" closed ticket from \" .. requester:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track ticket resolutions\nhook.Add(\"OnTicketClosed\", \"TrackTicketClosures\", function(client, requester, ticketMessage)\nlocal char = client:getChar()\nif char then\n    local resolved = char:getData(\"ticketsResolved\", 0)\n    char:setData(\"ticketsResolved\", resolved + 1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ticket closure handling\nhook.Add(\"OnTicketClosed\", \"AdvancedTicketClosure\", function(client, requester, ticketMessage)\n-- Log ticket closure\nlia.log.write(\"ticket_closed\", {\nadmin = client:SteamID(),\nrequester = requester:SteamID(),\nmessage = ticketMessage,\ntimestamp = os.time()\n})\n-- Notify both parties\nclient:ChatPrint(\"You closed the ticket from \" .. requester:Name())\nrequester:ChatPrint(\"Your ticket has been resolved by \" .. client:Name())\n-- Update ticket statistics\nlocal char = client:getChar()\nif char then\n    local stats = char:getData(\"ticketStats\", {claimed = 0, resolved = 0})\n    stats.resolved = stats.resolved + 1\n    char:setData(\"ticketStats\", stats)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onticketcreated","title":"OnTicketCreated","text":"<p>Purpose</p> <p>Called when a new support ticket is created</p> <p>When Called</p> <p>When a player creates a support ticket</p> <p>Parameters</p> <ul> <li><code>noob</code> (Player): The player creating the ticket</li> <li><code>message</code> (string): The ticket message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log ticket creation\nhook.Add(\"OnTicketCreated\", \"MyAddon\", function(noob, message)\nprint(noob:Name() .. \" created a ticket: \" .. message)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify admins of new tickets\nhook.Add(\"OnTicketCreated\", \"NotifyAdmins\", function(noob, message)\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"New ticket from \" .. noob:Name() .. \": \" .. message)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ticket creation handling\nhook.Add(\"OnTicketCreated\", \"AdvancedTicketCreation\", function(noob, message)\n-- Log ticket creation\nlia.log.write(\"ticket_created\", {\nplayer = noob:SteamID(),\nmessage = message,\ntimestamp = os.time()\n})\n-- Store ticket in database\nlia.db.query(\"INSERT INTO tickets (player, message, status, created) VALUES (?, ?, ?, ?)\",\nnoob:SteamID(),\nmessage,\n\"open\",\nos.time()\n)\n-- Notify all admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[TICKET] \" .. noob:Name() .. \": \" .. message)\n        surface.PlaySound(\"buttons/button15.wav\")\n        end\n    end\n-- Confirm to player\nnoob:ChatPrint(\"Your ticket has been submitted. An admin will assist you shortly.\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#ontransferred","title":"OnTransferred","text":"<p>Purpose</p> <p>Called when a player is transferred</p> <p>When Called</p> <p>When a player is successfully transferred</p> <p>Parameters</p> <ul> <li><code>targetPlayer</code> (Player): The player who was transferred</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log player transfers\nhook.Add(\"OnTransferred\", \"MyAddon\", function(targetPlayer)\nprint(targetPlayer:Name() .. \" was transferred\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track player transfers\nhook.Add(\"OnTransferred\", \"TrackTransfers\", function(targetPlayer)\nlocal char = targetPlayer:getChar()\nif char then\n    local transfers = char:getData(\"transfers\", 0)\n    char:setData(\"transfers\", transfers + 1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex transfer handling\nhook.Add(\"OnTransferred\", \"AdvancedTransfer\", function(targetPlayer)\nlocal char = targetPlayer:getChar()\nif not char then return end\n    -- Log transfer\n    lia.log.write(\"player_transferred\", {\n    player = targetPlayer:SteamID(),\n    character = char:getID(),\n    timestamp = os.time()\n    })\n    -- Update transfer statistics\n    local stats = char:getData(\"transferStats\", {count = 0})\n    stats.count = stats.count + 1\n    stats.lastTransfer = os.time()\n    char:setData(\"transferStats\", stats)\n    -- Notify player\n    targetPlayer:ChatPrint(\"You have been transferred\")\n    -- Sync character data\n    char:sync()\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onusergroupcreated","title":"OnUsergroupCreated","text":"<p>Purpose</p> <p>Called when a new usergroup is created</p> <p>When Called</p> <p>When a usergroup is added to the system</p> <p>Parameters</p> <ul> <li><code>groupName</code> (string): The name of the usergroup</li> <li><code>groupData</code> (table): The usergroup configuration data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log usergroup creation\nhook.Add(\"OnUsergroupCreated\", \"MyAddon\", function(groupName, groupData)\nprint(\"Usergroup created: \" .. groupName)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track usergroups\nhook.Add(\"OnUsergroupCreated\", \"TrackUsergroups\", function(groupName, groupData)\nMyAddon.usergroups = MyAddon.usergroups or {}\nMyAddon.usergroups[groupName] = {\ndata = groupData,\ncreated = os.time()\n}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex usergroup creation handling\nhook.Add(\"OnUsergroupCreated\", \"AdvancedUsergroupCreation\", function(groupName, groupData)\n-- Log usergroup creation\nlia.log.write(\"usergroup_created\", {\nname = groupName,\npermissions = groupData.permissions or {},\ntimestamp = os.time()\n})\n-- Store usergroup in database\nlia.db.query(\"INSERT INTO usergroups (name, data, created) VALUES (?, ?, ?)\",\ngroupName,\nutil.TableToJSON(groupData),\nos.time()\n)\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"New usergroup created: \" .. groupName)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onusergrouppermissionschanged","title":"OnUsergroupPermissionsChanged","text":"<p>Purpose</p> <p>Called when usergroup permissions are changed</p> <p>When Called</p> <p>When a usergroup's permissions are modified</p> <p>Parameters</p> <ul> <li><code>groupName</code> (string): The name of the usergroup</li> <li><code>permissions</code> (table): The new permissions table</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log permission changes\nhook.Add(\"OnUsergroupPermissionsChanged\", \"MyAddon\", function(groupName, permissions)\nprint(\"Permissions changed for: \" .. groupName)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track permission changes\nhook.Add(\"OnUsergroupPermissionsChanged\", \"TrackPermissionChanges\", function(groupName, permissions)\nMyAddon.permissionHistory = MyAddon.permissionHistory or {}\ntable.insert(MyAddon.permissionHistory, {\ngroup = groupName,\npermissions = permissions,\ntime = os.time()\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex permission change handling\nhook.Add(\"OnUsergroupPermissionsChanged\", \"AdvancedPermissionChange\", function(groupName, permissions)\n-- Log permission changes\nlia.log.write(\"permissions_changed\", {\ngroup = groupName,\npermissions = util.TableToJSON(permissions),\ntimestamp = os.time()\n})\n-- Update database\nlia.db.query(\"UPDATE usergroups SET permissions = ? WHERE name = ?\",\nutil.TableToJSON(permissions),\ngroupName\n)\n-- Notify affected players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:GetUserGroup() == groupName then\n        ply:ChatPrint(\"Your usergroup permissions have been updated\")\n        end\n    end\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"Permissions updated for \" .. groupName)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onusergroupremoved","title":"OnUsergroupRemoved","text":"<p>Purpose</p> <p>Called when a usergroup is removed</p> <p>When Called</p> <p>When a usergroup is deleted from the system</p> <p>Parameters</p> <ul> <li><code>groupName</code> (string): The name of the usergroup being removed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log usergroup removal\nhook.Add(\"OnUsergroupRemoved\", \"MyAddon\", function(groupName)\nprint(\"Usergroup removed: \" .. groupName)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up usergroup data\nhook.Add(\"OnUsergroupRemoved\", \"CleanupUsergroup\", function(groupName)\nif MyAddon.usergroups and MyAddon.usergroups[groupName] then\n    MyAddon.usergroups[groupName] = nil\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex usergroup removal handling\nhook.Add(\"OnUsergroupRemoved\", \"AdvancedUsergroupRemoval\", function(groupName)\n-- Log usergroup removal\nlia.log.write(\"usergroup_removed\", {\nname = groupName,\ntimestamp = os.time()\n})\n-- Remove from database\nlia.db.query(\"DELETE FROM usergroups WHERE name = ?\", groupName)\n-- Reassign affected players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:GetUserGroup() == groupName then\n        ply:SetUserGroup(\"user\")\n        ply:ChatPrint(\"Your usergroup has been removed. You have been reassigned to 'user'.\")\n        end\n    end\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"Usergroup removed: \" .. groupName)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onusergrouprenamed","title":"OnUsergroupRenamed","text":"<p>Purpose</p> <p>Called when a usergroup is renamed</p> <p>When Called</p> <p>When a usergroup's name is changed</p> <p>Parameters</p> <ul> <li><code>oldName</code> (string): The old name of the usergroup</li> <li><code>newName</code> (string): The new name of the usergroup</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log usergroup rename\nhook.Add(\"OnUsergroupRenamed\", \"MyAddon\", function(oldName, newName)\nprint(\"Usergroup renamed: \" .. oldName .. \" -&gt; \" .. newName)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update usergroup tracking\nhook.Add(\"OnUsergroupRenamed\", \"UpdateUsergroupTracking\", function(oldName, newName)\nif MyAddon.usergroups and MyAddon.usergroups[oldName] then\n    MyAddon.usergroups[newName] = MyAddon.usergroups[oldName]\n    MyAddon.usergroups[oldName] = nil\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex usergroup rename handling\nhook.Add(\"OnUsergroupRenamed\", \"AdvancedUsergroupRename\", function(oldName, newName)\n-- Log usergroup rename\nlia.log.write(\"usergroup_renamed\", {\noldName = oldName,\nnewName = newName,\ntimestamp = os.time()\n})\n-- Update database\nlia.db.query(\"UPDATE usergroups SET name = ? WHERE name = ?\", newName, oldName)\n-- Update all players in this usergroup\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:GetUserGroup() == oldName then\n        ply:SetUserGroup(newName)\n        ply:ChatPrint(\"Your usergroup has been renamed to: \" .. newName)\n        end\n    end\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"Usergroup renamed: \" .. oldName .. \" -&gt; \" .. newName)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#onvendoredited","title":"OnVendorEdited","text":"<p>Purpose</p> <p>Called when a vendor is edited</p> <p>When Called</p> <p>When a vendor's properties are modified</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player editing the vendor</li> <li><code>vendor</code> (Entity): The vendor entity being edited</li> <li><code>key</code> (string): The property being modified</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor edits\nhook.Add(\"OnVendorEdited\", \"MyAddon\", function(client, vendor, key)\nprint(client:Name() .. \" edited vendor property: \" .. key)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate vendor edits\nhook.Add(\"OnVendorEdited\", \"VendorValidation\", function(client, vendor, key)\nif key == \"price\" then\n    local newPrice = vendor:getNetVar(\"price\", 0)\n    if newPrice &lt; 0 then\n        client:ChatPrint(\"Price cannot be negative\")\n        return false\n        end\nelseif key == \"stock\" then\n    local newStock = vendor:getNetVar(\"stock\", 0)\n    if newStock &lt; 0 then\n        client:ChatPrint(\"Stock cannot be negative\")\n        return false\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor editing system\nhook.Add(\"OnVendorEdited\", \"AdvancedVendorEditing\", function(client, vendor, key)\nlocal char = client:getChar()\nif not char then return end\n    -- Check if player has permission to edit vendors\n    if not char:hasFlags(\"V\") then\n        client:ChatPrint(\"You don't have permission to edit vendors\")\n        return false\n        end\n    -- Validate specific properties\n    if key == \"price\" then\n        local newPrice = vendor:getNetVar(\"price\", 0)\n        if newPrice &lt; 0 then\n            client:ChatPrint(\"Price cannot be negative\")\n            return false\n            end\n        -- Check for price limits based on faction\n        local faction = char:getFaction()\n        local maxPrice = {\n        [\"police\"] = 10000,\n        [\"medic\"] = 8000,\n        [\"citizen\"] = 5000\n        }\n        local limit = maxPrice[faction] or 5000\n        if newPrice &gt; limit then\n            client:ChatPrint(\"Price exceeds your faction limit of $\" .. limit)\n            return false\n            end\n    elseif key == \"stock\" then\n        local newStock = vendor:getNetVar(\"stock\", 0)\n        if newStock &lt; 0 then\n            client:ChatPrint(\"Stock cannot be negative\")\n            return false\n            end\n        -- Check for stock limits\n        local maxStock = 1000\n        if newStock &gt; maxStock then\n            client:ChatPrint(\"Stock cannot exceed \" .. maxStock)\n            return false\n            end\n    elseif key == \"faction\" then\n        local newFaction = vendor:getNetVar(\"faction\", \"citizen\")\n        local allowedFactions = {\"police\", \"medic\", \"citizen\", \"criminal\"}\n        if not table.HasValue(allowedFactions, newFaction) then\n            client:ChatPrint(\"Invalid faction: \" .. newFaction)\n            return false\n            end\n        end\n    -- Log the edit\n    print(string.format(\"%s edited vendor %s property %s to %s\",\n    client:Name(), vendor:EntIndex(), key, tostring(vendor:getNetVar(key))))\n    -- Notify other admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() and ply ~= client then\n            ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" edited vendor \" .. vendor:EntIndex() .. \" (\" .. key .. \")\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#onlinestaffdatareceived","title":"OnlineStaffDataReceived","text":"<p>Purpose</p> <p>Called when online staff data is received</p> <p>When Called</p> <p>When the server receives updated staff information</p> <p>Parameters</p> <ul> <li><code>staffData</code> (table): The staff data containing online staff information</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log staff data\nhook.Add(\"OnlineStaffDataReceived\", \"MyAddon\", function(staffData)\nprint(\"Received staff data for \" .. table.Count(staffData) .. \" staff members\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track online staff\nhook.Add(\"OnlineStaffDataReceived\", \"TrackStaff\", function(staffData)\nMyAddon.onlineStaff = MyAddon.onlineStaff or {}\nfor steamID, data in pairs(staffData) do\n    MyAddon.onlineStaff[steamID] = {\n    name = data.name,\n    rank = data.rank,\n    lastSeen = os.time()\n    }\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex staff management\nhook.Add(\"OnlineStaffDataReceived\", \"AdvancedStaffManagement\", function(staffData)\n-- Log staff data update\nlia.log.write(\"staff_data_received\", {\ncount = table.Count(staffData),\ntimestamp = os.time()\n})\n-- Update staff database\nfor steamID, data in pairs(staffData) do\n    lia.db.query(\"INSERT OR REPLACE INTO staff_data (steamid, name, rank, last_seen) VALUES (?, ?, ?, ?)\",\n    steamID,\n    data.name,\n    data.rank,\n    os.time()\n    )\n    end\n-- Notify players of staff changes\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"Staff data updated\")\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#optionreceived","title":"OptionReceived","text":"<p>Purpose</p> <p>Called when a client option is received</p> <p>When Called</p> <p>When the server receives an option setting from a client</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who sent the option</li> <li><code>key</code> (string): The option key</li> <li><code>value</code> (any): The option value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log option changes\nhook.Add(\"OptionReceived\", \"MyAddon\", function(client, key, value)\nprint(client:Name() .. \" changed option \" .. key .. \" to \" .. tostring(value))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track option changes\nhook.Add(\"OptionReceived\", \"TrackOptions\", function(client, key, value)\nlocal char = client:getChar()\nif char then\n    local options = char:getData(\"options\", {})\n    options[key] = value\n    char:setData(\"options\", options)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex option handling\nhook.Add(\"OptionReceived\", \"AdvancedOptionHandling\", function(client, key, value)\n-- Log option change\nlia.log.write(\"option_changed\", {\nplayer = client:SteamID(),\nkey = key,\nvalue = tostring(value),\ntimestamp = os.time()\n})\n-- Validate option value\nif key == \"volume\" and (value &lt; 0 or value &gt; 1) then\n    client:ChatPrint(\"Invalid volume value\")\n    return\n    end\n-- Store option in character data\nlocal char = client:getChar()\nif char then\n    local options = char:getData(\"options\", {})\n    options[key] = value\n    char:setData(\"options\", options)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#overridespawntime","title":"OverrideSpawnTime","text":"<p>Purpose</p> <p>Called to override a player's respawn time</p> <p>When Called</p> <p>When a player's respawn time needs to be modified</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player respawning</li> <li><code>respawnTime</code> (number): The current respawn time in seconds</li> </ul> <p>Returns</p> <ul> <li>number - The overridden respawn time (or nil to use default)</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Reduce respawn time\nhook.Add(\"OverrideSpawnTime\", \"MyAddon\", function(client, respawnTime)\nreturn respawnTime * 0.5\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Faction-based respawn times\nhook.Add(\"OverrideSpawnTime\", \"FactionRespawnTime\", function(client, respawnTime)\nlocal char = client:getChar()\nif not char then return end\n    local faction = char:getFaction()\n    if faction == FACTION_POLICE then\n        return 30\n    elseif faction == FACTION_MEDIC then\n        return 20\n        end\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic respawn time system\nhook.Add(\"OverrideSpawnTime\", \"DynamicRespawnTime\", function(client, respawnTime)\nlocal char = client:getChar()\nif not char then return end\n    -- Check for respawn time reduction items\n    local inventory = char:getInv()\n    if inventory then\n        for _, item in pairs(inventory:getItems()) do\n            if item.reduceRespawnTime then\n                respawnTime = respawnTime * 0.75\n                end\n            end\n        end\n    -- Check for VIP status\n    if client:IsUserGroup(\"vip\") then\n        respawnTime = respawnTime * 0.5\n        end\n    -- Check death count\n    local deaths = char:getData(\"deaths\", 0)\n    if deaths &gt; 5 then\n        respawnTime = respawnTime + (deaths * 2)\n        end\n    return math.max(respawnTime, 5)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#playeraccessvendor","title":"PlayerAccessVendor","text":"<p>Purpose</p> <p>Called when a player accesses a vendor</p> <p>When Called</p> <p>When a player interacts with a vendor entity</p> <p>Parameters</p> <ul> <li><code>activator</code> (Player): The player accessing the vendor</li> <li><code>self</code> (Entity): The vendor entity</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor access\nhook.Add(\"PlayerAccessVendor\", \"MyAddon\", function(activator, self)\nprint(activator:Name() .. \" accessed a vendor\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track vendor usage\nhook.Add(\"PlayerAccessVendor\", \"TrackVendorUsage\", function(activator, self)\nlocal char = activator:getChar()\nif char then\n    local vendorUses = char:getData(\"vendorUses\", 0)\n    char:setData(\"vendorUses\", vendorUses + 1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor access tracking\nhook.Add(\"PlayerAccessVendor\", \"AdvancedVendorAccess\", function(activator, self)\nlocal char = activator:getChar()\nif not char then return end\n    -- Track vendor usage\n    local vendorUses = char:getData(\"vendorUses\", 0)\n    char:setData(\"vendorUses\", vendorUses + 1)\n    -- Log to database\n    local vendorID = self:getNetVar(\"vendorID\", \"unknown\")\n    lia.db.query(\"INSERT INTO vendor_logs (timestamp, charid, vendorid) VALUES (?, ?, ?)\",\n    os.time(), char:getID(), vendorID)\n    -- Apply first-time bonus\n    if vendorUses == 0 then\n        activator:ChatPrint(\"First time using a vendor! Here's a discount.\")\n        self:setNetVar(\"discount_\" .. char:getID(), 10)\n        end\n    -- Check for achievements\n    if vendorUses + 1 &gt;= 100 then\n        if not char:getData(\"achievement_shopaholic\", false) then\n            char:setData(\"achievement_shopaholic\", true)\n            activator:ChatPrint(\"Achievement unlocked: Shopaholic!\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#playercheatdetected","title":"PlayerCheatDetected","text":"<p>Purpose</p> <p>Called when a player is detected cheating</p> <p>When Called</p> <p>When anti-cheat systems detect suspicious behavior</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who was detected cheating</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log cheat detection\nhook.Add(\"PlayerCheatDetected\", \"MyAddon\", function(client)\nprint(\"Cheat detected: \" .. client:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle cheat detection\nhook.Add(\"PlayerCheatDetected\", \"HandleCheating\", function(client)\nclient:Kick(\"Cheating detected\")\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"Player \" .. client:Name() .. \" was kicked for cheating\")\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex cheat detection handling\nhook.Add(\"PlayerCheatDetected\", \"AdvancedCheatDetection\", function(client)\n-- Log cheat detection\nlia.log.write(\"cheat_detected\", {\nplayer = client:SteamID(),\nname = client:Name(),\nip = client:IPAddress(),\ntimestamp = os.time()\n})\n-- Record cheat attempt\nlia.db.query(\"INSERT INTO cheat_logs (steamid, name, ip, timestamp) VALUES (?, ?, ?, ?)\",\nclient:SteamID(),\nclient:Name(),\nclient:IPAddress(),\nos.time()\n)\n-- Apply punishment based on history\nlocal char = client:getChar()\nif char then\n    local cheatCount = char:getData(\"cheatCount\", 0) + 1\n    char:setData(\"cheatCount\", cheatCount)\n    if cheatCount &gt;= 3 then\n        client:Ban(0, \"Multiple cheat violations\")\n    else\n        client:Kick(\"Cheating detected (Warning \" .. cheatCount .. \"/3)\")\n        end\n    end\n-- Notify all admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[CHEAT] \" .. client:Name() .. \" detected and punished\")\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#playerdisconnect","title":"PlayerDisconnect","text":"<p>Purpose</p> <p>Called when a player disconnects</p> <p>When Called</p> <p>When a player leaves the server</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player disconnecting</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log disconnect\nhook.Add(\"PlayerDisconnect\", \"MyAddon\", function(client)\nprint(client:Name() .. \" disconnected\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save player data on disconnect\nhook.Add(\"PlayerDisconnect\", \"SaveOnDisconnect\", function(client)\nlocal char = client:getChar()\nif char then\n    char:save()\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex disconnect handling\nhook.Add(\"PlayerDisconnect\", \"AdvancedDisconnect\", function(client)\nlocal char = client:getChar()\nif char then\n    -- Save character data\n    char:save()\n    -- Update playtime\n    local sessionStart = char:getData(\"sessionStart\", os.time())\n    local sessionTime = os.time() - sessionStart\n    local totalPlaytime = char:getData(\"playTime\", 0)\n    char:setData(\"playTime\", totalPlaytime + sessionTime)\n    -- Log disconnect\n    lia.db.query(\"INSERT INTO disconnect_logs (timestamp, steamid, charid, playtime) VALUES (?, ?, ?, ?)\",\n    os.time(), client:SteamID(), char:getID(), sessionTime)\n    end\n-- Notify other players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client then\n        ply:ChatPrint(client:Name() .. \" has disconnected\")\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#playergagged","title":"PlayerGagged","text":"<p>Purpose</p> <p>Called when a player is gagged</p> <p>When Called</p> <p>When a player's voice chat is disabled</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player being gagged</li> <li><code>admin</code> (Player): The admin issuing the gag</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log gag\nhook.Add(\"PlayerGagged\", \"MyAddon\", function(target, admin)\nprint(target:Name() .. \" was gagged by \" .. admin:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track gag history\nhook.Add(\"PlayerGagged\", \"TrackGagHistory\", function(target, admin)\nlocal char = target:getChar()\nif char then\n    local gagHistory = char:getData(\"gagHistory\", {})\n    table.insert(gagHistory, {admin = admin:SteamID(), time = os.time()})\n    char:setData(\"gagHistory\", gagHistory)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex gag management\nhook.Add(\"PlayerGagged\", \"AdvancedGagManagement\", function(target, admin)\nlocal char = target:getChar()\nif not char then return end\n    -- Track gag history\n    local gagHistory = char:getData(\"gagHistory\", {})\n    table.insert(gagHistory, {\n    admin = admin:SteamID(),\n    adminName = admin:Name(),\n    time = os.time()\n    })\n    char:setData(\"gagHistory\", gagHistory)\n    -- Log to database\n    lia.db.query(\"INSERT INTO gag_logs (timestamp, target_steamid, admin_steamid) VALUES (?, ?, ?)\",\n    os.time(), target:SteamID(), admin:SteamID())\n    -- Notify player\n    target:ChatPrint(\"You have been gagged by \" .. admin:Name())\n    -- Notify other admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() and ply ~= admin and ply ~= target then\n            ply:ChatPrint(\"[ADMIN] \" .. admin:Name() .. \" gagged \" .. target:Name())\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#playerliliadataloaded","title":"PlayerLiliaDataLoaded","text":"<p>Purpose</p> <p>Called when a player's Lilia data is loaded</p> <p>When Called</p> <p>When a player's framework data has been loaded from the database</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose data was loaded</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log data loading\nhook.Add(\"PlayerLiliaDataLoaded\", \"MyAddon\", function(client)\nprint(\"Lilia data loaded for \" .. client:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize player after data load\nhook.Add(\"PlayerLiliaDataLoaded\", \"InitPlayer\", function(client)\nlocal char = client:getChar()\nif char then\n    char:setData(\"addonInitialized\", true)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data loading handling\nhook.Add(\"PlayerLiliaDataLoaded\", \"AdvancedDataLoading\", function(client)\nlocal char = client:getChar()\nif not char then return end\n    -- Log data loading\n    lia.log.write(\"player_data_loaded\", {\n    player = client:SteamID(),\n    character = char:getID(),\n    timestamp = os.time()\n    })\n    -- Load custom player data\n    lia.data.get(\"player_\" .. client:SteamID(), {}, function(data)\n    client.customData = data\n    end)\n    -- Initialize player systems\n    if MyAddon.playerSystems then\n        MyAddon.playerSystems:InitializePlayer(client)\n        end\n    -- Sync data to client\n    net.Start(\"liaPlayerDataSync\")\n    net.WriteTable(client.customData or {})\n    net.Send(client)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#playerloadedchar","title":"PlayerLoadedChar","text":"<p>Purpose</p> <p>Called when a player loads a character</p> <p>When Called</p> <p>When a player successfully loads a character</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player loading the character</li> <li><code>character</code> (Character): The character being loaded</li> <li><code>currentChar</code> (Character): The previously loaded character (if any)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character loading\nhook.Add(\"PlayerLoadedChar\", \"MyAddon\", function(client, character, currentChar)\nprint(client:Name() .. \" loaded character: \" .. character:getName())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle character switching\nhook.Add(\"PlayerLoadedChar\", \"CharSwitching\", function(client, character, currentChar)\nif currentChar then\n    -- Save previous character data\n    currentChar:setData(\"lastSwitch\", os.time())\n    currentChar:setData(\"switchPos\", client:GetPos())\n    end\n-- Set up new character\ncharacter:setData(\"lastLoad\", os.time())\ncharacter:setData(\"loadCount\", (character:getData(\"loadCount\", 0) + 1))\nclient:ChatPrint(\"Character loaded: \" .. character:getName())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character loading system\nhook.Add(\"PlayerLoadedChar\", \"AdvancedCharLoading\", function(client, character, currentChar)\n-- Handle previous character cleanup\nif currentChar then\n    currentChar:setData(\"lastSwitch\", os.time())\n    currentChar:setData(\"switchPos\", client:GetPos())\n    currentChar:setData(\"switchHealth\", client:Health())\n    currentChar:setData(\"switchArmor\", client:Armor())\n    end\n-- Set up new character\ncharacter:setData(\"lastLoad\", os.time())\ncharacter:setData(\"loadCount\", (character:getData(\"loadCount\", 0) + 1))\n-- Apply faction bonuses\nlocal faction = character:getFaction()\nlocal factionBonuses = {\n[\"police\"] = {\nauthority = 5,\nsalary = 1000,\nitems = {\"police_badge\", \"handcuffs\", \"radio\"}\n},\n[\"medic\"] = {\nhealingBonus = 1.5,\nmedicalKnowledge = 10,\nsalary = 800,\nitems = {\"medkit\", \"stethoscope\", \"bandage\"}\n},\n[\"citizen\"] = {\nauthority = 0,\nsalary = 500,\nitems = {\"wallet\", \"phone\"}\n}\n}\nlocal bonuses = factionBonuses[faction]\nif bonuses then\n    -- Apply stat bonuses\n    for stat, value in pairs(bonuses) do\n        if stat ~= \"items\" then\n            character:setData(stat, value)\n            end\n        end\n    -- Give faction items\n    if bonuses.items then\n        local inventory = character:getInv()\n        for _, itemID in ipairs(bonuses.items) do\n            local item = lia.item.instance(itemID)\n            if item then\n                inventory:add(item)\n                end\n            end\n        end\n    end\n-- Check for returning player bonuses\nlocal lastLoad = character:getData(\"lastLoad\", 0)\nlocal timeSinceLoad = os.time() - lastLoad\nif timeSinceLoad &gt; 86400 then -- 24 hours\n    character:setData(\"returningPlayerBonus\", true)\n    client:ChatPrint(\"Welcome back! You have a returning player bonus.\")\n    end\n-- Update character appearance\nhook.Run(\"SetupPlayerModel\", client, character)\n-- Notify other players\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client then\n        ply:ChatPrint(client:Name() .. \" is now playing as \" .. character:getName())\n        end\n    end\n-- Log character load\nprint(string.format(\"%s loaded character %s (Faction: %s)\",\nclient:Name(), character:getName(), faction))\nend)\n</code></pre></p>"},{"location":"hooks/server/#playermessagesend","title":"PlayerMessageSend","text":"<p>Purpose</p> <p>Called when a player sends a message</p> <p>When Called</p> <p>When a chat message is being sent</p> <p>Parameters</p> <ul> <li><code>speaker</code> (Player): The player sending the message</li> <li><code>chatType</code> (string): The type of chat</li> <li><code>text</code> (string): The message text</li> <li><code>anonymous</code> (boolean): Whether the message is anonymous</li> <li><code>receivers</code> (table): The players receiving the message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log messages\nhook.Add(\"PlayerMessageSend\", \"MyAddon\", function(speaker, chatType, text, anonymous, receivers)\nprint(speaker:Name() .. \" sent: \" .. text)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Filter inappropriate messages\nhook.Add(\"PlayerMessageSend\", \"FilterMessages\", function(speaker, chatType, text, anonymous, receivers)\nlocal bannedWords = {\"spam\", \"hack\"}\nfor _, word in ipairs(bannedWords) do\n    if string.find(string.lower(text), word) then\n        speaker:ChatPrint(\"Your message was blocked\")\n        return false\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex message handling\nhook.Add(\"PlayerMessageSend\", \"AdvancedMessageHandling\", function(speaker, chatType, text, anonymous, receivers)\nlocal char = speaker:getChar()\nif not char then return false end\n    -- Filter inappropriate content\n    local bannedWords = {\"spam\", \"hack\", \"cheat\"}\n    for _, word in ipairs(bannedWords) do\n        if string.find(string.lower(text), word) then\n            speaker:ChatPrint(\"Your message was blocked for inappropriate content\")\n            return false\n            end\n        end\n    -- Check spam protection\n    local lastMessage = char:getData(\"lastMessage\", 0)\n    if os.time() - lastMessage &lt; 1 then\n        speaker:ChatPrint(\"Please wait before sending another message\")\n        return false\n        end\n    char:setData(\"lastMessage\", os.time())\n    -- Log to database\n    lia.db.query(\"INSERT INTO chat_logs (timestamp, steamid, chattype, message) VALUES (?, ?, ?, ?)\",\n    os.time(), speaker:SteamID(), chatType, text)\n    -- Track message count\n    local messageCount = char:getData(\"messageCount\", 0)\n    char:setData(\"messageCount\", messageCount + 1)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#playermodelchanged","title":"PlayerModelChanged","text":"<p>Purpose</p> <p>Called when a player's model changes</p> <p>When Called</p> <p>When a player's character model is changed</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose model changed</li> <li><code>value</code> (string): The new model path</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log model change\nhook.Add(\"PlayerModelChanged\", \"MyAddon\", function(client, value)\nprint(client:Name() .. \" model changed to \" .. value)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track model changes\nhook.Add(\"PlayerModelChanged\", \"TrackModelChanges\", function(client, value)\nlocal char = client:getChar()\nif char then\n    local modelHistory = char:getData(\"modelHistory\", {})\n    table.insert(modelHistory, {model = value, time = os.time()})\n    char:setData(\"modelHistory\", modelHistory)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex model change tracking\nhook.Add(\"PlayerModelChanged\", \"AdvancedModelTracking\", function(client, value)\nlocal char = client:getChar()\nif not char then return end\n    -- Track model history\n    local modelHistory = char:getData(\"modelHistory\", {})\n    table.insert(modelHistory, {model = value, time = os.time()})\n    char:setData(\"modelHistory\", modelHistory)\n    -- Log to database\n    lia.db.query(\"INSERT INTO model_logs (timestamp, charid, model) VALUES (?, ?, ?)\",\n    os.time(), char:getID(), value)\n    -- Apply model-specific effects\n    local gender = hook.Run(\"GetModelGender\", value) or \"male\"\n    char:setData(\"gender\", gender)\n    -- Notify nearby players\n    for _, ply in ipairs(player.GetAll()) do\n        if ply ~= client and ply:GetPos():Distance(client:GetPos()) &lt; 500 then\n            ply:ChatPrint(client:Name() .. \" changed their appearance\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#playermuted","title":"PlayerMuted","text":"<p>Purpose</p> <p>Called when a player is muted</p> <p>When Called</p> <p>When a player's chat is disabled</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player being muted</li> <li><code>admin</code> (Player): The admin issuing the mute</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log mute\nhook.Add(\"PlayerMuted\", \"MyAddon\", function(target, admin)\nprint(target:Name() .. \" was muted by \" .. admin:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track mute history\nhook.Add(\"PlayerMuted\", \"TrackMuteHistory\", function(target, admin)\nlocal char = target:getChar()\nif char then\n    local muteHistory = char:getData(\"muteHistory\", {})\n    table.insert(muteHistory, {admin = admin:SteamID(), time = os.time()})\n    char:setData(\"muteHistory\", muteHistory)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex mute management\nhook.Add(\"PlayerMuted\", \"AdvancedMuteManagement\", function(target, admin)\nlocal char = target:getChar()\nif not char then return end\n    -- Track mute history\n    local muteHistory = char:getData(\"muteHistory\", {})\n    table.insert(muteHistory, {\n    admin = admin:SteamID(),\n    adminName = admin:Name(),\n    time = os.time()\n    })\n    char:setData(\"muteHistory\", muteHistory)\n    -- Log to database\n    lia.db.query(\"INSERT INTO mute_logs (timestamp, target_steamid, admin_steamid) VALUES (?, ?, ?)\",\n    os.time(), target:SteamID(), admin:SteamID())\n    -- Notify player\n    target:ChatPrint(\"You have been muted by \" .. admin:Name())\n    -- Notify other admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() and ply ~= admin and ply ~= target then\n            ply:ChatPrint(\"[ADMIN] \" .. admin:Name() .. \" muted \" .. target:Name())\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#playershouldact","title":"PlayerShouldAct","text":"<p>Purpose</p> <p>Called to check if a player should perform an action</p> <p>When Called</p> <p>When validating player actions</p> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Always allow\nhook.Add(\"PlayerShouldAct\", \"MyAddon\", function()\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check player state\nhook.Add(\"PlayerShouldAct\", \"CheckPlayerState\", function()\nlocal client = LocalPlayer()\nif not IsValid(client) then return false end\n    local char = client:getChar()\n    return char ~= nil\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex action validation\nhook.Add(\"PlayerShouldAct\", \"AdvancedActionValidation\", function()\nlocal client = LocalPlayer()\nif not IsValid(client) then return false end\n    local char = client:getChar()\n    if not char then return false end\n        -- Check if player is tied\n        if char:getData(\"tied\", false) then\n            return false\n            end\n        -- Check if player is stunned\n        if char:getData(\"stunned\", false) then\n            return false\n            end\n        -- Check if player is in cutscene\n        if char:getData(\"inCutscene\", false) then\n            return false\n            end\n        return true\n        end)\n</code></pre></p>"},{"location":"hooks/server/#playershouldpermakill","title":"PlayerShouldPermaKill","text":"<p>Purpose</p> <p>Called to check if a player should be permakilled</p> <p>When Called</p> <p>When a player dies and permakill is being considered</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The dying player</li> <li><code>inflictor</code> (Entity): The entity that caused death</li> <li><code>attacker</code> (Entity): The attacker</li> </ul> <p>Returns</p> <ul> <li>boolean - True to permakill, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Never permakill\nhook.Add(\"PlayerShouldPermaKill\", \"MyAddon\", function(client, inflictor, attacker)\nreturn false\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Permakill on admin command\nhook.Add(\"PlayerShouldPermaKill\", \"AdminPermakill\", function(client, inflictor, attacker)\nlocal char = client:getChar()\nif char and char:getData(\"markedForPK\", false) then\n    return true\n    end\nreturn false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex permakill system\nhook.Add(\"PlayerShouldPermaKill\", \"AdvancedPermakill\", function(client, inflictor, attacker)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check if marked for PK\n    if char:getData(\"markedForPK\", false) then\n        return true\n        end\n    -- Check faction-specific rules\n    local faction = char:getFaction()\n    if faction == \"police\" then\n        -- Police can only be PKed by admins\n        if IsValid(attacker) and attacker:IsPlayer() and attacker:IsAdmin() then\n            return true\n            end\n        return false\n        end\n    -- Check death count\n    local deathCount = char:getData(\"deathCount\", 0)\n    if deathCount &gt;= 5 then\n        -- Too many deaths, permakill\n        return true\n        end\n    return false\n    end)\n</code></pre></p>"},{"location":"hooks/server/#playerspawnpointselected","title":"PlayerSpawnPointSelected","text":"<p>Purpose</p> <p>Called when a player spawn point is selected</p> <p>When Called</p> <p>When determining where a player should spawn</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player spawning</li> <li><code>pos</code> (Vector): The spawn position</li> <li><code>ang</code> (Angle): The spawn angle</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log spawn point\nhook.Add(\"PlayerSpawnPointSelected\", \"MyAddon\", function(client, pos, ang)\nprint(client:Name() .. \" spawning at \" .. tostring(pos))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track spawn locations\nhook.Add(\"PlayerSpawnPointSelected\", \"TrackSpawnLocations\", function(client, pos, ang)\nlocal char = client:getChar()\nif char then\n    char:setData(\"lastSpawnPos\", pos)\n    char:setData(\"lastSpawnAng\", ang)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex spawn tracking\nhook.Add(\"PlayerSpawnPointSelected\", \"AdvancedSpawnTracking\", function(client, pos, ang)\nlocal char = client:getChar()\nif not char then return end\n    -- Track spawn location\n    char:setData(\"lastSpawnPos\", pos)\n    char:setData(\"lastSpawnAng\", ang)\n    char:setData(\"lastSpawnTime\", os.time())\n    -- Log to database\n    lia.db.query(\"INSERT INTO spawn_logs (timestamp, charid, x, y, z) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), char:getID(), pos.x, pos.y, pos.z)\n    -- Track spawn count\n    local spawnCount = char:getData(\"spawnCount\", 0)\n    char:setData(\"spawnCount\", spawnCount + 1)\n    -- Apply spawn effects\n    client:SetHealth(100)\n    client:SetArmor(0)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#playerthrowpunch","title":"PlayerThrowPunch","text":"<p>Purpose</p> <p>Called when a player throws a punch</p> <p>When Called</p> <p>When a player uses their fists to attack</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player throwing the punch</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log punch\nhook.Add(\"PlayerThrowPunch\", \"MyAddon\", function(client)\nprint(client:Name() .. \" threw a punch\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track punch count\nhook.Add(\"PlayerThrowPunch\", \"TrackPunches\", function(client)\nlocal char = client:getChar()\nif char then\n    local punchCount = char:getData(\"punchCount\", 0)\n    char:setData(\"punchCount\", punchCount + 1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex punch tracking system\nhook.Add(\"PlayerThrowPunch\", \"AdvancedPunchTracking\", function(client)\nlocal char = client:getChar()\nif not char then return end\n    -- Track punch count\n    local punchCount = char:getData(\"punchCount\", 0)\n    char:setData(\"punchCount\", punchCount + 1)\n    -- Drain stamina\n    local stamina = client:getNetVar(\"stamina\", 100)\n    client:setNetVar(\"stamina\", math.max(0, stamina - 5))\n    -- Check for achievements\n    if punchCount + 1 &gt;= 500 then\n        if not char:getData(\"achievement_brawler\", false) then\n            char:setData(\"achievement_brawler\", true)\n            client:ChatPrint(\"Achievement unlocked: Brawler!\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#playerungagged","title":"PlayerUngagged","text":"<p>Purpose</p> <p>Called when a player is ungagged</p> <p>When Called</p> <p>When a player's voice chat is re-enabled</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player being ungagged</li> <li><code>admin</code> (Player): The admin removing the gag</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log ungag\nhook.Add(\"PlayerUngagged\", \"MyAddon\", function(target, admin)\nprint(target:Name() .. \" was ungagged by \" .. admin:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify player\nhook.Add(\"PlayerUngagged\", \"NotifyUngag\", function(target, admin)\ntarget:ChatPrint(\"You have been ungagged by \" .. admin:Name())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ungag management\nhook.Add(\"PlayerUngagged\", \"AdvancedUngagManagement\", function(target, admin)\n-- Log to database\nlia.db.query(\"INSERT INTO ungag_logs (timestamp, target_steamid, admin_steamid) VALUES (?, ?, ?)\",\nos.time(), target:SteamID(), admin:SteamID())\n-- Notify player\ntarget:ChatPrint(\"You have been ungagged by \" .. admin:Name())\n-- Notify other admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() and ply ~= admin and ply ~= target then\n        ply:ChatPrint(\"[ADMIN] \" .. admin:Name() .. \" ungagged \" .. target:Name())\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#playerunmuted","title":"PlayerUnmuted","text":"<p>Purpose</p> <p>Called when a player is unmuted</p> <p>When Called</p> <p>When a player's chat is re-enabled</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player being unmuted</li> <li><code>admin</code> (Player): The admin removing the mute</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log unmute\nhook.Add(\"PlayerUnmuted\", \"MyAddon\", function(target, admin)\nprint(target:Name() .. \" was unmuted by \" .. admin:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify player\nhook.Add(\"PlayerUnmuted\", \"NotifyUnmute\", function(target, admin)\ntarget:ChatPrint(\"You have been unmuted by \" .. admin:Name())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex unmute management\nhook.Add(\"PlayerUnmuted\", \"AdvancedUnmuteManagement\", function(target, admin)\n-- Log to database\nlia.db.query(\"INSERT INTO unmute_logs (timestamp, target_steamid, admin_steamid) VALUES (?, ?, ?)\",\nos.time(), target:SteamID(), admin:SteamID())\n-- Notify player\ntarget:ChatPrint(\"You have been unmuted by \" .. admin:Name())\n-- Notify other admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() and ply ~= admin and ply ~= target then\n        ply:ChatPrint(\"[ADMIN] \" .. admin:Name() .. \" unmuted \" .. target:Name())\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#playerusedoor","title":"PlayerUseDoor","text":"<p>Purpose</p> <p>Called when a player uses a door</p> <p>When Called</p> <p>When a player interacts with a door entity</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player using the door</li> <li><code>door</code> (Entity): The door entity</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log door usage\nhook.Add(\"PlayerUseDoor\", \"MyAddon\", function(client, door)\nprint(client:Name() .. \" used a door\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track door usage\nhook.Add(\"PlayerUseDoor\", \"TrackDoorUsage\", function(client, door)\nlocal char = client:getChar()\nif char then\n    local doorUses = char:getData(\"doorUses\", 0)\n    char:setData(\"doorUses\", doorUses + 1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door usage tracking\nhook.Add(\"PlayerUseDoor\", \"AdvancedDoorUsage\", function(client, door)\nlocal char = client:getChar()\nif not char then return end\n    -- Track door usage\n    local doorUses = char:getData(\"doorUses\", 0)\n    char:setData(\"doorUses\", doorUses + 1)\n    -- Log to database\n    local doorID = door:MapCreationID()\n    lia.db.query(\"INSERT INTO door_usage_logs (timestamp, charid, doorid) VALUES (?, ?, ?)\",\n    os.time(), char:getID(), doorID)\n    -- Check for achievements\n    if doorUses + 1 &gt;= 1000 then\n        if not char:getData(\"achievement_doorman\", false) then\n            char:setData(\"achievement_doorman\", true)\n            client:ChatPrint(\"Achievement unlocked: Doorman!\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#postdoordataload","title":"PostDoorDataLoad","text":"<p>Purpose</p> <p>Called after door data is loaded</p> <p>When Called</p> <p>After door configuration data is loaded from the database</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The door entity</li> <li><code>doorData</code> (table): The door data that was loaded</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log door data load\nhook.Add(\"PostDoorDataLoad\", \"MyAddon\", function(ent, doorData)\nprint(\"Door data loaded for entity \" .. ent:EntIndex())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Apply custom door settings\nhook.Add(\"PostDoorDataLoad\", \"CustomDoorSettings\", function(ent, doorData)\nif doorData.customLocked then\n    ent:Fire(\"Lock\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door data processing\nhook.Add(\"PostDoorDataLoad\", \"AdvancedDoorDataProcessing\", function(ent, doorData)\nif not IsValid(ent) or not doorData then return end\n    -- Apply door settings\n    if doorData.locked then\n        ent:Fire(\"Lock\")\n    else\n        ent:Fire(\"Unlock\")\n        end\n    -- Set door title\n    if doorData.title then\n        ent:setNetVar(\"title\", doorData.title)\n        end\n    -- Set door price\n    if doorData.price then\n        ent:setNetVar(\"price\", doorData.price)\n        end\n    -- Set door owner\n    if doorData.owner then\n        ent:setNetVar(\"owner\", doorData.owner)\n        end\n    -- Apply faction restrictions\n    if doorData.allowedFactions then\n        ent:setNetVar(\"allowedFactions\", doorData.allowedFactions)\n        end\n    -- Log door data load\n    print(string.format(\"Door data loaded for entity %d: Title=%s, Price=%s, Owner=%s\",\n    ent:EntIndex(),\n    doorData.title or \"None\",\n    doorData.price or \"None\",\n    doorData.owner or \"None\"))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#postloaddata","title":"PostLoadData","text":"<p>Purpose</p> <p>Called after data is loaded</p> <p>When Called</p> <p>After all persistent data has been loaded</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log data load completion\nhook.Add(\"PostLoadData\", \"MyAddon\", function()\nprint(\"Data loaded\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize systems after data load\nhook.Add(\"PostLoadData\", \"InitializeSystems\", function()\nMyAddon.Initialize()\nprint(\"Systems initialized after data load\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex post-load initialization\nhook.Add(\"PostLoadData\", \"AdvancedPostLoadInit\", function()\n-- Initialize custom systems\nMyAddon.Initialize()\n-- Validate loaded data\nlocal data = lia.data.get(\"myAddonData\", {})\nif not data or table.IsEmpty(data) then\n    print(\"Warning: No data found, using defaults\")\n    data = MyAddon.GetDefaultData()\n    lia.data.set(\"myAddonData\", data)\n    end\n-- Set up timers\ntimer.Create(\"MyAddonDataSave\", 300, 0, function()\nMyAddon.SaveData()\nend)\nprint(\"Post-load initialization completed\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#postplayerinitialspawn","title":"PostPlayerInitialSpawn","text":"<p>Purpose</p> <p>Called after a player's initial spawn</p> <p>When Called</p> <p>After a player has fully spawned for the first time</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who spawned</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Welcome message\nhook.Add(\"PostPlayerInitialSpawn\", \"MyAddon\", function(client)\nclient:ChatPrint(\"Welcome to the server!\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Give starting items\nhook.Add(\"PostPlayerInitialSpawn\", \"GiveStartingItems\", function(client)\ntimer.Simple(1, function()\nif IsValid(client) then\n    local char = client:getChar()\n    if char then\n        local inv = char:getInv()\n        if inv then\n            local item = lia.item.instance(\"item_bandage\")\n            if item then\n                inv:add(item)\n                end\n            end\n        end\n    end\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex spawn initialization\nhook.Add(\"PostPlayerInitialSpawn\", \"AdvancedSpawnInit\", function(client)\ntimer.Simple(1, function()\nif not IsValid(client) then return end\n    local char = client:getChar()\n    if not char then return end\n        -- Give starting items\n        local inv = char:getInv()\n        if inv then\n            local startingItems = {\"item_bandage\", \"item_water\", \"item_food\"}\n            for _, itemID in ipairs(startingItems) do\n                local item = lia.item.instance(itemID)\n                if item then\n                    inv:add(item)\n                    end\n                end\n            end\n        -- Set starting money\n        if char:getMoney() == 0 then\n            char:giveMoney(500)\n            client:ChatPrint(\"You received $500 starting money\")\n            end\n        -- Apply first-time bonuses\n        local playTime = client:GetUTimeTotalTime()\n        if playTime == 0 then\n            char:setData(\"firstTimeBonus\", true)\n            client:ChatPrint(\"Welcome! You received a first-time bonus!\")\n            end\n        end)\n        end)\n</code></pre></p>"},{"location":"hooks/server/#postplayerloadedchar","title":"PostPlayerLoadedChar","text":"<p>Purpose</p> <p>Called after a player has loaded a character</p> <p>When Called</p> <p>After a character has been fully loaded for a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player</li> <li><code>character</code> (Character): The character that was loaded</li> <li><code>currentChar</code> (Character): The previous character (if any)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Welcome message\nhook.Add(\"PostPlayerLoadedChar\", \"MyAddon\", function(client, character, currentChar)\nclient:ChatPrint(\"Welcome back, \" .. character:getName())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Restore character state\nhook.Add(\"PostPlayerLoadedChar\", \"RestoreCharState\", function(client, character, currentChar)\nlocal health = character:getData(\"savedHealth\", 100)\nclient:SetHealth(health)\nlocal armor = character:getData(\"savedArmor\", 0)\nclient:SetArmor(armor)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character load handling\nhook.Add(\"PostPlayerLoadedChar\", \"AdvancedCharLoad\", function(client, character, currentChar)\n-- Restore character state\nlocal health = character:getData(\"savedHealth\", 100)\nclient:SetHealth(health)\nlocal armor = character:getData(\"savedArmor\", 0)\nclient:SetArmor(armor)\n-- Restore position if saved\nlocal savedPos = character:getData(\"savedPosition\")\nif savedPos then\n    client:SetPos(savedPos)\n    end\n-- Update session data\ncharacter:setData(\"sessionStart\", os.time())\ncharacter:setData(\"lastLogin\", os.time())\n-- Notify faction members\nlocal faction = character:getFaction()\nfor _, ply in ipairs(player.GetAll()) do\n    if ply ~= client then\n        local plyChar = ply:getChar()\n        if plyChar and plyChar:getFaction() == faction then\n            ply:ChatPrint(character:getName() .. \" has joined the server\")\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#postplayerloadout","title":"PostPlayerLoadout","text":"<p>Purpose</p> <p>Called after a player's loadout is given</p> <p>When Called</p> <p>After a player has received their weapons/equipment</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who received loadout</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log loadout\nhook.Add(\"PostPlayerLoadout\", \"MyAddon\", function(client)\nprint(client:Name() .. \" received loadout\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Give additional items\nhook.Add(\"PostPlayerLoadout\", \"GiveAdditionalItems\", function(client)\nlocal char = client:getChar()\nif char and char:getData(\"vip\", false) then\n    client:Give(\"weapon_pistol\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex loadout system\nhook.Add(\"PostPlayerLoadout\", \"AdvancedLoadout\", function(client)\nlocal char = client:getChar()\nif not char then return end\n    -- Give faction-specific weapons\n    local faction = char:getFaction()\n    if faction == \"police\" then\n        client:Give(\"weapon_pistol\")\n        client:Give(\"weapon_stunstick\")\n    elseif faction == \"medic\" then\n        client:Give(\"weapon_medkit\")\n        end\n    -- Give VIP bonuses\n    if char:getData(\"vip\", false) then\n        client:SetMaxHealth(150)\n        client:SetHealth(150)\n        client:SetArmor(50)\n        end\n    -- Apply class bonuses\n    local class = char:getData(\"class\")\n    if class == \"warrior\" then\n        client:SetMaxHealth(200)\n        client:SetHealth(200)\n    elseif class == \"scout\" then\n        client:SetRunSpeed(300)\n        client:SetWalkSpeed(150)\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#postplayersay","title":"PostPlayerSay","text":"<p>Purpose</p> <p>Called after a player says something in chat</p> <p>When Called</p> <p>After a chat message has been processed and sent</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who spoke</li> <li><code>message</code> (string): The message that was sent</li> <li><code>chatType</code> (string): The type of chat</li> <li><code>anonymous</code> (boolean): Whether the message was anonymous</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log chat messages\nhook.Add(\"PostPlayerSay\", \"MyAddon\", function(client, message, chatType, anonymous)\nprint(client:Name() .. \" said: \" .. message)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track chat statistics\nhook.Add(\"PostPlayerSay\", \"TrackChatStats\", function(client, message, chatType, anonymous)\nlocal char = client:getChar()\nif char then\n    local messageCount = char:getData(\"messageCount\", 0)\n    char:setData(\"messageCount\", messageCount + 1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex chat tracking system\nhook.Add(\"PostPlayerSay\", \"AdvancedChatTracking\", function(client, message, chatType, anonymous)\nlocal char = client:getChar()\nif not char then return end\n    -- Track message count\n    local messageCount = char:getData(\"messageCount\", 0)\n    char:setData(\"messageCount\", messageCount + 1)\n    -- Log to database\n    lia.db.query(\"INSERT INTO chat_logs (timestamp, charid, chattype, message, anonymous) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), char:getID(), chatType, message, anonymous and 1 or 0)\n    -- Check for achievements\n    if messageCount + 1 &gt;= 1000 then\n        if not char:getData(\"achievement_chatty\", false) then\n            char:setData(\"achievement_chatty\", true)\n            client:ChatPrint(\"Achievement unlocked: Chatty!\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#postscaledamage","title":"PostScaleDamage","text":"<p>Purpose</p> <p>Called after damage scaling is calculated</p> <p>When Called</p> <p>After damage has been scaled but before it's applied</p> <p>Parameters</p> <ul> <li><code>hitgroup</code> (number): The hitgroup that was hit</li> <li><code>dmgInfo</code> (CTakeDamageInfo): The damage info</li> <li><code>damageScale</code> (number): The calculated damage scale</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log damage scaling\nhook.Add(\"PostScaleDamage\", \"MyAddon\", function(hitgroup, dmgInfo, damageScale)\nprint(\"Damage scaled to: \" .. damageScale)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Apply damage effects\nhook.Add(\"PostScaleDamage\", \"ApplyDamageEffects\", function(hitgroup, dmgInfo, damageScale)\nlocal target = dmgInfo:GetAttacker()\nif IsValid(target) and target:IsPlayer() then\n    local char = target:getChar()\n    if char then\n        local damage = dmgInfo:GetDamage() * damageScale\n        char:setData(\"lastDamageTaken\", damage)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex damage tracking system\nhook.Add(\"PostScaleDamage\", \"AdvancedDamageTracking\", function(hitgroup, dmgInfo, damageScale)\nlocal target = dmgInfo:GetAttacker()\nlocal attacker = dmgInfo:GetAttacker()\nif not IsValid(target) or not IsValid(attacker) then return end\n    local targetChar = target:getChar()\n    local attackerChar = attacker:getChar()\n    if not targetChar or not attackerChar then return end\n        local damage = dmgInfo:GetDamage() * damageScale\n        -- Log damage to database\n        lia.db.query(\"INSERT INTO damage_logs (timestamp, target_charid, attacker_charid, damage, hitgroup) VALUES (?, ?, ?, ?, ?)\",\n        os.time(), targetChar:getID(), attackerChar:getID(), damage, hitgroup)\n        -- Track damage statistics\n        local damageDealt = attackerChar:getData(\"damageDealt\", 0)\n        attackerChar:setData(\"damageDealt\", damageDealt + damage)\n        local damageTaken = targetChar:getData(\"damageTaken\", 0)\n        targetChar:setData(\"damageTaken\", damageTaken + damage)\n        end)\n</code></pre></p>"},{"location":"hooks/server/#prechardelete","title":"PreCharDelete","text":"<p>Purpose</p> <p>Called before a character is deleted</p> <p>When Called</p> <p>Before a character deletion is processed</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The character ID being deleted</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character deletion\nhook.Add(\"PreCharDelete\", \"MyAddon\", function(id)\nprint(\"Character \" .. id .. \" is being deleted\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Backup character data\nhook.Add(\"PreCharDelete\", \"BackupCharData\", function(id)\nlocal char = lia.char.loaded[id]\nif char then\n    -- Create backup\n    lia.db.query(\"INSERT INTO char_backups SELECT * FROM characters WHERE id = ?\", id)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character deletion preparation\nhook.Add(\"PreCharDelete\", \"AdvancedCharDeletePrep\", function(id)\nlocal char = lia.char.loaded[id]\nif not char then return end\n    -- Create comprehensive backup\n    lia.db.query(\"INSERT INTO char_backups SELECT * FROM characters WHERE id = ?\", id)\n    lia.db.query(\"INSERT INTO char_items_backup SELECT * FROM char_items WHERE charid = ?\", id)\n    lia.db.query(\"INSERT INTO char_data_backup SELECT * FROM char_data WHERE charid = ?\", id)\n    -- Notify admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() then\n            ply:ChatPrint(\"Character \" .. char:getName() .. \" (\" .. id .. \") is being deleted\")\n            end\n        end\n    -- Log deletion\n    lia.log.add(\"Character \" .. char:getName() .. \" (\" .. id .. \") is being deleted\", \"character\")\n    end)\n</code></pre></p>"},{"location":"hooks/server/#predoordatasave","title":"PreDoorDataSave","text":"<p>Purpose</p> <p>Called before door data is saved</p> <p>When Called</p> <p>Before door configuration data is saved to database</p> <p>Parameters</p> <ul> <li><code>door</code> (Entity): The door entity</li> <li><code>doorData</code> (table): The door data being saved</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log door save\nhook.Add(\"PreDoorDataSave\", \"MyAddon\", function(door, doorData)\nprint(\"Saving door data for entity \" .. door:EntIndex())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate door data\nhook.Add(\"PreDoorDataSave\", \"ValidateDoorData\", function(door, doorData)\nif doorData.price and doorData.price &lt; 0 then\n    doorData.price = 0\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door data validation\nhook.Add(\"PreDoorDataSave\", \"AdvancedDoorDataValidation\", function(door, doorData)\nif not IsValid(door) then return end\n    -- Validate price\n    if doorData.price and doorData.price &lt; 0 then\n        doorData.price = 0\n    elseif doorData.price and doorData.price &gt; 100000 then\n        doorData.price = 100000\n        end\n    -- Validate title length\n    if doorData.title and #doorData.title &gt; 50 then\n        doorData.title = string.sub(doorData.title, 1, 50)\n        end\n    -- Add metadata\n    doorData.lastSaved = os.time()\n    doorData.map = game.GetMap()\n    -- Log save\n    print(string.format(\"Saving door data: Entity=%d, Title=%s, Price=%s\",\n    door:EntIndex(),\n    doorData.title or \"None\",\n    doorData.price or \"None\"))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#preplayerinteractitem","title":"PrePlayerInteractItem","text":"<p>Purpose</p> <p>Called before a player interacts with an item</p> <p>When Called</p> <p>Before an item interaction is processed</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player interacting</li> <li><code>action</code> (string): The action being performed</li> <li><code>self</code> (Item): The item being interacted with</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all interactions\nhook.Add(\"PrePlayerInteractItem\", \"MyAddon\", function(client, action, self)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check cooldown\nhook.Add(\"PrePlayerInteractItem\", \"CheckCooldown\", function(client, action, self)\nlocal char = client:getChar()\nif not char then return false end\n    local lastUse = char:getData(\"lastItemUse\", 0)\n    if CurTime() - lastUse &lt; 1 then\n        return false\n        end\n    char:setData(\"lastItemUse\", CurTime())\n    return true\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item interaction validation\nhook.Add(\"PrePlayerInteractItem\", \"AdvancedItemInteraction\", function(client, action, self)\nlocal char = client:getChar()\nif not char then return false end\n    -- Check cooldown\n    local lastUse = char:getData(\"lastItemUse\", 0)\n    if CurTime() - lastUse &lt; 1 then\n        client:ChatPrint(\"Please wait before using another item\")\n        return false\n        end\n    -- Check if item is broken\n    local durability = self:getData(\"durability\", 100)\n    if durability &lt;= 0 then\n        client:ChatPrint(\"This item is broken and cannot be used\")\n        return false\n        end\n    -- Check faction restrictions\n    local requiredFaction = self.requiredFaction\n    if requiredFaction and char:getFaction() ~= requiredFaction then\n        client:ChatPrint(\"Your faction cannot use this item\")\n        return false\n        end\n    char:setData(\"lastItemUse\", CurTime())\n    return true\n    end)\n</code></pre></p>"},{"location":"hooks/server/#preplayerloadedchar","title":"PrePlayerLoadedChar","text":"<p>Purpose</p> <p>Called before a player loads a character</p> <p>When Called</p> <p>Before a character is loaded for a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player</li> <li><code>character</code> (Character): The character being loaded</li> <li><code>currentChar</code> (Character): The current character (if any)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character load\nhook.Add(\"PrePlayerLoadedChar\", \"MyAddon\", function(client, character, currentChar)\nprint(client:Name() .. \" is loading character \" .. character:getName())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save current character state\nhook.Add(\"PrePlayerLoadedChar\", \"SaveCurrentChar\", function(client, character, currentChar)\nif currentChar then\n    currentChar:setData(\"lastHealth\", client:Health())\n    currentChar:setData(\"lastArmor\", client:Armor())\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character load preparation\nhook.Add(\"PrePlayerLoadedChar\", \"AdvancedCharLoadPrep\", function(client, character, currentChar)\n-- Save current character state\nif currentChar then\n    currentChar:setData(\"lastHealth\", client:Health())\n    currentChar:setData(\"lastArmor\", client:Armor())\n    currentChar:setData(\"lastPosition\", client:GetPos())\n    currentChar:setData(\"lastAngles\", client:GetAngles())\n    currentChar:save()\n    end\n-- Validate character data\nif not character:getData(\"validated\", false) then\n    character:setData(\"validated\", true)\n    character:setData(\"loadCount\", (character:getData(\"loadCount\", 0) + 1))\n    end\n-- Log character load\nlia.db.query(\"INSERT INTO char_load_logs (timestamp, charid, steamid) VALUES (?, ?, ?)\",\nos.time(), character:getID(), client:SteamID())\nend)\n</code></pre></p>"},{"location":"hooks/server/#presalarygive","title":"PreSalaryGive","text":"<p>Purpose</p> <p>Called before salary is given to a player</p> <p>When Called</p> <p>Before salary payment is processed</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player receiving salary</li> <li><code>char</code> (Character): The character receiving salary</li> <li><code>pay</code> (number): The salary amount</li> <li><code>faction</code> (string): The faction name</li> <li><code>class</code> (string): The class name</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log salary\nhook.Add(\"PreSalaryGive\", \"MyAddon\", function(client, char, pay, faction, class)\nprint(client:Name() .. \" is receiving $\" .. pay .. \" salary\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Modify salary amount\nhook.Add(\"PreSalaryGive\", \"ModifySalary\", function(client, char, pay, faction, class)\nlocal char = client:getChar()\nif char then\n    local level = char:getData(\"level\", 1)\n    pay = pay + (level * 10)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex salary calculation\nhook.Add(\"PreSalaryGive\", \"AdvancedSalaryCalculation\", function(client, char, pay, faction, class)\nlocal char = client:getChar()\nif not char then return end\n    -- Base salary modifications\n    local level = char:getData(\"level\", 1)\n    pay = pay + (level * 10)\n    -- Faction bonuses\n    if faction == \"police\" then\n        pay = pay * 1.2\n    elseif faction == \"medic\" then\n        pay = pay * 1.1\n        end\n    -- Class bonuses\n    if class == \"officer\" then\n        pay = pay + 50\n    elseif class == \"doctor\" then\n        pay = pay + 75\n        end\n    -- VIP bonus\n    if char:getData(\"vip\", false) then\n        pay = pay * 1.5\n        end\n    -- Log salary calculation\n    lia.db.query(\"INSERT INTO salary_logs (timestamp, charid, amount, faction, class) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), char:getID(), pay, faction, class)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#prescaledamage","title":"PreScaleDamage","text":"<p>Purpose</p> <p>Called before damage scaling is calculated</p> <p>When Called</p> <p>Before damage is scaled</p> <p>Parameters</p> <ul> <li><code>hitgroup</code> (number): The hitgroup that was hit</li> <li><code>dmgInfo</code> (CTakeDamageInfo): The damage info</li> <li><code>damageScale</code> (number): The current damage scale</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log damage scaling\nhook.Add(\"PreScaleDamage\", \"MyAddon\", function(hitgroup, dmgInfo, damageScale)\nprint(\"Scaling damage for hitgroup \" .. hitgroup)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Modify damage scale\nhook.Add(\"PreScaleDamage\", \"ModifyDamageScale\", function(hitgroup, dmgInfo, damageScale)\nif hitgroup == HITGROUP_HEAD then\n    damageScale = damageScale * 1.5\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex damage scaling system\nhook.Add(\"PreScaleDamage\", \"AdvancedDamageScaling\", function(hitgroup, dmgInfo, damageScale)\nlocal target = dmgInfo:GetAttacker()\nlocal attacker = dmgInfo:GetAttacker()\nif not IsValid(target) or not IsValid(attacker) then return end\n    local targetChar = target:getChar()\n    local attackerChar = attacker:getChar()\n    if not targetChar or not attackerChar then return end\n        -- Faction damage modifiers\n        local targetFaction = targetChar:getFaction()\n        local attackerFaction = attackerChar:getFaction()\n        if targetFaction == \"police\" and attackerFaction == \"criminal\" then\n            damageScale = damageScale * 1.2\n        elseif targetFaction == \"criminal\" and attackerFaction == \"police\" then\n            damageScale = damageScale * 0.8\n            end\n        -- Armor protection\n        local armor = target:getData(\"armor\", 0)\n        if armor &gt; 0 then\n            damageScale = damageScale * (1 - (armor / 200))\n            end\n        end)\n</code></pre></p>"},{"location":"hooks/server/#registerpreparedstatements","title":"RegisterPreparedStatements","text":"<p>Purpose</p> <p>Called to register prepared SQL statements</p> <p>When Called</p> <p>When setting up database prepared statements</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log statement registration\nhook.Add(\"RegisterPreparedStatements\", \"MyAddon\", function()\nprint(\"Registering prepared statements\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register custom statements\nhook.Add(\"RegisterPreparedStatements\", \"RegisterCustomStatements\", function()\nlia.db.prepare(\"my_query\", \"SELECT * FROM my_table WHERE id = ?\")\nlia.db.prepare(\"my_insert\", \"INSERT INTO my_table (data) VALUES (?)\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex statement registration\nhook.Add(\"RegisterPreparedStatements\", \"AdvancedStatementRegistration\", function()\n-- Register custom queries\nlia.db.prepare(\"get_player_stats\", \"SELECT * FROM player_stats WHERE steamid = ?\")\nlia.db.prepare(\"update_player_stats\", \"UPDATE player_stats SET kills = ?, deaths = ? WHERE steamid = ?\")\nlia.db.prepare(\"insert_player_stats\", \"INSERT INTO player_stats (steamid, kills, deaths) VALUES (?, ?, ?)\")\n-- Register character queries\nlia.db.prepare(\"get_char_data\", \"SELECT * FROM char_data WHERE charid = ?\")\nlia.db.prepare(\"update_char_data\", \"UPDATE char_data SET value = ? WHERE charid = ? AND key = ?\")\n-- Register item queries\nlia.db.prepare(\"get_item_data\", \"SELECT * FROM item_data WHERE itemid = ?\")\nlia.db.prepare(\"update_item_data\", \"UPDATE item_data SET value = ? WHERE itemid = ? AND key = ?\")\nprint(\"All prepared statements registered\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#removewarning","title":"RemoveWarning","text":"<p>Purpose</p> <p>Called when a warning is removed</p> <p>When Called</p> <p>When a character warning is deleted</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The character ID</li> <li><code>index</code> (number): The warning index</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log warning removal\nhook.Add(\"RemoveWarning\", \"MyAddon\", function(charID, index)\nprint(\"Warning \" .. index .. \" removed for character \" .. charID)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track warning removals\nhook.Add(\"RemoveWarning\", \"TrackWarningRemovals\", function(charID, index)\nlocal char = lia.char.loaded[charID]\nif char then\n    local warningRemovals = char:getData(\"warningRemovals\", 0)\n    char:setData(\"warningRemovals\", warningRemovals + 1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex warning removal system\nhook.Add(\"RemoveWarning\", \"AdvancedWarningRemoval\", function(charID, index)\nlocal char = lia.char.loaded[charID]\nif not char then return end\n    -- Track warning removals\n    local warningRemovals = char:getData(\"warningRemovals\", 0)\n    char:setData(\"warningRemovals\", warningRemovals + 1)\n    -- Log to database\n    lia.db.query(\"INSERT INTO warning_logs (timestamp, charid, action, warning_index) VALUES (?, ?, ?, ?)\",\n    os.time(), charID, \"removed\", index)\n    -- Notify character owner\n    local client = char:getPlayer()\n    if IsValid(client) then\n        client:ChatPrint(\"Warning \" .. index .. \" has been removed\")\n        end\n    -- Notify admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() then\n            ply:ChatPrint(\"[ADMIN] Warning \" .. index .. \" removed for \" .. char:getName())\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#runadminsystemcommand","title":"RunAdminSystemCommand","text":"<p>Purpose</p> <p>Called when an admin system command is run</p> <p>When Called</p> <p>When an admin command is executed</p> <p>Parameters</p> <ul> <li><code>cmd</code> (string): The command name</li> <li><code>admin</code> (Player): The admin running the command</li> <li><code>victim</code> (Player): The target player (if any)</li> <li><code>dur</code> (number): The duration (if applicable)</li> <li><code>reason</code> (string): The reason (if applicable)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log admin commands\nhook.Add(\"RunAdminSystemCommand\", \"MyAddon\", function(cmd, admin, victim, dur, reason)\nprint(admin:Name() .. \" ran command: \" .. cmd)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track command usage\nhook.Add(\"RunAdminSystemCommand\", \"TrackCommandUsage\", function(cmd, admin, victim, dur, reason)\nlocal char = admin:getChar()\nif char then\n    local commands = char:getData(\"commandsUsed\", {})\n    commands[cmd] = (commands[cmd] or 0) + 1\n    char:setData(\"commandsUsed\", commands)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex admin command tracking\nhook.Add(\"RunAdminSystemCommand\", \"AdvancedCommandTracking\", function(cmd, admin, victim, dur, reason)\nlocal char = admin:getChar()\nif not char then return end\n    -- Track command usage\n    local commands = char:getData(\"commandsUsed\", {})\n    commands[cmd] = (commands[cmd] or 0) + 1\n    char:setData(\"commandsUsed\", commands)\n    -- Log to database\n    lia.db.query(\"INSERT INTO admin_logs (timestamp, admin_steamid, command, target_steamid, duration, reason) VALUES (?, ?, ?, ?, ?, ?)\",\n    os.time(), admin:SteamID(), cmd, victim and victim:SteamID() or \"\", dur or 0, reason or \"\")\n    -- Notify other admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() and ply ~= admin then\n            local message = admin:Name() .. \" used \" .. cmd\n            if IsValid(victim) then\n                message = message .. \" on \" .. victim:Name()\n                end\n            ply:ChatPrint(\"[ADMIN] \" .. message)\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#savedata","title":"SaveData","text":"<p>Purpose</p> <p>Called to save persistent data</p> <p>When Called</p> <p>When data needs to be saved to storage</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log data save\nhook.Add(\"SaveData\", \"MyAddon\", function()\nprint(\"Saving data\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save custom data\nhook.Add(\"SaveData\", \"SaveCustomData\", function()\nlia.data.set(\"myAddonData\", MyAddon.data)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data saving system\nhook.Add(\"SaveData\", \"AdvancedDataSaving\", function()\n-- Save custom data\nlia.data.set(\"myAddonData\", MyAddon.data)\n-- Save player statistics\nfor _, ply in ipairs(player.GetAll()) do\n    local char = ply:getChar()\n    if char then\n        local stats = char:getData(\"myAddonStats\", {})\n        lia.data.set(\"playerStats_\" .. ply:SteamID(), stats)\n        end\n    end\n-- Save to database\nlia.db.query(\"INSERT INTO data_saves (timestamp, data) VALUES (?, ?)\",\nos.time(), util.TableToJSON(MyAddon.data))\nprint(\"All data saved successfully\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#sendpopup","title":"SendPopup","text":"<p>Purpose</p> <p>Called to send a popup message</p> <p>When Called</p> <p>When displaying a popup to a player</p> <p>Parameters</p> <ul> <li><code>noob</code> (Player): The player receiving the popup</li> <li><code>message</code> (string): The popup message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log popup\nhook.Add(\"SendPopup\", \"MyAddon\", function(noob, message)\nprint(\"Sending popup to \" .. noob:Name() .. \": \" .. message)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize popup message\nhook.Add(\"SendPopup\", \"CustomizePopup\", function(noob, message)\nlocal char = noob:getChar()\nif char then\n    local customMessage = \"[\" .. char:getFaction() .. \"] \" .. message\n    noob:ChatPrint(customMessage)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex popup system\nhook.Add(\"SendPopup\", \"AdvancedPopupSystem\", function(noob, message)\nlocal char = noob:getChar()\nif not char then return end\n    -- Customize message based on faction\n    local faction = char:getFaction()\n    local factionPrefix = {\n    [\"police\"] = \"[POLICE]\",\n    [\"medic\"] = \"[MEDICAL]\",\n    [\"criminal\"] = \"[CRIMINAL]\"\n    }\n    local prefix = factionPrefix[faction] or \"[SYSTEM]\"\n    local customMessage = prefix .. \" \" .. message\n    -- Send popup\n    noob:ChatPrint(customMessage)\n    -- Log popup\n    lia.db.query(\"INSERT INTO popup_logs (timestamp, steamid, message) VALUES (?, ?, ?)\",\n    os.time(), noob:SteamID(), message)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#setupbaginventoryaccessrules","title":"SetupBagInventoryAccessRules","text":"<p>Purpose</p> <p>Called to set up bag inventory access rules</p> <p>When Called</p> <p>When configuring access rules for a bag inventory</p> <p>Parameters</p> <ul> <li><code>inventory</code> (Inventory): The bag inventory</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log access rules setup\nhook.Add(\"SetupBagInventoryAccessRules\", \"MyAddon\", function(inventory)\nprint(\"Setting up bag access rules\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set basic access rules\nhook.Add(\"SetupBagInventoryAccessRules\", \"BasicAccessRules\", function(inventory)\ninventory:setData(\"accessLevel\", \"owner\")\ninventory:setData(\"allowTransfer\", true)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex access rule system\nhook.Add(\"SetupBagInventoryAccessRules\", \"AdvancedAccessRules\", function(inventory)\n-- Set access level\ninventory:setData(\"accessLevel\", \"owner\")\ninventory:setData(\"allowTransfer\", true)\ninventory:setData(\"allowView\", true)\n-- Set faction restrictions\nlocal owner = inventory:getOwner()\nif IsValid(owner) then\n    local char = owner:getChar()\n    if char then\n        local faction = char:getFaction()\n        inventory:setData(\"allowedFactions\", {faction})\n        end\n    end\n-- Set time restrictions\ninventory:setData(\"accessTime\", os.time())\ninventory:setData(\"accessDuration\", 3600) -- 1 hour\nend)\n</code></pre></p>"},{"location":"hooks/server/#setupbotplayer","title":"SetupBotPlayer","text":"<p>Purpose</p> <p>Called to set up a bot player</p> <p>When Called</p> <p>When initializing a bot player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The bot player</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log bot setup\nhook.Add(\"SetupBotPlayer\", \"MyAddon\", function(client)\nprint(\"Setting up bot: \" .. client:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Configure bot behavior\nhook.Add(\"SetupBotPlayer\", \"ConfigureBot\", function(client)\nclient:SetNetVar(\"isBot\", true)\nclient:SetNetVar(\"botType\", \"guard\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex bot setup system\nhook.Add(\"SetupBotPlayer\", \"AdvancedBotSetup\", function(client)\n-- Mark as bot\nclient:SetNetVar(\"isBot\", true)\nclient:SetNetVar(\"botType\", \"guard\")\n-- Set up bot AI\nclient:SetNetVar(\"botState\", \"patrol\")\nclient:SetNetVar(\"botTarget\", nil)\n-- Give bot equipment\nclient:Give(\"weapon_pistol\")\nclient:SetArmor(100)\n-- Set up bot behavior\ntimer.Create(\"BotAI_\" .. client:EntIndex(), 1, 0, function()\nif IsValid(client) then\n    hook.Run(\"BotAIUpdate\", client)\n    end\nend)\nend)\n</code></pre></p>"},{"location":"hooks/server/#setupdatabase","title":"SetupDatabase","text":"<p>Purpose</p> <p>Called to set up the database</p> <p>When Called</p> <p>When initializing database connections and tables</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log database setup\nhook.Add(\"SetupDatabase\", \"MyAddon\", function()\nprint(\"Setting up database\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create custom tables\nhook.Add(\"SetupDatabase\", \"CreateCustomTables\", function()\nlia.db.query(\"CREATE TABLE IF NOT EXISTS my_table (id INTEGER PRIMARY KEY, data TEXT)\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex database setup\nhook.Add(\"SetupDatabase\", \"AdvancedDatabaseSetup\", function()\n-- Create custom tables\nlocal tables = {\n\"CREATE TABLE IF NOT EXISTS my_table (id INTEGER PRIMARY KEY, data TEXT)\",\n\"CREATE TABLE IF NOT EXISTS player_stats (steamid TEXT PRIMARY KEY, kills INTEGER, deaths INTEGER)\",\n\"CREATE TABLE IF NOT EXISTS achievements (id INTEGER PRIMARY KEY, name TEXT, description TEXT)\"\n}\nfor _, query in ipairs(tables) do\n    lia.db.query(query)\n    end\n-- Create indexes\nlia.db.query(\"CREATE INDEX IF NOT EXISTS idx_player_stats_steamid ON player_stats(steamid)\")\n-- Set up prepared statements\nlia.db.prepare(\"get_player_stats\", \"SELECT * FROM player_stats WHERE steamid = ?\")\nlia.db.prepare(\"update_player_stats\", \"UPDATE player_stats SET kills = ?, deaths = ? WHERE steamid = ?\")\nend)\n</code></pre></p>"},{"location":"hooks/server/#setupplayermodel","title":"SetupPlayerModel","text":"<p>Purpose</p> <p>Called to set up a player's model</p> <p>When Called</p> <p>When configuring a player's character model</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player</li> <li><code>character</code> (Character): The character</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log model setup\nhook.Add(\"SetupPlayerModel\", \"MyAddon\", function(client, character)\nprint(\"Setting up model for \" .. character:getName())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set faction-based model\nhook.Add(\"SetupPlayerModel\", \"FactionModel\", function(client, character)\nlocal faction = character:getFaction()\nlocal factionModels = {\n[\"police\"] = \"models/player/police.mdl\",\n[\"medic\"] = \"models/player/medic.mdl\"\n}\nlocal model = factionModels[faction]\nif model then\n    client:SetModel(model)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex model setup system\nhook.Add(\"SetupPlayerModel\", \"AdvancedModelSetup\", function(client, character)\nlocal faction = character:getFaction()\nlocal class = character:getData(\"class\")\n-- Get model based on faction and class\nlocal model = character:getModel()\n-- Apply faction-specific model overrides\nlocal factionModels = lia.faction.indices[faction] and lia.faction.indices[faction].models\nif factionModels and factionModels[class] then\n    model = factionModels[class]\n    end\n-- Apply outfit model override\nlocal outfit = character:getData(\"outfit\")\nif outfit then\n    local outfitItem = lia.item.instances[outfit]\n    if outfitItem and outfitItem.model then\n        model = outfitItem.model\n        end\n    end\n-- Set model\nclient:SetModel(model)\n-- Apply skin and bodygroups\nlocal skin = character:getData(\"skin\", 0)\nclient:SetSkin(skin)\nlocal bodygroups = character:getData(\"bodygroups\", {})\nfor i, group in ipairs(bodygroups) do\n    client:SetBodygroup(i, group)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#shoulddatabesaved","title":"ShouldDataBeSaved","text":"<p>Purpose</p> <p>Called to check if data should be saved</p> <p>When Called</p> <p>When determining if current data should be persisted</p> <p>Returns</p> <ul> <li>boolean - True to save, false to skip</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Always save data\nhook.Add(\"ShouldDataBeSaved\", \"MyAddon\", function()\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check save conditions\nhook.Add(\"ShouldDataBeSaved\", \"CheckSaveConditions\", function()\nlocal players = player.GetAll()\nreturn #players &gt; 0\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex save validation\nhook.Add(\"ShouldDataBeSaved\", \"AdvancedSaveValidation\", function()\n-- Don't save if no players\nlocal players = player.GetAll()\nif #players == 0 then\n    return false\n    end\n-- Don't save if server is shutting down\nif game.IsDedicated() and GetConVar(\"sv_shutdown\"):GetBool() then\n    return false\n    end\n-- Don't save if too frequent\nlocal lastSave = lia.data.get(\"lastSave\", 0)\nif os.time() - lastSave &lt; 60 then\n    return false\n    end\nreturn true\nend)\n</code></pre></p>"},{"location":"hooks/server/#shoulddeletesaveditems","title":"ShouldDeleteSavedItems","text":"<p>Purpose</p> <p>Called to check if saved items should be deleted</p> <p>When Called</p> <p>When determining if old saved items should be cleaned up</p> <p>Returns</p> <ul> <li>boolean - True to delete, false to keep</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Never delete saved items\nhook.Add(\"ShouldDeleteSavedItems\", \"MyAddon\", function()\nreturn false\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Delete old items\nhook.Add(\"ShouldDeleteSavedItems\", \"DeleteOldItems\", function()\nlocal lastCleanup = lia.data.get(\"lastItemCleanup\", 0)\nreturn os.time() - lastCleanup &gt; 86400 -- 24 hours\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item cleanup system\nhook.Add(\"ShouldDeleteSavedItems\", \"AdvancedItemCleanup\", function()\nlocal lastCleanup = lia.data.get(\"lastItemCleanup\", 0)\nlocal cleanupInterval = 86400 -- 24 hours\n-- Don't cleanup too frequently\nif os.time() - lastCleanup &lt; cleanupInterval then\n    return false\n    end\n-- Check server load\nlocal serverLoad = GetConVar(\"sv_stats\"):GetFloat()\nif serverLoad &gt; 0.8 then\n    return false\n    end\n-- Check player count\nlocal players = player.GetAll()\nif #players &gt; 20 then\n    return false\n    end\nreturn true\nend)\n</code></pre></p>"},{"location":"hooks/server/#storagecantransferitem","title":"StorageCanTransferItem","text":"<p>Purpose</p> <p>Called to check if an item can be transferred to storage</p> <p>When Called</p> <p>When attempting to transfer an item to storage</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player transferring the item</li> <li><code>storage</code> (Entity): The storage entity</li> <li><code>item</code> (Item): The item being transferred</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Allow all transfers\nhook.Add(\"StorageCanTransferItem\", \"MyAddon\", function(client, storage, item)\nreturn true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check item restrictions\nhook.Add(\"StorageCanTransferItem\", \"ItemRestrictions\", function(client, storage, item)\nlocal restrictedItems = {\"weapon_crowbar\", \"weapon_stunstick\"}\nreturn not table.HasValue(restrictedItems, item.uniqueID)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage transfer system\nhook.Add(\"StorageCanTransferItem\", \"AdvancedStorageTransfer\", function(client, storage, item)\nif not IsValid(client) or not IsValid(storage) or not item then\n    return false\n    end\nlocal char = client:getChar()\nif not char then return false end\n    -- Check storage capacity\n    local storageInv = storage:getInv()\n    if not storageInv then return false end\n        local maxWeight = storageInv:getMaxWeight()\n        local currentWeight = storageInv:getWeight()\n        local itemWeight = item:getWeight()\n        if currentWeight + itemWeight &gt; maxWeight then\n            client:ChatPrint(\"Storage is full\")\n            return false\n            end\n        -- Check item restrictions\n        local restrictedItems = {\n        [\"weapon_crowbar\"] = \"Weapons not allowed in storage\",\n        [\"weapon_stunstick\"] = \"Weapons not allowed in storage\"\n        }\n        if restrictedItems[item.uniqueID] then\n            client:ChatPrint(restrictedItems[item.uniqueID])\n            return false\n            end\n        -- Check faction restrictions\n        local faction = char:getFaction()\n        local storageFaction = storage:getNetVar(\"faction\")\n        if storageFaction and storageFaction ~= faction then\n            client:ChatPrint(\"You cannot access this storage\")\n            return false\n            end\n        -- Check distance\n        local distance = client:GetPos():Distance(storage:GetPos())\n        if distance &gt; 200 then\n            client:ChatPrint(\"You are too far away from the storage\")\n            return false\n            end\n        -- Check if storage is locked\n        if storage:getNetVar(\"locked\", false) then\n            client:ChatPrint(\"Storage is locked\")\n            return false\n            end\n        return true\n        end)\n</code></pre></p>"},{"location":"hooks/server/#storageentityremoved","title":"StorageEntityRemoved","text":"<p>Purpose</p> <p>Called when a storage entity is removed</p> <p>When Called</p> <p>When a storage entity is deleted or removed</p> <p>Parameters</p> <ul> <li><code>self</code> (Entity): The storage entity being removed</li> <li><code>inventory</code> (Inventory): The inventory associated with the storage</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log storage removal\nhook.Add(\"StorageEntityRemoved\", \"MyAddon\", function(self, inventory)\nprint(\"Storage entity removed: \" .. tostring(self))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up storage data\nhook.Add(\"StorageEntityRemoved\", \"CleanupStorage\", function(self, inventory)\nif inventory then\n    inventory:save()\n    end\n-- Remove from storage list\nlia.storage.list[self] = nil\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage cleanup system\nhook.Add(\"StorageEntityRemoved\", \"AdvancedStorageCleanup\", function(self, inventory)\nif not IsValid(self) then return end\n    -- Save inventory data\n    if inventory then\n        inventory:save()\n        -- Log inventory contents\n        local items = inventory:getItems()\n        local itemCount = 0\n        for _, item in pairs(items) do\n            itemCount = itemCount + 1\n            end\n        print(string.format(\"Storage %s removed with %d items\", self:EntIndex(), itemCount))\n        end\n    -- Remove from storage list\n    lia.storage.list[self] = nil\n    -- Notify nearby players\n    local pos = self:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 then\n            ply:ChatPrint(\"Storage has been removed\")\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO storage_logs (timestamp, entityid, action) VALUES (?, ?, ?)\",\n    os.time(), self:EntIndex(), \"removed\")\n    -- Clean up any associated data\n    local storageData = self:getNetVar(\"storageData\", {})\n    if storageData.owner then\n        local ownerChar = lia.char.loaded[storageData.owner]\n        if ownerChar then\n            ownerChar:setData(\"storageCount\", (ownerChar:getData(\"storageCount\", 0) - 1))\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#storageinventoryset","title":"StorageInventorySet","text":"<p>Purpose</p> <p>Called when a storage inventory is set</p> <p>When Called</p> <p>When a storage entity gets its inventory assigned</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The storage entity</li> <li><code>inventory</code> (Inventory): The inventory being set</li> <li><code>isCar</code> (boolean): Whether this is a car storage</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log storage inventory set\nhook.Add(\"StorageInventorySet\", \"MyAddon\", function(entity, inventory, isCar)\nprint(\"Storage inventory set for \" .. tostring(entity))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set storage properties\nhook.Add(\"StorageInventorySet\", \"SetStorageProperties\", function(entity, inventory, isCar)\nif inventory then\n    inventory:setMaxWeight(isCar and 1000 or 500)\n    inventory:setMaxItems(isCar and 50 or 25)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage inventory system\nhook.Add(\"StorageInventorySet\", \"AdvancedStorageInventory\", function(entity, inventory, isCar)\nif not IsValid(entity) or not inventory then return end\n    -- Set storage properties based on type\n    if isCar then\n        inventory:setMaxWeight(1000)\n        inventory:setMaxItems(50)\n        inventory:setData(\"storageType\", \"car\")\n    else\n        inventory:setMaxWeight(500)\n        inventory:setMaxItems(25)\n        inventory:setData(\"storageType\", \"storage\")\n        end\n    -- Set storage data\n    entity:setNetVar(\"storageData\", {\n    inventory = inventory:getID(),\n    isCar = isCar,\n    maxWeight = inventory:getMaxWeight(),\n    maxItems = inventory:getMaxItems()\n    })\n    -- Add to storage list\n    lia.storage.list[entity] = {\n    inventory = inventory,\n    isCar = isCar,\n    created = os.time()\n    }\n    -- Log to database\n    lia.db.query(\"INSERT INTO storage_logs (timestamp, entityid, action, isCar) VALUES (?, ?, ?, ?)\",\n    os.time(), entity:EntIndex(), \"inventory_set\", isCar and 1 or 0)\n    -- Notify nearby players\n    local pos = entity:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 300 then\n            ply:ChatPrint(\"Storage is now available\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#storageitemremoved","title":"StorageItemRemoved","text":"<p>Purpose</p> <p>Called when an item is removed from storage</p> <p>When Called</p> <p>When an item is removed from a storage inventory</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item removal\nhook.Add(\"StorageItemRemoved\", \"MyAddon\", function()\nprint(\"Item removed from storage\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update storage statistics\nhook.Add(\"StorageItemRemoved\", \"UpdateStats\", function()\nlocal storageCount = 0\nfor _, storage in pairs(lia.storage.list) do\n    if storage.inventory then\n        storageCount = storageCount + 1\n        end\n    end\nprint(\"Active storages: \" .. storageCount)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage item removal system\nhook.Add(\"StorageItemRemoved\", \"AdvancedStorageItemRemoval\", function()\n-- Update storage statistics\nlocal totalItems = 0\nlocal totalWeight = 0\nfor _, storage in pairs(lia.storage.list) do\n    if storage.inventory then\n        local items = storage.inventory:getItems()\n        for _, item in pairs(items) do\n            totalItems = totalItems + 1\n            totalWeight = totalWeight + item:getWeight()\n            end\n        end\n    end\n-- Log statistics\nprint(string.format(\"Storage statistics: %d items, %.2f weight\", totalItems, totalWeight))\n-- Update storage data\nfor entity, storage in pairs(lia.storage.list) do\n    if IsValid(entity) and storage.inventory then\n        local items = storage.inventory:getItems()\n        local itemCount = 0\n        for _, item in pairs(items) do\n            itemCount = itemCount + 1\n            end\n        entity:setNetVar(\"itemCount\", itemCount)\n        end\n    end\n-- Notify nearby players\nfor _, ply in ipairs(player.GetAll()) do\n    if IsValid(ply) then\n        local char = ply:getChar()\n        if char then\n            local pos = ply:GetPos()\n            for entity, storage in pairs(lia.storage.list) do\n                if IsValid(entity) and entity:GetPos():Distance(pos) &lt; 300 then\n                    ply:ChatPrint(\"Storage contents updated\")\n                    end\n                end\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#storageopen","title":"StorageOpen","text":"<p>Purpose</p> <p>Called when storage is opened</p> <p>When Called</p> <p>When a player opens a storage entity</p> <p>Parameters</p> <ul> <li><code>storage</code> (Entity): The storage entity being opened</li> <li><code>isCar</code> (boolean): Whether this is a car storage</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log storage opening\nhook.Add(\"StorageOpen\", \"MyAddon\", function(storage, isCar)\nprint(\"Storage opened: \" .. tostring(storage))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track storage usage\nhook.Add(\"StorageOpen\", \"TrackUsage\", function(storage, isCar)\nlocal storageData = storage:getNetVar(\"storageData\", {})\nstorageData.openCount = (storageData.openCount or 0) + 1\nstorageData.lastOpened = os.time()\nstorage:setNetVar(\"storageData\", storageData)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage opening system\nhook.Add(\"StorageOpen\", \"AdvancedStorageOpening\", function(storage, isCar)\nif not IsValid(storage) then return end\n    -- Update storage statistics\n    local storageData = storage:getNetVar(\"storageData\", {})\n    storageData.openCount = (storageData.openCount or 0) + 1\n    storageData.lastOpened = os.time()\n    storage:setNetVar(\"storageData\", storageData)\n    -- Check storage capacity\n    local inventory = storage:getInv()\n    if inventory then\n        local items = inventory:getItems()\n        local itemCount = 0\n        for _, item in pairs(items) do\n            itemCount = itemCount + 1\n            end\n        storage:setNetVar(\"itemCount\", itemCount)\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO storage_logs (timestamp, entityid, action, isCar) VALUES (?, ?, ?, ?)\",\n    os.time(), storage:EntIndex(), \"opened\", isCar and 1 or 0)\n    -- Notify nearby players\n    local pos = storage:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 then\n            ply:ChatPrint(\"Storage has been opened\")\n            end\n        end\n    -- Check for storage upgrades\n    local openCount = storageData.openCount\n    if openCount &gt;= 100 and not storageData.upgraded then\n        storageData.upgraded = true\n        storage:setNetVar(\"storageData\", storageData)\n        -- Increase storage capacity\n        if inventory then\n            inventory:setMaxWeight(inventory:getMaxWeight() * 1.5)\n            inventory:setMaxItems(inventory:getMaxItems() * 1.5)\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#storagerestored","title":"StorageRestored","text":"<p>Purpose</p> <p>Called when storage is restored</p> <p>When Called</p> <p>When a storage entity is restored from save data</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The storage entity being restored</li> <li><code>inventory</code> (Inventory): The inventory being restored</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log storage restoration\nhook.Add(\"StorageRestored\", \"MyAddon\", function(ent, inventory)\nprint(\"Storage restored: \" .. tostring(ent))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate storage data\nhook.Add(\"StorageRestored\", \"ValidateStorage\", function(ent, inventory)\nif inventory then\n    inventory:setMaxWeight(500)\n    inventory:setMaxItems(25)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex storage restoration system\nhook.Add(\"StorageRestored\", \"AdvancedStorageRestoration\", function(ent, inventory)\nif not IsValid(ent) or not inventory then return end\n    -- Validate inventory data\n    if inventory:getMaxWeight() &lt;= 0 then\n        inventory:setMaxWeight(500)\n        end\n    if inventory:getMaxItems() &lt;= 0 then\n        inventory:setMaxItems(25)\n        end\n    -- Set storage data\n    ent:setNetVar(\"storageData\", {\n    inventory = inventory:getID(),\n    restored = true,\n    restoredAt = os.time()\n    })\n    -- Add to storage list\n    lia.storage.list[ent] = {\n    inventory = inventory,\n    restored = true,\n    restoredAt = os.time()\n    }\n    -- Log to database\n    lia.db.query(\"INSERT INTO storage_logs (timestamp, entityid, action) VALUES (?, ?, ?)\",\n    os.time(), ent:EntIndex(), \"restored\")\n    -- Notify nearby players\n    local pos = ent:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 300 then\n            ply:ChatPrint(\"Storage has been restored\")\n            end\n        end\n    -- Check for corrupted items\n    local items = inventory:getItems()\n    local corruptedItems = 0\n    for _, item in pairs(items) do\n        if not item.uniqueID or not lia.item.list[item.uniqueID] then\n            corruptedItems = corruptedItems + 1\n            end\n        end\n    if corruptedItems &gt; 0 then\n        print(string.format(\"Storage %s restored with %d corrupted items\", ent:EntIndex(), corruptedItems))\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#storespawns","title":"StoreSpawns","text":"<p>Purpose</p> <p>Called to store spawn points</p> <p>When Called</p> <p>When spawn points are being stored</p> <p>Parameters</p> <ul> <li><code>spawns</code> (table): The spawn points to store</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log spawn storage\nhook.Add(\"StoreSpawns\", \"MyAddon\", function(spawns)\nprint(\"Storing \" .. #spawns .. \" spawn points\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate spawn points\nhook.Add(\"StoreSpawns\", \"ValidateSpawns\", function(spawns)\nfor i, spawn in ipairs(spawns) do\n    if not spawn.pos or not spawn.ang then\n        print(\"Invalid spawn point at index \" .. i)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex spawn storage system\nhook.Add(\"StoreSpawns\", \"AdvancedSpawnStorage\", function(spawns)\nif not spawns or #spawns == 0 then\n    print(\"No spawn points to store\")\n    return\n    end\n-- Validate spawn points\nlocal validSpawns = {}\nfor i, spawn in ipairs(spawns) do\n    if spawn.pos and spawn.ang then\n        -- Check if spawn is valid\n        local trace = util.TraceLine({\n        start = spawn.pos,\n        endpos = spawn.pos + Vector(0, 0, -100),\n        mask = MASK_SOLID\n        })\n        if trace.Hit then\n            table.insert(validSpawns, spawn)\n        else\n            print(\"Spawn point \" .. i .. \" is not on solid ground\")\n            end\n    else\n        print(\"Invalid spawn point at index \" .. i)\n        end\n    end\n-- Store valid spawns\nlia.spawns = validSpawns\n-- Log to database\nlia.db.query(\"DELETE FROM spawns\")\nfor _, spawn in ipairs(validSpawns) do\n    lia.db.query(\"INSERT INTO spawns (pos_x, pos_y, pos_z, ang_p, ang_y, ang_r) VALUES (?, ?, ?, ?, ?, ?)\",\n    spawn.pos.x, spawn.pos.y, spawn.pos.z,\n    spawn.ang.p, spawn.ang.y, spawn.ang.r)\n    end\nprint(string.format(\"Stored %d valid spawn points\", #validSpawns))\nend)\n</code></pre></p>"},{"location":"hooks/server/#synccharlist","title":"SyncCharList","text":"<p>Purpose</p> <p>Called to sync character list with client</p> <p>When Called</p> <p>When character list needs to be synchronized</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client to sync with</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log character list sync\nhook.Add(\"SyncCharList\", \"MyAddon\", function(client)\nprint(\"Syncing character list with \" .. client:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate character data\nhook.Add(\"SyncCharList\", \"ValidateChars\", function(client)\nlocal charList = client:getCharList()\nfor _, char in ipairs(charList) do\n    if not char.name or not char.faction then\n        print(\"Invalid character data for \" .. client:Name())\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex character list sync system\nhook.Add(\"SyncCharList\", \"AdvancedCharSync\", function(client)\nif not IsValid(client) then return end\n    local charList = client:getCharList()\n    if not charList then\n        print(\"No character list for \" .. client:Name())\n        return\n        end\n    -- Validate character data\n    local validChars = {}\n    for _, char in ipairs(charList) do\n        if char.name and char.faction then\n            -- Check if character is valid\n            local faction = lia.faction.list[char.faction]\n            if faction then\n                table.insert(validChars, char)\n            else\n                print(\"Invalid faction for character \" .. char.name)\n                end\n        else\n            print(\"Invalid character data for \" .. client:Name())\n            end\n        end\n    -- Update client character list\n    client:setCharList(validChars)\n    -- Log to database\n    lia.db.query(\"UPDATE players SET char_list = ? WHERE steamid = ?\",\n    util.TableToJSON(validChars), client:SteamID())\n    -- Notify client\n    net.Start(\"liaCharListUpdated\")\n    net.WriteTable(validChars)\n    net.Send(client)\n    print(string.format(\"Synced %d characters for %s\", #validChars, client:Name()))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#ticketsystemclaim","title":"TicketSystemClaim","text":"<p>Purpose</p> <p>Called when a ticket is claimed</p> <p>When Called</p> <p>When a support ticket is claimed by an admin</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The admin claiming the ticket</li> <li><code>requester</code> (Player): The player who requested the ticket</li> <li><code>ticketMessage</code> (string): The ticket message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log ticket claim\nhook.Add(\"TicketSystemClaim\", \"MyAddon\", function(client, requester, ticketMessage)\nprint(client:Name() .. \" claimed ticket from \" .. requester:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify players\nhook.Add(\"TicketSystemClaim\", \"NotifyClaim\", function(client, requester, ticketMessage)\nrequester:ChatPrint(\"Your ticket has been claimed by \" .. client:Name())\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" claimed ticket from \" .. requester:Name())\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ticket claim system\nhook.Add(\"TicketSystemClaim\", \"AdvancedTicketClaim\", function(client, requester, ticketMessage)\nif not IsValid(client) or not IsValid(requester) then return end\n    -- Check if client is admin\n    if not client:IsAdmin() then\n        client:ChatPrint(\"You do not have permission to claim tickets\")\n        return\n        end\n    -- Update ticket status\n    local ticketData = {\n    claimed = true,\n    claimedBy = client:SteamID(),\n    claimedAt = os.time(),\n    message = ticketMessage\n    }\n    requester:setData(\"ticketData\", ticketData)\n    -- Notify requester\n    requester:ChatPrint(\"Your ticket has been claimed by \" .. client:Name())\n    -- Notify admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() then\n            ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" claimed ticket from \" .. requester:Name())\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO ticket_logs (timestamp, requester_steamid, claimer_steamid, message) VALUES (?, ?, ?, ?)\",\n    os.time(), requester:SteamID(), client:SteamID(), ticketMessage)\n    -- Update client data\n    local clientData = client:getData(\"ticketStats\", {})\n    clientData.claimed = (clientData.claimed or 0) + 1\n    client:setData(\"ticketStats\", clientData)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#ticketsystemclose","title":"TicketSystemClose","text":"<p>Purpose</p> <p>Called when a ticket is closed</p> <p>When Called</p> <p>When a support ticket is closed</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The admin closing the ticket</li> <li><code>requester</code> (Player): The player who requested the ticket</li> <li><code>ticketMessage</code> (string): The ticket message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log ticket close\nhook.Add(\"TicketSystemClose\", \"MyAddon\", function(client, requester, ticketMessage)\nprint(client:Name() .. \" closed ticket from \" .. requester:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify players\nhook.Add(\"TicketSystemClose\", \"NotifyClose\", function(client, requester, ticketMessage)\nrequester:ChatPrint(\"Your ticket has been closed by \" .. client:Name())\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" closed ticket from \" .. requester:Name())\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ticket close system\nhook.Add(\"TicketSystemClose\", \"AdvancedTicketClose\", function(client, requester, ticketMessage)\nif not IsValid(client) or not IsValid(requester) then return end\n    -- Check if client is admin\n    if not client:IsAdmin() then\n        client:ChatPrint(\"You do not have permission to close tickets\")\n        return\n        end\n    -- Update ticket status\n    local ticketData = requester:getData(\"ticketData\", {})\n    ticketData.closed = true\n    ticketData.closedBy = client:SteamID()\n    ticketData.closedAt = os.time()\n    ticketData.closeMessage = ticketMessage\n    requester:setData(\"ticketData\", ticketData)\n    -- Notify requester\n    requester:ChatPrint(\"Your ticket has been closed by \" .. client:Name())\n    if ticketMessage and ticketMessage ~= \"\" then\n        requester:ChatPrint(\"Reason: \" .. ticketMessage)\n        end\n    -- Notify admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() then\n            ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" closed ticket from \" .. requester:Name())\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO ticket_logs (timestamp, requester_steamid, closer_steamid, message, action) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), requester:SteamID(), client:SteamID(), ticketMessage, \"closed\")\n    -- Update client data\n    local clientData = client:getData(\"ticketStats\", {})\n    clientData.closed = (clientData.closed or 0) + 1\n    client:setData(\"ticketStats\", clientData)\n    -- Clear ticket data after delay\n    timer.Simple(60, function()\n    if IsValid(requester) then\n        requester:setData(\"ticketData\", nil)\n        end\n    end)\n    end)\n</code></pre></p>"},{"location":"hooks/server/#ticketsystemcreated","title":"TicketSystemCreated","text":"<p>Purpose</p> <p>Called when a ticket is created</p> <p>When Called</p> <p>When a player creates a support ticket</p> <p>Parameters</p> <ul> <li><code>noob</code> (Player): The player creating the ticket</li> <li><code>message</code> (string): The ticket message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log ticket creation\nhook.Add(\"TicketSystemCreated\", \"MyAddon\", function(noob, message)\nprint(noob:Name() .. \" created a ticket: \" .. message)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify admins\nhook.Add(\"TicketSystemCreated\", \"NotifyAdmins\", function(noob, message)\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[TICKET] \" .. noob:Name() .. \": \" .. message)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ticket creation system\nhook.Add(\"TicketSystemCreated\", \"AdvancedTicketCreation\", function(noob, message)\nif not IsValid(noob) then return end\n    -- Check if player already has an open ticket\n    local ticketData = noob:getData(\"ticketData\", {})\n    if ticketData.open and not ticketData.closed then\n        noob:ChatPrint(\"You already have an open ticket. Please wait for it to be resolved.\")\n        return\n        end\n    -- Validate message\n    if not message or #message &lt; 10 then\n        noob:ChatPrint(\"Please provide a more detailed description of your issue.\")\n        return\n        end\n    -- Create ticket data\n    local newTicketData = {\n    open = true,\n    closed = false,\n    message = message,\n    createdAt = os.time(),\n    requester = noob:SteamID()\n    }\n    noob:setData(\"ticketData\", newTicketData)\n    -- Notify admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() then\n            ply:ChatPrint(\"[TICKET] \" .. noob:Name() .. \" created a new ticket\")\n            ply:ChatPrint(\"[TICKET] Message: \" .. message)\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO ticket_logs (timestamp, requester_steamid, message, action) VALUES (?, ?, ?, ?)\",\n    os.time(), noob:SteamID(), message, \"created\")\n    -- Update player data\n    local playerData = noob:getData(\"ticketStats\", {})\n    playerData.created = (playerData.created or 0) + 1\n    noob:setData(\"ticketStats\", playerData)\n    -- Notify player\n    noob:ChatPrint(\"Your ticket has been created. An admin will respond soon.\")\n    end)\n</code></pre></p>"},{"location":"hooks/server/#togglelock","title":"ToggleLock","text":"<p>Purpose</p> <p>Called when a door lock is toggled</p> <p>When Called</p> <p>When a door is locked or unlocked</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player toggling the lock</li> <li><code>door</code> (Entity): The door entity</li> <li><code>state</code> (boolean): The new lock state</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log door lock toggle\nhook.Add(\"ToggleLock\", \"MyAddon\", function(client, door, state)\nprint(client:Name() .. \" \" .. (state and \"locked\" or \"unlocked\") .. \" door\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify nearby players\nhook.Add(\"ToggleLock\", \"NotifyToggle\", function(client, door, state)\nlocal pos = door:GetPos()\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:GetPos():Distance(pos) &lt; 500 then\n        ply:ChatPrint(\"A door has been \" .. (state and \"locked\" or \"unlocked\"))\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door lock system\nhook.Add(\"ToggleLock\", \"AdvancedDoorLock\", function(client, door, state)\nif not IsValid(client) or not IsValid(door) then return end\n    local char = client:getChar()\n    if not char then return end\n        -- Check permissions\n        if not client:IsAdmin() then\n            local doorOwner = door:getNetVar(\"owner\")\n            if doorOwner and doorOwner ~= char:getID() then\n                client:ChatPrint(\"You do not have permission to lock this door\")\n                return\n                end\n            end\n        -- Update door data\n        door:setNetVar(\"locked\", state)\n        door:setNetVar(\"lastLocked\", os.time())\n        door:setNetVar(\"lastLockedBy\", client:SteamID())\n        -- Log to database\n        lia.db.query(\"INSERT INTO door_logs (timestamp, steamid, doorid, action) VALUES (?, ?, ?, ?)\",\n        os.time(), client:SteamID(), door:EntIndex(), state and \"locked\" or \"unlocked\")\n        -- Notify nearby players\n        local pos = door:GetPos()\n        for _, ply in ipairs(player.GetAll()) do\n            if ply:GetPos():Distance(pos) &lt; 500 and ply ~= client then\n                ply:ChatPrint(\"A door has been \" .. (state and \"locked\" or \"unlocked\"))\n                end\n            end\n        -- Update character stats\n        local locks = char:getData(\"doorsLocked\", 0)\n        char:setData(\"doorsLocked\", locks + 1)\n        -- Check for door upgrades\n        local lockCount = char:getData(\"doorsLocked\", 0)\n        if lockCount &gt;= 10 and not char:getData(\"doorMaster\", false) then\n            char:setData(\"doorMaster\", true)\n            client:ChatPrint(\"You have mastered door locking!\")\n            end\n        end)\n</code></pre></p>"},{"location":"hooks/server/#transferitem","title":"TransferItem","text":"<p>Purpose</p> <p>Called to transfer an item</p> <p>When Called</p> <p>When an item is being transferred</p> <p>Parameters</p> <ul> <li><code>itemID</code> (string): The ID of the item being transferred</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item transfer\nhook.Add(\"TransferItem\", \"MyAddon\", function(itemID)\nprint(\"Item transferred: \" .. itemID)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track item transfers\nhook.Add(\"TransferItem\", \"TrackTransfers\", function(itemID)\nlocal item = lia.item.instances[itemID]\nif item then\n    local transferCount = item:getData(\"transferCount\", 0)\n    item:setData(\"transferCount\", transferCount + 1)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item transfer system\nhook.Add(\"TransferItem\", \"AdvancedItemTransfer\", function(itemID)\nif not itemID then return end\n    local item = lia.item.instances[itemID]\n    if not item then return end\n        -- Get item data\n        local itemData = item:getData()\n        local fromInventory = item:getInventory()\n        local toInventory = item:getData(\"targetInventory\")\n        if not fromInventory or not toInventory then return end\n            -- Check transfer permissions\n            local fromOwner = fromInventory:getOwner()\n            local toOwner = toInventory:getOwner()\n            if fromOwner and toOwner and fromOwner ~= toOwner then\n                -- Check if transfer is allowed between different owners\n                local transferAllowed = item:getData(\"transferable\", true)\n                if not transferAllowed then\n                    print(\"Item \" .. itemID .. \" is not transferable\")\n                    return\n                    end\n                end\n            -- Update item data\n            local transferCount = item:getData(\"transferCount\", 0)\n            item:setData(\"transferCount\", transferCount + 1)\n            item:setData(\"lastTransfer\", os.time())\n            -- Log to database\n            lia.db.query(\"INSERT INTO item_transfer_logs (timestamp, itemid, from_inventory, to_inventory) VALUES (?, ?, ?, ?)\",\n            os.time(), itemID, fromInventory:getID(), toInventory:getID())\n            -- Notify players\n            local fromChar = lia.char.loaded[fromOwner]\n            local toChar = lia.char.loaded[toOwner]\n            if fromChar and fromChar:getPlayer() then\n                fromChar:getPlayer():ChatPrint(\"Item transferred: \" .. item:getName())\n                end\n            if toChar and toChar:getPlayer() and toChar:getPlayer() ~= fromChar:getPlayer() then\n                toChar:getPlayer():ChatPrint(\"Item received: \" .. item:getName())\n                end\n            -- Check for item degradation\n            local durability = item:getData(\"durability\", 100)\n            if durability &gt; 0 then\n                local newDurability = math.max(0, durability - 1)\n                item:setData(\"durability\", newDurability)\n                if newDurability &lt;= 0 then\n                    item:setData(\"broken\", true)\n                    end\n                end\n            end)\n</code></pre></p>"},{"location":"hooks/server/#updateentitypersistence","title":"UpdateEntityPersistence","text":"<p>Purpose</p> <p>Called to update entity persistence</p> <p>When Called</p> <p>When an entity's persistence data needs to be updated</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The entity to update</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log entity persistence update\nhook.Add(\"UpdateEntityPersistence\", \"MyAddon\", function(ent)\nprint(\"Updating persistence for \" .. tostring(ent))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update entity data\nhook.Add(\"UpdateEntityPersistence\", \"UpdateData\", function(ent)\nif IsValid(ent) then\n    ent:setData(\"lastUpdate\", os.time())\n    ent:setData(\"persistent\", true)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entity persistence system\nhook.Add(\"UpdateEntityPersistence\", \"AdvancedPersistence\", function(ent)\nif not IsValid(ent) then return end\n    -- Check if entity should be persistent\n    local shouldPersist = hook.Run(\"CanPersistEntity\", ent)\n    if not shouldPersist then\n        ent:setData(\"persistent\", false)\n        return\n        end\n    -- Update entity data\n    local entityData = {\n    class = ent:GetClass(),\n    model = ent:GetModel(),\n    pos = ent:GetPos(),\n    ang = ent:GetAngles(),\n    lastUpdate = os.time(),\n    persistent = true\n    }\n    -- Save custom data\n    local customData = ent:getData(\"customData\", {})\n    if customData and next(customData) then\n        entityData.customData = customData\n        end\n    -- Save to database\n    local entityID = ent:EntIndex()\n    lia.db.query(\"INSERT OR REPLACE INTO persistent_entities (entityid, data, lastupdate) VALUES (?, ?, ?)\",\n    entityID, util.TableToJSON(entityData), os.time())\n    -- Update entity\n    ent:setData(\"persistent\", true)\n    ent:setData(\"lastUpdate\", os.time())\n    -- Notify nearby players\n    local pos = ent:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 then\n            ply:ChatPrint(\"Entity persistence updated\")\n            end\n        end\n    -- Log to file\n    lia.log.write(\"entity_persistence\", {\n    entityID = entityID,\n    class = ent:GetClass(),\n    timestamp = os.time()\n    })\n    end)\n</code></pre></p>"},{"location":"hooks/server/#vendorclassupdated","title":"VendorClassUpdated","text":"<p>Purpose</p> <p>Called when a vendor class is updated</p> <p>When Called</p> <p>When a vendor's allowed classes are modified</p> <p>Parameters</p> <ul> <li><code>vendor</code> (Entity): The vendor entity</li> <li><code>id</code> (string): The class ID being updated</li> <li><code>allowed</code> (boolean): Whether the class is allowed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor class update\nhook.Add(\"VendorClassUpdated\", \"MyAddon\", function(vendor, id, allowed)\nprint(\"Vendor class \" .. id .. \" \" .. (allowed and \"allowed\" or \"denied\"))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify players\nhook.Add(\"VendorClassUpdated\", \"NotifyPlayers\", function(vendor, id, allowed)\nlocal pos = vendor:GetPos()\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:GetPos():Distance(pos) &lt; 500 then\n        ply:ChatPrint(\"Vendor class \" .. id .. \" \" .. (allowed and \"allowed\" or \"denied\"))\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor class system\nhook.Add(\"VendorClassUpdated\", \"AdvancedVendorClass\", function(vendor, id, allowed)\nif not IsValid(vendor) then return end\n    -- Update vendor data\n    local vendorData = vendor:getNetVar(\"vendorData\", {})\n    vendorData.allowedClasses = vendorData.allowedClasses or {}\n    vendorData.allowedClasses[id] = allowed\n    vendor:setNetVar(\"vendorData\", vendorData)\n    -- Update vendor inventory\n    local inventory = vendor:getInv()\n    if inventory then\n        local items = inventory:getItems()\n        for _, item in pairs(items) do\n            if item.uniqueID == id then\n                item:setData(\"allowed\", allowed)\n                end\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO vendor_class_logs (timestamp, vendorid, classid, allowed) VALUES (?, ?, ?, ?)\",\n    os.time(), vendor:EntIndex(), id, allowed and 1 or 0)\n    -- Notify nearby players\n    local pos = vendor:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 then\n            local char = ply:getChar()\n            if char and char:getFaction() == id then\n                ply:ChatPrint(\"Vendor access \" .. (allowed and \"granted\" or \"revoked\") .. \" for your class\")\n                end\n            end\n        end\n    -- Update vendor UI if open\n    if IsValid(lia.gui.vendor) and lia.gui.vendor.vendor == vendor then\n        lia.gui.vendor:Populate()\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#vendoredited","title":"VendorEdited","text":"<p>Purpose</p> <p>Called when a vendor is edited</p> <p>When Called</p> <p>When a vendor's properties are modified</p> <p>Parameters</p> <ul> <li><code>liaVendorEnt</code> (Entity): The vendor entity being edited</li> <li><code>key</code> (string): The property key being edited</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor edit\nhook.Add(\"VendorEdited\", \"MyAddon\", function(liaVendorEnt, key)\nprint(\"Vendor edited: \" .. key)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate vendor edits\nhook.Add(\"VendorEdited\", \"ValidateEdits\", function(liaVendorEnt, key)\nif key == \"name\" and liaVendorEnt:getNetVar(\"name\") == \"\" then\n    liaVendorEnt:setNetVar(\"name\", \"Unnamed Vendor\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor editing system\nhook.Add(\"VendorEdited\", \"AdvancedVendorEdit\", function(liaVendorEnt, key)\nif not IsValid(liaVendorEnt) then return end\n    -- Update vendor data\n    local vendorData = liaVendorEnt:getNetVar(\"vendorData\", {})\n    vendorData.lastEdit = os.time()\n    vendorData.editedBy = key\n    liaVendorEnt:setNetVar(\"vendorData\", vendorData)\n    -- Validate specific properties\n    if key == \"name\" then\n        local name = liaVendorEnt:getNetVar(\"name\", \"\")\n        if name == \"\" then\n            liaVendorEnt:setNetVar(\"name\", \"Unnamed Vendor\")\n        elseif #name &gt; 50 then\n            liaVendorEnt:setNetVar(\"name\", string.sub(name, 1, 50))\n            end\n    elseif key == \"money\" then\n        local money = liaVendorEnt:getNetVar(\"money\", 0)\n        if money &lt; 0 then\n            liaVendorEnt:setNetVar(\"money\", 0)\n        elseif money &gt; 1000000 then\n            liaVendorEnt:setNetVar(\"money\", 1000000)\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO vendor_edit_logs (timestamp, vendorid, property, value) VALUES (?, ?, ?, ?)\",\n    os.time(), liaVendorEnt:EntIndex(), key, tostring(liaVendorEnt:getNetVar(key, \"\")))\n    -- Notify nearby players\n    local pos = liaVendorEnt:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 then\n            ply:ChatPrint(\"Vendor \" .. key .. \" has been updated\")\n            end\n        end\n    -- Update vendor UI if open\n    if IsValid(lia.gui.vendor) and lia.gui.vendor.vendor == liaVendorEnt then\n        lia.gui.vendor:Populate()\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#vendorfactionupdated","title":"VendorFactionUpdated","text":"<p>Purpose</p> <p>Called when a vendor faction is updated</p> <p>When Called</p> <p>When a vendor's allowed factions are modified</p> <p>Parameters</p> <ul> <li><code>vendor</code> (Entity): The vendor entity</li> <li><code>id</code> (string): The faction ID being updated</li> <li><code>allowed</code> (boolean): Whether the faction is allowed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor faction update\nhook.Add(\"VendorFactionUpdated\", \"MyAddon\", function(vendor, id, allowed)\nprint(\"Vendor faction \" .. id .. \" \" .. (allowed and \"allowed\" or \"denied\"))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify players\nhook.Add(\"VendorFactionUpdated\", \"NotifyPlayers\", function(vendor, id, allowed)\nlocal pos = vendor:GetPos()\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:GetPos():Distance(pos) &lt; 500 then\n        local char = ply:getChar()\n        if char and char:getFaction() == id then\n            ply:ChatPrint(\"Vendor access \" .. (allowed and \"granted\" or \"revoked\") .. \" for your faction\")\n            end\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor faction system\nhook.Add(\"VendorFactionUpdated\", \"AdvancedVendorFaction\", function(vendor, id, allowed)\nif not IsValid(vendor) then return end\n    -- Update vendor data\n    local vendorData = vendor:getNetVar(\"vendorData\", {})\n    vendorData.allowedFactions = vendorData.allowedFactions or {}\n    vendorData.allowedFactions[id] = allowed\n    vendor:setNetVar(\"vendorData\", vendorData)\n    -- Update vendor inventory\n    local inventory = vendor:getInv()\n    if inventory then\n        local items = inventory:getItems()\n        for _, item in pairs(items) do\n            if item.faction == id then\n                item:setData(\"allowed\", allowed)\n                end\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO vendor_faction_logs (timestamp, vendorid, factionid, allowed) VALUES (?, ?, ?, ?)\",\n    os.time(), vendor:EntIndex(), id, allowed and 1 or 0)\n    -- Notify affected players\n    local pos = vendor:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 then\n            local char = ply:getChar()\n            if char and char:getFaction() == id then\n                ply:ChatPrint(\"Vendor access \" .. (allowed and \"granted\" or \"revoked\") .. \" for your faction\")\n                end\n            end\n        end\n    -- Update vendor UI if open\n    if IsValid(lia.gui.vendor) and lia.gui.vendor.vendor == vendor then\n        lia.gui.vendor:Populate()\n        end\n    -- Check for faction-specific items\n    local factionItems = lia.item.getByFaction(id)\n    for _, item in ipairs(factionItems) do\n        if allowed then\n            vendor:addItem(item.uniqueID, 1)\n        else\n            vendor:removeItem(item.uniqueID, 1)\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#vendoritemmaxstockupdated","title":"VendorItemMaxStockUpdated","text":"<p>Purpose</p> <p>Called when a vendor item max stock is updated</p> <p>When Called</p> <p>When a vendor item's maximum stock is modified</p> <p>Parameters</p> <ul> <li><code>vendor</code> (Entity): The vendor entity</li> <li><code>itemType</code> (string): The item type being updated</li> <li><code>value</code> (number): The new maximum stock value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log max stock update\nhook.Add(\"VendorItemMaxStockUpdated\", \"MyAddon\", function(vendor, itemType, value)\nprint(\"Vendor item \" .. itemType .. \" max stock set to \" .. value)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate max stock value\nhook.Add(\"VendorItemMaxStockUpdated\", \"ValidateMaxStock\", function(vendor, itemType, value)\nif value &lt; 0 then\n    value = 0\nelseif value &gt; 1000 then\n    value = 1000\n    end\nvendor:setNetVar(\"itemMaxStock_\" .. itemType, value)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor max stock system\nhook.Add(\"VendorItemMaxStockUpdated\", \"AdvancedVendorMaxStock\", function(vendor, itemType, value)\nif not IsValid(vendor) then return end\n    -- Validate value\n    if value &lt; 0 then\n        value = 0\n    elseif value &gt; 10000 then\n        value = 10000\n        end\n    -- Update vendor data\n    local vendorData = vendor:getNetVar(\"vendorData\", {})\n    vendorData.itemMaxStock = vendorData.itemMaxStock or {}\n    vendorData.itemMaxStock[itemType] = value\n    vendor:setNetVar(\"vendorData\", vendorData)\n    -- Update item in inventory\n    local inventory = vendor:getInv()\n    if inventory then\n        local items = inventory:getItems()\n        for _, item in pairs(items) do\n            if item.uniqueID == itemType then\n                item:setData(\"maxStock\", value)\n                -- Adjust current stock if it exceeds max\n                local currentStock = item:getData(\"stock\", 0)\n                if currentStock &gt; value then\n                    item:setData(\"stock\", value)\n                    end\n                end\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO vendor_item_logs (timestamp, vendorid, itemtype, property, value) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), vendor:EntIndex(), itemType, \"maxStock\", value)\n    -- Notify nearby players\n    local pos = vendor:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 then\n            ply:ChatPrint(\"Vendor item \" .. itemType .. \" max stock updated to \" .. value)\n            end\n        end\n    -- Update vendor UI if open\n    if IsValid(lia.gui.vendor) and lia.gui.vendor.vendor == vendor then\n        lia.gui.vendor:Populate()\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#vendoritemmodeupdated","title":"VendorItemModeUpdated","text":"<p>Purpose</p> <p>Called when a vendor item mode is updated</p> <p>When Called</p> <p>When a vendor item's mode is modified</p> <p>Parameters</p> <ul> <li><code>vendor</code> (Entity): The vendor entity</li> <li><code>itemType</code> (string): The item type being updated</li> <li><code>value</code> (string): The new mode value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item mode update\nhook.Add(\"VendorItemModeUpdated\", \"MyAddon\", function(vendor, itemType, value)\nprint(\"Vendor item \" .. itemType .. \" mode set to \" .. value)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate mode value\nhook.Add(\"VendorItemModeUpdated\", \"ValidateMode\", function(vendor, itemType, value)\nlocal validModes = {\"buy\", \"sell\", \"both\"}\nif not table.HasValue(validModes, value) then\n    value = \"both\"\n    end\nvendor:setNetVar(\"itemMode_\" .. itemType, value)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor item mode system\nhook.Add(\"VendorItemModeUpdated\", \"AdvancedVendorItemMode\", function(vendor, itemType, value)\nif not IsValid(vendor) then return end\n    -- Validate mode\n    local validModes = {\"buy\", \"sell\", \"both\"}\n    if not table.HasValue(validModes, value) then\n        value = \"both\"\n        end\n    -- Update vendor data\n    local vendorData = vendor:getNetVar(\"vendorData\", {})\n    vendorData.itemModes = vendorData.itemModes or {}\n    vendorData.itemModes[itemType] = value\n    vendor:setNetVar(\"vendorData\", vendorData)\n    -- Update item in inventory\n    local inventory = vendor:getInv()\n    if inventory then\n        local items = inventory:getItems()\n        for _, item in pairs(items) do\n            if item.uniqueID == itemType then\n                item:setData(\"mode\", value)\n                -- Update item display based on mode\n                if value == \"buy\" then\n                    item:setData(\"sellable\", false)\n                    item:setData(\"buyable\", true)\n                elseif value == \"sell\" then\n                    item:setData(\"sellable\", true)\n                    item:setData(\"buyable\", false)\n                else\n                    item:setData(\"sellable\", true)\n                    item:setData(\"buyable\", true)\n                    end\n                end\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO vendor_item_logs (timestamp, vendorid, itemtype, property, value) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), vendor:EntIndex(), itemType, \"mode\", value)\n    -- Notify nearby players\n    local pos = vendor:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 then\n            ply:ChatPrint(\"Vendor item \" .. itemType .. \" mode updated to \" .. value)\n            end\n        end\n    -- Update vendor UI if open\n    if IsValid(lia.gui.vendor) and lia.gui.vendor.vendor == vendor then\n        lia.gui.vendor:Populate()\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#vendoritempriceupdated","title":"VendorItemPriceUpdated","text":"<p>Purpose</p> <p>Called when a vendor item price is updated</p> <p>When Called</p> <p>When a vendor item's price is modified</p> <p>Parameters</p> <ul> <li><code>vendor</code> (Entity): The vendor entity</li> <li><code>itemType</code> (string): The item type being updated</li> <li><code>value</code> (number): The new price value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log price update\nhook.Add(\"VendorItemPriceUpdated\", \"MyAddon\", function(vendor, itemType, value)\nprint(\"Vendor item \" .. itemType .. \" price set to \" .. value)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate price value\nhook.Add(\"VendorItemPriceUpdated\", \"ValidatePrice\", function(vendor, itemType, value)\nif value &lt; 0 then\n    value = 0\nelseif value &gt; 1000000 then\n    value = 1000000\n    end\nvendor:setNetVar(\"itemPrice_\" .. itemType, value)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor price system\nhook.Add(\"VendorItemPriceUpdated\", \"AdvancedVendorPrice\", function(vendor, itemType, value)\nif not IsValid(vendor) then return end\n    -- Validate price\n    if value &lt; 0 then\n        value = 0\n    elseif value &gt; 10000000 then\n        value = 10000000\n        end\n    -- Update vendor data\n    local vendorData = vendor:getNetVar(\"vendorData\", {})\n    vendorData.itemPrices = vendorData.itemPrices or {}\n    vendorData.itemPrices[itemType] = value\n    vendor:setNetVar(\"vendorData\", vendorData)\n    -- Update item in inventory\n    local inventory = vendor:getInv()\n    if inventory then\n        local items = inventory:getItems()\n        for _, item in pairs(items) do\n            if item.uniqueID == itemType then\n                item:setData(\"price\", value)\n                -- Calculate profit margin\n                local basePrice = item:getData(\"basePrice\", value)\n                local profitMargin = ((value - basePrice) / basePrice) * 100\n                item:setData(\"profitMargin\", profitMargin)\n                end\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO vendor_item_logs (timestamp, vendorid, itemtype, property, value) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), vendor:EntIndex(), itemType, \"price\", value)\n    -- Notify nearby players\n    local pos = vendor:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 then\n            ply:ChatPrint(\"Vendor item \" .. itemType .. \" price updated to $\" .. value)\n            end\n        end\n    -- Update vendor UI if open\n    if IsValid(lia.gui.vendor) and lia.gui.vendor.vendor == vendor then\n        lia.gui.vendor:Populate()\n        end\n    -- Check for price alerts\n    local priceAlerts = lia.config.get(\"priceAlerts\", {})\n    for _, alert in ipairs(priceAlerts) do\n        if alert.itemType == itemType and alert.priceThreshold and value &gt;= alert.priceThreshold then\n            for _, ply in ipairs(player.GetAll()) do\n                ply:ChatPrint(\"Price alert: \" .. itemType .. \" is now $\" .. value)\n                end\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#vendoritemstockupdated","title":"VendorItemStockUpdated","text":"<p>Purpose</p> <p>Called when a vendor item stock is updated</p> <p>When Called</p> <p>When a vendor item's stock is modified</p> <p>Parameters</p> <ul> <li><code>vendor</code> (Entity): The vendor entity</li> <li><code>itemType</code> (string): The item type being updated</li> <li><code>value</code> (number): The new stock value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log stock update\nhook.Add(\"VendorItemStockUpdated\", \"MyAddon\", function(vendor, itemType, value)\nprint(\"Vendor item \" .. itemType .. \" stock set to \" .. value)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate stock value\nhook.Add(\"VendorItemStockUpdated\", \"ValidateStock\", function(vendor, itemType, value)\nif value &lt; 0 then\n    value = 0\n    end\nvendor:setNetVar(\"itemStock_\" .. itemType, value)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor stock system\nhook.Add(\"VendorItemStockUpdated\", \"AdvancedVendorStock\", function(vendor, itemType, value)\nif not IsValid(vendor) then return end\n    -- Validate stock\n    if value &lt; 0 then\n        value = 0\n        end\n    -- Get max stock\n    local maxStock = vendor:getNetVar(\"itemMaxStock_\" .. itemType, 100)\n    if value &gt; maxStock then\n        value = maxStock\n        end\n    -- Update vendor data\n    local vendorData = vendor:getNetVar(\"vendorData\", {})\n    vendorData.itemStocks = vendorData.itemStocks or {}\n    vendorData.itemStocks[itemType] = value\n    vendor:setNetVar(\"vendorData\", vendorData)\n    -- Update item in inventory\n    local inventory = vendor:getInv()\n    if inventory then\n        local items = inventory:getItems()\n        for _, item in pairs(items) do\n            if item.uniqueID == itemType then\n                item:setData(\"stock\", value)\n                -- Check if item is out of stock\n                if value &lt;= 0 then\n                    item:setData(\"outOfStock\", true)\n                else\n                    item:setData(\"outOfStock\", false)\n                    end\n                end\n            end\n        end\n    -- Log to database\n    lia.db.query(\"INSERT INTO vendor_item_logs (timestamp, vendorid, itemtype, property, value) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), vendor:EntIndex(), itemType, \"stock\", value)\n    -- Notify nearby players\n    local pos = vendor:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 then\n            ply:ChatPrint(\"Vendor item \" .. itemType .. \" stock updated to \" .. value)\n            end\n        end\n    -- Update vendor UI if open\n    if IsValid(lia.gui.vendor) and lia.gui.vendor.vendor == vendor then\n        lia.gui.vendor:Populate()\n        end\n    -- Check for low stock alerts\n    local lowStockThreshold = lia.config.get(\"lowStockThreshold\", 10)\n    if value &lt;= lowStockThreshold then\n        for _, ply in ipairs(player.GetAll()) do\n            if ply:IsAdmin() then\n                ply:ChatPrint(\"Low stock alert: \" .. itemType .. \" has \" .. value .. \" left\")\n                end\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#vendoropened","title":"VendorOpened","text":"<p>Purpose</p> <p>Called when a vendor is opened by a player</p> <p>When Called</p> <p>When a player successfully opens a vendor</p> <p>Parameters</p> <ul> <li><code>vendor</code> (Entity): The vendor entity being opened</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor opening\nhook.Add(\"VendorOpened\", \"MyAddon\", function(vendor)\nprint(\"Vendor opened: \" .. vendor:EntIndex())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track vendor usage\nhook.Add(\"VendorOpened\", \"VendorTracking\", function(vendor)\nlocal vendorData = vendor:getNetVar(\"vendorData\", {})\nvendorData.openCount = (vendorData.openCount or 0) + 1\nvendorData.lastOpened = os.time()\nvendor:setNetVar(\"vendorData\", vendorData)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor opening system\nhook.Add(\"VendorOpened\", \"AdvancedVendorOpening\", function(vendor)\nlocal char = vendor:getChar()\nif not char then return end\n    -- Update vendor statistics\n    local vendorData = vendor:getNetVar(\"vendorData\", {})\n    vendorData.openCount = (vendorData.openCount or 0) + 1\n    vendorData.lastOpened = os.time()\n    vendorData.totalRevenue = vendorData.totalRevenue or 0\n    vendor:setNetVar(\"vendorData\", vendorData)\n    -- Check for vendor upgrades\n    local openCount = vendorData.openCount\n    if openCount &gt;= 100 and not vendorData.upgraded then\n        vendorData.upgraded = true\n        vendor:setNetVar(\"vendorData\", vendorData)\n        char:getPlayer():ChatPrint(\"Vendor upgraded! Increased stock capacity.\")\n        end\n    -- Apply faction bonuses\n    local faction = char:getFaction()\n    local bonuses = {\n    [\"police\"] = {discount = 0.1, bonusStock = 50},\n    [\"medic\"] = {discount = 0.05, bonusStock = 25},\n    [\"citizen\"] = {discount = 0.0, bonusStock = 0}\n    }\n    local bonus = bonuses[faction] or {discount = 0.0, bonusStock = 0}\n    vendor:setNetVar(\"factionDiscount\", bonus.discount)\n    vendor:setNetVar(\"bonusStock\", bonus.bonusStock)\n    -- Check for time-based events\n    local currentHour = tonumber(os.date(\"%H\"))\n    if currentHour &gt;= 18 and currentHour &lt;= 22 then\n        -- Peak hours bonus\n        vendor:setNetVar(\"peakHoursBonus\", 0.2)\n    else\n        vendor:setNetVar(\"peakHoursBonus\", 0.0)\n        end\n    -- Log vendor opening\n    print(string.format(\"Vendor %s opened by %s (Faction: %s, Opens: %d)\",\n    vendor:EntIndex(), char:getName(), faction, openCount))\n    end)\n</code></pre></p>"},{"location":"hooks/server/#vendortradeevent","title":"VendorTradeEvent","text":"<p>Purpose</p> <p>Called when a vendor trade event occurs</p> <p>When Called</p> <p>When a player trades with a vendor</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player trading</li> <li><code>vendor</code> (Entity): The vendor entity</li> <li><code>itemType</code> (string): The type of item being traded</li> <li><code>isSellingToVendor</code> (boolean): Whether the player is selling to the vendor</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log vendor trade\nhook.Add(\"VendorTradeEvent\", \"MyAddon\", function(client, vendor, itemType, isSellingToVendor)\nprint(client:Name() .. \" traded \" .. itemType)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track trade statistics\nhook.Add(\"VendorTradeEvent\", \"TrackTrades\", function(client, vendor, itemType, isSellingToVendor)\nlocal char = client:getChar()\nif not char then return end\n    local trades = char:getData(\"vendorTrades\", 0)\n    char:setData(\"vendorTrades\", trades + 1)\n    end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor trade system\nhook.Add(\"VendorTradeEvent\", \"AdvancedVendorTrade\", function(client, vendor, itemType, isSellingToVendor)\nlocal char = client:getChar()\nif not char then return end\n    -- Update trade statistics\n    local trades = char:getData(\"vendorTrades\", 0)\n    char:setData(\"vendorTrades\", trades + 1)\n    -- Track trade value\n    local tradeValue = char:getData(\"tradeValue\", 0)\n    local itemPrice = lia.item.list[itemType] and lia.item.list[itemType].price or 0\n    char:setData(\"tradeValue\", tradeValue + itemPrice)\n    -- Log to database\n    lia.db.query(\"INSERT INTO trade_logs (timestamp, steamid, vendorid, itemtype, selling) VALUES (?, ?, ?, ?, ?)\",\n    os.time(), client:SteamID(), vendor:EntIndex(), itemType, isSellingToVendor and 1 or 0)\n    -- Update vendor reputation\n    local vendorID = vendor:EntIndex()\n    local reputation = char:getData(\"vendorRep_\" .. vendorID, 0)\n    char:setData(\"vendorRep_\" .. vendorID, reputation + 1)\n    -- Notify nearby players\n    local pos = vendor:GetPos()\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:GetPos():Distance(pos) &lt; 500 and ply ~= client then\n            ply:ChatPrint(client:Name() .. \" traded with the vendor\")\n            end\n        end\n    end)\n</code></pre></p>"},{"location":"hooks/server/#warningissued","title":"WarningIssued","text":"<p>Purpose</p> <p>Called when a warning is issued</p> <p>When Called</p> <p>When a player receives a warning</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who issued the warning</li> <li><code>target</code> (Player): The player who received the warning</li> <li><code>reason</code> (string): The reason for the warning</li> <li><code>count</code> (number): The total warning count</li> <li><code>warnerSteamID</code> (string): The SteamID of the warner</li> <li><code>warnerName</code> (string): The name of the warner</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log warning\nhook.Add(\"WarningIssued\", \"MyAddon\", function(client, target, reason, count, warnerSteamID, warnerName)\nprint(target:Name() .. \" was warned by \" .. client:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify admins\nhook.Add(\"WarningIssued\", \"NotifyAdmins\", function(client, target, reason, count, warnerSteamID, warnerName)\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(target:Name() .. \" was warned for: \" .. reason)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex warning system\nhook.Add(\"WarningIssued\", \"AdvancedWarningSystem\", function(client, target, reason, count, warnerSteamID, warnerName)\n-- Log to database\nlia.db.query(\"INSERT INTO warning_logs (timestamp, warner_steamid, target_steamid, reason, count) VALUES (?, ?, ?, ?, ?)\",\nos.time(), warnerSteamID, target:SteamID(), reason, count)\n-- Notify target\ntarget:ChatPrint(\"You have been warned by \" .. warnerName .. \" for: \" .. reason)\ntarget:ChatPrint(\"Total warnings: \" .. count)\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[ADMIN] \" .. target:Name() .. \" was warned by \" .. warnerName .. \" for: \" .. reason)\n        end\n    end\n-- Auto-kick if too many warnings\nif count &gt;= 3 then\n    target:Kick(\"Too many warnings (\" .. count .. \")\")\n    end\n-- Update character data\nlocal char = target:getChar()\nif char then\n    char:setData(\"totalWarnings\", count)\n    char:setData(\"lastWarning\", os.time())\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#warningremoved","title":"WarningRemoved","text":"<p>Purpose</p> <p>Called when a warning is removed</p> <p>When Called</p> <p>When a warning is removed from a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who removed the warning</li> <li><code>targetClient</code> (Player): The player whose warning was removed</li> <li><code>reason</code> (string): The reason for the warning removal</li> <li><code>count</code> (number): The remaining warning count</li> <li><code>warnerSteamID</code> (string): The SteamID of the original warner</li> <li><code>warnerName</code> (string): The name of the original warner</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log warning removal\nhook.Add(\"WarningRemoved\", \"MyAddon\", function(client, targetClient, reason, count, warnerSteamID, warnerName)\nprint(targetClient:Name() .. \"'s warning was removed by \" .. client:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify admins\nhook.Add(\"WarningRemoved\", \"NotifyWarningRemoval\", function(client, targetClient, reason, count, warnerSteamID, warnerName)\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(targetClient:Name() .. \"'s warning was removed by \" .. client:Name())\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex warning removal system\nhook.Add(\"WarningRemoved\", \"AdvancedWarningRemoval\", function(client, targetClient, reason, count, warnerSteamID, warnerName)\n-- Log to database\nlia.db.query(\"INSERT INTO warning_removal_logs (timestamp, remover_steamid, target_steamid, reason, remaining_count) VALUES (?, ?, ?, ?, ?)\",\nos.time(), client:SteamID(), targetClient:SteamID(), reason, count)\n-- Notify target\ntargetClient:ChatPrint(\"One of your warnings has been removed by \" .. client:Name())\ntargetClient:ChatPrint(\"Remaining warnings: \" .. count)\n-- Notify admins\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        ply:ChatPrint(\"[ADMIN] \" .. client:Name() .. \" removed a warning from \" .. targetClient:Name())\n        ply:ChatPrint(\"[ADMIN] Reason: \" .. reason .. \" | Remaining: \" .. count)\n        end\n    end\n-- Update character data\nlocal char = targetClient:getChar()\nif char then\n    char:setData(\"totalWarnings\", count)\n    char:setData(\"lastWarningRemoval\", os.time())\n    end\nend)\n</code></pre></p>"},{"location":"hooks/server/#setdata","title":"setData","text":"<p>Purpose</p> <p>Called to set persistent data</p> <p>When Called</p> <p>When setting global or character-specific data</p> <p>Parameters</p> <ul> <li><code>value</code> (any): The value to set</li> <li><code>global</code> (boolean): Whether this is global data</li> <li><code>ignoreMap</code> (boolean): Whether to ignore map-specific data</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log data setting\nhook.Add(\"setData\", \"MyAddon\", function(value, global, ignoreMap)\nprint(\"Data set: \" .. tostring(value))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate data before setting\nhook.Add(\"setData\", \"ValidateData\", function(value, global, ignoreMap)\nif type(value) == \"string\" and #value &gt; 1000 then\n    print(\"Warning: Data value too long\")\n    return false\n    end\nreturn true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data validation system\nhook.Add(\"setData\", \"AdvancedDataValidation\", function(value, global, ignoreMap)\n-- Validate data type and size\nif type(value) == \"string\" and #value &gt; 1000 then\n    print(\"Warning: Data value too long, truncating\")\n    value = string.sub(value, 1, 1000)\n    end\n-- Validate global data\nif global and type(value) == \"table\" then\n    -- Check for circular references\n    local function hasCircularRef(obj, seen)\n        seen = seen or {}\n        if type(obj) ~= \"table\" then return false end\n            if seen[obj] then return true end\n                seen[obj] = true\n                for k, v in pairs(obj) do\n                    if hasCircularRef(v, seen) then return true end\n                        end\n                    return false\n                    end\n                if hasCircularRef(value) then\n                    print(\"Error: Circular reference detected in global data\")\n                    return false\n                    end\n                end\n            -- Log data changes\n            lia.db.query(\"INSERT INTO data_logs (timestamp, global, value_type) VALUES (?, ?, ?)\",\n            os.time(), global and 1 or 0, type(value))\n            return true\n            end)\n</code></pre></p>"},{"location":"hooks/shared/","title":"Shared Hooks","text":"<p>Shared hook system for the Lilia framework.</p> <p>Overview</p> <p>Shared hooks in the Lilia framework handle functionality available on both client and server, typically for data synchronization, shared utilities, and cross-realm features. They follow the Garry's Mod hook system and can be overridden or extended by addons and modules.</p>"},{"location":"hooks/shared/#adjuststaminaoffset","title":"AdjustStaminaOffset","text":"<p>Purpose</p> <p>Allows modification of stamina regeneration/drain offset for a player</p> <p>When Called</p> <p>During stamina calculation, allowing custom stamina modifiers</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose stamina is being calculated</li> <li><code>offset</code> (number): The current stamina offset (positive for regen, negative for drain)</li> </ul> <p>Returns</p> <ul> <li>number - The modified stamina offset, or nil to use original offset</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Increase stamina regeneration\nhook.Add(\"AdjustStaminaOffset\", \"MyAddon\", function(client, offset)\n    if offset &gt; 0 then -- Only modify regeneration, not drain\n        return offset * 1.5 -- 50% faster regeneration\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Modify stamina based on character attributes\nhook.Add(\"AdjustStaminaOffset\", \"AttributeStamina\", function(client, offset)\n    local char = client:getChar()\n    if not char then return end\n    local con = char:getAttrib(\"con\", 0) -- Constitution attribute\n    if offset &gt; 0 then -- Regeneration\n        return offset * (1 + con * 0.1) -- 10% bonus per constitution point\n    else -- Drain\n        return offset * (1 - con * 0.05) -- 5% less drain per constitution point\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex stamina system with multiple factors\nhook.Add(\"AdjustStaminaOffset\", \"AdvancedStamina\", function(client, offset)\n    local char = client:getChar()\n    if not char then return end\n    local modifiers = {\n        regeneration = 1.0,\n        drain = 1.0\n    }\n    -- Constitution bonus\n    local con = char:getAttrib(\"con\", 0)\n    modifiers.regeneration = modifiers.regeneration + (con * 0.1)\n    modifiers.drain = modifiers.drain - (con * 0.05)\n    -- Faction bonuses\n    local faction = char:getFaction()\n    if faction == \"athlete\" then\n        modifiers.regeneration = modifiers.regeneration + 0.3\n        modifiers.drain = modifiers.drain - 0.2\n    elseif faction == \"elderly\" then\n        modifiers.regeneration = modifiers.regeneration - 0.2\n        modifiers.drain = modifiers.drain + 0.3\n    end\n    -- Equipment bonuses\n    local items = char:getInv()\n    for _, item in pairs(items) do\n        if item.uniqueID == \"stamina_boost\" then\n            modifiers.regeneration = modifiers.regeneration + 0.5\n        elseif item.uniqueID == \"heavy_armor\" then\n            modifiers.drain = modifiers.drain + 0.3\n        end\n    end\n    -- Apply modifiers\n    if offset &gt; 0 then\n        return offset * modifiers.regeneration\n    else\n        return offset * modifiers.drain\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#canoutfitchangemodel","title":"CanOutfitChangeModel","text":"<p>Purpose</p> <p>Called to check if an outfit can change model</p> <p>When Called</p> <p>When attempting to change a player's model via outfit</p> <p>Parameters</p> <ul> <li><code>self</code> (Item): The outfit item</li> </ul> <p>Returns</p> <ul> <li>boolean - True to allow, false to deny</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Always allow\nhook.Add(\"CanOutfitChangeModel\", \"MyAddon\", function(self)\n    return true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction restrictions\nhook.Add(\"CanOutfitChangeModel\", \"OutfitModelCheck\", function(self)\n    local client = self.player\n    if not client then return false end\n    local char = client:getChar()\n    if not char then return false end\n    local allowedFactions = self.allowedFactions\n    if allowedFactions and not table.HasValue(allowedFactions, char:getFaction()) then\n        return false\n    end\n    return true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex outfit model system\nhook.Add(\"CanOutfitChangeModel\", \"AdvancedOutfitModel\", function(self)\n    local client = self.player\n    if not client then return false end\n    local char = client:getChar()\n    if not char then return false end\n    -- Check faction restrictions\n    local allowedFactions = self.allowedFactions\n    if allowedFactions and not table.HasValue(allowedFactions, char:getFaction()) then\n        if SERVER then\n            client:ChatPrint(\"Your faction cannot wear this outfit\")\n        end\n        return false\n    end\n    -- Check level requirements\n    local requiredLevel = self.requiredLevel or 0\n    local charLevel = char:getData(\"level\", 1)\n    if charLevel &lt; requiredLevel then\n        if SERVER then\n            client:ChatPrint(\"You need to be level \" .. requiredLevel .. \" to wear this outfit\")\n        end\n        return false\n    end\n    return true\nend)\n</code></pre></p>"},{"location":"hooks/shared/#commandadded","title":"CommandAdded","text":"<p>Purpose</p> <p>Called when a command is added</p> <p>When Called</p> <p>When a new command is registered to the framework</p> <p>Parameters</p> <ul> <li><code>command</code> (string): The command name</li> <li><code>data</code> (table): The command data and properties</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log command additions\nhook.Add(\"CommandAdded\", \"MyAddon\", function(command, data)\n    print(\"Command added: \" .. command)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track registered commands\nhook.Add(\"CommandAdded\", \"CommandTracking\", function(command, data)\n    lia.commandList = lia.commandList or {}\n    table.insert(lia.commandList, command)\n    print(\"Command \" .. command .. \" registered\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex command registration tracking\nhook.Add(\"CommandAdded\", \"AdvancedCommandTracking\", function(command, data)\n    -- Track command registration\n    lia.commandList = lia.commandList or {}\n    table.insert(lia.commandList, {\n        name = command,\n        data = data,\n        registeredAt = os.time()\n    })\n    -- Log command details\n    print(string.format(\"Command registered: %s (Admin: %s, Syntax: %s)\",\n        command,\n        tostring(data.adminOnly or false),\n        data.syntax or \"N/A\"))\nend)\n</code></pre></p>"},{"location":"hooks/shared/#domoduleincludes","title":"DoModuleIncludes","text":"<p>Purpose</p> <p>Called when doing module includes</p> <p>When Called</p> <p>When a module is being loaded and files are being included</p> <p>Parameters</p> <ul> <li><code>path</code> (string): The path being included</li> <li><code>MODULE</code> (table): The module table</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log module includes\nhook.Add(\"DoModuleIncludes\", \"MyAddon\", function(path, MODULE)\n    print(\"Including: \" .. path)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track module load times\nhook.Add(\"DoModuleIncludes\", \"ModuleLoadTime\", function(path, MODULE)\n    local startTime = SysTime()\n    timer.Simple(0, function()\n        local loadTime = SysTime() - startTime\n        print(\"Loaded \" .. path .. \" in \" .. loadTime .. \"s\")\n    end)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex module loading system\nhook.Add(\"DoModuleIncludes\", \"AdvancedModuleLoading\", function(path, MODULE)\n    local startTime = SysTime()\n    -- Log module loading\n    print(\"Loading module: \" .. (MODULE.name or \"Unknown\") .. \" from \" .. path)\n    -- Track dependencies\n    local dependencies = MODULE.dependencies or {}\n    for _, dep in ipairs(dependencies) do\n        print(\"  Dependency: \" .. dep)\n    end\n    -- Measure load time\n    timer.Simple(0, function()\n        local loadTime = SysTime() - startTime\n        print(\"Loaded \" .. (MODULE.name or \"Unknown\") .. \" in \" .. loadTime .. \"s\")\n        -- Store load statistics\n        lia.moduleLoadTimes = lia.moduleLoadTimes or {}\n        lia.moduleLoadTimes[MODULE.name or path] = loadTime\n    end)\nend)\n</code></pre></p>"},{"location":"hooks/shared/#getdisplayeddescription","title":"GetDisplayedDescription","text":"<p>Purpose</p> <p>Called to get displayed description</p> <p>When Called</p> <p>When showing a player's description</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player being described</li> <li><code>description</code> (string): The current description</li> </ul> <p>Returns</p> <ul> <li>string - The modified description</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return unchanged\nhook.Add(\"GetDisplayedDescription\", \"MyAddon\", function(ply, description)\n    return description\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add faction prefix\nhook.Add(\"GetDisplayedDescription\", \"FactionDescPrefix\", function(ply, description)\n    local char = ply:getChar()\n    if char then\n        local faction = char:getFaction()\n        return \"[\" .. faction .. \"] \" .. description\n    end\n    return description\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex description formatting\nhook.Add(\"GetDisplayedDescription\", \"AdvancedDescDisplay\", function(ply, description)\n    local char = ply:getChar()\n    if not char then return description end\n    -- Add faction and rank\n    local faction = char:getFaction()\n    local rank = char:getData(\"rank\", 0)\n    local rankName = char:getData(\"rankName\", \"Recruit\")\n    local prefix = string.format(\"[%s - %s] \", faction, rankName)\n    -- Add status indicators\n    if char:getData(\"injured\", false) then\n        prefix = prefix .. \"[INJURED] \"\n    end\n    if char:getData(\"wanted\", false) then\n        prefix = prefix .. \"[WANTED] \"\n    end\n    return prefix .. description\nend)\n</code></pre></p>"},{"location":"hooks/shared/#getdisplayedname","title":"GetDisplayedName","text":"<p>Purpose</p> <p>Called to get displayed name in chat</p> <p>When Called</p> <p>When showing a player's name in chat</p> <p>Parameters</p> <ul> <li><code>speaker</code> (Player): The player speaking</li> <li><code>chatType</code> (string): The chat type</li> </ul> <p>Returns</p> <ul> <li>string - The displayed name</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return character name\nhook.Add(\"GetDisplayedName\", \"MyAddon\", function(speaker, chatType)\n    local char = speaker:getChar()\n    return char and char:getName() or speaker:Name()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Chat type-specific names\nhook.Add(\"GetDisplayedName\", \"ChatTypeNames\", function(speaker, chatType)\n    local char = speaker:getChar()\n    if not char then return speaker:Name() end\n    if chatType == \"ooc\" then\n        return speaker:Name()\n    else\n        return char:getName()\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex name display system\nhook.Add(\"GetDisplayedName\", \"AdvancedNameDisplay\", function(speaker, chatType)\n    local char = speaker:getChar()\n    if not char then return speaker:Name() end\n    -- OOC shows Steam name\n    if chatType == \"ooc\" then\n        return speaker:Name()\n    end\n    -- IC shows character name with title\n    local name = char:getName()\n    local faction = char:getFaction()\n    -- Add faction title\n    if faction == \"police\" then\n        local rank = char:getData(\"rankName\", \"Officer\")\n        name = rank .. \" \" .. name\n    elseif faction == \"medic\" then\n        name = \"Dr. \" .. name\n    end\n    -- Add status indicators\n    if speaker:IsAdmin() then\n        name = \"[ADMIN] \" .. name\n    end\n    return name\nend)\n</code></pre></p>"},{"location":"hooks/shared/#getdoorinfo","title":"GetDoorInfo","text":"<p>Purpose</p> <p>Called to get door information</p> <p>When Called</p> <p>When retrieving door data</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The door entity</li> <li><code>doorData</code> (table): The door data table</li> <li><code>doorInfo</code> (table): The door info table</li> </ul> <p>Returns</p> <ul> <li>table - The modified door info</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return unchanged\nhook.Add(\"GetDoorInfo\", \"MyAddon\", function(entity, doorData, doorInfo)\n    return doorInfo\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add custom door info\nhook.Add(\"GetDoorInfo\", \"CustomDoorInfo\", function(entity, doorData, doorInfo)\n    doorInfo.customField = \"Custom Value\"\n    doorInfo.price = entity:getNetVar(\"price\", 0)\n    return doorInfo\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex door info system\nhook.Add(\"GetDoorInfo\", \"AdvancedDoorInfo\", function(entity, doorData, doorInfo)\n    -- Add basic info\n    doorInfo.price = entity:getNetVar(\"price\", 0)\n    doorInfo.title = entity:getNetVar(\"title\", \"Door\")\n    doorInfo.owner = entity:getNetVar(\"owner\")\n    doorInfo.locked = entity:getNetVar(\"locked\", false)\n    -- Add owner name\n    if doorInfo.owner then\n        local ownerChar = lia.char.loaded[doorInfo.owner]\n        if ownerChar then\n            doorInfo.ownerName = ownerChar:getName()\n        end\n    end\n    -- Add faction restrictions\n    local allowedFactions = entity:getNetVar(\"allowedFactions\", {})\n    if #allowedFactions &gt; 0 then\n        doorInfo.factionRestricted = true\n        doorInfo.allowedFactions = allowedFactions\n    end\n    return doorInfo\nend)\n</code></pre></p>"},{"location":"hooks/shared/#getmodelgender","title":"GetModelGender","text":"<p>Purpose</p> <p>Called to get model gender</p> <p>When Called</p> <p>When determining a model's gender</p> <p>Parameters</p> <ul> <li><code>model</code> (string): The model path</li> </ul> <p>Returns</p> <ul> <li>string - \"male\" or \"female\"</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default gender\nhook.Add(\"GetModelGender\", \"MyAddon\", function(model)\n    return \"male\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check model path\nhook.Add(\"GetModelGender\", \"ModelGenderCheck\", function(model)\n    if string.find(model, \"female\") then\n        return \"female\"\n    end\n    return \"male\"\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex gender detection\nhook.Add(\"GetModelGender\", \"AdvancedGenderDetection\", function(model)\n    -- Check for female keywords\n    local femaleKeywords = {\"female\", \"woman\", \"girl\", \"alyx\"}\n    for _, keyword in ipairs(femaleKeywords) do\n        if string.find(string.lower(model), keyword) then\n            return \"female\"\n        end\n    end\n    -- Check specific models\n    local femaleModels = {\n        [\"models/player/alyx.mdl\"] = true,\n        [\"models/player/mossman.mdl\"] = true\n    }\n    if femaleModels[model] then\n        return \"female\"\n    end\n    return \"male\"\nend)\n</code></pre></p>"},{"location":"hooks/shared/#initializedconfig","title":"InitializedConfig","text":"<p>Purpose</p> <p>Called when configuration is initialized</p> <p>When Called</p> <p>When the configuration system has finished loading</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log config initialization\nhook.Add(\"InitializedConfig\", \"MyAddon\", function()\n    print(\"Configuration initialized\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set up custom config values\nhook.Add(\"InitializedConfig\", \"CustomConfig\", function()\n    lia.config.add(\"myAddonEnabled\", true, \"Enable My Addon\")\n    lia.config.add(\"myAddonValue\", 100, \"My Addon Value\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex configuration initialization\nhook.Add(\"InitializedConfig\", \"AdvancedConfigInit\", function()\n    -- Add custom configuration options\n    local configOptions = {\n        {key = \"myAddonEnabled\", default = true, description = \"Enable My Addon\", type = \"boolean\"},\n        {key = \"myAddonValue\", default = 100, description = \"My Addon Value\", type = \"number\"},\n        {key = \"myAddonString\", default = \"default\", description = \"My Addon String\", type = \"string\"},\n        {key = \"myAddonColor\", default = Color(255, 255, 255), description = \"My Addon Color\", type = \"color\"}\n    }\n    for _, option in ipairs(configOptions) do\n        lia.config.add(option.key, option.default, option.description)\n    end\n    -- Load saved configuration\n    local savedConfig = lia.data.get(\"myAddonConfig\", {})\n    for key, value in pairs(savedConfig) do\n        lia.config.set(key, value)\n    end\n    -- Set up configuration callbacks\n    lia.config.addCallback(\"myAddonEnabled\", function(value)\n        print(\"My Addon enabled: \" .. tostring(value))\n    end)\n    print(\"Configuration system initialized with \" .. #configOptions .. \" options\")\nend)\n</code></pre></p>"},{"location":"hooks/shared/#initializeditems","title":"InitializedItems","text":"<p>Purpose</p> <p>Called when items are initialized</p> <p>When Called</p> <p>When the item system has finished loading</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item initialization\nhook.Add(\"InitializedItems\", \"MyAddon\", function()\n    print(\"Items initialized\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register custom items\nhook.Add(\"InitializedItems\", \"CustomItems\", function()\n    lia.item.register(\"my_custom_item\", {\n        name = \"My Custom Item\",\n        model = \"models/props_junk/cardboard_box004a.mdl\",\n        description = \"A custom item\"\n    })\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item initialization system\nhook.Add(\"InitializedItems\", \"AdvancedItemInit\", function()\n    -- Register custom item categories\n    local categories = {\n        \"weapons\",\n        \"medical\",\n        \"food\",\n        \"tools\",\n        \"misc\"\n    }\n    for _, category in ipairs(categories) do\n        lia.item.addCategory(category)\n    end\n    -- Register custom items\n    local customItems = {\n        {\n            uniqueID = \"my_weapon\",\n            name = \"My Weapon\",\n            model = \"models/weapons/w_pistol.mdl\",\n            description = \"A custom weapon\",\n            category = \"weapons\",\n            weight = 2,\n            price = 100\n        },\n        {\n            uniqueID = \"my_medkit\",\n            name = \"My Medkit\",\n            model = \"models/items/medkit.mdl\",\n            description = \"A custom medkit\",\n            category = \"medical\",\n            weight = 1,\n            price = 50\n        }\n    }\n    for _, itemData in ipairs(customItems) do\n        lia.item.register(itemData.uniqueID, itemData)\n    end\n    -- Set up item callbacks\n    lia.item.addCallback(\"my_weapon\", \"onUse\", function(item, client)\n        client:ChatPrint(\"Used custom weapon!\")\n    end)\n    print(\"Item system initialized with \" .. #customItems .. \" custom items\")\nend)\n</code></pre></p>"},{"location":"hooks/shared/#initializedmodules","title":"InitializedModules","text":"<p>Purpose</p> <p>Called when modules are initialized</p> <p>When Called</p> <p>When the module system has finished loading</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log module initialization\nhook.Add(\"InitializedModules\", \"MyAddon\", function()\n    print(\"Modules initialized\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register custom modules\nhook.Add(\"InitializedModules\", \"CustomModules\", function()\n    lia.module.register(\"my_module\", {\n        name = \"My Module\",\n        description = \"A custom module\",\n        author = \"Me\",\n        version = \"1.0.0\"\n    })\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex module initialization system\nhook.Add(\"InitializedModules\", \"AdvancedModuleInit\", function()\n    -- Register custom modules\n    local modules = {\n        {\n            uniqueID = \"my_module\",\n            name = \"My Module\",\n            description = \"A custom module\",\n            author = \"Me\",\n            version = \"1.0.0\",\n            dependencies = {\"base\"}\n        },\n        {\n            uniqueID = \"my_other_module\",\n            name = \"My Other Module\",\n            description = \"Another custom module\",\n            author = \"Me\",\n            version = \"1.0.0\",\n            dependencies = {\"my_module\"}\n        }\n    }\n    for _, moduleData in ipairs(modules) do\n        lia.module.register(moduleData.uniqueID, moduleData)\n    end\n    -- Set up module callbacks\n    lia.module.addCallback(\"my_module\", \"onLoad\", function()\n        print(\"My module loaded!\")\n    end)\n    lia.module.addCallback(\"my_module\", \"onUnload\", function()\n        print(\"My module unloaded!\")\n    end)\n    -- Load module configurations\n    local moduleConfigs = lia.data.get(\"moduleConfigs\", {})\n    for moduleID, config in pairs(moduleConfigs) do\n        lia.module.setConfig(moduleID, config)\n    end\n    print(\"Module system initialized with \" .. #modules .. \" custom modules\")\nend)\n</code></pre></p>"},{"location":"hooks/shared/#initializedschema","title":"InitializedSchema","text":"<p>Purpose</p> <p>Called when schema is initialized</p> <p>When Called</p> <p>When the schema system has finished loading</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log schema initialization\nhook.Add(\"InitializedSchema\", \"MyAddon\", function()\n    print(\"Schema initialized\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set up custom schema data\nhook.Add(\"InitializedSchema\", \"CustomSchema\", function()\n    lia.schema.set(\"myAddonVersion\", \"1.0.0\")\n    lia.schema.set(\"myAddonEnabled\", true)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex schema initialization system\nhook.Add(\"InitializedSchema\", \"AdvancedSchemaInit\", function()\n    -- Set up custom schema data\n    local schemaData = {\n        version = \"1.0.0\",\n        name = \"My Custom Schema\",\n        description = \"A custom schema for my addon\",\n        author = \"Me\",\n        enabled = true,\n        settings = {\n            maxPlayers = 32,\n            respawnTime = 5,\n            roundTime = 600\n        }\n    }\n    for key, value in pairs(schemaData) do\n        lia.schema.set(key, value)\n    end\n    -- Set up schema callbacks\n    lia.schema.addCallback(\"onLoad\", function()\n        print(\"Schema loaded!\")\n    end)\n    lia.schema.addCallback(\"onUnload\", function()\n        print(\"Schema unloaded!\")\n    end)\n    -- Load saved schema settings\n    local savedSettings = lia.data.get(\"schemaSettings\", {})\n    for key, value in pairs(savedSettings) do\n        lia.schema.set(key, value)\n    end\n    print(\"Schema system initialized with custom data\")\nend)\n</code></pre></p>"},{"location":"hooks/shared/#inventorydatachanged","title":"InventoryDataChanged","text":"<p>Purpose</p> <p>Called when inventory data changes</p> <p>When Called</p> <p>When an inventory's data is modified</p> <p>Parameters</p> <ul> <li><code>instance</code> (Inventory): The inventory instance</li> <li><code>key</code> (string): The data key that changed</li> <li><code>oldValue</code> (any): The old value</li> <li><code>value</code> (any): The new value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log data changes\nhook.Add(\"InventoryDataChanged\", \"MyAddon\", function(instance, key, oldValue, value)\n    print(\"Inventory data changed: \" .. key .. \" = \" .. tostring(value))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track specific data changes\nhook.Add(\"InventoryDataChanged\", \"TrackInventoryChanges\", function(instance, key, oldValue, value)\n    if key == \"weight\" then\n        print(\"Inventory weight changed from \" .. oldValue .. \" to \" .. value)\n    elseif key == \"maxWeight\" then\n        print(\"Max weight changed from \" .. oldValue .. \" to \" .. value)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory data tracking\nhook.Add(\"InventoryDataChanged\", \"AdvancedInventoryTracking\", function(instance, key, oldValue, value)\n    if SERVER then\n        -- Log to database\n        lia.db.query(\"INSERT INTO inventory_logs (timestamp, invid, key, oldvalue, newvalue) VALUES (?, ?, ?, ?, ?)\",\n            os.time(), instance:getID(), key, tostring(oldValue), tostring(value))\n    end\n    -- Track weight changes\n    if key == \"weight\" then\n        local maxWeight = instance:getData(\"maxWeight\", 100)\n        local weightPercent = (value / maxWeight) * 100\n        if weightPercent &gt;= 90 then\n            if CLIENT then\n                LocalPlayer():ChatPrint(\"Warning: Inventory is almost full!\")\n            end\n        end\n    end\n    -- Notify owner of changes\n    if SERVER then\n        local owner = instance:getOwner()\n        if IsValid(owner) then\n            owner:ChatPrint(\"Inventory \" .. key .. \" changed to \" .. tostring(value))\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#inventoryinitialized","title":"InventoryInitialized","text":"<p>Purpose</p> <p>Called when an inventory is initialized</p> <p>When Called</p> <p>When an inventory is first created and set up</p> <p>Parameters</p> <ul> <li><code>instance</code> (Inventory): The inventory being initialized</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log inventory initialization\nhook.Add(\"InventoryInitialized\", \"MyAddon\", function(instance)\n    print(\"Inventory initialized: \" .. instance:getID())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set default inventory data\nhook.Add(\"InventoryInitialized\", \"SetDefaultInventoryData\", function(instance)\n    instance:setData(\"weight\", 0)\n    instance:setData(\"maxWeight\", 100)\n    instance:setData(\"created\", os.time())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory initialization\nhook.Add(\"InventoryInitialized\", \"AdvancedInventoryInit\", function(instance)\n    -- Set default data\n    instance:setData(\"weight\", 0)\n    instance:setData(\"maxWeight\", 100)\n    instance:setData(\"created\", os.time())\n    instance:setData(\"lastAccessed\", os.time())\n    if SERVER then\n        -- Log to database\n        lia.db.query(\"INSERT INTO inventory_logs (timestamp, invid, action) VALUES (?, ?, ?)\",\n            os.time(), instance:getID(), \"initialized\")\n        -- Set up owner-specific settings\n        local owner = instance:getOwner()\n        if IsValid(owner) then\n            local char = owner:getChar()\n            if char then\n                -- Adjust max weight based on faction\n                local faction = char:getFaction()\n                if faction == \"police\" then\n                    instance:setData(\"maxWeight\", 150)\n                elseif faction == \"medic\" then\n                    instance:setData(\"maxWeight\", 120)\n                end\n                -- Add starting items\n                if instance:getData(\"isNew\", true) then\n                    local startingItems = {\"item_bandage\", \"item_water\"}\n                    for _, itemID in ipairs(startingItems) do\n                        local item = lia.item.instance(itemID)\n                        if item then\n                            instance:add(item)\n                        end\n                    end\n                    instance:setData(\"isNew\", false)\n                end\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#inventoryitemdatachanged","title":"InventoryItemDataChanged","text":"<p>Purpose</p> <p>Called when an item's data changes in an inventory</p> <p>When Called</p> <p>When an item's data is modified while in an inventory</p> <p>Parameters</p> <ul> <li><code>item</code> (Item): The item whose data changed</li> <li><code>key</code> (string): The data key that changed</li> <li><code>oldValue</code> (any): The old value</li> <li><code>newValue</code> (any): The new value</li> <li><code>inventory</code> (Inventory): The inventory containing the item</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item data changes\nhook.Add(\"InventoryItemDataChanged\", \"MyAddon\", function(item, key, oldValue, newValue, inventory)\n    print(\"Item data changed: \" .. key .. \" = \" .. tostring(newValue))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track durability changes\nhook.Add(\"InventoryItemDataChanged\", \"TrackDurability\", function(item, key, oldValue, newValue, inventory)\n    if key == \"durability\" then\n        if newValue &lt;= 0 then\n            print(\"Item \" .. item.name .. \" is broken!\")\n        elseif newValue &lt;= 20 then\n            print(\"Item \" .. item.name .. \" is almost broken!\")\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item data tracking\nhook.Add(\"InventoryItemDataChanged\", \"AdvancedItemDataTracking\", function(item, key, oldValue, newValue, inventory)\n    if SERVER then\n        -- Log to database\n        lia.db.query(\"INSERT INTO item_data_logs (timestamp, itemid, key, oldvalue, newvalue) VALUES (?, ?, ?, ?, ?)\",\n            os.time(), item:getID(), key, tostring(oldValue), tostring(newValue))\n        -- Handle durability changes\n        if key == \"durability\" then\n            if newValue &lt;= 0 then\n                -- Item is broken\n                local owner = inventory:getOwner()\n                if IsValid(owner) then\n                    owner:ChatPrint(item.name .. \" is broken!\")\n                end\n                -- Remove item if it's broken\n                timer.Simple(1, function()\n                    if IsValid(item) then\n                        item:remove()\n                    end\n                end)\n            elseif newValue &lt;= 20 then\n                -- Item is almost broken\n                local owner = inventory:getOwner()\n                if IsValid(owner) then\n                    owner:ChatPrint(\"Warning: \" .. item.name .. \" is almost broken!\")\n                end\n            end\n        end\n        -- Handle quality changes\n        if key == \"quality\" then\n            local owner = inventory:getOwner()\n            if IsValid(owner) then\n                owner:ChatPrint(item.name .. \" quality changed to \" .. newValue)\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#ischarfakerecognized","title":"IsCharFakeRecognized","text":"<p>Purpose</p> <p>Called to check if a character is fake recognized</p> <p>When Called</p> <p>When checking if a character appears recognized but isn't truly</p> <p>Parameters</p> <ul> <li><code>self</code> (Character): The character checking recognition</li> <li><code>id</code> (number): The character ID being checked</li> </ul> <p>Returns</p> <ul> <li>boolean - True if fake recognized, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Always return false\nhook.Add(\"IsCharFakeRecognized\", \"MyAddon\", function(self, id)\n    return false\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check fake recognition list\nhook.Add(\"IsCharFakeRecognized\", \"FakeRecognitionCheck\", function(self, id)\n    local fakeRecognized = self:getData(\"fakeRecognized\", {})\n    return table.HasValue(fakeRecognized, id)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex fake recognition system\nhook.Add(\"IsCharFakeRecognized\", \"AdvancedFakeRecognition\", function(self, id)\n    local fakeRecognized = self:getData(\"fakeRecognized\", {})\n    -- Check if in fake recognition list\n    if table.HasValue(fakeRecognized, id) then\n        -- Check if fake recognition has expired\n        local fakeRecognitionTime = self:getData(\"fakeRecognitionTime_\" .. id, 0)\n        if os.time() - fakeRecognitionTime &lt; 3600 then -- 1 hour\n            return true\n        else\n            -- Remove expired fake recognition\n            table.RemoveByValue(fakeRecognized, id)\n            self:setData(\"fakeRecognized\", fakeRecognized)\n        end\n    end\n    return false\nend)\n</code></pre></p>"},{"location":"hooks/shared/#ischarrecognized","title":"IsCharRecognized","text":"<p>Purpose</p> <p>Called to check if a character is recognized</p> <p>When Called</p> <p>When checking if one character recognizes another</p> <p>Parameters</p> <ul> <li><code>self</code> (Character): The character checking recognition</li> <li><code>id</code> (number): The character ID being checked</li> </ul> <p>Returns</p> <ul> <li>boolean - True if recognized, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check recognition list\nhook.Add(\"IsCharRecognized\", \"MyAddon\", function(self, id)\n    local recognized = self:getData(\"recognized\", {})\n    return table.HasValue(recognized, id)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check recognition with faction bonus\nhook.Add(\"IsCharRecognized\", \"FactionRecognition\", function(self, id)\n    local recognized = self:getData(\"recognized\", {})\n    if table.HasValue(recognized, id) then\n        return true\n    end\n    -- Same faction members recognize each other\n    local targetChar = lia.char.loaded[id]\n    if targetChar and targetChar:getFaction() == self:getFaction() then\n        return true\n    end\n    return false\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex recognition system\nhook.Add(\"IsCharRecognized\", \"AdvancedRecognition\", function(self, id)\n    local recognized = self:getData(\"recognized\", {})\n    if table.HasValue(recognized, id) then\n        return true\n    end\n    local targetChar = lia.char.loaded[id]\n    if not targetChar then return false end\n    -- Same faction members recognize each other\n    if targetChar:getFaction() == self:getFaction() then\n        return true\n    end\n    -- Check if in same group/party\n    local myGroup = self:getData(\"group\")\n    local targetGroup = targetChar:getData(\"group\")\n    if myGroup and targetGroup and myGroup == targetGroup then\n        return true\n    end\n    -- Check proximity-based recognition\n    local myPlayer = self:getPlayer()\n    local targetPlayer = targetChar:getPlayer()\n    if IsValid(myPlayer) and IsValid(targetPlayer) then\n        local distance = myPlayer:GetPos():Distance(targetPlayer:GetPos())\n        if distance &lt; 100 then -- Very close range\n            return true\n        end\n    end\n    return false\nend)\n</code></pre></p>"},{"location":"hooks/shared/#isrecognizedchattype","title":"IsRecognizedChatType","text":"<p>Purpose</p> <p>Called to check if a chat type requires recognition</p> <p>When Called</p> <p>When determining if players need to be recognized to see names in chat</p> <p>Parameters</p> <ul> <li><code>chatType</code> (string): The chat type being checked</li> </ul> <p>Returns</p> <ul> <li>boolean - True if recognition is required, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Only IC chat requires recognition\nhook.Add(\"IsRecognizedChatType\", \"MyAddon\", function(chatType)\n    return chatType == \"ic\"\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Multiple chat types require recognition\nhook.Add(\"IsRecognizedChatType\", \"RecognizedChatTypes\", function(chatType)\n    local recognizedTypes = {\"ic\", \"w\", \"y\"}\n    return table.HasValue(recognizedTypes, chatType)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex recognition requirements\nhook.Add(\"IsRecognizedChatType\", \"AdvancedChatRecognition\", function(chatType)\n    -- OOC and admin chats never require recognition\n    local noRecognitionTypes = {\"ooc\", \"looc\", \"admin\"}\n    if table.HasValue(noRecognitionTypes, chatType) then\n        return false\n    end\n    -- IC and whisper chats require recognition\n    local recognitionTypes = {\"ic\", \"w\", \"y\", \"me\", \"it\"}\n    if table.HasValue(recognitionTypes, chatType) then\n        return true\n    end\n    -- Radio and faction chats don't require recognition\n    if chatType == \"radio\" or chatType == \"faction\" then\n        return false\n    end\n    -- Default to requiring recognition\n    return true\nend)\n</code></pre></p>"},{"location":"hooks/shared/#isvalid","title":"IsValid","text":"<p>Purpose</p> <p>Called to validate an entity</p> <p>When Called</p> <p>When checking if an entity reference is valid</p> <p>Returns</p> <ul> <li>boolean - True if valid, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic validation\nhook.Add(\"IsValid\", \"MyAddon\", function()\n    return true\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check entity state\nhook.Add(\"IsValid\", \"EntityStateCheck\", function()\n    -- This hook is typically not used directly\n    -- IsValid() is a built-in GMod function\n    return true\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex validation\nhook.Add(\"IsValid\", \"AdvancedValidation\", function()\n    -- This hook is typically not used directly\n    -- IsValid() is a built-in GMod function\n    -- Custom validation logic would go here\n    return true\nend)\n</code></pre></p>"},{"location":"hooks/shared/#itemdatachanged","title":"ItemDataChanged","text":"<p>Purpose</p> <p>Called when an item's data changes</p> <p>When Called</p> <p>When an item's data is modified</p> <p>Parameters</p> <ul> <li><code>item</code> (Item): The item whose data changed</li> <li><code>key</code> (string): The data key that changed</li> <li><code>oldValue</code> (any): The old value</li> <li><code>newValue</code> (any): The new value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item data changes\nhook.Add(\"ItemDataChanged\", \"MyAddon\", function(item, key, oldValue, newValue)\n    print(\"Item data changed: \" .. key .. \" = \" .. tostring(newValue))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track durability changes\nhook.Add(\"ItemDataChanged\", \"TrackItemDurability\", function(item, key, oldValue, newValue)\n    if key == \"durability\" then\n        if newValue &lt;= 0 then\n            print(\"Item \" .. item.name .. \" is broken!\")\n        elseif newValue &lt;= 20 then\n            print(\"Item \" .. item.name .. \" is almost broken!\")\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item data tracking\nhook.Add(\"ItemDataChanged\", \"AdvancedItemDataTracking\", function(item, key, oldValue, newValue)\n    if SERVER then\n        -- Log to database\n        lia.db.query(\"INSERT INTO item_data_logs (timestamp, itemid, key, oldvalue, newvalue) VALUES (?, ?, ?, ?, ?)\",\n            os.time(), item:getID(), key, tostring(oldValue), tostring(newValue))\n        -- Handle durability changes\n        if key == \"durability\" then\n            if newValue &lt;= 0 then\n                -- Item is broken\n                local owner = item:getOwner()\n                if IsValid(owner) then\n                    owner:ChatPrint(item.name .. \" is broken!\")\n                end\n                -- Remove item\n                timer.Simple(1, function()\n                    if IsValid(item) then\n                        item:remove()\n                    end\n                end)\n            elseif newValue &lt;= 20 then\n                -- Item is almost broken\n                local owner = item:getOwner()\n                if IsValid(owner) then\n                    owner:ChatPrint(\"Warning: \" .. item.name .. \" is almost broken!\")\n                end\n            end\n        end\n        -- Handle quality changes\n        if key == \"quality\" then\n            local owner = item:getOwner()\n            if IsValid(owner) then\n                owner:ChatPrint(item.name .. \" quality changed to \" .. newValue)\n            end\n        end\n        -- Handle quantity changes\n        if key == \"quantity\" then\n            if newValue &lt;= 0 then\n                item:remove()\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#itemdefaultfunctions","title":"ItemDefaultFunctions","text":"<p>Purpose</p> <p>Called to get default functions for an item</p> <p>When Called</p> <p>When building the default interaction functions for an item</p> <p>Parameters</p> <ul> <li><code>item</code> (Item): The item to get functions for</li> </ul> <p>Returns</p> <ul> <li>table - Table of default functions</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return basic functions\nhook.Add(\"ItemDefaultFunctions\", \"MyAddon\", function(item)\n    return {\n        use = {name = \"Use\", icon = \"icon16/accept.png\"},\n        drop = {name = \"Drop\", icon = \"icon16/bin.png\"}\n    }\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional functions\nhook.Add(\"ItemDefaultFunctions\", \"ConditionalItemFunctions\", function(item)\n    local functions = {\n        use = {name = \"Use\", icon = \"icon16/accept.png\"},\n        drop = {name = \"Drop\", icon = \"icon16/bin.png\"}\n    }\n    if not item:getData(\"equipped\", false) then\n        functions.equip = {name = \"Equip\", icon = \"icon16/add.png\"}\n    else\n        functions.unequip = {name = \"Unequip\", icon = \"icon16/delete.png\"}\n    end\n    return functions\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex function system\nhook.Add(\"ItemDefaultFunctions\", \"AdvancedItemFunctions\", function(item)\n    local functions = {}\n    -- Always add use function\n    functions.use = {name = \"Use\", icon = \"icon16/accept.png\"}\n    -- Add drop if not equipped\n    if not item:getData(\"equipped\", false) then\n        functions.drop = {name = \"Drop\", icon = \"icon16/bin.png\"}\n    end\n    -- Add equip/unequip\n    if item.equipable then\n        if item:getData(\"equipped\", false) then\n            functions.unequip = {name = \"Unequip\", icon = \"icon16/delete.png\"}\n        else\n            functions.equip = {name = \"Equip\", icon = \"icon16/add.png\"}\n        end\n    end\n    -- Add examine\n    functions.examine = {name = \"Examine\", icon = \"icon16/magnifier.png\"}\n    -- Add repair if damaged\n    local durability = item:getData(\"durability\")\n    if durability and durability &lt; 100 then\n        functions.repair = {name = \"Repair\", icon = \"icon16/wrench.png\"}\n    end\n    return functions\nend)\n</code></pre></p>"},{"location":"hooks/shared/#iteminitialized","title":"ItemInitialized","text":"<p>Purpose</p> <p>Called when an item is initialized</p> <p>When Called</p> <p>When an item is first created and set up</p> <p>Parameters</p> <ul> <li><code>item</code> (Item): The item being initialized</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item initialization\nhook.Add(\"ItemInitialized\", \"MyAddon\", function(item)\n    print(\"Item initialized: \" .. item.name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set default item data\nhook.Add(\"ItemInitialized\", \"SetDefaultItemData\", function(item)\n    if not item:getData(\"durability\") then\n        item:setData(\"durability\", 100)\n    end\n    if not item:getData(\"quality\") then\n        item:setData(\"quality\", \"common\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item initialization\nhook.Add(\"ItemInitialized\", \"AdvancedItemInit\", function(item)\n    -- Set default data\n    if not item:getData(\"durability\") then\n        item:setData(\"durability\", 100)\n    end\n    if not item:getData(\"quality\") then\n        item:setData(\"quality\", \"common\")\n    end\n    if not item:getData(\"created\") then\n        item:setData(\"created\", os.time())\n    end\n    if SERVER then\n        -- Log to database\n        lia.db.query(\"INSERT INTO item_logs (timestamp, itemid, action) VALUES (?, ?, ?)\",\n            os.time(), item:getID(), \"initialized\")\n        -- Set up item-specific data\n        if item.category == \"weapon\" then\n            item:setData(\"ammo\", item.maxAmmo or 30)\n        elseif item.category == \"armor\" then\n            item:setData(\"defense\", item.baseDefense or 10)\n        end\n        -- Add to item registry\n        lia.itemRegistry = lia.itemRegistry or {}\n        lia.itemRegistry[item:getID()] = item\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#itemquantitychanged","title":"ItemQuantityChanged","text":"<p>Purpose</p> <p>Called when an item's quantity changes</p> <p>When Called</p> <p>When the stack size of an item is modified</p> <p>Parameters</p> <ul> <li><code>item</code> (Item): The item whose quantity changed</li> <li><code>oldValue</code> (number): The old quantity</li> <li><code>quantity</code> (number): The new quantity</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log quantity changes\nhook.Add(\"ItemQuantityChanged\", \"MyAddon\", function(item, oldValue, quantity)\n    print(item.name .. \" quantity changed from \" .. oldValue .. \" to \" .. quantity)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Remove item if quantity is zero\nhook.Add(\"ItemQuantityChanged\", \"RemoveEmptyItems\", function(item, oldValue, quantity)\n    if quantity &lt;= 0 then\n        item:remove()\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex quantity management\nhook.Add(\"ItemQuantityChanged\", \"AdvancedQuantityManagement\", function(item, oldValue, quantity)\n    if SERVER then\n        -- Log to database\n        lia.db.query(\"INSERT INTO item_quantity_logs (timestamp, itemid, oldquantity, newquantity) VALUES (?, ?, ?, ?)\",\n            os.time(), item:getID(), oldValue, quantity)\n        -- Remove item if quantity is zero or negative\n        if quantity &lt;= 0 then\n            local owner = item:getOwner()\n            if IsValid(owner) then\n                owner:ChatPrint(item.name .. \" has been depleted\")\n            end\n            item:remove()\n            return\n        end\n        -- Notify owner of quantity change\n        local owner = item:getOwner()\n        if IsValid(owner) then\n            local change = quantity - oldValue\n            if change &gt; 0 then\n                owner:ChatPrint(\"+\" .. change .. \" \" .. item.name)\n            else\n                owner:ChatPrint(change .. \" \" .. item.name)\n            end\n        end\n        -- Check for achievements\n        if quantity &gt;= 100 then\n            local owner = item:getOwner()\n            if IsValid(owner) then\n                local char = owner:getChar()\n                if char and not char:getData(\"achievement_hoarder_\" .. item.uniqueID, false) then\n                    char:setData(\"achievement_hoarder_\" .. item.uniqueID, true)\n                    owner:ChatPrint(\"Achievement unlocked: Hoarder of \" .. item.name)\n                end\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#lilialoaded","title":"LiliaLoaded","text":"<p>Purpose</p> <p>Called when Lilia framework is fully loaded</p> <p>When Called</p> <p>After all Lilia systems are initialized</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log framework load\nhook.Add(\"LiliaLoaded\", \"MyAddon\", function()\nprint(\"Lilia framework loaded\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize addon systems\nhook.Add(\"LiliaLoaded\", \"InitializeAddon\", function()\nMyAddon.Initialize()\nprint(\"MyAddon initialized\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex framework initialization\nhook.Add(\"LiliaLoaded\", \"AdvancedFrameworkInit\", function()\n    -- Initialize custom systems\n    MyAddon.Initialize()\n    -- Register custom chat commands\n    lia.command.add(\"mycmd\", {\n        description = \"My custom command\",\n        onRun = function(client, arguments)\n            client:ChatPrint(\"Command executed!\")\n        end\n    })\n    -- Register custom items\n    lia.item.register(\"my_item\", {\n        name = \"My Item\",\n        desc = \"A custom item\",\n        model = \"models/props_lab/box01a.mdl\"\n    })\n    print(\"MyAddon fully initialized with Lilia\")\nend)\n</code></pre></p>"},{"location":"hooks/shared/#netvarchanged","title":"NetVarChanged","text":"<p>Purpose</p> <p>Called when a network variable changes</p> <p>When Called</p> <p>When an entity's netvar is modified</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The entity whose netvar changed</li> <li><code>key</code> (string): The netvar key</li> <li><code>oldValue</code> (any): The old value</li> <li><code>value</code> (any): The new value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log netvar changes\nhook.Add(\"NetVarChanged\", \"MyAddon\", function(entity, key, oldValue, value)\nprint(\"NetVar changed: \" .. key .. \" = \" .. tostring(value))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track specific netvars\nhook.Add(\"NetVarChanged\", \"TrackNetvars\", function(entity, key, oldValue, value)\n    if key == \"health\" then\n        print(\"Health changed from \" .. oldValue .. \" to \" .. value)\n    elseif key == \"armor\" then\n        print(\"Armor changed from \" .. oldValue .. \" to \" .. value)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex netvar tracking system\nhook.Add(\"NetVarChanged\", \"AdvancedNetvarTracking\", function(entity, key, oldValue, value)\n    if not IsValid(entity) then return end\n    -- Log to console\n    print(string.format(\"NetVar changed on %s: %s = %s (was %s)\",\n        tostring(entity), key, tostring(value), tostring(oldValue)))\n    -- Handle specific netvars\n    if key == \"health\" and entity:IsPlayer() then\n        if value &lt; oldValue then\n            -- Player took damage\n            local damage = oldValue - value\n            print(entity:Name() .. \" took \" .. damage .. \" damage\")\n        elseif value &gt; oldValue then\n            -- Player healed\n            local healing = value - oldValue\n            print(entity:Name() .. \" healed \" .. healing .. \" HP\")\n        end\n    end\n    -- Trigger custom events\n    hook.Run(\"CustomNetVarChanged_\" .. key, entity, oldValue, value)\nend)\n</code></pre></p>"},{"location":"hooks/shared/#onitemregistered","title":"OnItemRegistered","text":"<p>Purpose</p> <p>Called when an item is registered</p> <p>When Called</p> <p>When a new item is added to the item system</p> <p>Parameters</p> <ul> <li><code>ITEM</code> (table): The item table being registered</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log item registration\nhook.Add(\"OnItemRegistered\", \"MyAddon\", function(ITEM)\nprint(\"Item registered: \" .. ITEM.name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track registered items\nhook.Add(\"OnItemRegistered\", \"TrackItems\", function(ITEM)\nMyAddon.registeredItems = MyAddon.registeredItems or {}\nMyAddon.registeredItems[ITEM.uniqueID] = {\nname = ITEM.name,\nmodel = ITEM.model,\nregistered = os.time()\n}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item registration handling\nhook.Add(\"OnItemRegistered\", \"AdvancedItemRegistration\", function(ITEM)\n    -- Log item registration\n    lia.log.write(\"item_registered\", {\n        uniqueID = ITEM.uniqueID,\n        name = ITEM.name,\n        model = ITEM.model,\n        timestamp = os.time()\n    })\n    -- Validate item data\n    if not ITEM.uniqueID or not ITEM.name then\n        print(\"Warning: Invalid item data for \" .. tostring(ITEM.uniqueID))\n    end\n    -- Add custom properties\n    ITEM.customProperty = \"MyAddonValue\"\n    -- Register item in custom system\n    MyAddon.itemSystem:RegisterItem(ITEM)\n    -- Notify clients if server\n    if SERVER then\n        net.Start(\"liaItemRegistered\")\n        net.WriteString(ITEM.uniqueID)\n        net.Broadcast()\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#onloaded","title":"OnLoaded","text":"<p>Purpose</p> <p>Called when the framework has finished loading</p> <p>When Called</p> <p>After all framework components have been initialized</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log framework loaded\nhook.Add(\"OnLoaded\", \"MyAddon\", function()\nprint(\"Lilia framework has finished loading\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize addon after framework loads\nhook.Add(\"OnLoaded\", \"InitMyAddon\", function()\n    if SERVER then\n        -- Server-side initialization\n        print(\"Server addon initialized\")\n    else\n        -- Client-side initialization\n        print(\"Client addon initialized\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex post-load initialization\nhook.Add(\"OnLoaded\", \"AdvancedInit\", function()\n    if SERVER then\n        -- Load saved data\n        lia.data.get(\"addonData\", {}, function(data)\n            MyAddon.data = data\n            print(\"Addon data loaded\")\n        end)\n        -- Register custom network strings\n        util.AddNetworkString(\"MyAddonSync\")\n    else\n        -- Setup client UI\n        hook.Add(\"HUDPaint\", \"MyAddonHUD\", function()\n            -- Draw custom HUD elements\n        end)\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#onprivilegeregistered","title":"OnPrivilegeRegistered","text":"<p>Purpose</p> <p>Called when a new privilege is registered</p> <p>When Called</p> <p>When a privilege is added to the system</p> <p>Parameters</p> <ul> <li><code>privilege</code> (string): The privilege identifier</li> <li><code>name</code> (string): The display name of the privilege</li> <li><code>access</code> (string): The access level required</li> <li><code>category</code> (string): The category the privilege belongs to</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log privilege registration\nhook.Add(\"OnPrivilegeRegistered\", \"MyAddon\", function(privilege, name, access, category)\nprint(\"Privilege registered: \" .. name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track privileges\nhook.Add(\"OnPrivilegeRegistered\", \"TrackPrivileges\", function(privilege, name, access, category)\nMyAddon.privileges = MyAddon.privileges or {}\nMyAddon.privileges[privilege] = {\nname = name,\naccess = access,\ncategory = category\n}\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex privilege management\nhook.Add(\"OnPrivilegeRegistered\", \"AdvancedPrivilegeManagement\", function(privilege, name, access, category)\n    -- Store privilege data\n    if SERVER then\n        lia.data.get(\"privileges\", {}, function(data)\n            data[privilege] = {\n                name = name,\n                access = access,\n                category = category,\n                registered = os.time()\n            }\n            lia.data.set(\"privileges\", data)\n        end)\n    end\n    -- Notify admins\n    for _, ply in ipairs(player.GetAll()) do\n        if ply:IsAdmin() then\n            ply:ChatPrint(\"New privilege registered: \" .. name)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#onprivilegeunregistered","title":"OnPrivilegeUnregistered","text":"<p>Purpose</p> <p>Called when a privilege is unregistered</p> <p>When Called</p> <p>When a privilege is removed from the system</p> <p>Parameters</p> <ul> <li><code>privilege</code> (string): The privilege identifier</li> <li><code>name</code> (string): The display name of the privilege</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log privilege removal\nhook.Add(\"OnPrivilegeUnregistered\", \"MyAddon\", function(privilege, name)\nprint(\"Privilege unregistered: \" .. name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up privilege data\nhook.Add(\"OnPrivilegeUnregistered\", \"CleanupPrivilege\", function(privilege, name)\n    if MyAddon.privileges and MyAddon.privileges[privilege] then\n        MyAddon.privileges[privilege] = nil\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex privilege cleanup\nhook.Add(\"OnPrivilegeUnregistered\", \"AdvancedPrivilegeCleanup\", function(privilege, name)\n    -- Remove privilege data\n    if SERVER then\n        lia.data.get(\"privileges\", {}, function(data)\n            data[privilege] = nil\n            lia.data.set(\"privileges\", data)\n        end)\n    end\n    -- Revoke privilege from all players\n    for _, ply in ipairs(player.GetAll()) do\n        local char = ply:getChar()\n        if char and char:hasPrivilege(privilege) then\n            char:revokePrivilege(privilege)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#optionadded","title":"OptionAdded","text":"<p>Purpose</p> <p>Called when an option is added to the options system</p> <p>When Called</p> <p>When a new option is registered</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The option key that was added</li> <li><code>option</code> (table): The option data table containing all option properties</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log when options are added\nhook.Add(\"OptionAdded\", \"MyAddon\", function(key, option)\nprint(\"Option \" .. key .. \" was added\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track added options\nhook.Add(\"OptionAdded\", \"TrackOptions\", function(key, option)\nMyAddon.addedOptions = MyAddon.addedOptions or {}\nMyAddon.addedOptions[key] = option\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced option handling\nhook.Add(\"OptionAdded\", \"AdvancedOptionHandler\", function(key, option)\n    -- Log option addition\n    lia.log.write(\"option_added\", {\n        key = key,\n        type = option.type,\n        default = option.default,\n        timestamp = os.time()\n    })\n    -- Handle special option types\n    if option.type == \"boolean\" then\n        -- Initialize boolean option handling\n        MyAddon.booleanOptions = MyAddon.booleanOptions or {}\n        MyAddon.booleanOptions[key] = option.default or false\n    elseif option.type == \"number\" then\n        -- Initialize number option handling\n        MyAddon.numberOptions = MyAddon.numberOptions or {}\n        MyAddon.numberOptions[key] = {\n            value = option.default or 0,\n            min = option.min or 0,\n            max = option.max or 100\n        }\n    end\n    -- Notify clients if needed\n    if SERVER and option.shouldNetwork then\n        net.Start(\"liaOptionAdded\")\n        net.WriteString(key)\n        net.WriteTable(option)\n        net.Broadcast()\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#optionchanged","title":"OptionChanged","text":"<p>Purpose</p> <p>Called when a configuration option is changed</p> <p>When Called</p> <p>When a configuration value is modified</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The option key that was changed</li> <li><code>old</code> (any): The old value</li> <li><code>value</code> (any): The new value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log option changes\nhook.Add(\"OptionChanged\", \"MyAddon\", function(key, old, value)\nprint(\"Option \" .. key .. \" changed from \" .. tostring(old) .. \" to \" .. tostring(value))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track option changes\nhook.Add(\"OptionChanged\", \"TrackOptions\", function(key, old, value)\nMyAddon.optionHistory = MyAddon.optionHistory or {}\ntable.insert(MyAddon.optionHistory, {\nkey = key,\nold = old,\nnew = value,\ntime = os.time()\n})\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex option change handling\nhook.Add(\"OptionChanged\", \"AdvancedOptionChange\", function(key, old, value)\n    -- Log option change\n    lia.log.write(\"option_changed\", {\n        key = key,\n        old = tostring(old),\n        new = tostring(value),\n        timestamp = os.time()\n    })\n    -- Handle specific option changes\n    if key == \"serverName\" then\n        SetHostName(value)\n    elseif key == \"maxPlayers\" then\n        game.SetMaxPlayers(value)\n    end\n    -- Notify clients of important changes\n    if SERVER then\n        net.Start(\"liaOptionChanged\")\n        net.WriteString(key)\n        net.WriteType(value)\n        net.Broadcast()\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#overridefactiondesc","title":"OverrideFactionDesc","text":"<p>Purpose</p> <p>Called to override a faction's description</p> <p>When Called</p> <p>When a faction description needs to be modified</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): The faction's unique ID</li> <li><code>description</code> (string): The current description</li> </ul> <p>Returns</p> <ul> <li>string - The overridden description (or nil to use default)</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add prefix to description\nhook.Add(\"OverrideFactionDesc\", \"MyAddon\", function(uniqueID, description)\nreturn \"[FACTION] \" .. description\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Customize specific faction descriptions\nhook.Add(\"OverrideFactionDesc\", \"CustomFactionDesc\", function(uniqueID, description)\n    if uniqueID == \"citizen\" then\n        return \"Citizens are the backbone of society.\"\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic faction description\nhook.Add(\"OverrideFactionDesc\", \"DynamicFactionDesc\", function(uniqueID, description)\n    local faction = lia.faction.indices[uniqueID]\n    if not faction then return end\n    -- Add player count to description\n    local count = 0\n    for _, ply in ipairs(player.GetAll()) do\n        local char = ply:getChar()\n        if char and char:getFaction() == faction.index then\n            count = count + 1\n        end\n    end\n    return description .. \"\\n\\nCurrent Members: \" .. count\nend)\n</code></pre></p>"},{"location":"hooks/shared/#overridefactionmodels","title":"OverrideFactionModels","text":"<p>Purpose</p> <p>Called to override a faction's models</p> <p>When Called</p> <p>When a faction's available models need to be modified</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): The faction's unique ID</li> <li><code>models</code> (table): The current models table</li> </ul> <p>Returns</p> <ul> <li>table - The overridden models table (or nil to use default)</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a model to faction\nhook.Add(\"OverrideFactionModels\", \"MyAddon\", function(uniqueID, models)\n    if uniqueID == \"citizen\" then\n        table.insert(models, \"models/player/group01/male_01.mdl\")\n        return models\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Replace faction models\nhook.Add(\"OverrideFactionModels\", \"ReplaceFactionModels\", function(uniqueID, models)\n    if uniqueID == \"police\" then\n        return {\n            \"models/player/police.mdl\",\n            \"models/player/police_fem.mdl\"\n        }\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic faction models based on rank\nhook.Add(\"OverrideFactionModels\", \"DynamicFactionModels\", function(uniqueID, models)\n    local faction = lia.faction.indices[uniqueID]\n    if not faction then return end\n    -- Load models from configuration\n    local customModels = lia.config.get(\"faction_models_\" .. uniqueID, {})\n    if table.Count(customModels) &gt; 0 then\n        return customModels\n    end\n    -- Filter models based on gender setting\n    if lia.config.get(\"faction_gender_filter\", false) then\n        local filtered = {}\n        for _, model in ipairs(models) do\n            if not string.find(model, \"_fem\") then\n                table.insert(filtered, model)\n            end\n        end\n        return filtered\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#overridefactionname","title":"OverrideFactionName","text":"<p>Purpose</p> <p>Called to override a faction's name</p> <p>When Called</p> <p>When a faction name needs to be modified</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): The faction's unique ID</li> <li><code>name</code> (string): The current name</li> </ul> <p>Returns</p> <ul> <li>string - The overridden name (or nil to use default)</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add prefix to name\nhook.Add(\"OverrideFactionName\", \"MyAddon\", function(uniqueID, name)\nreturn \"[\" .. uniqueID:upper() .. \"] \" .. name\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Localize faction names\nhook.Add(\"OverrideFactionName\", \"LocalizeFactionNames\", function(uniqueID, name)\nlocal localizedNames = {\ncitizen = \"Citoyen\",\npolice = \"Police\",\nmedic = \"M\u00e9decin\"\n}\nreturn localizedNames[uniqueID] or name\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic faction naming\nhook.Add(\"OverrideFactionName\", \"DynamicFactionName\", function(uniqueID, name)\n    local faction = lia.faction.indices[uniqueID]\n    if not faction then return end\n    -- Add member count to name\n    local count = 0\n    for _, ply in ipairs(player.GetAll()) do\n        local char = ply:getChar()\n        if char and char:getFaction() == faction.index then\n            count = count + 1\n        end\n    end\n    -- Add status indicator\n    local status = \"\"\n    if lia.config.get(\"faction_recruiting_\" .. uniqueID, false) then\n        status = \" [RECRUITING]\"\n    end\n    return name .. \" (\" .. count .. \")\" .. status\nend)\n</code></pre></p>"},{"location":"hooks/shared/#playerstaminagained","title":"PlayerStaminaGained","text":"<p>Purpose</p> <p>Called when player gains stamina</p> <p>When Called</p> <p>When a player's stamina increases</p> <p>Parameters</p> <ul> <li><code>self</code> (Player): The player gaining stamina</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log stamina gain\nhook.Add(\"PlayerStaminaGained\", \"MyAddon\", function(self)\nprint(self:Name() .. \" gained stamina\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track stamina gains\nhook.Add(\"PlayerStaminaGained\", \"TrackStaminaGains\", function(self)\n    if SERVER then\n        local char = self:getChar()\n        if char then\n            local staminaGains = char:getData(\"staminaGains\", 0)\n            char:setData(\"staminaGains\", staminaGains + 1)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex stamina gain tracking\nhook.Add(\"PlayerStaminaGained\", \"AdvancedStaminaGain\", function(self)\n    if SERVER then\n        local char = self:getChar()\n        if not char then return end\n        -- Track stamina gains\n        local staminaGains = char:getData(\"staminaGains\", 0)\n        char:setData(\"staminaGains\", staminaGains + 1)\n        -- Check for achievements\n        if staminaGains + 1 &gt;= 1000 then\n            if not char:getData(\"achievement_marathonRunner\", false) then\n                char:setData(\"achievement_marathonRunner\", true)\n                self:ChatPrint(\"Achievement unlocked: Marathon Runner!\")\n            end\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#playerstaminalost","title":"PlayerStaminaLost","text":"<p>Purpose</p> <p>Called when player loses stamina</p> <p>When Called</p> <p>When a player's stamina decreases</p> <p>Parameters</p> <ul> <li><code>self</code> (Player): The player losing stamina</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log stamina loss\nhook.Add(\"PlayerStaminaLost\", \"MyAddon\", function(self)\nprint(self:Name() .. \" lost stamina\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Track stamina loss\nhook.Add(\"PlayerStaminaLost\", \"TrackStaminaLoss\", function(self)\n    if SERVER then\n        local char = self:getChar()\n        if char then\n            local staminaLoss = char:getData(\"staminaLoss\", 0)\n            char:setData(\"staminaLoss\", staminaLoss + 1)\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex stamina loss tracking\nhook.Add(\"PlayerStaminaLost\", \"AdvancedStaminaLoss\", function(self)\n    if SERVER then\n        local char = self:getChar()\n        if not char then return end\n        -- Track stamina loss\n        local staminaLoss = char:getData(\"staminaLoss\", 0)\n        char:setData(\"staminaLoss\", staminaLoss + 1)\n        -- Check if stamina is critically low\n        local stamina = self:getNetVar(\"stamina\", 100)\n        if stamina &lt;= 10 then\n            self:ChatPrint(\"Warning: Stamina is critically low!\")\n        end\n    end\nend)\n</code></pre></p>"},{"location":"hooks/shared/#prelilialoaded","title":"PreLiliaLoaded","text":"<p>Purpose</p> <p>Called before Lilia framework is loaded</p> <p>When Called</p> <p>Before Lilia systems are initialized</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log pre-load\nhook.Add(\"PreLiliaLoaded\", \"MyAddon\", function()\nprint(\"Lilia is about to load\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize addon systems\nhook.Add(\"PreLiliaLoaded\", \"InitializeAddon\", function()\nMyAddon.PreInitialize()\nprint(\"Addon pre-initialized\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex pre-load initialization\nhook.Add(\"PreLiliaLoaded\", \"AdvancedPreLoadInit\", function()\n    -- Initialize custom systems\n    MyAddon.PreInitialize()\n    -- Set up configuration\n    MyAddon.config = MyAddon.config or {}\n    MyAddon.config.enabled = true\n    MyAddon.config.debug = false\n    -- Register custom hooks\n    hook.Add(\"PlayerInitialSpawn\", \"MyAddonSpawn\", MyAddon.OnPlayerSpawn)\n    print(\"Advanced pre-load initialization completed\")\nend)\n</code></pre></p>"},{"location":"hooks/shared/#calcstaminachange","title":"calcStaminaChange","text":"<p>Purpose</p> <p>Called to calculate stamina change</p> <p>When Called</p> <p>When calculating how much stamina should change</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose stamina is changing</li> </ul> <p>Returns</p> <ul> <li>number - The stamina change amount</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Return default stamina change\nhook.Add(\"calcStaminaChange\", \"MyAddon\", function(client)\nreturn 1\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Calculate based on character attributes\nhook.Add(\"calcStaminaChange\", \"AttributeStamina\", function(client)\n    local char = client:getChar()\n    if not char then return 1 end\n    local endurance = char:getAttrib(\"end\", 0)\n    return 1 + (endurance * 0.1)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex stamina calculation system\nhook.Add(\"calcStaminaChange\", \"AdvancedStaminaCalc\", function(client)\n    local char = client:getChar()\n    if not char then return 1 end\n    -- Base stamina change\n    local baseChange = 1\n    -- Attribute bonus\n    local endurance = char:getAttrib(\"end\", 0)\n    local strength = char:getAttrib(\"str\", 0)\n    local attrBonus = (endurance * 0.1) + (strength * 0.05)\n    -- Faction bonus\n    local faction = char:getFaction()\n    local factionBonuses = {\n        [\"athlete\"] = 0.5,\n        [\"soldier\"] = 0.3,\n        [\"citizen\"] = 0.0\n    }\n    local factionBonus = factionBonuses[faction] or 0.0\n    -- Item bonuses\n    local itemBonus = 0\n    local inv = char:getInv()\n    if inv then\n        for _, item in pairs(inv:getItems()) do\n            if item:getData(\"equipped\", false) then\n                itemBonus = itemBonus + (item.staminaBonus or 0)\n            end\n        end\n    end\n    -- Status effects\n    local statusPenalty = 0\n    if char:getData(\"injured\", false) then\n        statusPenalty = statusPenalty - 0.5\n    end\n    if char:getData(\"exhausted\", false) then\n        statusPenalty = statusPenalty - 0.3\n    end\n    -- Calculate final change\n    local finalChange = baseChange + attrBonus + factionBonus + itemBonus + statusPenalty\n    return math.max(0.1, finalChange)\nend)\n</code></pre></p>"},{"location":"hooks/shared/#getdata","title":"getData","text":"<p>Purpose</p> <p>Called to get persistent data</p> <p>When Called</p> <p>When retrieving stored data</p> <p>Parameters</p> <ul> <li><code>default</code> (any): The default value if data doesn't exist</li> </ul> <p>Returns</p> <ul> <li>any - The retrieved data or default value</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get data with default\nhook.Add(\"getData\", \"MyAddon\", function(default)\nreturn default\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get data with validation\nhook.Add(\"getData\", \"ValidateData\", function(default)\n    local data = lia.data.get(\"someKey\", default)\n    if type(data) ~= type(default) then\n        return default\n    end\n    return data\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data retrieval system\nhook.Add(\"getData\", \"AdvancedDataGet\", function(default)\n    -- Try to get from cache first\n    local cache = lia.data.cache or {}\n    local key = \"someKey\"\n    if cache[key] and cache[key].expiry &gt; CurTime() then\n        return cache[key].value\n    end\n    -- Get from storage\n    local data = lia.data.get(key, default)\n    -- Validate data type\n    if type(data) ~= type(default) then\n        print(\"Warning: Data type mismatch, using default\")\n        data = default\n    end\n    -- Cache the result\n    cache[key] = {\n        value = data,\n        expiry = CurTime() + 60\n    }\n    lia.data.cache = cache\n    return data\nend)\n</code></pre></p>"},{"location":"libraries/lia.admin/","title":"Administrator Library","text":"<p>Comprehensive user group and privilege management system for the Lilia framework.</p> <p>Overview</p> <p>The administrator library provides comprehensive functionality for managing user groups, privileges, and administrative permissions in the Lilia framework. It handles the creation, modification, and deletion of user groups with inheritance-based privilege systems. The library operates on both server and client sides, with the server managing privilege storage and validation while the client provides user interface elements for administrative management. It includes integration with CAMI (Comprehensive Administration Management Interface) for compatibility with other administrative systems. The library ensures proper privilege inheritance, automatic privilege registration for tools and properties, and comprehensive logging of administrative actions. It supports both console-based and GUI-based administrative command execution with proper permission checking and validation.</p> <p>Setting Superadmin: To set yourself as superadmin in the console, use: plysetgroup [NAME] superadmin The system has three default user groups with inheritance levels: user (level 1), admin (level 2), and superadmin (level 3). Superadmin automatically has all privileges and cannot be restricted by any permission checks.</p>"},{"location":"libraries/lia.admin/#applypunishment","title":"applyPunishment","text":"<p>Purpose</p> <p>Applies punishment actions (kick/ban) to a player based on infraction details</p> <p>When Called</p> <p>When an administrative action needs to be taken against a player for rule violations</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to punish</li> <li><code>infraction</code> (string): Description of the infraction committed</li> <li><code>kick</code> (boolean): Whether to kick the player</li> <li><code>ban</code> (boolean): Whether to ban the player</li> <li><code>time</code> (number): Ban duration in minutes (0 = permanent)</li> <li><code>kickKey</code> (string): Language key for kick message (optional)</li> <li><code>banKey</code> (string): Language key for ban message (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Kick a player for cheating\nlia.administrator.applyPunishment(player, \"Cheating detected\", true, false)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Ban a player for 60 minutes with custom message\nlia.administrator.applyPunishment(player, \"RDM\", false, true, 60, \"kickedForRDM\", \"bannedForRDM\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Apply punishment based on infraction severity\nlocal punishments = {\n[\"RDM\"] = {kick = true, ban = false, time = 0},\n[\"Cheating\"] = {kick = true, ban = true, time = 0},\n[\"Spam\"] = {kick = true, ban = false, time = 30}\n}\nlocal punishment = punishments[infractionType]\nif punishment then\n    lia.administrator.applyPunishment(player, infractionType, punishment.kick, punishment.ban, punishment.time)\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#hasaccess","title":"hasAccess","text":"<p>Purpose</p> <p>Checks if a player or user group has access to a specific privilege</p> <p>When Called</p> <p>When permission validation is needed before allowing access to features or commands</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player|string): Player entity or user group name to check</li> <li><code>privilege</code> (string): The privilege identifier to check access for</li> </ul> <p>Returns</p> <ul> <li>boolean - true if access is granted, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player can use admin tools\nif lia.administrator.hasAccess(player, \"tool_adminstick\") then\n    -- Grant access to admin stick\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check access for different user groups\nlocal groups = {\"admin\", \"moderator\", \"user\"}\nfor _, group in ipairs(groups) do\n    if lia.administrator.hasAccess(group, \"manageUsergroups\") then\n        print(group .. \" can manage user groups\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex permission checking with fallback\nlocal function checkMultiplePrivileges(player, privileges)\n    for _, privilege in ipairs(privileges) do\n        if lia.administrator.hasAccess(player, privilege) then\n            return true, privilege\n        end\n    end\n    return false, nil\nend\nlocal hasAccess, grantedPrivilege = checkMultiplePrivileges(player, {\"admin\", \"moderator\", \"helper\"})\n</code></pre></p>"},{"location":"libraries/lia.admin/#save","title":"save","text":"<p>Purpose</p> <p>Saves all administrator groups and privileges to the database and synchronizes with clients</p> <p>When Called</p> <p>When administrator data needs to be persisted to the database after changes</p> <p>Parameters</p> <ul> <li><code>noNetwork</code> (boolean): If true, skips network synchronization (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Save administrator data\nlia.administrator.save()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save without network sync during bulk operations\nfor i = 1, 10 do\n    lia.administrator.createGroup(\"group\" .. i, {})\nend\nlia.administrator.save(true) -- Save without network sync\nlia.administrator.save() -- Final save with sync\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch save with error handling\nlocal function safeSave(noNetwork)\n    local success, err = pcall(function()\n    lia.administrator.save(noNetwork)\nend)\nif not success then\n    lia.log.add(nil, \"adminSaveError\", err)\n    return false\nend\nreturn true\nend\nif safeSave(true) then\n    print(\"Administrator data saved successfully\")\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#registerprivilege","title":"registerPrivilege","text":"<p>Purpose</p> <p>Registers a new privilege in the administrator system with specified access requirements</p> <p>When Called</p> <p>When a new privilege needs to be added to the system for permission checking</p> <p>Parameters</p> <ul> <li><code>priv</code> (table): Privilege definition table containing:</li> <li><code>ID</code> (string): Unique identifier for the privilege</li> <li><code>Name</code> (string): Display name for the privilege (optional)</li> <li><code>MinAccess</code> (string): Minimum access level required (default: \"user\")</li> <li><code>Category</code> (string): Category for organizing privileges (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic privilege\nlia.administrator.registerPrivilege({\nID = \"accessAdminPanel\",\nName = \"Access Admin Panel\",\nMinAccess = \"admin\"\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register privilege with category\nlia.administrator.registerPrivilege({\nID = \"managePlayers\",\nName = \"Manage Players\",\nMinAccess = \"moderator\",\nCategory = \"Player Management\"\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register multiple privileges from module\nlocal modulePrivileges = {\n{ID = \"module_feature1\", Name = \"Feature 1\", MinAccess = \"user\", Category = \"Module\"},\n{ID = \"module_feature2\", Name = \"Feature 2\", MinAccess = \"admin\", Category = \"Module\"},\n{ID = \"module_feature3\", Name = \"Feature 3\", MinAccess = \"superadmin\", Category = \"Module\"}\n}\nfor _, privilege in ipairs(modulePrivileges) do\n    lia.administrator.registerPrivilege(privilege)\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#unregisterprivilege","title":"unregisterPrivilege","text":"<p>Purpose</p> <p>Removes a privilege from the administrator system and all user groups</p> <p>When Called</p> <p>When a privilege is no longer needed and should be completely removed</p> <p>Parameters</p> <ul> <li><code>id</code> (string): The privilege identifier to remove</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove a privilege\nlia.administrator.unregisterPrivilege(\"oldPrivilege\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Remove privilege with validation\nlocal privilegeToRemove = \"deprecatedFeature\"\nif lia.administrator.privileges[privilegeToRemove] then\n    lia.administrator.unregisterPrivilege(privilegeToRemove)\n    print(\"Privilege removed: \" .. privilegeToRemove)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Remove multiple privileges with cleanup\nlocal privilegesToRemove = {\"old_feature1\", \"old_feature2\", \"deprecated_tool\"}\nfor _, privilege in ipairs(privilegesToRemove) do\n    if lia.administrator.privileges[privilege] then\n        lia.administrator.unregisterPrivilege(privilege)\n        lia.log.add(nil, \"privilegeRemoved\", privilege)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#applyinheritance","title":"applyInheritance","text":"<p>Purpose</p> <p>Applies privilege inheritance from parent groups to a specific user group</p> <p>When Called</p> <p>When a user group's inheritance needs to be recalculated after changes</p> <p>Parameters</p> <ul> <li><code>groupName</code> (string): The name of the user group to apply inheritance to</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Apply inheritance to a group\nlia.administrator.applyInheritance(\"moderator\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Apply inheritance after group modification\nlia.administrator.groups[\"moderator\"]._info.inheritance = \"admin\"\nlia.administrator.applyInheritance(\"moderator\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Apply inheritance to multiple groups with validation\nlocal groupsToUpdate = {\"moderator\", \"helper\", \"vip\"}\nfor _, groupName in ipairs(groupsToUpdate) do\n    if lia.administrator.groups[groupName] then\n        lia.administrator.applyInheritance(groupName)\n        print(\"Applied inheritance to: \" .. groupName)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#load","title":"load","text":"<p>Purpose</p> <p>Loads administrator groups and privileges from the database and initializes the system</p> <p>When Called</p> <p>During server startup or when administrator data needs to be reloaded</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load administrator data\nlia.administrator.load()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load with callback handling\nlia.administrator.load()\nhook.Add(\"OnAdminSystemLoaded\", \"MyModule\", function(groups, privileges)\nprint(\"Admin system loaded with \" .. table.Count(groups) .. \" groups\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load with error handling and validation\nlocal function safeLoad()\n    local success, err = pcall(function()\n    lia.administrator.load()\nend)\nif not success then\n    lia.log.add(nil, \"adminLoadError\", err)\n    -- Fallback to default groups\n    lia.administrator.groups = {\n    user = {_info = {inheritance = \"user\", types = {}}},\n    admin = {_info = {inheritance = \"admin\", types = {\"Staff\"}}},\n    superadmin = {_info = {inheritance = \"superadmin\", types = {\"Staff\"}}}\n    }\n    return false\nend\nreturn true\nend\nif safeLoad() then\n    print(\"Administrator system loaded successfully\")\n    else\n        print(\"Failed to load administrator system, using defaults\")\n    end\n</code></pre></p>"},{"location":"libraries/lia.admin/#creategroup","title":"createGroup","text":"<p>Purpose</p> <p>Creates a new user group with specified inheritance and type information</p> <p>When Called</p> <p>When a new user group needs to be added to the administrator system</p> <p>Parameters</p> <ul> <li><code>groupName</code> (string): The name of the new user group</li> <li><code>info</code> (table): Group configuration table containing:</li> <li><code>_info</code> (table): Group metadata with inheritance and types (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a basic group\nlia.administrator.createGroup(\"moderator\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create group with inheritance\nlia.administrator.createGroup(\"helper\", {\n_info = {\ninheritance = \"user\",\ntypes = {\"Staff\"}\n}\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create multiple groups with different configurations\nlocal groupConfigs = {\n{name = \"moderator\", inherit = \"admin\", types = {\"Staff\"}},\n{name = \"helper\", inherit = \"user\", types = {\"Staff\"}},\n{name = \"vip\", inherit = \"user\", types = {\"VIP\"}}\n}\nfor _, config in ipairs(groupConfigs) do\n    lia.administrator.createGroup(config.name, {\n    _info = {\n    inheritance = config.inherit,\n    types = config.types\n    }\n    })\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#removegroup","title":"removeGroup","text":"<p>Purpose</p> <p>Removes a user group from the administrator system (cannot remove base groups)</p> <p>When Called</p> <p>When a user group is no longer needed and should be deleted</p> <p>Parameters</p> <ul> <li><code>groupName</code> (string): The name of the user group to remove</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove a group\nlia.administrator.removeGroup(\"oldGroup\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Remove group with validation\nlocal groupToRemove = \"deprecatedGroup\"\nif lia.administrator.groups[groupToRemove] and not lia.administrator.DefaultGroups[groupToRemove] then\n    lia.administrator.removeGroup(groupToRemove)\n    print(\"Group removed: \" .. groupToRemove)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Remove multiple groups with safety checks\nlocal groupsToRemove = {\"tempGroup1\", \"tempGroup2\", \"oldModerator\"}\nfor _, groupName in ipairs(groupsToRemove) do\n    if lia.administrator.groups[groupName] and not lia.administrator.DefaultGroups[groupName] then\n        lia.administrator.removeGroup(groupName)\n        lia.log.add(nil, \"groupRemoved\", groupName)\n        else\n            print(\"Cannot remove group: \" .. groupName)\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.admin/#renamegroup","title":"renameGroup","text":"<p>Purpose</p> <p>Renames an existing user group to a new name (cannot rename base groups)</p> <p>When Called</p> <p>When a user group needs to be renamed for organizational purposes</p> <p>Parameters</p> <ul> <li><code>oldName</code> (string): The current name of the user group</li> <li><code>newName</code> (string): The new name for the user group</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Rename a group\nlia.administrator.renameGroup(\"oldModerator\", \"moderator\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Rename with validation\nlocal oldGroupName = \"tempGroup\"\nlocal newGroupName = \"permanentGroup\"\nif lia.administrator.groups[oldGroupName] and not lia.administrator.groups[newGroupName] then\n    lia.administrator.renameGroup(oldGroupName, newGroupName)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch rename with error handling\nlocal renameOperations = {\n{old = \"oldHelper\", new = \"helper\"},\n{old = \"oldVIP\", new = \"vip\"},\n{old = \"tempMod\", new = \"moderator\"}\n}\nfor _, operation in ipairs(renameOperations) do\n    if lia.administrator.groups[operation.old] and not lia.administrator.groups[operation.new] then\n        lia.administrator.renameGroup(operation.old, operation.new)\n        lia.log.add(nil, \"groupRenamed\", operation.old, operation.new)\n        else\n            print(\"Cannot rename \" .. operation.old .. \" to \" .. operation.new)\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.admin/#notifyadmin","title":"notifyAdmin","text":"<p>Purpose</p> <p>Sends administrative notifications to all players with the appropriate privilege</p> <p>When Called</p> <p>When administrative notifications need to be broadcast to qualified players</p> <p>Parameters</p> <ul> <li><code>notification</code> (table): Notification data to send to players</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Notify admins about an event\nlia.administrator.notifyAdmin({\ntext = \"Player kicked for cheating\",\ntype = \"warning\"\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Notify with specific privilege requirement\nlia.administrator.notifyAdmin({\ntext = \"Suspicious activity detected\",\ntype = \"alert\",\nprivilege = \"canSeeAltingNotifications\"\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch notifications with different privilege levels\nlocal notifications = {\n{text = \"Server restart in 5 minutes\", privilege = \"admin\"},\n{text = \"New player joined\", privilege = \"moderator\"},\n{text = \"VIP player online\", privilege = \"vip\"}\n}\nfor _, notification in ipairs(notifications) do\n    lia.administrator.notifyAdmin(notification)\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#addpermission","title":"addPermission","text":"<p>Purpose</p> <p>Adds a permission to a specific user group</p> <p>When Called</p> <p>When a user group needs to be granted a new permission</p> <p>Parameters</p> <ul> <li><code>groupName</code> (string): The name of the user group</li> <li><code>permission</code> (string): The permission identifier to add</li> <li><code>silent</code> (boolean): If true, skips network synchronization (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add permission to group\nlia.administrator.addPermission(\"moderator\", \"kickPlayers\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add permission silently during bulk operations\nlia.administrator.addPermission(\"helper\", \"mutePlayers\", true)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add multiple permissions with validation\nlocal permissions = {\"kickPlayers\", \"mutePlayers\", \"banPlayers\"}\nfor _, permission in ipairs(permissions) do\n    if not lia.administrator.groups[\"moderator\"][permission] then\n        lia.administrator.addPermission(\"moderator\", permission)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#removepermission","title":"removePermission","text":"<p>Purpose</p> <p>Removes a permission from a specific user group</p> <p>When Called</p> <p>When a user group should no longer have a specific permission</p> <p>Parameters</p> <ul> <li><code>groupName</code> (string): The name of the user group</li> <li><code>permission</code> (string): The permission identifier to remove</li> <li><code>silent</code> (boolean): If true, skips network synchronization (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove permission from group\nlia.administrator.removePermission(\"moderator\", \"banPlayers\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Remove permission silently during bulk operations\nlia.administrator.removePermission(\"helper\", \"kickPlayers\", true)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Remove multiple permissions with validation\nlocal permissionsToRemove = {\"banPlayers\", \"kickPlayers\", \"mutePlayers\"}\nfor _, permission in ipairs(permissionsToRemove) do\n    if lia.administrator.groups[\"moderator\"][permission] then\n        lia.administrator.removePermission(\"moderator\", permission)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#sync","title":"sync","text":"<p>Purpose</p> <p>Synchronizes administrator data with connected clients</p> <p>When Called</p> <p>When administrator data needs to be sent to clients after changes</p> <p>Parameters</p> <ul> <li><code>c</code> (Player): Specific client to sync with (optional, syncs all if nil)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Sync with all clients\nlia.administrator.sync()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Sync with specific client\nlia.administrator.sync(player)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Sync with validation and error handling\nlocal function safeSync(client)\n    if client and not IsValid(client) then\n        lia.log.add(nil, \"syncError\", \"Invalid client\")\n        return false\n    end\n    local success, err = pcall(function()\n    lia.administrator.sync(client)\nend)\nif not success then\n    lia.log.add(nil, \"syncError\", err)\n    return false\nend\nreturn true\nend\nif safeSync(player) then\n    print(\"Administrator data synced successfully\")\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#setplayerusergroup","title":"setPlayerUsergroup","text":"<p>Purpose</p> <p>Changes a player's user group and triggers CAMI events</p> <p>When Called</p> <p>When a player's user group needs to be changed</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player whose group should be changed</li> <li><code>newGroup</code> (string): The new user group name</li> <li><code>source</code> (string): Source identifier for CAMI events (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Change player's group\nlia.administrator.setPlayerUsergroup(player, \"moderator\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Change group with source tracking\nlia.administrator.setPlayerUsergroup(player, \"admin\", \"MyModule\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch group changes with validation\nlocal groupChanges = {\n{player = player1, group = \"moderator\", source = \"promotion\"},\n{player = player2, group = \"helper\", source = \"demotion\"},\n{player = player3, group = \"vip\", source = \"donation\"}\n}\nfor _, change in ipairs(groupChanges) do\n    if IsValid(change.player) then\n        lia.administrator.setPlayerUsergroup(change.player, change.group, change.source)\n        lia.log.add(nil, \"groupChanged\", change.player:Name(), change.group)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#setsteamidusergroup","title":"setSteamIDUsergroup","text":"<p>Purpose</p> <p>Changes a Steam ID's user group and triggers CAMI events</p> <p>When Called</p> <p>When a Steam ID's user group needs to be changed (for offline players)</p> <p>Parameters</p> <ul> <li><code>steamId</code> (string): The Steam ID whose group should be changed</li> <li><code>newGroup</code> (string): The new user group name</li> <li><code>source</code> (string): Source identifier for CAMI events (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Change Steam ID's group\nlia.administrator.setSteamIDUsergroup(\"STEAM_0:1:123456789\", \"moderator\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Change group with source tracking\nlia.administrator.setSteamIDUsergroup(\"STEAM_0:1:123456789\", \"admin\", \"WebPanel\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch Steam ID group changes with validation\nlocal steamGroupChanges = {\n{steamid = \"STEAM_0:1:123456789\", group = \"moderator\", source = \"promotion\"},\n{steamid = \"STEAM_0:1:987654321\", group = \"helper\", source = \"demotion\"},\n{steamid = \"STEAM_0:1:555555555\", group = \"vip\", source = \"donation\"}\n}\nfor _, change in ipairs(steamGroupChanges) do\n    if change.steamid and change.steamid ~= \"\" then\n        lia.administrator.setSteamIDUsergroup(change.steamid, change.group, change.source)\n        lia.log.add(nil, \"steamGroupChanged\", change.steamid, change.group)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#serverexeccommand","title":"serverExecCommand","text":"<p>Purpose</p> <p>Executes administrative commands on the server with permission checking</p> <p>When Called</p> <p>When administrative commands need to be executed with proper validation</p> <p>Parameters</p> <ul> <li><code>cmd</code> (string): The command to execute</li> <li><code>victim</code> (Player|string): Target player or Steam ID</li> <li><code>dur</code> (number): Duration parameter for timed commands (optional)</li> <li><code>reason</code> (string): Reason for the command (optional)</li> <li><code>admin</code> (Player): The admin executing the command</li> </ul> <p>Returns</p> <ul> <li>boolean - true if command was executed successfully, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Kick a player\nlia.administrator.serverExecCommand(\"kick\", player, nil, \"Cheating\", admin)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Ban player with duration\nlia.administrator.serverExecCommand(\"ban\", player, 60, \"RDM\", admin)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Execute multiple commands with validation\nlocal commands = {\n{cmd = \"kick\", target = player1, reason = \"Cheating\"},\n{cmd = \"ban\", target = player2, duration = 30, reason = \"RDM\"},\n{cmd = \"mute\", target = player3, duration = 10, reason = \"Spam\"}\n}\nfor _, command in ipairs(commands) do\n    local success = lia.administrator.serverExecCommand(\n    command.cmd,\n    command.target,\n    command.duration,\n    command.reason,\n    admin\n    )\n    if success then\n        print(\"Command executed: \" .. command.cmd)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.admin/#execcommand","title":"execCommand","text":"<p>Purpose</p> <p>Executes administrative commands on the client with hook system integration and callback support</p> <p>When Called</p> <p>When administrative commands need to be executed from the client side</p> <p>Parameters</p> <ul> <li><code>cmd</code> (string): The command to execute</li> <li><code>victim</code> (Player|string): Target player or Steam ID</li> <li><code>dur</code> (number): Duration parameter for timed commands (optional)</li> <li><code>reason</code> (string): Reason for the command (optional)</li> </ul> <p>Returns</p> <ul> <li>boolean - true if command was executed successfully, false otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Kick a player\nlia.administrator.execCommand(\"kick\", player, nil, \"Cheating\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Ban player with duration\nlia.administrator.execCommand(\"ban\", player, 60, \"RDM\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Execute multiple commands with validation\nlocal commands = {\n{cmd = \"kick\", target = player1, reason = \"Cheating\"},\n{cmd = \"ban\", target = player2, duration = 30, reason = \"RDM\"},\n{cmd = \"mute\", target = player3, duration = 10, reason = \"Spam\"}\n}\nfor _, command in ipairs(commands) do\n    local success = lia.administrator.execCommand(\n    command.cmd,\n    command.target,\n    command.duration,\n    command.reason\n    )\n    if success then\n        print(\"Command sent: \" .. command.cmd)\n    end\nend\n</code></pre></p> <p>Hook Implementation Complexity: <pre><code>-- Custom admin system hook\nhook.Add(\"RunAdminSystemCommand\", \"MyAdminSystem\", function(cmd, victim, dur, reason)\nif cmd == \"kick\" then\n    MyAdminSystem:KickPlayer(victim, reason)\n    return true, function()\n    print(\"Player kicked via MyAdminSystem\")\nend\nend\nreturn false -- Don't handle other commands\nend)\n</code></pre></p>"},{"location":"libraries/lia.attributes/","title":"Attributes Library","text":"<p>Character attribute management system for the Lilia framework.</p> <p>Overview</p> <p>The attributes library provides functionality for managing character attributes in the Lilia framework. It handles loading attribute definitions from files, registering attributes in the system, and setting up attributes for characters during spawn. The library operates on both server and client sides, with the server managing attribute setup during character spawning and the client handling attribute-related UI elements. It includes automatic attribute loading from directories, localization support for attribute names and descriptions, and hooks for custom attribute behavior.</p>"},{"location":"libraries/lia.attributes/#loadfromdir","title":"loadFromDir","text":"<p>Purpose</p> <p>Loads attribute definitions from a specified directory and registers them in the attributes system</p> <p>When Called</p> <p>During gamemode initialization or when loading attribute modules</p> <p>Parameters</p> <ul> <li><code>directory</code> (string): The directory path to search for attribute files</li> </ul> <p>Returns</p> <ul> <li>None (modifies lia.attribs.list)</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load attributes from a single directory\nlia.attribs.loadFromDir(\"gamemode/attributes\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load attributes with conditional directory checking\nlocal attrDir = \"gamemode/attributes\"\nif file.Exists(attrDir, \"LUA\") then\n    lia.attribs.loadFromDir(attrDir)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load attributes from multiple directories with error handling\nlocal attributeDirs = {\"gamemode/attributes\", \"modules/attributes\", \"plugins/attributes\"}\nfor _, dir in ipairs(attributeDirs) do\n    if file.Exists(dir, \"LUA\") then\n        lia.attribs.loadFromDir(dir)\n        else\n            print(\"Warning: Attribute directory not found: \" .. dir)\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.attributes/#setup","title":"setup","text":"<p>Purpose</p> <p>Sets up attributes for a client's character by calling OnSetup hooks for each registered attribute</p> <p>When Called</p> <p>When a client spawns or when their character is created</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client whose character attributes need to be set up</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Setup attributes for a client\nlia.attribs.setup(client)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Setup attributes with validation\nif IsValid(client) and client:IsPlayer() then\n    lia.attribs.setup(client)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Setup attributes with custom logic and error handling\nhook.Add(\"PlayerSpawn\", \"SetupAttributes\", function(client)\nif not client:getChar() then return end\n    timer.Simple(0.1, function()\n    if IsValid(client) then\n        lia.attribs.setup(client)\n        print(\"Attributes set up for \" .. client:Name())\n    end\nend)\nend)\n</code></pre></p>"},{"location":"libraries/lia.bars/","title":"Bars Library","text":"<p>Dynamic progress bar creation and management system for the Lilia framework.</p> <p>Overview</p> <p>The bars library provides a comprehensive system for creating and managing dynamic progress bars in the Lilia framework. It handles the creation, rendering, and lifecycle management of various types of bars including health, armor, and custom progress indicators. The library operates primarily on the client side, providing smooth animated transitions between bar values and intelligent visibility management based on value changes and user preferences. It includes built-in health and armor bars, custom action progress displays, and a flexible system for adding custom bars with priority-based ordering. The library ensures consistent visual presentation across all bar types while providing hooks for customization and integration with other framework components.</p>"},{"location":"libraries/lia.bars/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves a bar object by its identifier from the bars list</p> <p>When Called</p> <p>When you need to access or modify an existing bar's properties</p> <p>Parameters</p> <ul> <li><code>identifier</code> (string): The unique identifier of the bar to retrieve</li> </ul> <p>Returns</p> <ul> <li>table|nil - The bar object if found, nil otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a bar by identifier\nlocal healthBar = lia.bar.get(\"health\")\nif healthBar then\n    print(\"Health bar found\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get and modify bar properties\nlocal customBar = lia.bar.get(\"custom_stamina\")\nif customBar then\n    customBar.color = Color(255, 255, 0)\n    customBar.priority = 2\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic bar management with validation\nlocal barIdentifiers = {\"health\", \"armor\", \"stamina\", \"hunger\"}\nfor _, id in ipairs(barIdentifiers) do\n    local bar = lia.bar.get(id)\n    if bar then\n        bar.lifeTime = CurTime() + 10\n        print(\"Extended lifetime for \" .. id .. \" bar\")\n        else\n            print(\"Bar \" .. id .. \" not found\")\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.bars/#add","title":"add","text":"<p>Purpose</p> <p>Adds a new progress bar to the bars system with specified properties</p> <p>When Called</p> <p>When creating custom bars or adding new progress indicators to the HUD</p> <p>Parameters</p> <ul> <li><code>getValue</code> (function): Function that returns the current value (0-1) for the bar</li> <li><code>color</code> (Color): Color of the bar fill (optional, defaults to random color)</li> <li><code>priority</code> (number): Display priority, lower numbers appear first (optional)</li> <li><code>identifier</code> (string): Unique identifier for the bar (optional)</li> </ul> <p>Returns</p> <ul> <li>number - The priority assigned to the bar</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a basic health bar\nlia.bar.add(function()\nreturn LocalPlayer():Health() / LocalPlayer():GetMaxHealth()\nend, Color(255, 0, 0), 1, \"health\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add a custom stamina bar with validation\nlia.bar.add(function()\nlocal ply = LocalPlayer()\nif not IsValid(ply) then return 0 end\n    return ply:GetNWFloat(\"stamina\", 100) / 100\nend, Color(0, 255, 0), 2, \"stamina\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic bar creation with multiple conditions\nlocal function createConditionalBar(condition, getValue, color, priority, id)\n    if condition then\n        return lia.bar.add(function()\n        local ply = LocalPlayer()\n        if not IsValid(ply) then return 0 end\n            return getValue(ply)\n        end, color, priority, id)\n    end\n    return nil\nend\ncreateConditionalBar(\ntrue,\nfunction(ply) return ply:Armor() / ply:GetMaxArmor() end,\n    Color(0, 0, 255),\n    3,\n    \"armor\"\n    )\n</code></pre></p>"},{"location":"libraries/lia.bars/#remove","title":"remove","text":"<p>Purpose</p> <p>Removes a bar from the bars system by its identifier</p> <p>When Called</p> <p>When you need to remove a specific bar from the HUD or clean up bars</p> <p>Parameters</p> <ul> <li><code>identifier</code> (string): The unique identifier of the bar to remove</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove a bar by identifier\nlia.bar.remove(\"health\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditionally remove bars\nif not player:HasPermission(\"see_health\") then\n    lia.bar.remove(\"health\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Remove multiple bars with validation\nlocal barsToRemove = {\"stamina\", \"hunger\", \"thirst\"}\nfor _, barId in ipairs(barsToRemove) do\n    local bar = lia.bar.get(barId)\n    if bar then\n        lia.bar.remove(barId)\n        print(\"Removed bar: \" .. barId)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.bars/#drawbar","title":"drawBar","text":"<p>Purpose</p> <p>Draws a single progress bar at specified coordinates with given properties</p> <p>When Called</p> <p>Internally by the bars system or when manually drawing custom bars</p> <p>Parameters</p> <ul> <li><code>x</code> (number): X coordinate for the bar position</li> <li><code>y</code> (number): Y coordinate for the bar position</li> <li><code>w</code> (number): Width of the bar</li> <li><code>h</code> (number): Height of the bar</li> <li><code>pos</code> (number): Current progress value (0-max)</li> <li><code>max</code> (number): Maximum value for the bar</li> <li><code>color</code> (Color): Color of the bar fill</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw a basic progress bar\nlia.bar.drawBar(10, 10, 200, 20, 75, 100, Color(255, 0, 0))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw a bar with calculated values\nlocal health = LocalPlayer():Health()\nlocal maxHealth = LocalPlayer():GetMaxHealth()\nlia.bar.drawBar(10, 10, 200, 20, health, maxHealth, Color(255, 0, 0))\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic bar drawing with multiple conditions\nlocal function drawCustomBar(x, y, w, h, value, maxValue, color, condition)\n    if condition and value &gt; 0 then\n        local normalizedValue = math.min(value, maxValue)\n        lia.bar.drawBar(x, y, w, h, normalizedValue, maxValue, color)\n    end\nend\ndrawCustomBar(10, 10, 200, 20, player:Health(), player:GetMaxHealth(),\nColor(255, 0, 0), player:Alive())\n</code></pre></p>"},{"location":"libraries/lia.bars/#drawaction","title":"drawAction","text":"<p>Purpose</p> <p>Draws a temporary action progress bar with text overlay for timed actions</p> <p>When Called</p> <p>When displaying progress for actions like reloading, healing, or other timed activities</p> <p>Parameters</p> <ul> <li><code>text</code> (string): Text to display above the progress bar</li> <li><code>duration</code> (number): Duration in seconds for the action to complete</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Show reload progress\nlia.bar.drawAction(\"Reloading...\", 2.5)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Show healing progress with dynamic text\nlocal healAmount = 50\nlia.bar.drawAction(\"Healing for \" .. healAmount .. \" HP\", 3.0)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Conditional action display with multiple states\nlocal function showActionProgress(actionType, duration, data)\n    local text = \"\"\n    if actionType == \"heal\" then\n        text = \"Healing for \" .. (data.amount or 25) .. \" HP\"\n        elseif actionType == \"repair\" then\n            text = \"Repairing \" .. (data.item or \"item\")\n            elseif actionType == \"craft\" then\n                text = \"Crafting \" .. (data.item or \"item\")\n            end\n            if text ~= \"\" then\n                lia.bar.drawAction(text, duration)\n            end\n        end\n        showActionProgress(\"heal\", 2.5, {amount = 75})\n</code></pre></p>"},{"location":"libraries/lia.bars/#drawall","title":"drawAll","text":"<p>Purpose</p> <p>Renders all registered bars in priority order with smooth animations and visibility management</p> <p>When Called</p> <p>Automatically called during HUDPaintBackground hook, or manually for custom rendering</p> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Manually trigger bar rendering\nlia.bar.drawAll()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom rendering with conditions\nhook.Add(\"HUDPaint\", \"CustomBarRender\", function()\nif not hook.Run(\"ShouldHideBars\") then\n    lia.bar.drawAll()\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced rendering with custom positioning and filtering\nlocal function customDrawAll()\n    if hook.Run(\"ShouldHideBars\") then return end\n        -- Custom positioning logic\n        local baseX, baseY = 10, 10\n        local barSpacing = 18\n        -- Sort bars by priority\n        table.sort(lia.bar.list, function(a, b)\n        if a.priority == b.priority then\n            return (a.order or 0) &lt; (b.order or 0)\n        end\n        return a.priority &lt; b.priority\n    end)\n    -- Draw each bar with custom logic\n    for i, bar in ipairs(lia.bar.list) do\n        if hook.Run(\"ShouldBarDraw\", bar) then\n            local y = baseY + (i - 1) * barSpacing\n            lia.bar.drawBar(baseX, y, 200, 14, bar.getValue(), 1, bar.color)\n        end\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.character/","title":"Character Library","text":"<p>Comprehensive character creation, management, and persistence system for the Lilia framework.</p> <p>Overview</p> <p>The character library provides comprehensive functionality for managing player characters in the Lilia framework. It handles character creation, loading, saving, and management across both server and client sides. The library operates character data persistence, networking synchronization, and provides hooks for character variable changes. It includes functions for character validation, database operations, inventory management, and character lifecycle management. The library ensures proper character data integrity and provides a robust system for character-based gameplay mechanics including factions, attributes, money, and custom character variables.</p>"},{"location":"libraries/lia.character/#getcharacter","title":"getCharacter","text":"<p>Purpose</p> <p>Retrieves a character by its ID, loading it if necessary</p> <p>When Called</p> <p>When a character needs to be accessed by ID, either from server or client</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The unique identifier of the character</li> <li><code>client</code> (Player): The player requesting the character (optional)</li> <li><code>callback</code> (function): Function to call when character is loaded (optional)</li> </ul> <p>Returns</p> <ul> <li>Character object if found/loaded, nil otherwise</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a character by ID\nlocal character = lia.char.getCharacter(123)\nif character then\n    print(\"Character name:\", character:getName())\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get character with callback for async loading\nlia.char.getCharacter(123, client, function(character)\nif character then\n    character:setMoney(1000)\n    print(\"Character loaded:\", character:getName())\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get multiple characters with validation and error handling\nlocal charIDs = {123, 456, 789}\nlocal loadedChars = {}\nfor _, charID in ipairs(charIDs) do\n    lia.char.getCharacter(charID, client, function(character)\n        if character then\n            loadedChars[charID] = character\n            if table.Count(loadedChars) == #charIDs then\n                print(\"All characters loaded successfully\")\n            end\n        else\n            print(\"Failed to load character:\", charID)\n        end\n    end)\nend\n</code></pre></p>"},{"location":"libraries/lia.character/#getall","title":"getAll","text":"<p>Purpose</p> <p>Retrieves all currently loaded characters from all players</p> <p>When Called</p> <p>When you need to iterate through all active characters on the server</p> <p>Returns</p> <ul> <li>Table with Player objects as keys and their Character objects as values</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all characters and count them\nlocal allChars = lia.char.getAll()\nprint(\"Total active characters:\", table.Count(allChars))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Find characters by faction\nlocal allChars = lia.char.getAll()\nlocal citizenChars = {}\nfor player, character in pairs(allChars) do\n    if character:getFaction() == \"Citizen\" then\n        citizenChars[player] = character\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Process all characters with validation and statistics\nlocal allChars = lia.char.getAll()\nlocal stats = {\ntotalChars = 0,\ntotalMoney = 0,\nfactions = {}\n}\nfor player, character in pairs(allChars) do\n    if IsValid(player) and character then\n        stats.totalChars = stats.totalChars + 1\n        stats.totalMoney = stats.totalMoney + character:getMoney()\n        local faction = character:getFaction()\n        stats.factions[faction] = (stats.factions[faction] or 0) + 1\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.character/#isloaded","title":"isLoaded","text":"<p>Purpose</p> <p>Checks if a character with the given ID is currently loaded in memory</p> <p>When Called</p> <p>Before attempting to access a character to avoid unnecessary loading</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The unique identifier of the character to check</li> </ul> <p>Returns</p> <ul> <li>Boolean - true if character is loaded, false otherwise</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if character is loaded\nif lia.char.isLoaded(123) then\n    print(\"Character 123 is loaded\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional character access\nlocal charID = 123\nif lia.char.isLoaded(charID) then\n    local character = lia.char.getCharacter(charID)\n    character:setMoney(5000)\n    else\n        print(\"Character not loaded, loading...\")\n        lia.char.getCharacter(charID, client, function(char)\n        if char then char:setMoney(5000) end\n        end)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch character loading with status checking\nlocal charIDs = {123, 456, 789}\nlocal loadedChars = {}\nlocal unloadedChars = {}\nfor _, charID in ipairs(charIDs) do\n    if lia.char.isLoaded(charID) then\n        loadedChars[charID] = lia.char.getCharacter(charID)\n        else\n            table.insert(unloadedChars, charID)\n        end\n    end\n    print(\"Loaded:\", table.Count(loadedChars), \"Unloaded:\", #unloadedChars)\n</code></pre></p>"},{"location":"libraries/lia.character/#addcharacter","title":"addCharacter","text":"<p>Purpose</p> <p>Adds a character to the loaded characters cache and triggers pending callbacks</p> <p>When Called</p> <p>When a character is loaded from database or created, to make it available in memory</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The unique identifier of the character</li> <li><code>character</code> (Character): The character object to add to cache</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a character to cache\nlocal character = lia.char.new(charData, 123, client)\nlia.char.addCharacter(123, character)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add character and handle pending requests\nlocal charID = 123\nlocal character = lia.char.new(charData, charID, client)\n-- This will trigger any pending callbacks for this character ID\nlia.char.addCharacter(charID, character)\n-- Check if there were pending requests\nif lia.char.pendingRequests[charID] then\n    print(\"Character had pending requests that were triggered\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch character loading with callback management\nlocal characters = {}\nlocal charIDs = {123, 456, 789}\nfor _, charID in ipairs(charIDs) do\n    local charData = lia.char.getCharData(charID)\n    if charData then\n        local character = lia.char.new(charData, charID, client)\n        characters[charID] = character\n        lia.char.addCharacter(charID, character)\n    end\nend\nprint(\"Loaded\", table.Count(characters), \"characters into cache\")\n</code></pre></p>"},{"location":"libraries/lia.character/#removecharacter","title":"removeCharacter","text":"<p>Purpose</p> <p>Removes a character from the loaded characters cache</p> <p>When Called</p> <p>When a character needs to be unloaded from memory (cleanup, deletion, etc.)</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The unique identifier of the character to remove</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove character from cache\nlia.char.removeCharacter(123)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Remove character with validation\nlocal charID = 123\nif lia.char.isLoaded(charID) then\n    local character = lia.char.getCharacter(charID)\n    if character then\n        character:save() -- Save before removing\n        lia.char.removeCharacter(charID)\n        print(\"Character\", charID, \"removed from cache\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch character cleanup with error handling\nlocal charIDs = {123, 456, 789}\nlocal removedCount = 0\nfor _, charID in ipairs(charIDs) do\n    if lia.char.isLoaded(charID) then\n        local character = lia.char.getCharacter(charID)\n        if character then\n            -- Perform cleanup operations\n            character:save()\n            lia.inventory.cleanUpForCharacter(character)\n            lia.char.removeCharacter(charID)\n            removedCount = removedCount + 1\n        end\n    end\nend\nprint(\"Removed\", removedCount, \"characters from cache\")\n</code></pre></p>"},{"location":"libraries/lia.character/#new","title":"new","text":"<p>Purpose</p> <p>Creates a new character object from data with proper metatable and variable initialization</p> <p>When Called</p> <p>When creating a new character instance from database data or character creation</p> <p>Parameters</p> <ul> <li><code>data</code> (table): Character data containing all character variables</li> <li><code>id</code> (number): The unique identifier for the character (optional)</li> <li><code>client</code> (Player): The player who owns this character (optional)</li> <li><code>steamID</code> (string): Steam ID of the character owner (optional, used when client is invalid)</li> </ul> <p>Returns</p> <ul> <li>Character object with proper metatable and initialized variables</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a basic character\nlocal charData = {\nname = \"John Doe\",\ndesc = \"A citizen of the city\",\nfaction = \"Citizen\",\nmodel = \"models/player/Group01/male_01.mdl\"\n}\nlocal character = lia.char.new(charData, 123, client)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create character with full data and validation\nlocal charData = {\nname = \"Jane Smith\",\ndesc = \"A skilled engineer\",\nfaction = \"Engineer\",\nmodel = \"models/player/Group01/female_01.mdl\",\nmoney = 1000,\nattribs = {strength = 5, intelligence = 8}\n}\nlocal character = lia.char.new(charData, 456, client)\nif character then\n    character:setSkin(1)\n    character:setBodygroups({[0] = 1, [1] = 2})\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create character from database with error handling\nlocal charID = 789\nlocal charData = lia.char.getCharData(charID)\nif charData then\n    -- Validate required fields\n    if not charData.name or not charData.faction then\n        print(\"Invalid character data for ID:\", charID)\n        return\n    end\n    -- Create character with fallback SteamID\n    local steamID = client and client:SteamID() or \"STEAM_0:0:0\"\n    local character = lia.char.new(charData, charID, client, steamID)\n    if character then\n        -- Initialize additional data\n        character.vars.inv = {}\n        character.vars.loginTime = os.time()\n        lia.char.addCharacter(charID, character)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.character/#hookvar","title":"hookVar","text":"<p>Purpose</p> <p>Registers a hook function for a specific character variable</p> <p>When Called</p> <p>When you need to add custom behavior when a character variable changes</p> <p>Parameters</p> <ul> <li><code>varName</code> (string): The name of the character variable to hook</li> <li><code>hookName</code> (string): The name/identifier for this hook</li> <li><code>func</code> (function): The function to call when the variable changes</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Hook a variable change\nlia.char.hookVar(\"money\", \"onMoneyChange\", function(character, oldValue, newValue)\nprint(\"Money changed from\", oldValue, \"to\", newValue)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Hook with validation and side effects\nlia.char.hookVar(\"faction\", \"onFactionChange\", function(character, oldValue, newValue)\nlocal client = character:getPlayer()\nif IsValid(client) then\n    -- Update player team\n    client:SetTeam(lia.faction.indices[newValue].index)\n    -- Notify player\n    client:notify(\"Faction changed to: \" .. newValue)\n    -- Log the change\n    lia.log.add(\"Faction change: \" .. client:Name() .. \" changed faction from \" .. oldValue .. \" to \" .. newValue)\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Multiple hooks with complex logic\nlocal hooks = {\nmoney = function(character, oldValue, newValue)\nlocal client = character:getPlayer()\nif IsValid(client) then\n    local difference = newValue - oldValue\n    if difference &gt; 0 then\n        client:notify(\"Gained $\" .. difference)\n        elseif difference &lt; 0 then\n            client:notify(\"Lost $\" .. math.abs(difference))\n        end\n        -- Update HUD if it exists\n        if client.liaHUD then\n            client.liaHUD:updateMoney(newValue)\n        end\n    end\nend,\nhealth = function(character, oldValue, newValue)\nif newValue &lt;= 0 and oldValue &gt; 0 then\n    hook.Run(\"OnCharacterDeath\", character)\n    elseif newValue &gt; 0 and oldValue &lt;= 0 then\n        hook.Run(\"OnCharacterRevive\", character)\n    end\nend\n}\nfor varName, hookFunc in pairs(hooks) do\n    lia.char.hookVar(varName, \"customHook_\" .. varName, hookFunc)\nend\n</code></pre></p>"},{"location":"libraries/lia.character/#registervar","title":"registerVar","text":"<p>Purpose</p> <p>Registers a new character variable with validation, networking, and database persistence</p> <p>When Called</p> <p>During gamemode initialization to define character variables and their behavior</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The unique identifier for the character variable</li> <li><code>data</code> (table): Configuration table containing variable properties and callbacks</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic character variable\nlia.char.registerVar(\"level\", {\nfield = \"level\",\nfieldType = \"integer\",\ndefault = 1,\nindex = 5\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register variable with validation and custom behavior\nlia.char.registerVar(\"reputation\", {\nfield = \"reputation\",\nfieldType = \"integer\",\ndefault = 0,\nindex = 6,\nonValidate = function(value, data, client)\nif not isnumber(value) or value &lt; -100 or value &gt; 100 then\n    return false, \"invalid\", \"reputation\"\nend\nreturn true\nend,\nonSet = function(character, value)\nlocal oldValue = character:getReputation()\ncharacter.vars.reputation = value\n-- Notify player of reputation change\nlocal client = character:getPlayer()\nif IsValid(client) then\n    client:notify(\"Reputation changed to: \" .. value)\nend\nhook.Run(\"OnCharVarChanged\", character, \"reputation\", oldValue, value)\nend\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register complex variable with full feature set\nlia.char.registerVar(\"skills\", {\nfield = \"skills\",\nfieldType = \"text\",\ndefault = {},\nindex = 7,\nisLocal = true,\nonValidate = function(value, data, client)\nif not istable(value) then return false, \"invalid\", \"skills\" end\n    local totalPoints = 0\n    for skillName, level in pairs(value) do\n        if not isnumber(level) or level &lt; 0 or level &gt; 100 then\n            return false, \"invalid\", \"skillLevel\"\n        end\n        totalPoints = totalPoints + level\n    end\n    local maxPoints = hook.Run(\"GetMaxSkillPoints\", client) or 500\n    if totalPoints &gt; maxPoints then\n        return false, \"tooManySkillPoints\"\n    end\n    return true\nend,\nonSet = function(character, value)\nlocal oldValue = character:getSkills()\ncharacter.vars.skills = value\n-- Recalculate derived stats\nlocal client = character:getPlayer()\nif IsValid(client) then\n    hook.Run(\"OnSkillsChanged\", character, oldValue, value)\nend\nend,\nonGet = function(character, default)\nreturn character.vars.skills or default or {}\nend,\nshouldDisplay = function()\nreturn lia.config.get(\"EnableSkills\", true)\nend\n})\n</code></pre></p>"},{"location":"libraries/lia.character/#getchardata","title":"getCharData","text":"<p>Purpose</p> <p>Retrieves character data from the database with automatic decoding</p> <p>When Called</p> <p>When you need to access character data directly from the database</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The unique identifier of the character</li> <li><code>key</code> (string): Specific data key to retrieve (optional)</li> </ul> <p>Returns</p> <ul> <li>Table of character data or specific value if key provided</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all character data\nlocal charData = lia.char.getCharData(123)\nprint(\"Character name:\", charData.name)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get specific character data\nlocal charID = 123\nlocal characterName = lia.char.getCharData(charID, \"name\")\nlocal characterMoney = lia.char.getCharData(charID, \"money\")\nif characterName then\n    print(\"Character\", characterName, \"has\", characterMoney or 0, \"money\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch character data retrieval with validation\nlocal charIDs = {123, 456, 789}\nlocal charactersData = {}\nfor _, charID in ipairs(charIDs) do\n    local charData = lia.char.getCharData(charID)\n    if charData and charData.name then\n        charactersData[charID] = {\n        name = charData.name,\n        faction = charData.faction,\n        money = charData.money or 0,\n        lastLogin = charData.lastJoinTime\n        }\n    end\nend\nprint(\"Retrieved data for\", table.Count(charactersData), \"characters\")\n</code></pre></p>"},{"location":"libraries/lia.character/#getchardataraw","title":"getCharDataRaw","text":"<p>Purpose</p> <p>Retrieves raw character data from database without automatic processing</p> <p>When Called</p> <p>When you need unprocessed character data or want to handle decoding manually</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The unique identifier of the character</li> <li><code>key</code> (string): Specific data key to retrieve (optional)</li> </ul> <p>Returns</p> <ul> <li>Raw decoded data or specific value if key provided</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get raw character data\nlocal rawData = lia.char.getCharDataRaw(123)\nprint(\"Raw data keys:\", table.GetKeys(rawData))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get specific raw data with error handling\nlocal charID = 123\nlocal rawValue = lia.char.getCharDataRaw(charID, \"customData\")\nif rawValue ~= false then\n    print(\"Custom data found:\", rawValue)\n    else\n        print(\"No custom data found for character\", charID)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Process multiple raw data entries\nlocal charID = 123\nlocal rawData = lia.char.getCharDataRaw(charID)\nlocal processedData = {}\nif rawData then\n    for key, value in pairs(rawData) do\n        -- Custom processing based on key type\n        if key:find(\"^skill_\") then\n            processedData[key] = tonumber(value) or 0\n            elseif key:find(\"^item_\") then\n                processedData[key] = istable(value) and value or {}\n                else\n                    processedData[key] = value\n                end\n            end\n        end\n        return processedData\n</code></pre></p>"},{"location":"libraries/lia.character/#getownerbyid","title":"getOwnerByID","text":"<p>Purpose</p> <p>Finds the player who owns a character with the given ID</p> <p>When Called</p> <p>When you need to find which player is using a specific character</p> <p>Parameters</p> <ul> <li><code>ID</code> (number): The unique identifier of the character</li> </ul> <p>Returns</p> <ul> <li>Player object if found, nil otherwise</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find character owner\nlocal owner = lia.char.getOwnerByID(123)\nif owner then\n    print(\"Character 123 is owned by:\", owner:Name())\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Find owner and perform action\nlocal charID = 123\nlocal owner = lia.char.getOwnerByID(charID)\nif IsValid(owner) then\n    local character = owner:getChar()\n    if character and character:getID() == charID then\n        owner:notify(\"Your character has been updated!\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch owner lookup with validation\nlocal charIDs = {123, 456, 789}\nlocal owners = {}\nfor _, charID in ipairs(charIDs) do\n    local owner = lia.char.getOwnerByID(charID)\n    if IsValid(owner) then\n        owners[charID] = {\n        player = owner,\n        name = owner:Name(),\n        steamID = owner:SteamID(),\n        character = owner:getChar()\n        }\n    end\nend\nprint(\"Found owners for\", table.Count(owners), \"characters\")\n</code></pre></p>"},{"location":"libraries/lia.character/#getbysteamid","title":"getBySteamID","text":"<p>Purpose</p> <p>Finds a character by the Steam ID of its owner</p> <p>When Called</p> <p>When you need to find a character using the player's Steam ID</p> <p>Parameters</p> <ul> <li><code>steamID</code> (string): Steam ID of the character owner (supports both formats)</li> </ul> <p>Returns</p> <ul> <li>Character object if found, nil otherwise</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find character by Steam ID\nlocal character = lia.char.getBySteamID(\"STEAM_0:1:123456\")\nif character then\n    print(\"Found character:\", character:getName())\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Find character with Steam ID conversion\nlocal steamID64 = \"76561198000000000\"\nlocal character = lia.char.getBySteamID(steamID64)\nif character then\n    local owner = character:getPlayer()\n    if IsValid(owner) then\n        owner:notify(\"Character found and loaded\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch character lookup by Steam IDs\nlocal steamIDs = {\"STEAM_0:1:123456\", \"76561198000000000\", \"STEAM_0:0:789012\"}\nlocal foundCharacters = {}\nfor _, steamID in ipairs(steamIDs) do\n    local character = lia.char.getBySteamID(steamID)\n    if character then\n        local owner = character:getPlayer()\n        foundCharacters[steamID] = {\n        character = character,\n        owner = owner,\n        name = character:getName(),\n        faction = character:getFaction()\n        }\n    end\nend\nprint(\"Found\", table.Count(foundCharacters), \"characters\")\n</code></pre></p>"},{"location":"libraries/lia.character/#getteamcolor","title":"getTeamColor","text":"<p>Purpose</p> <p>Gets the team color for a player based on their character's class</p> <p>When Called</p> <p>When you need to determine the appropriate color for a player's team/class</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to get the team color for</li> </ul> <p>Returns</p> <ul> <li>Color object representing the team/class color</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player team color\nlocal color = lia.char.getTeamColor(client)\nprint(\"Team color:\", color.r, color.g, color.b)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use team color for UI elements\nlocal color = lia.char.getTeamColor(client)\n-- Set player name color in chat\nlocal nameColor = Color(color.r, color.g, color.b, 255)\nchat.AddText(nameColor, client:Name(), color_white, \": Hello!\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch team color processing for UI\nlocal players = player.GetAll()\nlocal teamColors = {}\nfor _, ply in ipairs(players) do\n    if IsValid(ply) then\n        local color = lia.char.getTeamColor(ply)\n        local character = ply:getChar()\n        teamColors[ply] = {\n        color = color,\n        character = character,\n        faction = character and character:getFaction() or \"Unknown\",\n        class = character and character:getClass() or 0\n        }\n    end\nend\n-- Update scoreboard with team colors\nhook.Run(\"UpdateScoreboardColors\", teamColors)\n</code></pre></p>"},{"location":"libraries/lia.character/#create","title":"create","text":"<p>Purpose</p> <p>Creates a new character in the database and initializes it with default inventory</p> <p>When Called</p> <p>When a player creates a new character through character creation</p> <p>Parameters</p> <ul> <li><code>data</code> (table): Character data containing name, description, faction, model, etc.</li> <li><code>callback</code> (function): Function to call when character creation is complete</li> </ul> <p>Returns</p> <ul> <li>None (uses callback for result)</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a basic character\nlocal charData = {\nname = \"John Doe\",\ndesc = \"A citizen of the city\",\nfaction = \"Citizen\",\nmodel = \"models/player/Group01/male_01.mdl\",\nsteamID = client:SteamID()\n}\nlia.char.create(charData, function(charID)\nprint(\"Character created with ID:\", charID)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create character with validation and inventory\nlocal charData = {\nname = \"Jane Smith\",\ndesc = \"A skilled engineer\",\nfaction = \"Engineer\",\nmodel = \"models/player/Group01/female_01.mdl\",\nsteamID = client:SteamID(),\nmoney = 1000,\nattribs = {strength = 5, intelligence = 8}\n}\nlia.char.create(charData, function(charID)\nif charID then\n    local character = lia.char.getCharacter(charID)\n    if character then\n        -- Add starting items\n        character:getInv(1):add(\"crowbar\")\n        character:getInv(1):add(\"flashlight\")\n        client:notify(\"Character created successfully!\")\n    end\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create character with full validation and error handling\nlocal function createCharacterWithValidation(client, charData)\n    -- Validate required fields\n    if not charData.name or not charData.faction then\n        client:notifyError(\"Missing required character data\")\n        return\n    end\n    -- Validate faction access\n    if not client:hasWhitelist(charData.faction) then\n        client:notifyError(\"You don't have access to this faction\")\n        return\n    end\n    -- Set default values\n    charData.steamID = client:SteamID()\n    charData.money = charData.money or lia.config.get(\"DefaultMoney\", 1000)\n    charData.createTime = os.date(\"%Y-%m-%d %H:%M:%S\", os.time())\n    lia.char.create(charData, function(charID)\n    if charID then\n        local character = lia.char.getCharacter(charID)\n        if character then\n            -- Initialize character-specific data\n            character:setData(\"lastLogin\", os.time())\n            character:setData(\"creationIP\", client:IPAddress())\n            -- Add to player's character list\n            client.liaCharList = client.liaCharList or {}\n            table.insert(client.liaCharList, charID)\n            -- Notify success\n            client:notify(\"Character '\" .. charData.name .. \"' created successfully!\")\n            hook.Run(\"OnCharacterCreated\", character, client)\n        end\n        else\n            client:notifyError(\"Failed to create character\")\n        end\n    end)\nend\n</code></pre></p>"},{"location":"libraries/lia.character/#restore","title":"restore","text":"<p>Purpose</p> <p>Restores/loads all characters for a player from the database</p> <p>When Called</p> <p>When a player connects and needs their characters loaded</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to restore characters for</li> <li><code>callback</code> (function): Function to call when restoration is complete</li> <li><code>id</code> (number): Specific character ID to restore (optional)</li> </ul> <p>Returns</p> <ul> <li>None (uses callback for result)</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Restore all characters for player\nlia.char.restore(client, function(characters)\nprint(\"Restored\", #characters, \"characters for\", client:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Restore with character validation\nlia.char.restore(client, function(characters)\nif #characters &gt; 0 then\n    client.liaCharList = characters\n    -- Validate each character\n    for _, charID in ipairs(characters) do\n        local character = lia.char.getCharacter(charID)\n        if character then\n            -- Check if character is banned\n            if character:getBanned() &gt; 0 then\n                print(\"Character\", charID, \"is banned\")\n            end\n        end\n    end\n    client:notify(\"Characters loaded successfully!\")\n    else\n        client:notify(\"No characters found\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Restore with full error handling and statistics\nlia.char.restore(client, function(characters)\nlocal stats = {\ntotal = #characters,\nloaded = 0,\nbanned = 0,\ninvalid = 0\n}\nclient.liaCharList = characters\nfor _, charID in ipairs(characters) do\n    local character = lia.char.getCharacter(charID)\n    if character then\n        stats.loaded = stats.loaded + 1\n        -- Check character status\n        if character:getBanned() &gt; 0 then\n            stats.banned = stats.banned + 1\n        end\n        -- Validate character data\n        if not character:getName() or character:getName() == \"\" then\n            stats.invalid = stats.invalid + 1\n            print(\"Invalid character data for ID:\", charID)\n        end\n    end\nend\n-- Log statistics\nlia.log.add(\"Character restoration: \" ..\nclient:Name() .. \" - Total: \" .. stats.total ..\n\", Loaded: \" .. stats.loaded ..\n\", Banned: \" .. stats.banned ..\n\", Invalid: \" .. stats.invalid\n)\nhook.Run(\"OnCharactersRestored\", client, characters, stats)\nend)\n</code></pre></p>"},{"location":"libraries/lia.character/#cleanupforplayer","title":"cleanUpForPlayer","text":"<p>Purpose</p> <p>Cleans up all loaded characters for a player when they disconnect</p> <p>When Called</p> <p>When a player disconnects to free up memory and save data</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to clean up characters for</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Clean up player characters\nlia.char.cleanUpForPlayer(client)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up with logging\nlia.char.cleanUpForPlayer(client)\nlocal charCount = table.Count(client.liaCharList or {})\nif charCount &gt; 0 then\n    lia.log.add(\"Player disconnect: \" ..\n    client:Name() .. \" disconnected with \" .. charCount .. \" characters loaded\"\n    )\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Clean up with statistics and validation\nlocal function cleanupPlayerCharacters(client)\n    local charList = client.liaCharList or {}\n    local stats = {\n    total = #charList,\n    saved = 0,\n    errors = 0\n    }\n    for _, charID in ipairs(charList) do\n        local character = lia.char.getCharacter(charID)\n        if character then\n            -- Save character data\n            local success = character:save()\n            if success then\n                stats.saved = stats.saved + 1\n                else\n                    stats.errors = stats.errors + 1\n                    print(\"Failed to save character\", charID, \"for\", client:Name())\n                end\n            end\n        end\n        -- Clean up\n        lia.char.cleanUpForPlayer(client)\n        -- Log statistics\n        lia.log.add(\"Player cleanup: \" ..\n        client:Name() .. \" - Characters: \" .. stats.total ..\n        \", Saved: \" .. stats.saved ..\n        \", Errors: \" .. stats.errors\n        )\n    end\n</code></pre></p>"},{"location":"libraries/lia.character/#delete","title":"delete","text":"<p>Purpose</p> <p>Permanently deletes a character from the database and all associated data</p> <p>When Called</p> <p>When a character needs to be permanently removed (admin action, etc.)</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The unique identifier of the character to delete</li> <li><code>client</code> (Player): The player who owns the character (optional)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Delete a character\nlia.char.delete(123)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Delete character with validation\nlocal charID = 123\nlocal character = lia.char.getCharacter(charID)\nif character then\n    local owner = character:getPlayer()\n    if IsValid(owner) then\n        owner:notify(\"Your character '\" .. character:getName() .. \"' has been deleted\")\n    end\n    lia.char.delete(charID, owner)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Delete character with full cleanup and logging\nlocal function deleteCharacterWithCleanup(charID, admin)\n    local character = lia.char.getCharacter(charID)\n    if not character then\n        if admin then\n            admin:notifyError(\"Character not found\")\n        end\n        return\n    end\n    local owner = character:getPlayer()\n    local charName = character:getName()\n    -- Log deletion\n    lia.log.add(\"Character deletion: \" ..\n    \"Character '\" .. charName .. \"' (ID: \" .. charID .. \") deleted by \" ..\n    (IsValid(admin) and admin:Name() or \"System\")\n    )\n    -- Notify owner if online\n    if IsValid(owner) then\n        owner:notify(\"Your character '\" .. charName .. \"' has been deleted\")\n    end\n    -- Perform deletion\n    lia.char.delete(charID, owner)\n    -- Notify admin\n    if IsValid(admin) then\n        admin:notify(\"Character '\" .. charName .. \"' deleted successfully\")\n    end\n    -- Run deletion hook\n    hook.Run(\"OnCharacterDeleted\", charID, charName, owner, admin)\nend\n</code></pre></p>"},{"location":"libraries/lia.character/#getcharbanned","title":"getCharBanned","text":"<p>Purpose</p> <p>Checks if a character is banned and returns the ban timestamp</p> <p>When Called</p> <p>When you need to check if a character is banned</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The unique identifier of the character</li> </ul> <p>Returns</p> <ul> <li>Number representing ban timestamp (0 if not banned)</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if character is banned\nlocal banTime = lia.char.getCharBanned(123)\nif banTime &gt; 0 then\n    print(\"Character is banned since:\", os.date(\"%Y-%m-%d\", banTime))\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check ban status with validation\nlocal charID = 123\nlocal banTime = lia.char.getCharBanned(charID)\nif banTime &gt; 0 then\n    local character = lia.char.getCharacter(charID)\n    if character then\n        local owner = character:getPlayer()\n        if IsValid(owner) then\n            owner:notify(\"Your character is banned\")\n        end\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch ban checking with detailed information\nlocal function checkCharacterBans(charIDs)\n    local banInfo = {}\n    for _, charID in ipairs(charIDs) do\n        local banTime = lia.char.getCharBanned(charID)\n        if banTime &gt; 0 then\n            local character = lia.char.getCharacter(charID)\n            banInfo[charID] = {\n            banned = true,\n            banTime = banTime,\n            banDate = os.date(\"%Y-%m-%d %H:%M:%S\", banTime),\n            character = character,\n            owner = character and character:getPlayer()\n            }\n        end\n    end\n    return banInfo\nend\n</code></pre></p>"},{"location":"libraries/lia.character/#setchardatabase","title":"setCharDatabase","text":"<p>Purpose</p> <p>Sets character data in the database with proper type handling and networking</p> <p>When Called</p> <p>When character data needs to be saved to the database</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The unique identifier of the character</li> <li><code>field</code> (string): The field name to set</li> <li><code>value</code> (any): The value to set for the field</li> </ul> <p>Returns</p> <ul> <li>Boolean indicating success</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set character data\nlocal success = lia.char.setCharDatabase(123, \"money\", 1000)\nif success then\n    print(\"Character money updated\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set character data with validation\nlocal charID = 123\nlocal newMoney = 5000\nlocal character = lia.char.getCharacter(charID)\nif character then\n    local oldMoney = character:getMoney()\n    local success = lia.char.setCharDatabase(charID, \"money\", newMoney)\n    if success then\n        character:setMoney(newMoney)\n        print(\"Money changed from\", oldMoney, \"to\", newMoney)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch character data updates with error handling\nlocal function updateCharacterData(charID, dataUpdates)\n    local character = lia.char.getCharacter(charID)\n    if not character then\n        print(\"Character not found:\", charID)\n        return false\n    end\n    local results = {}\n    local successCount = 0\n    for field, value in pairs(dataUpdates) do\n        local success = lia.char.setCharDatabase(charID, field, value)\n        results[field] = success\n        if success then\n            successCount = successCount + 1\n            -- Update loaded character if it exists\n            if character[\"set\" .. field:sub(1, 1):upper() .. field:sub(2)] then\n                character[\"set\" .. field:sub(1, 1):upper() .. field:sub(2)](character, value)\n            end\n            else\n                print(\"Failed to update field:\", field)\n            end\n        end\n        print(\"Updated\", successCount, \"out of\", table.Count(dataUpdates), \"fields\")\n        return successCount == table.Count(dataUpdates)\n    end\n</code></pre></p>"},{"location":"libraries/lia.character/#unloadcharacter","title":"unloadCharacter","text":"<p>Purpose</p> <p>Unloads a character from memory, saving data and cleaning up resources</p> <p>When Called</p> <p>When a character needs to be removed from memory to free up resources</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The unique identifier of the character to unload</li> </ul> <p>Returns</p> <ul> <li>Boolean indicating success</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Unload a character\nlocal success = lia.char.unloadCharacter(123)\nif success then\n    print(\"Character unloaded successfully\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Unload character with validation\nlocal charID = 123\nlocal character = lia.char.getCharacter(charID)\nif character then\n    local owner = character:getPlayer()\n    if IsValid(owner) then\n        owner:notify(\"Character is being unloaded\")\n    end\n    local success = lia.char.unloadCharacter(charID)\n    if success then\n        print(\"Character\", charID, \"unloaded successfully\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch character unloading with statistics\nlocal function unloadCharacters(charIDs)\n    local stats = {\n    total = #charIDs,\n    unloaded = 0,\n    errors = 0,\n    skipped = 0\n    }\n    for _, charID in ipairs(charIDs) do\n        if lia.char.isLoaded(charID) then\n            local character = lia.char.getCharacter(charID)\n            if character then\n                -- Check if character is in use\n                local owner = character:getPlayer()\n                if IsValid(owner) and owner:getChar() == character then\n                    stats.skipped = stats.skipped + 1\n                    print(\"Skipping active character:\", charID)\n                    continue\n                end\n                local success = lia.char.unloadCharacter(charID)\n                if success then\n                    stats.unloaded = stats.unloaded + 1\n                    else\n                        stats.errors = stats.errors + 1\n                    end\n                end\n            end\n        end\n        print(\"Unloaded\", stats.unloaded, \"characters, skipped\", stats.skipped, \"active characters\")\n        return stats\n    end\n</code></pre></p>"},{"location":"libraries/lia.character/#unloadunusedcharacters","title":"unloadUnusedCharacters","text":"<p>Purpose</p> <p>Unloads unused characters for a player, keeping only the active one</p> <p>When Called</p> <p>When a player switches characters or to free up memory</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to unload unused characters for</li> <li><code>activeCharID</code> (number): The ID of the character to keep loaded</li> </ul> <p>Returns</p> <ul> <li>Number of characters unloaded</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Unload unused characters\nlocal unloadedCount = lia.char.unloadUnusedCharacters(client, 123)\nprint(\"Unloaded\", unloadedCount, \"characters\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Unload with validation\nlocal activeCharID = client:getChar() and client:getChar():getID()\nif activeCharID then\n    local unloadedCount = lia.char.unloadUnusedCharacters(client, activeCharID)\n    if unloadedCount &gt; 0 then\n        client:notify(\"Unloaded \" .. unloadedCount .. \" unused characters\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Unload with detailed logging and statistics\nlocal function unloadUnusedCharactersWithStats(client)\n    local activeChar = client:getChar()\n    local activeCharID = activeChar and activeChar:getID()\n    if not activeCharID then\n        print(\"No active character for\", client:Name())\n        return 0\n    end\n    local charList = client.liaCharList or {}\n    local stats = {\n    total = #charList,\n    active = activeCharID,\n    unloaded = 0,\n    errors = 0\n    }\n    -- Unload unused characters\n    stats.unloaded = lia.char.unloadUnusedCharacters(client, activeCharID)\n    -- Log statistics\n    lia.log.add(\"Character unloading: \" ..\n    client:Name() .. \" - Total: \" .. stats.total ..\n    \", Active: \" .. stats.active ..\n    \", Unloaded: \" .. stats.unloaded\n    )\n    return stats.unloaded\nend\n</code></pre></p>"},{"location":"libraries/lia.character/#loadsinglecharacter","title":"loadSingleCharacter","text":"<p>Purpose</p> <p>Loads a single character from the database with inventory initialization</p> <p>When Called</p> <p>When a specific character needs to be loaded on demand</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The unique identifier of the character to load</li> <li><code>client</code> (Player): The player requesting the character (optional)</li> <li><code>callback</code> (function): Function to call when loading is complete</li> </ul> <p>Returns</p> <ul> <li>None (uses callback for result)</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a single character\nlia.char.loadSingleCharacter(123, client, function(character)\nif character then\n    print(\"Character loaded:\", character:getName())\nend\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load character with validation\nlocal charID = 123\nlia.char.loadSingleCharacter(charID, client, function(character)\nif character then\n    -- Validate character access\n    if not client.liaCharList or not table.HasValue(client.liaCharList, charID) then\n        print(\"Player doesn't have access to character\", charID)\n        return\n    end\n    -- Check if character is banned\n    if character:getBanned() &gt; 0 then\n        client:notify(\"This character is banned\")\n        return\n    end\n    client:notify(\"Character loaded successfully\")\n    else\n        client:notify(\"Failed to load character\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load character with full error handling and statistics\nlocal function loadCharacterWithValidation(charID, client)\n    if not charID or not isnumber(charID) then\n        if client then\n            client:notifyError(\"Invalid character ID\")\n        end\n        return\n    end\n    -- Check if character is already loaded\n    if lia.char.isLoaded(charID) then\n        local character = lia.char.getCharacter(charID)\n        if character then\n            print(\"Character already loaded:\", charID)\n            return character\n        end\n    end\n    -- Validate player access\n    if client and (not client.liaCharList or not table.HasValue(client.liaCharList, charID)) then\n        client:notifyError(\"You don't have access to this character\")\n        return\n    end\n    lia.char.loadSingleCharacter(charID, client, function(character)\n    if character then\n        -- Validate character data\n        if not character:getName() or character:getName() == \"\" then\n            print(\"Invalid character data for ID:\", charID)\n            return\n        end\n        -- Check ban status\n        if character:getBanned() &gt; 0 then\n            if client then\n                client:notify(\"This character is banned\")\n            end\n            return\n        end\n        -- Log successful load\n        lia.log.add(\"Character loaded: \" ..\n        \"Character '\" .. character:getName() .. \"' (ID: \" .. charID .. \") loaded for \" ..\n        (client and client:Name() or \"System\")\n        )\n        -- Run load hook\n        hook.Run(\"OnCharacterLoaded\", character, client)\n        if client then\n            client:notify(\"Character '\" .. character:getName() .. \"' loaded successfully\")\n        end\n        else\n            if client then\n                client:notifyError(\"Failed to load character\")\n            end\n            print(\"Failed to load character:\", charID)\n        end\n    end)\nend\n</code></pre></p>"},{"location":"libraries/lia.chatbox/","title":"Chatbox Library","text":"<p>Comprehensive chat system management with message routing and formatting for the Lilia framework.</p> <p>Overview</p> <p>The chatbox library provides comprehensive functionality for managing chat systems in the Lilia framework. It handles registration of different chat types (IC, OOC, whisper, etc.), message parsing and routing, distance-based hearing mechanics, and chat formatting. The library operates on both server and client sides, with the server managing message distribution and validation, while the client handles parsing and display formatting. It includes support for anonymous messaging, custom prefixes, radius-based communication, and integration with the command system for chat-based commands.</p>"},{"location":"libraries/lia.chatbox/#timestamp","title":"timestamp","text":"<p>Purpose</p> <p>Generates a formatted timestamp string for chat messages based on current time</p> <p>When Called</p> <p>Automatically called when displaying chat messages if timestamps are enabled</p> <p>Parameters</p> <ul> <li><code>ooc</code> (boolean): Whether this is an OOC message (affects spacing format)</li> </ul> <p>Returns</p> <ul> <li>string - Formatted timestamp string or empty string if timestamps disabled</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get timestamp for IC message\nlocal timestamp = lia.chat.timestamp(false)\n-- Returns: \" (14:30) \" or \"\" if timestamps disabled\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use timestamp in custom chat format\nlocal function customChatFormat(speaker, text)\n    local timeStr = lia.chat.timestamp(false)\n    chat.AddText(timeStr, Color(255, 255, 255), speaker:Name() .. \": \" .. text)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic timestamp with custom formatting\nlocal function getFormattedTimestamp(isOOC, customFormat)\n    local baseTime = lia.chat.timestamp(isOOC)\n    if customFormat and baseTime ~= \"\" then\n        return baseTime:gsub(\"%((%d+:%d+)%)\", \"[\" .. customFormat .. \"]\")\n    end\n    return baseTime\nend\n</code></pre></p>"},{"location":"libraries/lia.chatbox/#register","title":"register","text":"<p>Purpose</p> <p>Registers a new chat type with the chatbox system, defining its behavior and properties</p> <p>When Called</p> <p>During module initialization to register custom chat types (IC, OOC, whisper, etc.)</p> <p>Parameters</p> <ul> <li><code>chatType</code> (string): Unique identifier for the chat type</li> <li><code>data</code> (table): Configuration table containing chat type properties</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register basic IC chat\nlia.chat.register(\"ic\", {\nprefix = \"/\",\ncolor = Color(255, 255, 255),\nradius = 200\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register whisper chat with custom properties\nlia.chat.register(\"whisper\", {\nprefix = {\"/w\", \"/whisper\"},\ncolor = Color(150, 150, 255),\nradius = 50,\nformat = \"whisperFormat\",\ndesc = \"Whisper to nearby players\"\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register admin chat with complex validation\nlia.chat.register(\"admin\", {\nprefix = \"/a\",\ncolor = Color(255, 100, 100),\nonCanSay = function(speaker)\nreturn speaker:IsAdmin()\nend,\nonCanHear = function(speaker, listener)\nreturn listener:IsAdmin()\nend,\nformat = \"adminFormat\",\narguments = {\n{type = \"string\", name = \"message\"}\n},\ndesc = \"Admin-only communication channel\"\n})\n</code></pre></p>"},{"location":"libraries/lia.chatbox/#parse","title":"parse","text":"<p>Purpose</p> <p>Parses a chat message to determine its type and extract the actual message content</p> <p>When Called</p> <p>When a player sends a chat message, either from client input or server processing</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who sent the message</li> <li><code>message</code> (string): The raw message text to parse</li> <li><code>noSend</code> (boolean, optional): If true, prevents sending the message to other players</li> </ul> <p>Returns</p> <ul> <li>chatType (string), message (string), anonymous (boolean)</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Parse a basic IC message\nlocal chatType, message, anonymous = lia.chat.parse(LocalPlayer(), \"Hello everyone!\")\n-- Returns: \"ic\", \"Hello everyone!\", false\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Parse message with prefix detection\nlocal function processPlayerMessage(player, rawMessage)\n    local chatType, cleanMessage, anonymous = lia.chat.parse(player, rawMessage)\n    if chatType == \"ooc\" then\n        print(player:Name() .. \" said OOC: \" .. cleanMessage)\n    end\n    return chatType, cleanMessage, anonymous\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced message processing with validation\nlocal function advancedMessageParser(player, message, options)\n    local chatType, cleanMessage, anonymous = lia.chat.parse(player, message, options.noSend)\n    -- Custom validation based on chat type\n    if chatType == \"admin\" and not player:IsAdmin() then\n        player:notifyErrorLocalized(\"noPerm\")\n        return nil, nil, nil\n    end\n    -- Log message for moderation\n    if options.logMessages then\n        lia.log.add(\"chat\", player:Name() .. \" [\" .. chatType .. \"]: \" .. cleanMessage)\n    end\n    return chatType, cleanMessage, anonymous\nend\n</code></pre></p>"},{"location":"libraries/lia.chatbox/#send","title":"send","text":"<p>Purpose</p> <p>Sends a chat message to appropriate recipients based on chat type and hearing rules</p> <p>When Called</p> <p>Server-side when distributing parsed chat messages to players</p> <p>Parameters</p> <ul> <li><code>speaker</code> (Player): The player who sent the message</li> <li><code>chatType</code> (string): The type of chat message (ic, ooc, whisper, etc.)</li> <li><code>text</code> (string): The message content to send</li> <li><code>anonymous</code> (boolean, optional): Whether to hide the speaker's identity</li> <li><code>receivers</code> (table, optional): Specific list of players to send to</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send IC message to all nearby players\nlia.chat.send(player, \"ic\", \"Hello everyone!\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send anonymous whisper to specific players\nlocal function sendAnonymousWhisper(speaker, message, targets)\n    lia.chat.send(speaker, \"whisper\", message, true, targets)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced message broadcasting with custom logic\nlocal function broadcastAdminMessage(speaker, message, options)\n    local receivers = {}\n    -- Collect admin players\n    for _, player in pairs(player.GetAll()) do\n        if player:IsAdmin() and (not options.excludeSelf or player ~= speaker) then\n            table.insert(receivers, player)\n        end\n    end\n    -- Send with custom formatting\n    lia.chat.send(speaker, \"admin\", \"[ADMIN] \" .. message, false, receivers)\n    -- Log the message\n    lia.log.add(\"admin_chat\", speaker:Name() .. \": \" .. message)\nend\n</code></pre></p>"},{"location":"libraries/lia.classes/","title":"Classes Library","text":"<p>Character class management and validation system for the Lilia framework.</p> <p>Overview</p> <p>The classes library provides comprehensive functionality for managing character classes in the Lilia framework. It handles registration, validation, and management of player classes within factions. The library operates on both server and client sides, allowing for dynamic class creation, whitelist management, and player class assignment validation. It includes functionality for loading classes from directories, checking class availability, retrieving class information, and managing class limits. The library ensures proper faction validation and provides hooks for custom class behavior and restrictions.</p>"},{"location":"libraries/lia.classes/#register","title":"register","text":"<p>Purpose</p> <p>Registers a new character class with the specified unique ID and data</p> <p>When Called</p> <p>During gamemode initialization or when dynamically creating classes</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): Unique identifier for the class</li> <li><code>data</code> (table): Table containing class properties (name, desc, limit, faction, etc.)</li> </ul> <p>Returns</p> <ul> <li>The registered class table</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>lia.class.register(\"citizen\", {\nname = \"Citizen\",\ndesc = \"A regular citizen\",\nfaction = FACTION_CITIZEN,\nlimit = 0\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>lia.class.register(\"police_officer\", {\nname = \"Police Officer\",\ndesc = \"A law enforcement officer\",\nfaction = FACTION_POLICE,\nlimit = 5,\nOnCanBe = function(self, client)\nreturn client:getChar():getAttrib(\"strength\", 0) &gt;= 10\nend\n})\n</code></pre></p> <p>High Complexity: <pre><code>local classData = {\nname = \"Elite Soldier\",\ndesc = \"A highly trained military operative\",\nfaction = FACTION_MILITARY,\nlimit = 2,\nisWhitelisted = true,\nOnCanBe = function(self, client)\nlocal char = client:getChar()\nreturn char:getAttrib(\"strength\", 0) &gt;= 15 and\nchar:getAttrib(\"endurance\", 0) &gt;= 12 and\nclient:IsAdmin()\nend,\nOnSpawn = function(self, client)\nclient:Give(\"weapon_ar2\")\nclient:SetHealth(150)\nend\n}\nlia.class.register(\"elite_soldier\", classData)\n</code></pre></p>"},{"location":"libraries/lia.classes/#loadfromdir","title":"loadFromDir","text":"<p>Purpose</p> <p>Loads character classes from a directory containing class definition files</p> <p>When Called</p> <p>During gamemode initialization to load classes from files</p> <p>Parameters</p> <ul> <li><code>directory</code> (string): Path to directory containing class files</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>lia.class.loadFromDir(\"gamemodes/lilia/classes\")\n</code></pre></p> <p>Medium Complexity: <pre><code>local classDir = \"gamemodes/lilia/modules/custom_classes/classes\"\nif file.Exists(classDir, \"LUA\") then\n    lia.class.loadFromDir(classDir)\nend\n</code></pre></p> <p>High Complexity: <pre><code>local classDirectories = {\n\"gamemodes/lilia/classes\",\n\"gamemodes/lilia/modules/factions/classes\",\n\"gamemodes/lilia/modules/custom_classes/classes\"\n}\nfor _, dir in ipairs(classDirectories) do\n    if file.Exists(dir, \"LUA\") then\n        print(\"Loading classes from: \" .. dir)\n        lia.class.loadFromDir(dir)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.classes/#canbe","title":"canBe","text":"<p>Purpose</p> <p>Checks if a client can join a specific character class</p> <p>When Called</p> <p>When a player attempts to join a class or when checking class availability</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to join the class</li> <li><code>class</code> (number): The class index to check</li> </ul> <p>Returns</p> <ul> <li>boolean, string - Whether the player can join and reason if they cannot</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local canJoin, reason = lia.class.canBe(client, 1)\nif canJoin then\n    print(\"Player can join class\")\n    else\n        print(\"Cannot join: \" .. reason)\n    end\n</code></pre></p> <p>Medium Complexity: <pre><code>local function checkClassAvailability(client, className)\n    local classIndex = lia.class.retrieveClass(className)\n    if not classIndex then\n        return false, \"Class not found\"\n    end\n    local canJoin, reason = lia.class.canBe(client, classIndex)\n    return canJoin, reason\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function validateClassSwitch(client, newClass)\n    local currentChar = client:getChar()\n    if not currentChar then\n        return false, \"No character\"\n    end\n    local currentClass = currentChar:getClass()\n    if currentClass == newClass then\n        return false, \"Already in this class\"\n    end\n    local canJoin, reason = lia.class.canBe(client, newClass)\n    if not canJoin then\n        return false, reason\n    end\n    -- Additional custom validation\n    if hook.Run(\"CustomClassValidation\", client, newClass) == false then\n        return false, \"Custom validation failed\"\n    end\n    return true, \"Valid\"\nend\n</code></pre></p>"},{"location":"libraries/lia.classes/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves a character class by its identifier (index or uniqueID)</p> <p>When Called</p> <p>When needing to access class information or properties</p> <p>Parameters</p> <ul> <li><code>identifier</code> (number/string): Class index or uniqueID to retrieve</li> </ul> <p>Returns</p> <ul> <li>table - The class data table or nil if not found</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local class = lia.class.get(1)\nif class then\n    print(\"Class name: \" .. class.name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>local function getClassInfo(identifier)\n    local class = lia.class.get(identifier)\n    if not class then\n        return nil, \"Class not found\"\n    end\n    return {\n    name = class.name,\n    description = class.desc,\n    limit = class.limit,\n    faction = class.faction\n    }\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function getClassDetails(identifier)\n    local class = lia.class.get(identifier)\n    if not class then\n        return nil, \"Class not found\"\n    end\n    local players = lia.class.getPlayers(identifier)\n    local playerCount = #players\n    return {\n    info = class,\n    currentPlayers = players,\n    playerCount = playerCount,\n    isAvailable = class.limit == 0 or playerCount &lt; class.limit,\n    isWhitelisted = class.isWhitelisted or false,\n    canJoin = function(client)\n    return lia.class.canBe(client, identifier)\nend\n}\nend\n</code></pre></p>"},{"location":"libraries/lia.classes/#getplayers","title":"getPlayers","text":"<p>Purpose</p> <p>Gets all players currently using a specific character class</p> <p>When Called</p> <p>When needing to find players in a particular class or check class population</p> <p>Parameters</p> <ul> <li><code>class</code> (number): The class index to get players for</li> </ul> <p>Returns</p> <ul> <li>table - Array of player entities in the specified class</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local players = lia.class.getPlayers(1)\nprint(\"Players in class 1: \" .. #players)\n</code></pre></p> <p>Medium Complexity: <pre><code>local function getClassMembers(className)\n    local classIndex = lia.class.retrieveClass(className)\n    if not classIndex then\n        return {}\n    end\n    local players = lia.class.getPlayers(classIndex)\n    local memberNames = {}\n    for _, player in ipairs(players) do\n        table.insert(memberNames, player:Name())\n    end\n    return memberNames\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function getClassStatistics(classIndex)\n    local players = lia.class.getPlayers(classIndex)\n    local stats = {\n    count = #players,\n    players = {},\n    onlineTime = 0,\n    averageLevel = 0\n    }\n    for _, player in ipairs(players) do\n        local char = player:getChar()\n        if char then\n            table.insert(stats.players, {\n            name = player:Name(),\n            level = char:getLevel(),\n            playtime = char:getPlayTime()\n            })\n            stats.onlineTime = stats.onlineTime + char:getPlayTime()\n        end\n    end\n    if stats.count &gt; 0 then\n        stats.averageLevel = stats.onlineTime / stats.count\n    end\n    return stats\nend\n</code></pre></p>"},{"location":"libraries/lia.classes/#getplayercount","title":"getPlayerCount","text":"<p>Purpose</p> <p>Gets the count of players currently using a specific character class</p> <p>When Called</p> <p>When needing to check class population without retrieving player objects</p> <p>Parameters</p> <ul> <li><code>class</code> (number): The class index to count players for</li> </ul> <p>Returns</p> <ul> <li>number - Number of players in the specified class</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local count = lia.class.getPlayerCount(1)\nprint(\"Players in class: \" .. count)\n</code></pre></p> <p>Medium Complexity: <pre><code>local function checkClassAvailability(classIndex)\n    local class = lia.class.get(classIndex)\n    if not class then\n        return false, \"Class not found\"\n    end\n    local currentCount = lia.class.getPlayerCount(classIndex)\n    local isFull = class.limit &gt; 0 and currentCount &gt;= class.limit\n    return not isFull, isFull and \"Class is full\" or \"Available\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function getClassPopulationReport()\n    local report = {}\n    for i, class in ipairs(lia.class.list) do\n        local count = lia.class.getPlayerCount(i)\n        local percentage = 0\n        if class.limit &gt; 0 then\n            percentage = (count / class.limit) * 100\n        end\n        table.insert(report, {\n        name = class.name,\n        currentCount = count,\n        limit = class.limit,\n        percentage = percentage,\n        isFull = class.limit &gt; 0 and count &gt;= class.limit,\n        faction = class.faction\n        })\n    end\n    return report\nend\n</code></pre></p>"},{"location":"libraries/lia.classes/#retrieveclass","title":"retrieveClass","text":"<p>Purpose</p> <p>Finds a class by matching its uniqueID or name with a search string</p> <p>When Called</p> <p>When needing to find a class by name or partial identifier</p> <p>Parameters</p> <ul> <li><code>class</code> (string): String to match against class uniqueID or name</li> </ul> <p>Returns</p> <ul> <li>number - The class index if found, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local classIndex = lia.class.retrieveClass(\"citizen\")\nif classIndex then\n    print(\"Found class at index: \" .. classIndex)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>local function findClassByName(searchTerm)\n    local classIndex = lia.class.retrieveClass(searchTerm)\n    if not classIndex then\n        return nil, \"Class '\" .. searchTerm .. \"' not found\"\n    end\n    local class = lia.class.get(classIndex)\n    return classIndex, class\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function searchClasses(searchTerm)\n    local results = {}\n    local term = string.lower(searchTerm)\n    for i, class in ipairs(lia.class.list) do\n        local uniqueID = string.lower(class.uniqueID or \"\")\n        local name = string.lower(class.name or \"\")\n        if string.find(uniqueID, term) or string.find(name, term) then\n            table.insert(results, {\n            index = i,\n            class = class,\n            matchType = string.find(uniqueID, term) and \"uniqueID\" or \"name\"\n            })\n        end\n    end\n    return results\nend\n</code></pre></p>"},{"location":"libraries/lia.classes/#haswhitelist","title":"hasWhitelist","text":"<p>Purpose</p> <p>Checks if a character class has whitelist restrictions</p> <p>When Called</p> <p>When checking if a class requires special permissions or whitelist access</p> <p>Parameters</p> <ul> <li><code>class</code> (number): The class index to check for whitelist</li> </ul> <p>Returns</p> <ul> <li>boolean - True if the class has whitelist restrictions, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local hasWhitelist = lia.class.hasWhitelist(1)\nif hasWhitelist then\n    print(\"This class requires whitelist\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>local function checkClassAccess(client, classIndex)\n    local class = lia.class.get(classIndex)\n    if not class then\n        return false, \"Class not found\"\n    end\n    if lia.class.hasWhitelist(classIndex) then\n        -- Check if player has whitelist access\n        local hasAccess = client:IsAdmin() or client:IsSuperAdmin()\n        return hasAccess, hasAccess and \"Access granted\" or \"Whitelist required\"\n    end\n    return true, \"No whitelist required\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function getWhitelistClasses()\n    local whitelistClasses = {}\n    local regularClasses = {}\n    for i, class in ipairs(lia.class.list) do\n        if lia.class.hasWhitelist(i) then\n            table.insert(whitelistClasses, {\n            index = i,\n            class = class,\n            requiredPermissions = class.requiredPermissions or {}\n            })\n            else\n                table.insert(regularClasses, {\n                index = i,\n                class = class\n                })\n            end\n        end\n        return {\n        whitelist = whitelistClasses,\n        regular = regularClasses,\n        totalWhitelist = #whitelistClasses,\n        totalRegular = #regularClasses\n        }\n    end\n</code></pre></p>"},{"location":"libraries/lia.classes/#retrievejoinable","title":"retrieveJoinable","text":"<p>Purpose</p> <p>Retrieves all classes that a specific client can join</p> <p>When Called</p> <p>When displaying available classes to a player or checking joinable options</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to check joinable classes for (optional, defaults to LocalPlayer on client)</li> </ul> <p>Returns</p> <ul> <li>table - Array of class tables that the client can join</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local joinableClasses = lia.class.retrieveJoinable(client)\nprint(\"Player can join \" .. #joinableClasses .. \" classes\")\n</code></pre></p> <p>Medium Complexity: <pre><code>local function getJoinableClassNames(client)\n    local joinableClasses = lia.class.retrieveJoinable(client)\n    local classNames = {}\n    for _, class in ipairs(joinableClasses) do\n        table.insert(classNames, class.name)\n    end\n    return classNames\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function getDetailedJoinableClasses(client)\n    local joinableClasses = lia.class.retrieveJoinable(client)\n    local detailedClasses = {}\n    for _, class in ipairs(joinableClasses) do\n        local playerCount = lia.class.getPlayerCount(class.index)\n        local isFull = class.limit &gt; 0 and playerCount &gt;= class.limit\n        table.insert(detailedClasses, {\n        class = class,\n        playerCount = playerCount,\n        limit = class.limit,\n        isFull = isFull,\n        availability = isFull and \"Full\" or \"Available\",\n        requiresWhitelist = lia.class.hasWhitelist(class.index)\n        })\n    end\n    -- Sort by availability and name\n    table.sort(detailedClasses, function(a, b)\n    if a.isFull ~= b.isFull then\n        return not a.isFull -- Available classes first\n    end\n    return a.class.name &lt; b.class.name\nend)\nreturn detailedClasses\nend\n</code></pre></p>"},{"location":"libraries/lia.color/","title":"Color Library","text":"<p>Comprehensive color and theme management system for the Lilia framework.</p> <p>Overview</p> <p>The color library provides comprehensive functionality for managing colors and themes in the Lilia framework. It handles color registration, theme management, color manipulation, and smooth theme transitions. The library operates primarily on the client side, with theme registration available on both server and client. It includes predefined color names, theme switching capabilities, color adjustment functions, and smooth animated transitions between themes. The library ensures consistent color usage across the entire gamemode interface and provides tools for creating custom themes and color schemes.</p>"},{"location":"libraries/lia.color/#register","title":"register","text":"<p>Purpose</p> <p>Registers a named color for use throughout the gamemode</p> <p>When Called</p> <p>When defining custom colors or extending the color palette</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name identifier for the color</li> <li><code>color</code> (table): Color table with r, g, b, a values or array format</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic color\nlia.color.register(\"myred\", {255, 0, 0})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register color with alpha channel\nlia.color.register(\"semitransparent\", {255, 255, 255, 128})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register multiple colors from configuration\nlocal colorConfig = {\nprimary = {100, 150, 200},\nsecondary = {200, 100, 150},\naccent = {150, 200, 100}\n}\nfor name, color in pairs(colorConfig) do\n    lia.color.register(name, color)\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#adjust","title":"adjust","text":"<p>Purpose</p> <p>Adjusts color values by adding offsets to each channel</p> <p>When Called</p> <p>When creating color variations or adjusting existing colors</p> <p>Parameters</p> <ul> <li><code>color</code> (Color): The base color to adjust</li> <li><code>rOffset</code> (number): Red channel offset (-255 to 255)</li> <li><code>gOffset</code> (number): Green channel offset (-255 to 255)</li> <li><code>bOffset</code> (number): Blue channel offset (-255 to 255)</li> <li><code>aOffset</code> (number, optional): Alpha channel offset (-255 to 255)</li> </ul> <p>Returns</p> <ul> <li>Color - New adjusted color with clamped values</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Brighten a color\nlocal brightRed = lia.color.adjust(Color(100, 0, 0), 50, 0, 0)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create color variations\nlocal baseColor = Color(128, 128, 128)\nlocal lighter = lia.color.adjust(baseColor, 30, 30, 30)\nlocal darker = lia.color.adjust(baseColor, -30, -30, -30)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic color adjustment based on conditions\nlocal function adjustColorForTime(color, timeOfDay)\n    local multiplier = math.sin(timeOfDay * math.pi / 12) * 0.3\n    return lia.color.adjust(color,\n    multiplier * 50,\n    multiplier * 30,\n    multiplier * 20,\n    multiplier * 100\n    )\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#darken","title":"darken","text":"<p>Purpose</p> <p>Darkens a color by multiplying RGB values by a factor</p> <p>When Called</p> <p>When creating darker variations of colors for shadows or depth</p> <p>Parameters</p> <ul> <li><code>color</code> (Color): The color to darken</li> <li><code>factor</code> (number, optional): Darkening factor (0-1), defaults to 0.1</li> </ul> <p>Returns</p> <ul> <li>Color - New darkened color with preserved alpha</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Darken a color slightly\nlocal darkBlue = lia.color.darken(Color(0, 0, 255))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create shadow effect\nlocal baseColor = Color(100, 150, 200)\nlocal shadowColor = lia.color.darken(baseColor, 0.5)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic darkening based on distance\nlocal function getShadowColor(baseColor, distance)\n    local darkenFactor = math.min(distance / 1000, 0.8)\n    return lia.color.darken(baseColor, darkenFactor)\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#getcurrenttheme","title":"getCurrentTheme","text":"<p>Purpose</p> <p>Gets the current active theme name in lowercase</p> <p>When Called</p> <p>When checking which theme is currently active</p> <p>Returns</p> <ul> <li>string - Current theme name in lowercase</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check current theme\nlocal currentTheme = lia.color.getCurrentTheme()\nprint(\"Current theme:\", currentTheme)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional theme-based logic\nif lia.color.getCurrentTheme() == \"dark\" then\n    -- Apply dark theme specific settings\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Theme-based UI customization\nlocal function getThemeSpecificColor(colorName)\n    local theme = lia.color.getCurrentTheme()\n    local themeColors = {\n    dark = {primary = Color(100, 100, 100)},\n    light = {primary = Color(200, 200, 200)}\n    }\n    return themeColors[theme] and themeColors[theme][colorName] or Color(255, 255, 255)\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#getcurrentthemename","title":"getCurrentThemeName","text":"<p>Purpose</p> <p>Gets the current active theme name with proper capitalization</p> <p>When Called</p> <p>When displaying theme name to users or for configuration</p> <p>Returns</p> <ul> <li>string - Current theme name with proper capitalization</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display theme name\nlocal themeName = lia.color.getCurrentThemeName()\nprint(\"Active theme:\", themeName)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Theme selection menu\nlocal function createThemeMenu()\n    local currentTheme = lia.color.getCurrentThemeName()\n    local menu = vgui.Create(\"DFrame\")\n    menu:SetTitle(\"Current Theme: \" .. currentTheme)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Theme validation and fallback\nlocal function validateTheme()\n    local themeName = lia.color.getCurrentThemeName()\n    local availableThemes = lia.color.getAllThemes()\n    if not table.HasValue(availableThemes, themeName:lower()) then\n        lia.config.set(\"Theme\", \"Teal\")\n        return \"Teal\"\n    end\n    return themeName\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#getmaincolor","title":"getMainColor","text":"<p>Purpose</p> <p>Gets the main color from the current theme</p> <p>When Called</p> <p>When needing the primary accent color for UI elements</p> <p>Returns</p> <ul> <li>Color - The main color from current theme or default teal</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get main theme color\nlocal mainColor = lia.color.getMainColor()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use main color for UI elements\nlocal function createThemedButton(text)\n    local button = vgui.Create(\"DButton\")\n    button:SetText(text)\n    button:SetTextColor(lia.color.getMainColor())\n    return button\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic color scheme generation\nlocal function generateColorScheme()\n    local mainColor = lia.color.getMainColor()\n    return {\n    primary = mainColor,\n    secondary = lia.color.adjust(mainColor, -50, -50, -50),\n    accent = lia.color.adjust(mainColor, 50, 50, 50),\n    background = lia.color.darken(mainColor, 0.8)\n    }\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#applytheme","title":"applyTheme","text":"<p>Purpose</p> <p>Applies a theme to the interface with optional smooth transition</p> <p>When Called</p> <p>When switching themes or initializing the color system</p> <p>Parameters</p> <ul> <li><code>themeName</code> (string, optional): Name of theme to apply, defaults to current theme</li> <li><code>useTransition</code> (boolean, optional): Whether to use smooth transition animation</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Apply theme without transition\nlia.color.applyTheme(\"dark\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Apply theme with smooth transition\nlia.color.applyTheme(\"light\", true)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Theme switching with validation and fallback\nlocal function switchTheme(themeName)\n    local availableThemes = lia.color.getAllThemes()\n    if not table.HasValue(availableThemes, themeName:lower()) then\n        themeName = \"teal\"\n    end\n    lia.color.applyTheme(themeName, true)\n    lia.config.set(\"Theme\", themeName)\n    -- Notify other systems of theme change\n    hook.Run(\"OnThemeChanged\", themeName, true)\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#istransitionactive","title":"isTransitionActive","text":"<p>Purpose</p> <p>Checks if a theme transition animation is currently active</p> <p>When Called</p> <p>When checking transition state before starting new transitions</p> <p>Returns</p> <ul> <li>boolean - True if transition is active, false otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if transition is running\nif lia.color.isTransitionActive() then\n    print(\"Theme transition in progress\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Prevent multiple transitions\nlocal function safeThemeSwitch(themeName)\n    if lia.color.isTransitionActive() then\n        print(\"Please wait for current transition to finish\")\n        return\n    end\n    lia.color.applyTheme(themeName, true)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Queue theme changes during transitions\nlocal themeQueue = {}\nlocal function queueThemeChange(themeName)\n    if lia.color.isTransitionActive() then\n        table.insert(themeQueue, themeName)\n        else\n            lia.color.applyTheme(themeName, true)\n        end\n    end\n    hook.Add(\"OnThemeChanged\", \"ProcessThemeQueue\", function()\n    if #themeQueue &gt; 0 and not lia.color.isTransitionActive() then\n        local nextTheme = table.remove(themeQueue, 1)\n        lia.color.applyTheme(nextTheme, true)\n    end\nend)\n</code></pre></p>"},{"location":"libraries/lia.color/#testthemetransition","title":"testThemeTransition","text":"<p>Purpose</p> <p>Tests a theme transition by applying it with animation</p> <p>When Called</p> <p>When previewing theme changes or testing transitions</p> <p>Parameters</p> <ul> <li><code>themeName</code> (string): Name of theme to test transition to</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Test theme transition\nlia.color.testThemeTransition(\"dark\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Preview multiple themes\nlocal function previewTheme(themeName)\n    lia.color.testThemeTransition(themeName)\n    timer.Simple(2, function()\n    lia.color.applyTheme(lia.color.getCurrentTheme(), true)\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Theme preview system with cycling\nlocal previewThemes = {\"dark\", \"light\", \"blue\", \"red\"}\nlocal currentPreview = 1\nlocal function cycleThemePreview()\n    if lia.color.isTransitionActive() then return end\n        local theme = previewThemes[currentPreview]\n        lia.color.testThemeTransition(theme)\n        currentPreview = (currentPreview % #previewThemes) + 1\n        timer.Simple(3, cycleThemePreview)\n    end\n</code></pre></p>"},{"location":"libraries/lia.color/#startthemetransition","title":"startThemeTransition","text":"<p>Purpose</p> <p>Starts a smooth animated transition to a new theme</p> <p>When Called</p> <p>When applying themes with transition animation enabled</p> <p>Parameters</p> <ul> <li><code>name</code> (string): Name of the theme to transition to</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Start theme transition\nlia.color.startThemeTransition(\"dark\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Transition with validation\nlocal function transitionToTheme(themeName)\n    if lia.color.isTransitionActive() then\n        print(\"Transition already in progress\")\n        return\n    end\n    local availableThemes = lia.color.getAllThemes()\n    if table.HasValue(availableThemes, themeName:lower()) then\n        lia.color.startThemeTransition(themeName)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom transition with progress tracking\nlocal function customThemeTransition(themeName, callback)\n    lia.color.startThemeTransition(themeName)\n    local function checkProgress()\n        if not lia.color.isTransitionActive() then\n            if callback then callback() end\n                return\n            end\n            timer.Simple(0.1, checkProgress)\n        end\n        checkProgress()\n    end\n</code></pre></p>"},{"location":"libraries/lia.color/#iscolor","title":"isColor","text":"<p>Purpose</p> <p>Checks if a value is a valid color object</p> <p>When Called</p> <p>When validating color data or processing theme transitions</p> <p>Parameters</p> <ul> <li><code>v</code> (any): Value to check if it's a color</li> </ul> <p>Returns</p> <ul> <li>boolean - True if value is a valid color, false otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if value is color\nif lia.color.isColor(someValue) then\n    print(\"It's a color!\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate color data\nlocal function processColorData(data)\n    if lia.color.isColor(data) then\n        return data\n        else\n            return Color(255, 255, 255)\n        end\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Recursive color validation in nested tables\nlocal function validateThemeData(themeData)\n    for key, value in pairs(themeData) do\n        if istable(value) and #value &gt; 0 then\n            for i, item in ipairs(value) do\n                if not lia.color.isColor(item) then\n                    error(\"Invalid color at \" .. key .. \"[\" .. i .. \"]\")\n                end\n            end\n            elseif lia.color.isColor(value) then\n                -- Valid color\n                else\n                    error(\"Invalid color at \" .. key)\n                end\n            end\n        end\n</code></pre></p>"},{"location":"libraries/lia.color/#returnmainadjustedcolors","title":"returnMainAdjustedColors","text":"<p>Purpose</p> <p>Returns a set of adjusted colors based on the main theme color</p> <p>When Called</p> <p>When creating UI color schemes or theme-based color palettes</p> <p>Returns</p> <ul> <li>table - Table containing adjusted colors (background, sidebar, accent, text, hover, border, highlight)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get theme colors\nlocal colors = lia.color.returnMainAdjustedColors()\nlocal bgColor = colors.background\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Apply colors to UI elements\nlocal function createThemedPanel()\n    local colors = lia.color.returnMainAdjustedColors()\n    local panel = vgui.Create(\"DPanel\")\n    panel:SetBackgroundColor(colors.background)\n    panel.Paint = function(self, w, h)\n    draw.RoundedBox(4, 0, 0, w, h, colors.background)\n    draw.RoundedBox(4, 0, 0, w, 2, colors.accent)\nend\nreturn panel\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic UI system with theme colors\nlocal function createAdvancedUI()\n    local colors = lia.color.returnMainAdjustedColors()\n    local ui = {\n    background = colors.background,\n    primary = colors.accent,\n    secondary = colors.sidebar,\n    text = colors.text,\n    hover = colors.hover,\n    border = colors.border,\n    highlight = colors.highlight\n    }\n    -- Apply colors to multiple UI elements\n    for _, element in ipairs(uiElements) do\n        element:SetColor(ui.primary)\n        element:SetTextColor(ui.text)\n    end\n    return ui\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#lerp","title":"lerp","text":"<p>Purpose</p> <p>Interpolates between two colors using frame time for smooth transitions</p> <p>When Called</p> <p>During theme transitions to smoothly blend between colors</p> <p>Parameters</p> <ul> <li><code>frac</code> (number): Interpolation factor/speed multiplier</li> <li><code>col1</code> (Color): Starting color</li> <li><code>col2</code> (Color): Target color</li> </ul> <p>Returns</p> <ul> <li>Color - Interpolated color between col1 and col2</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Lerp between colors\nlocal blendedColor = lia.color.lerp(5, Color(255, 0, 0), Color(0, 255, 0))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Smooth color transition\nlocal function fadeBetweenColors(startColor, endColor, duration)\n    local startTime = CurTime()\n    hook.Add(\"Think\", \"ColorFade\", function()\n    local elapsed = CurTime() - startTime\n    local progress = math.min(elapsed / duration, 1)\n    if progress &gt;= 1 then\n        hook.Remove(\"Think\", \"ColorFade\")\n    end\n    local currentColor = lia.color.lerp(10, startColor, endColor)\n    -- Use currentColor for UI elements\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Multi-color gradient system\nlocal function createColorGradient(colors, steps)\n    local gradient = {}\n    for i = 1, steps do\n        local t = (i - 1) / (steps - 1)\n        local colorIndex = math.floor(t * (#colors - 1)) + 1\n        local nextIndex = math.min(colorIndex + 1, #colors)\n        local localT = (t * (#colors - 1)) - (colorIndex - 1)\n        gradient[i] = lia.color.lerp(1, colors[colorIndex], colors[nextIndex])\n    end\n    return gradient\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#liacolor","title":"lia.Color","text":"<p>Purpose</p> <p>Interpolates between two colors using frame time for smooth transitions</p> <p>When Called</p> <p>During theme transitions to smoothly blend between colors</p> <p>Parameters</p> <ul> <li><code>frac</code> (number): Interpolation factor/speed multiplier</li> <li><code>col1</code> (Color): Starting color</li> <li><code>col2</code> (Color): Target color</li> </ul> <p>Returns</p> <ul> <li>Color - Interpolated color between col1 and col2</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Lerp between colors\nlocal blendedColor = lia.color.lerp(5, Color(255, 0, 0), Color(0, 255, 0))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Smooth color transition\nlocal function fadeBetweenColors(startColor, endColor, duration)\n    local startTime = CurTime()\n    hook.Add(\"Think\", \"ColorFade\", function()\n    local elapsed = CurTime() - startTime\n    local progress = math.min(elapsed / duration, 1)\n    if progress &gt;= 1 then\n        hook.Remove(\"Think\", \"ColorFade\")\n    end\n    local currentColor = lia.color.lerp(10, startColor, endColor)\n    -- Use currentColor for UI elements\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Multi-color gradient system\nlocal function createColorGradient(colors, steps)\n    local gradient = {}\n    for i = 1, steps do\n        local t = (i - 1) / (steps - 1)\n        local colorIndex = math.floor(t * (#colors - 1)) + 1\n        local nextIndex = math.min(colorIndex + 1, #colors)\n        local localT = (t * (#colors - 1)) - (colorIndex - 1)\n        gradient[i] = lia.color.lerp(1, colors[colorIndex], colors[nextIndex])\n    end\n    return gradient\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#registertheme","title":"registerTheme","text":"<p>Purpose</p> <p>Registers a new theme with color definitions</p> <p>When Called</p> <p>When creating custom themes or extending the theme system</p> <p>Parameters</p> <ul> <li><code>name</code> (string): Name of the theme to register</li> <li><code>themeData</code> (table): Table containing color definitions for the theme</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic theme\nlia.color.registerTheme(\"MyTheme\", {\nmaincolor = Color(100, 150, 200),\nbackground = Color(20, 20, 20),\ntext = Color(255, 255, 255)\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register theme with full color set\nlia.color.registerTheme(\"CustomDark\", {\nheader = Color(40, 40, 40),\nbackground = Color(25, 25, 25),\nbutton = Color(54, 54, 54),\nmaincolor = Color(106, 108, 197),\ntext = Color(255, 255, 255),\naccent = Color(106, 108, 197)\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic theme generation\nlocal function generateThemeFromConfig(config)\n    local themeData = {\n    maincolor = Color(config.primary.r, config.primary.g, config.primary.b),\n    background = Color(config.background.r, config.background.g, config.background.b),\n    text = Color(config.text.r, config.text.g, config.text.b),\n    accent = Color(config.accent.r, config.accent.g, config.accent.b),\n    panel = {\n    Color(config.panel1.r, config.panel1.g, config.panel1.b),\n    Color(config.panel2.r, config.panel2.g, config.panel2.b),\n    Color(config.panel3.r, config.panel3.g, config.panel3.b)\n    }\n    }\n    lia.color.registerTheme(config.name, themeData)\nend\n</code></pre></p>"},{"location":"libraries/lia.color/#getallthemes","title":"getAllThemes","text":"<p>Purpose</p> <p>Gets a list of all available theme names</p> <p>When Called</p> <p>When building theme selection menus or validating theme names</p> <p>Returns</p> <ul> <li>table - Array of theme names in alphabetical order</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all themes\nlocal themes = lia.color.getAllThemes()\nprint(\"Available themes:\", table.concat(themes, \", \"))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create theme selection menu\nlocal function createThemeMenu()\n    local themes = lia.color.getAllThemes()\n    local menu = vgui.Create(\"DFrame\")\n    for _, themeName in ipairs(themes) do\n        local button = vgui.Create(\"DButton\", menu)\n        button:SetText(themeName)\n        button.DoClick = function()\n        lia.color.applyTheme(themeName, true)\n    end\nend\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Theme validation and management system\nlocal function validateAndManageThemes()\n    local themes = lia.color.getAllThemes()\n    local validThemes = {}\n    for _, themeName in ipairs(themes) do\n        local themeData = lia.color.themes[themeName]\n        if themeData and themeData.maincolor then\n            table.insert(validThemes, {\n            name = themeName,\n            displayName = themeName:gsub(\"_\", \" \"):gsub(\"(%a)([%w]*)\", function(first, rest)\n            return first:upper() .. rest:lower()\n        end),\n        mainColor = themeData.maincolor\n        })\n    end\nend\nreturn validThemes\nend\n</code></pre></p>"},{"location":"libraries/lia.commands/","title":"Commands Library","text":"<p>Comprehensive command registration, parsing, and execution system for the Lilia framework.</p> <p>Overview</p> <p>The commands library provides comprehensive functionality for managing and executing commands in the Lilia framework. It handles command registration, argument parsing, access control, privilege management, and command execution across both server and client sides. The library supports complex argument types including players, booleans, strings, and tables, with automatic syntax generation and validation. It integrates with the administrator system for privilege-based access control and provides user interface elements for command discovery and argument prompting. The library ensures secure command execution with proper permission checks and logging capabilities.</p>"},{"location":"libraries/lia.commands/#buildsyntaxfromarguments","title":"buildSyntaxFromArguments","text":"<p>Purpose</p> <p>Generates a human-readable syntax string from command argument definitions</p> <p>When Called</p> <p>Automatically called by lia.command.add when registering commands</p> <p>Parameters</p> <ul> <li><code>args</code> (table): Array of argument definition tables with type, name, and optional properties</li> </ul> <p>Returns</p> <ul> <li>string - Formatted syntax string showing argument types and names</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Generate syntax for basic arguments\nlocal args = {\n{type = \"string\", name = \"target\"},\n{type = \"player\", name = \"player\"}\n}\nlocal syntax = lia.command.buildSyntaxFromArguments(args)\n-- Returns: \"[string target] [player player]\"\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Generate syntax with optional arguments\nlocal args = {\n{type = \"string\", name = \"message\"},\n{type = \"bool\", name = \"silent\", optional = true}\n}\nlocal syntax = lia.command.buildSyntaxFromArguments(args)\n-- Returns: \"[string message] [bool silent optional]\"\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Generate syntax for complex command with multiple argument types\nlocal args = {\n{type = \"player\", name = \"target\"},\n{type = \"string\", name = \"reason\"},\n{type = \"number\", name = \"duration\", optional = true},\n{type = \"bool\", name = \"notify\", optional = true}\n}\nlocal syntax = lia.command.buildSyntaxFromArguments(args)\n-- Returns: \"[player target] [string reason] [number duration optional] [bool notify optional]\"\n</code></pre></p>"},{"location":"libraries/lia.commands/#add","title":"add","text":"<p>Purpose</p> <p>Registers a new command with the command system, handling privileges, aliases, and access control</p> <p>When Called</p> <p>When registering commands during gamemode initialization or module loading</p> <p>Parameters</p> <ul> <li><code>command</code> (string): The command name, data (table) - Command configuration including onRun, arguments, privilege, etc.</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic command\nlia.command.add(\"hello\", {\nonRun = function(client, arguments)\nclient:notify(\"Hello, \" .. client:Name() .. \"!\")\nend,\ndesc = \"Say hello\"\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register command with arguments and admin privilege\nlia.command.add(\"kick\", {\narguments = {\n{type = \"player\", name = \"target\"},\n{type = \"string\", name = \"reason\", optional = true}\n},\nonRun = function(client, arguments)\nlocal target = arguments[1]\nlocal reason = arguments[2] or \"No reason provided\"\ntarget:Kick(reason)\nclient:notify(\"Kicked \" .. target:Name())\nend,\nadminOnly = true,\ndesc = \"Kick a player from the server\"\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register complex command with aliases, custom access check, and privilege\nlia.command.add(\"ban\", {\narguments = {\n{type = \"player\", name = \"target\"},\n{type = \"string\", name = \"reason\"},\n{type = \"number\", name = \"duration\", optional = true}\n},\nalias = {\"tempban\", \"tban\"},\nonRun = function(client, arguments)\nlocal target = arguments[1]\nlocal reason = arguments[2]\nlocal duration = arguments[3] or 0\n-- Ban logic here\nend,\nonCheckAccess = function(client, command, data)\nreturn client:IsSuperAdmin() or client:hasPrivilege(\"moderation\")\nend,\nprivilege = \"moderation\",\ndesc = \"Ban a player temporarily or permanently\"\n})\n</code></pre></p>"},{"location":"libraries/lia.commands/#hasaccess","title":"hasAccess","text":"<p>Purpose</p> <p>Checks if a client has access to execute a specific command based on privileges, faction, and class permissions</p> <p>When Called</p> <p>Before command execution to verify player permissions</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to use the command, command (string) - Command name, data (table, optional) - Command data table</li> </ul> <p>Returns</p> <ul> <li>boolean, string - Access granted status and privilege name</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check basic command access\nlocal hasAccess, privilege = lia.command.hasAccess(client, \"hello\")\nif hasAccess then\n    client:notify(\"You can use the hello command!\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check admin command access with custom privilege\nlocal hasAccess, privilege = lia.command.hasAccess(client, \"kick\")\nif not hasAccess then\n    client:notifyError(\"You need \" .. privilege .. \" to use this command!\")\n    return\nend\n-- Execute kick command\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check access with faction/class specific permissions\nlocal hasAccess, privilege = lia.command.hasAccess(client, \"arrest\")\nif hasAccess then\n    local char = client:getChar()\n    local faction = lia.faction.indices[char:getFaction()]\n    if faction and faction.commands and faction.commands[\"arrest\"] then\n        client:notify(\"Faction command access granted!\")\n        elseif client:hasPrivilege(privilege) then\n            client:notify(\"Privilege-based access granted!\")\n        end\n        else\n            client:notifyError(\"Access denied: \" .. privilege)\n        end\n</code></pre></p>"},{"location":"libraries/lia.commands/#extractargs","title":"extractArgs","text":"<p>Purpose</p> <p>Parses command text and extracts individual arguments, handling quoted strings and spaces</p> <p>When Called</p> <p>When parsing command input to separate arguments for command execution</p> <p>Parameters</p> <ul> <li><code>text</code> (string): The command text to parse (excluding the command name)</li> </ul> <p>Returns</p> <ul> <li>table - Array of extracted argument strings</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Extract basic arguments\nlocal args = lia.command.extractArgs(\"player1 Hello World\")\n-- Returns: {\"player1\", \"Hello\", \"World\"}\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Extract arguments with quoted strings\nlocal args = lia.command.extractArgs('player1 \"Hello World\" true')\n-- Returns: {\"player1\", \"Hello World\", \"true\"}\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Extract complex arguments with mixed quotes and spaces\nlocal args = lia.command.extractArgs('\"John Doe\" \"This is a long message with spaces\" 123 true')\n-- Returns: {\"John Doe\", \"This is a long message with spaces\", \"123\", \"true\"}\n-- Process arguments for command\nlocal target = args[1]\nlocal message = args[2]\nlocal duration = tonumber(args[3])\nlocal silent = args[4] == \"true\"\n</code></pre></p>"},{"location":"libraries/lia.commands/#run","title":"run","text":"<p>Purpose</p> <p>Executes a registered command for a client with proper error handling and result processing</p> <p>When Called</p> <p>When a command needs to be executed after parsing and access validation</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player executing the command, command (string) - Command name, arguments (table) - Command arguments</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Execute a basic command\nlia.command.run(client, \"hello\", {})\n-- Executes the hello command for the client\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Execute command with arguments\nlocal args = {\"player1\", \"Hello World\"}\nlia.command.run(client, \"pm\", args)\n-- Executes PM command with target and message\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Execute command with error handling and logging\nlocal command = \"kick\"\nlocal args = {target:Name(), \"Rule violation\"}\n-- Check access first\nlocal hasAccess = lia.command.hasAccess(client, command)\nif hasAccess then\n    lia.command.run(client, command, args)\n    lia.log.add(client, \"command\", \"/\" .. command .. \" \" .. table.concat(args, \" \"))\n    else\n        client:notifyError(\"Access denied!\")\n    end\n</code></pre></p>"},{"location":"libraries/lia.commands/#parse","title":"parse","text":"<p>Purpose</p> <p>Parses command text input, validates arguments, and executes commands with proper error handling</p> <p>When Called</p> <p>When processing player chat input or console commands that start with \"/\"</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player executing the command, text (string) - Full command text, realCommand (string, optional) - Pre-parsed command name, arguments (table, optional) - Pre-parsed arguments</li> </ul> <p>Returns</p> <ul> <li>boolean - True if command was processed, false if not a command</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Parse basic command from chat\nlocal success = lia.command.parse(client, \"/hello\")\nif success then\n    -- Command was processed\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Parse command with arguments\nlocal success = lia.command.parse(client, \"/kick player1 Rule violation\")\nif success then\n    -- Kick command was executed\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Parse command with argument validation and prompting\nlocal text = \"/pm\"\nlocal success = lia.command.parse(client, text)\nif success then\n    -- If arguments are missing, client will be prompted\n    -- If arguments are valid, PM command will execute\n    else\n        -- Not a command, treat as regular chat\n        lia.chatbox.add(client, text)\n    end\n</code></pre></p>"},{"location":"libraries/lia.commands/#openargumentprompt","title":"openArgumentPrompt","text":"<p>Purpose</p> <p>Creates a GUI prompt for users to input missing command arguments with validation</p> <p>When Called</p> <p>When a command is executed with missing required arguments</p> <p>Parameters</p> <ul> <li><code>cmdKey</code> (string): Command name, missing (table) - Array of missing argument names, prefix (table) - Already provided arguments</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open prompt for single missing argument\nlia.command.openArgumentPrompt(\"pm\", {\"target\"}, {})\n-- Shows GUI to select target player for PM command\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Open prompt with partial arguments\nlia.command.openArgumentPrompt(\"kick\", {\"reason\"}, {\"player1\"})\n-- Shows GUI to enter reason, player1 already provided\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Open prompt for complex command with multiple argument types\nlia.command.openArgumentPrompt(\"ban\", {\"reason\", \"duration\"}, {\"player1\"})\n-- Shows GUI with:\n-- - Reason text field\n-- - Duration number field\n-- - Submit button (enabled when all required fields filled)\n-- - Cancel button\n</code></pre></p>"},{"location":"libraries/lia.commands/#liactrlonvaluechange","title":"lia.ctrl:OnValueChange","text":"<p>Purpose</p> <p>Creates a GUI prompt for users to input missing command arguments with validation</p> <p>When Called</p> <p>When a command is executed with missing required arguments</p> <p>Parameters</p> <ul> <li><code>cmdKey</code> (string): Command name, missing (table) - Array of missing argument names, prefix (table) - Already provided arguments</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open prompt for single missing argument\nlia.command.openArgumentPrompt(\"pm\", {\"target\"}, {})\n-- Shows GUI to select target player for PM command\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Open prompt with partial arguments\nlia.command.openArgumentPrompt(\"kick\", {\"reason\"}, {\"player1\"})\n-- Shows GUI to enter reason, player1 already provided\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Open prompt for complex command with multiple argument types\nlia.command.openArgumentPrompt(\"ban\", {\"reason\", \"duration\"}, {\"player1\"})\n-- Shows GUI with:\n-- - Reason text field\n-- - Duration number field\n-- - Submit button (enabled when all required fields filled)\n-- - Cancel button\n</code></pre></p>"},{"location":"libraries/lia.commands/#liactrlontextchanged","title":"lia.ctrl:OnTextChanged","text":"<p>Purpose</p> <p>Creates a GUI prompt for users to input missing command arguments with validation</p> <p>When Called</p> <p>When a command is executed with missing required arguments</p> <p>Parameters</p> <ul> <li><code>cmdKey</code> (string): Command name, missing (table) - Array of missing argument names, prefix (table) - Already provided arguments</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open prompt for single missing argument\nlia.command.openArgumentPrompt(\"pm\", {\"target\"}, {})\n-- Shows GUI to select target player for PM command\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Open prompt with partial arguments\nlia.command.openArgumentPrompt(\"kick\", {\"reason\"}, {\"player1\"})\n-- Shows GUI to enter reason, player1 already provided\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Open prompt for complex command with multiple argument types\nlia.command.openArgumentPrompt(\"ban\", {\"reason\", \"duration\"}, {\"player1\"})\n-- Shows GUI with:\n-- - Reason text field\n-- - Duration number field\n-- - Submit button (enabled when all required fields filled)\n-- - Cancel button\n</code></pre></p>"},{"location":"libraries/lia.commands/#liactrlonchange","title":"lia.ctrl:OnChange","text":"<p>Purpose</p> <p>Creates a GUI prompt for users to input missing command arguments with validation</p> <p>When Called</p> <p>When a command is executed with missing required arguments</p> <p>Parameters</p> <ul> <li><code>cmdKey</code> (string): Command name, missing (table) - Array of missing argument names, prefix (table) - Already provided arguments</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open prompt for single missing argument\nlia.command.openArgumentPrompt(\"pm\", {\"target\"}, {})\n-- Shows GUI to select target player for PM command\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Open prompt with partial arguments\nlia.command.openArgumentPrompt(\"kick\", {\"reason\"}, {\"player1\"})\n-- Shows GUI to enter reason, player1 already provided\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Open prompt for complex command with multiple argument types\nlia.command.openArgumentPrompt(\"ban\", {\"reason\", \"duration\"}, {\"player1\"})\n-- Shows GUI with:\n-- - Reason text field\n-- - Duration number field\n-- - Submit button (enabled when all required fields filled)\n-- - Cancel button\n</code></pre></p>"},{"location":"libraries/lia.commands/#liactrlonselect","title":"lia.ctrl:OnSelect","text":"<p>Purpose</p> <p>Creates a GUI prompt for users to input missing command arguments with validation</p> <p>When Called</p> <p>When a command is executed with missing required arguments</p> <p>Parameters</p> <ul> <li><code>cmdKey</code> (string): Command name, missing (table) - Array of missing argument names, prefix (table) - Already provided arguments</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open prompt for single missing argument\nlia.command.openArgumentPrompt(\"pm\", {\"target\"}, {})\n-- Shows GUI to select target player for PM command\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Open prompt with partial arguments\nlia.command.openArgumentPrompt(\"kick\", {\"reason\"}, {\"player1\"})\n-- Shows GUI to enter reason, player1 already provided\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Open prompt for complex command with multiple argument types\nlia.command.openArgumentPrompt(\"ban\", {\"reason\", \"duration\"}, {\"player1\"})\n-- Shows GUI with:\n-- - Reason text field\n-- - Duration number field\n-- - Submit button (enabled when all required fields filled)\n-- - Cancel button\n</code></pre></p>"},{"location":"libraries/lia.commands/#send","title":"send","text":"<p>Purpose</p> <p>Sends a command execution request from client to server via network</p> <p>When Called</p> <p>When client needs to execute a command on the server</p> <p>Parameters</p> <ul> <li><code>command</code> (string): Command name, ... (vararg) - Command arguments</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send basic command\nlia.command.send(\"hello\")\n-- Sends hello command to server\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send command with arguments\nlia.command.send(\"pm\", \"player1\", \"Hello there!\")\n-- Sends PM command with target and message\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send complex command with multiple arguments\nlocal target = \"player1\"\nlocal reason = \"Rule violation\"\nlocal duration = 300\nlia.command.send(\"ban\", target, reason, duration)\n-- Sends ban command with all parameters\n</code></pre></p>"},{"location":"libraries/lia.config/","title":"Configuration Library","text":"<p>Comprehensive user-configurable settings management system for the Lilia framework.</p> <p>Overview</p> <p>The configuration library provides comprehensive functionality for managing user-configurable settings in the Lilia framework. It handles the creation, storage, retrieval, and persistence of various types of options including boolean toggles, numeric sliders, color pickers, text inputs, and dropdown selections. The library operates on both client and server sides, with automatic persistence to JSON files and optional networking capabilities for server-side options. It includes a complete user interface system for displaying and modifying options through the configuration menu, with support for categories, visibility conditions, and real-time updates. The library ensures that all user preferences are maintained across sessions and provides hooks for modules to react to option changes.</p>"},{"location":"libraries/lia.config/#add","title":"add","text":"<p>Purpose</p> <p>Adds a new configuration option to the system with specified properties and validation</p> <p>When Called</p> <p>During gamemode initialization, module loading, or when registering new config options</p> <p>Parameters</p> <ul> <li><code>key</code> (string): Unique identifier for the configuration option</li> <li><code>name</code> (string): Display name for the configuration option</li> <li><code>value</code> (any): Default value for the configuration option</li> <li><code>callback</code> (function, optional): Function to call when the option value changes</li> <li><code>data</code> (table): Configuration metadata including type, description, category, and constraints</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a basic boolean configuration\nlia.config.add(\"EnableFeature\", \"Enable Feature\", true, nil, {\ndesc = \"Enable or disable this feature\",\ncategory = \"general\",\ntype = \"Boolean\"\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add configuration with callback and constraints\nlia.config.add(\"WalkSpeed\", \"Walk Speed\", 130, function(_, newValue)\nfor _, client in player.Iterator() do\n    client:SetWalkSpeed(newValue)\nend\nend, {\ndesc = \"Player walking speed\",\ncategory = \"character\",\ntype = \"Int\",\nmin = 50,\nmax = 300\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add configuration with dynamic options and complex validation\nlia.config.add(\"Language\", \"Language\", \"English\", nil, {\ndesc = \"Select your preferred language\",\ncategory = \"general\",\ntype = \"Table\",\noptions = function()\nlocal languages = {}\nfor code, data in pairs(lia.lang.getLanguages()) do\n    languages[data.name] = code\nend\nreturn languages\nend\n})\n</code></pre></p>"},{"location":"libraries/lia.config/#getoptions","title":"getOptions","text":"<p>Purpose</p> <p>Retrieves the available options for a configuration setting, supporting both static and dynamic option lists</p> <p>When Called</p> <p>When building UI elements for configuration options, particularly dropdown menus and selection lists</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The configuration key to get options for</li> </ul> <p>Returns</p> <ul> <li>table - Array of available options for the configuration</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get static options for a configuration\nlocal options = lia.config.getOptions(\"DermaSkin\")\nfor _, option in ipairs(options) do\n    print(\"Available skin:\", option)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use options in UI creation\nlocal combo = vgui.Create(\"liaComboBox\")\nlocal options = lia.config.getOptions(\"Language\")\nfor _, text in pairs(options) do\n    combo:AddChoice(text, text)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic options with validation and filtering\nlocal function createDynamicOptions()\n    local options = lia.config.getOptions(\"DefaultMenuTab\")\n    local filteredOptions = {}\n    for key, value in pairs(options) do\n        if IsValid(value) and value:IsVisible() then\n            filteredOptions[key] = value\n        end\n    end\n    return filteredOptions\nend\n</code></pre></p>"},{"location":"libraries/lia.config/#setdefault","title":"setDefault","text":"<p>Purpose</p> <p>Updates the default value for an existing configuration option without changing the current value</p> <p>When Called</p> <p>During configuration updates, module reloads, or when default values need to be changed</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The configuration key to update the default for</li> <li><code>value</code> (any): The new default value to set</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Update default value for a configuration\nlia.config.setDefault(\"MaxCharacters\", 10)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update default based on server conditions\nlocal maxChars = SERVER and 5 or 3\nlia.config.setDefault(\"MaxCharacters\", maxChars)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Update multiple defaults based on module availability\nlocal function updateModuleDefaults()\n    local defaults = {\n    MaxCharacters = lia.module.get(\"characters\") and 5 or 1,\n    AllowPMs = lia.module.get(\"chatbox\") and true or false,\n    WalkSpeed = lia.module.get(\"attributes\") and 130 or 100\n    }\n    for key, value in pairs(defaults) do\n        lia.config.setDefault(key, value)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.config/#forceset","title":"forceSet","text":"<p>Purpose</p> <p>Forces a configuration value to be set immediately without triggering networking or callbacks, with optional save control</p> <p>When Called</p> <p>During initialization, module loading, or when bypassing normal configuration update mechanisms</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The configuration key to set</li> <li><code>value</code> (any): The value to set</li> <li><code>noSave</code> (boolean, optional): If true, prevents automatic saving of the configuration</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Force set a configuration value\nlia.config.forceSet(\"WalkSpeed\", 150)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Force set without saving for temporary changes\nlia.config.forceSet(\"DebugMode\", true, true)\n-- Do some debug operations\nlia.config.forceSet(\"DebugMode\", false, true)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Bulk force set with conditional saving\nlocal function applyModuleConfigs(moduleName, configs, saveAfter)\n    for key, value in pairs(configs) do\n        lia.config.forceSet(key, value, not saveAfter)\n    end\n    if saveAfter then\n        lia.config.save()\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.config/#set","title":"set","text":"<p>Purpose</p> <p>Sets a configuration value with full networking, callback execution, and automatic saving on server</p> <p>When Called</p> <p>When users change configuration values through UI, commands, or programmatic updates</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The configuration key to set</li> <li><code>value</code> (any): The value to set</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set a configuration value\nlia.config.set(\"WalkSpeed\", 150)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set configuration with validation\nlocal function setConfigWithValidation(key, value, min, max)\n    if type(value) == \"number\" and value &gt;= min and value &lt;= max then\n        lia.config.set(key, value)\n        else\n            print(\"Invalid value for \" .. key)\n        end\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch configuration updates with rollback\nlocal function batchConfigUpdate(updates)\n    local originalValues = {}\n    for key, value in pairs(updates) do\n        originalValues[key] = lia.config.get(key)\n        lia.config.set(key, value)\n    end\n    return function()\n    for key, value in pairs(originalValues) do\n        lia.config.set(key, value)\n    end\nend\nend\n</code></pre></p>"},{"location":"libraries/lia.config/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves the current value of a configuration option with fallback to default values</p> <p>When Called</p> <p>When reading configuration values for gameplay logic, UI updates, or module functionality</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The configuration key to retrieve</li> <li><code>default</code> (any, optional): Fallback value if configuration doesn't exist</li> </ul> <p>Returns</p> <ul> <li>any - The current configuration value, default value, or provided fallback</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a configuration value\nlocal walkSpeed = lia.config.get(\"WalkSpeed\")\nplayer:SetWalkSpeed(walkSpeed)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get configuration with validation and fallback\nlocal function getConfigValue(key, expectedType, fallback)\n    local value = lia.config.get(key, fallback)\n    if type(value) == expectedType then\n        return value\n        else\n            return fallback\n        end\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get multiple configurations with type checking and validation\nlocal function getPlayerSettings()\n    local settings = {}\n    local configs = {\n    walkSpeed = {\"WalkSpeed\", \"number\", 130},\n    runSpeed = {\"RunSpeed\", \"number\", 275},\n    maxChars = {\"MaxCharacters\", \"number\", 5}\n    }\n    for setting, data in pairs(configs) do\n        local key, expectedType, fallback = data[1], data[2], data[3]\n        local value = lia.config.get(key, fallback)\n        settings[setting] = type(value) == expectedType and value or fallback\n    end\n    return settings\nend\n</code></pre></p>"},{"location":"libraries/lia.config/#load","title":"load","text":"<p>Purpose</p> <p>Loads configuration values from the database on server or requests them from server on client</p> <p>When Called</p> <p>During gamemode initialization, after database connection, or when configuration needs to be refreshed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load configurations during initialization\nlia.config.load()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load configurations with callback\nlia.config.load()\nhook.Add(\"InitializedConfig\", \"MyModule\", function()\nprint(\"Configurations loaded successfully\")\n-- Initialize module with loaded configs\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load configurations with error handling and fallback\nlocal function loadConfigWithFallback()\n    local success = pcall(lia.config.load)\n    if not success then\n        print(\"Failed to load configurations, using defaults\")\n        -- Apply default configurations\n        for key, config in pairs(lia.config.stored) do\n            config.value = config.default\n        end\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.config/#getchangedvalues","title":"getChangedValues","text":"<p>Purpose</p> <p>Retrieves all configuration values that differ from their default values for efficient synchronization</p> <p>When Called</p> <p>Before sending configurations to clients or when preparing configuration data for export</p> <p>Returns</p> <ul> <li>table - Dictionary of changed configuration keys and their current values</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all changed values\nlocal changed = lia.config.getChangedValues()\nprint(\"Changed configurations:\", table.Count(changed))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send only changed configurations to specific client\nlocal function sendConfigToClient(client)\n    local changed = lia.config.getChangedValues()\n    if table.Count(changed) &gt; 0 then\n        net.Start(\"liaCfgList\")\n        net.WriteTable(changed)\n        net.Send(client)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Export changed configurations with filtering and validation\nlocal function exportChangedConfigs(filterFunc)\n    local changed = lia.config.getChangedValues()\n    local filtered = {}\n    for key, value in pairs(changed) do\n        local config = lia.config.stored[key]\n        if config and (not filterFunc or filterFunc(key, value, config)) then\n            filtered[key] = {\n            value = value,\n            name = config.name,\n            category = config.category,\n            type = config.data.type\n            }\n        end\n    end\n    return filtered\nend\n</code></pre></p>"},{"location":"libraries/lia.config/#send","title":"send","text":"<p>Purpose</p> <p>Sends configuration data to clients with intelligent batching and rate limiting for large datasets</p> <p>When Called</p> <p>When a client connects, when configurations change, or when manually syncing configurations</p> <p>Parameters</p> <ul> <li><code>client</code> (Player, optional): Specific client to send to, or nil to send to all clients</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send configurations to all clients\nlia.config.send()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send configurations to specific client on connect\nhook.Add(\"PlayerInitialSpawn\", \"SendConfigs\", function(client)\ntimer.Simple(1, function()\nif IsValid(client) then\n    lia.config.send(client)\nend\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send configurations with priority and filtering\nlocal function sendConfigsWithPriority(priority, filterFunc)\n    local changed = lia.config.getChangedValues()\n    local filtered = {}\n    for key, value in pairs(changed) do\n        local config = lia.config.stored[key]\n        if config and (not filterFunc or filterFunc(key, value, config)) then\n            if config.data.priority == priority then\n                filtered[key] = value\n            end\n        end\n    end\n    if table.Count(filtered) &gt; 0 then\n        net.Start(\"liaCfgList\")\n        net.WriteTable(filtered)\n        net.Broadcast()\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.config/#save","title":"save","text":"<p>Purpose</p> <p>Saves all changed configuration values to the database using transaction-based operations</p> <p>When Called</p> <p>When configuration values change, during server shutdown, or when manually saving configurations</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Save all configurations\nlia.config.save()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save configurations with error handling\nlocal function saveConfigsSafely()\n    local success, err = pcall(lia.config.save)\n    if not success then\n        print(\"Failed to save configurations:\", err)\n        -- Implement fallback or retry logic\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Save configurations with backup and validation\nlocal function saveConfigsWithBackup()\n    local changed = lia.config.getChangedValues()\n    if table.Count(changed) == 0 then return end\n        -- Create backup\n        local backup = util.TableToJSON(changed)\n        file.Write(\"config_backup_\" .. os.time() .. \".json\", backup)\n        -- Save with validation\n        local success, err = pcall(lia.config.save)\n        if not success then\n            print(\"Save failed, restoring from backup\")\n            -- Restore from backup logic\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.config/#reset","title":"reset","text":"<p>Purpose</p> <p>Resets all configuration values to their default values and synchronizes changes to clients</p> <p>When Called</p> <p>When resetting server configurations, during maintenance, or when reverting to defaults</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Reset all configurations to defaults\nlia.config.reset()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Reset configurations with confirmation\nlocal function resetConfigsWithConfirmation()\n    print(\"Resetting all configurations to defaults...\")\n    lia.config.reset()\n    print(\"Configuration reset complete\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Reset configurations with selective restoration and logging\nlocal function resetConfigsSelectively(keepConfigs)\n    local originalValues = {}\n    -- Store current values for configs to keep\n    for _, key in ipairs(keepConfigs) do\n        originalValues[key] = lia.config.get(key)\n    end\n    -- Reset all configurations\n    lia.config.reset()\n    -- Restore selected configurations\n    for key, value in pairs(originalValues) do\n        lia.config.set(key, value)\n    end\n    print(\"Reset complete, restored \" .. table.Count(originalValues) .. \" configurations\")\nend\n</code></pre></p>"},{"location":"libraries/lia.currency/","title":"Currency Library","text":"<p>In-game currency formatting, display, and management system for the Lilia framework.</p> <p>Overview</p> <p>The currency library provides comprehensive functionality for managing in-game currency within the Lilia framework. It handles currency formatting, display, and physical money entity spawning. The library operates on both server and client sides, with the server handling money entity creation and spawning, while the client handles currency display formatting. It includes localization support for currency names and symbols, ensuring proper pluralization and formatting based on amount values. The library integrates with the configuration system to allow customizable currency symbols and names.</p>"},{"location":"libraries/lia.currency/#get","title":"get","text":"<p>Purpose</p> <p>Formats a currency amount with the proper symbol, singular/plural form, and localization.</p> <p>When Called</p> <p>When displaying currency amounts in UI, chat messages, or any text output.</p> <p>Returns</p> <ul> <li>string Formatted currency string with symbol and proper singular/plural form.</li> </ul> <p>Realm</p> <p>Shared (works on both client and server)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Format a basic currency amount\nlocal formatted = lia.currency.get(100)\nprint(formatted) -- \"$100 dollars\" (example output)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Format currency with conditional display\nlocal playerMoney = 1500\nif playerMoney &gt; 0 then\n    local displayText = \"Balance: \" .. lia.currency.get(playerMoney)\n    chat.AddText(Color(255, 255, 255), displayText)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Format multiple currency amounts with validation\nlocal transactions = {100, 1, 0, -50, 2500}\nfor _, amount in ipairs(transactions) do\n    if amount and amount ~= 0 then\n        local formatted = lia.currency.get(math.abs(amount))\n        local prefix = amount &gt; 0 and \"+\" or \"-\"\n        print(prefix .. formatted)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.currency/#spawn","title":"spawn","text":"<p>Purpose</p> <p>Creates and spawns a physical money entity at the specified position with the given amount.</p> <p>When Called</p> <p>When spawning money drops, creating money rewards, or placing currency in the world.</p> <p>Returns</p> <ul> <li>Entity The created money entity if successful, nil if parameters are invalid.</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Spawn money at player's position\nlocal pos = player:GetPos()\nlia.currency.spawn(pos, 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Spawn money with specific angle and validation\nlocal dropPos = trace.HitPos\nlocal dropAmount = math.random(50, 200)\nif dropPos then\n    local money = lia.currency.spawn(dropPos, dropAmount, Angle(0, math.random(0, 360), 0))\n    if money then\n        print(\"Money spawned successfully\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Spawn multiple money entities with advanced positioning\nlocal spawnPositions = {\n{pos = Vector(100, 200, 50), amount = 500, angle = Angle(0, 45, 0)},\n{pos = Vector(-100, 200, 50), amount = 250, angle = Angle(0, 90, 0)},\n{pos = Vector(0, 0, 100), amount = 1000, angle = Angle(0, 180, 0)}\n}\nfor _, data in ipairs(spawnPositions) do\n    local money = lia.currency.spawn(data.pos, data.amount, data.angle)\n    if money then\n        money:SetVelocity(Vector(math.random(-50, 50), math.random(-50, 50), 100))\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.darkrp/","title":"DarkRP Compatibility Library","text":"<p>The DarkRP compatibility library provides essential functions for maintaining compatibility</p>"},{"location":"libraries/lia.darkrp/#isempty","title":"isEmpty","text":"<p>Purpose</p> <p>Checks if a given position is empty and suitable for spawning entities or players</p> <p>When Called</p> <p>Called when checking spawn positions, entity placement, or any position validation</p> <p>Parameters</p> <ul> <li><code>position</code> (Vector): The world position to check</li> <li><code>entitiesToIgnore</code> (table, optional): Table of entities to ignore during the check</li> </ul> <p>Returns</p> <ul> <li>boolean - true if the position is empty, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if a position is empty\nlocal pos = Vector(100, 200, 50)\nif lia.darkrp.isEmpty(pos) then\n    print(\"Position is empty\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check position while ignoring specific entities\nlocal pos = player:GetPos()\nlocal ignoreEntities = {player, someProp}\nif lia.darkrp.isEmpty(pos, ignoreEntities) then\n    player:SetPos(pos)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Validate spawn position with multiple checks\nlocal spawnPos = Vector(0, 0, 0)\nlocal ignoreList = {}\nfor _, ent in ipairs(ents.GetAll()) do\n    if ent:GetClass() == \"prop_physics\" then\n        table.insert(ignoreList, ent)\n    end\nend\nif lia.darkrp.isEmpty(spawnPos, ignoreList) then\n    local spawn = ents.Create(\"npc_citizen\")\n    spawn:SetPos(spawnPos)\n    spawn:Spawn()\nend\n</code></pre></p>"},{"location":"libraries/lia.darkrp/#findemptypos","title":"findEmptyPos","text":"<p>Purpose</p> <p>Finds the nearest empty position to a starting position within specified parameters</p> <p>When Called</p> <p>Called when spawning entities or players and the initial position is occupied</p> <p>Parameters</p> <ul> <li><code>startPos</code> (Vector): The starting position to search from</li> <li><code>entitiesToIgnore</code> (table, optional): Table of entities to ignore during the search</li> <li><code>maxDistance</code> (number): Maximum distance to search from the starting position</li> <li><code>searchStep</code> (number): Step size for the search radius</li> <li><code>checkArea</code> (Vector): Additional area to check around each position</li> </ul> <p>Returns</p> <ul> <li>Vector - The nearest empty position found, or the original position if none found</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find empty position near spawn point\nlocal spawnPos = Vector(0, 0, 0)\nlocal emptyPos = lia.darkrp.findEmptyPos(spawnPos, {}, 100, 10, Vector(0, 0, 0))\nplayer:SetPos(emptyPos)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Find spawn position ignoring specific entities\nlocal startPos = Vector(100, 200, 50)\nlocal ignoreList = {player, someNPC}\nlocal emptyPos = lia.darkrp.findEmptyPos(startPos, ignoreList, 200, 25, Vector(32, 32, 64))\nif emptyPos ~= startPos then\n    print(\"Found empty position at: \" .. tostring(emptyPos))\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced spawn system with multiple checks\nlocal spawnPoints = {Vector(0, 0, 0), Vector(100, 0, 0), Vector(0, 100, 0)}\nlocal ignoreEntities = {}\nfor _, ent in ipairs(ents.FindInSphere(Vector(0, 0, 0), 500)) do\n    if ent:IsPlayer() or ent:IsNPC() then\n        table.insert(ignoreEntities, ent)\n    end\nend\nfor _, spawnPoint in ipairs(spawnPoints) do\n    local emptyPos = lia.darkrp.findEmptyPos(spawnPoint, ignoreEntities, 150, 20, Vector(16, 16, 32))\n    if emptyPos ~= spawnPoint then\n        local newPlayer = ents.Create(\"npc_citizen\")\n        newPlayer:SetPos(emptyPos)\n        newPlayer:Spawn()\n        break\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.darkrp/#notify","title":"notify","text":"<p>Purpose</p> <p>Sends a localized notification to a client (DarkRP compatibility function)</p> <p>When Called</p> <p>Called when sending notifications to players in DarkRP-compatible systems</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to send the notification to</li> <li><code>_</code> (any): Unused parameter (DarkRP compatibility)</li> <li><code>_</code> (any): Unused parameter (DarkRP compatibility)</li> <li><code>message</code> (string): The localized message key to send</li> </ul> <p>Returns</p> <ul> <li>nil</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send basic notification\nlia.darkrp.notify(player, nil, nil, \"welcome_message\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send notification with context\nlocal message = \"player_joined\"\nlia.darkrp.notify(player, nil, nil, message)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send notifications to multiple players\nlocal message = \"server_restart_warning\"\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsValid() and ply:IsConnected() then\n        lia.darkrp.notify(ply, nil, nil, message)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.darkrp/#textwrap","title":"textWrap","text":"<p>Purpose</p> <p>Wraps text to fit within a specified maximum line width using font metrics</p> <p>When Called</p> <p>Called when displaying text in UI elements that need to fit within width constraints</p> <p>Parameters</p> <ul> <li><code>text</code> (string): The text to wrap</li> <li><code>fontName</code> (string): The font name to use for width calculations</li> <li><code>maxLineWidth</code> (number): The maximum width in pixels for each line</li> </ul> <p>Returns</p> <ul> <li>string - The wrapped text with line breaks inserted</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Wrap basic text\nlocal wrappedText = lia.darkrp.textWrap(\"Hello world this is a long text\", \"DermaDefault\", 200)\nprint(wrappedText)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Wrap text with different fonts\nlocal text = \"This is a sample text that needs to be wrapped properly\"\nlocal font = \"liaFont\"\nlocal maxWidth = 300\nlocal wrapped = lia.darkrp.textWrap(text, font, maxWidth)\n-- Display in a panel\nlocal label = vgui.Create(\"DLabel\")\nlabel:SetText(wrapped)\nlabel:SetFont(font)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic text wrapping with multiple paragraphs\nlocal paragraphs = {\n\"First paragraph with lots of text that needs wrapping\",\n\"Second paragraph with different content\",\n\"Third paragraph with even more content\"\n}\nlocal font = \"liaFont\"\nlocal maxWidth = 400\nlocal wrappedParagraphs = {}\nfor i, paragraph in ipairs(paragraphs) do\n    local wrapped = lia.darkrp.textWrap(paragraph, font, maxWidth)\n    table.insert(wrappedParagraphs, wrapped)\nend\nlocal finalText = table.concat(wrappedParagraphs, \"\\n\\n\")\n-- Use finalText in UI\n</code></pre></p>"},{"location":"libraries/lia.darkrp/#formatmoney","title":"formatMoney","text":"<p>Purpose</p> <p>Formats a numeric amount as currency using the Lilia currency system</p> <p>When Called</p> <p>Called when displaying money amounts in UI or chat messages</p> <p>Parameters</p> <ul> <li><code>amount</code> (number): The numeric amount to format</li> </ul> <p>Returns</p> <ul> <li>string - The formatted currency string</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Format a basic amount\nlocal formatted = lia.darkrp.formatMoney(1000)\nprint(formatted) -- \"$1,000\"\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Format player's money for display\nlocal playerMoney = player:getMoney()\nlocal formattedMoney = lia.darkrp.formatMoney(playerMoney)\nplayer:notifyInfoLocalized(\"your_money\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Format multiple amounts for transaction display\nlocal amounts = {500, 1250, 9999, 150000}\nlocal formattedAmounts = {}\nfor _, amount in ipairs(amounts) do\n    local formatted = lia.darkrp.formatMoney(amount)\n    table.insert(formattedAmounts, formatted)\nend\nlocal displayText = \"Transaction amounts: \" .. table.concat(formattedAmounts, \", \")\nchat.AddText(Color(255, 255, 255), displayText)\n</code></pre></p>"},{"location":"libraries/lia.darkrp/#createentity","title":"createEntity","text":"<p>Purpose</p> <p>Creates a DarkRP-compatible entity item in the Lilia item system</p> <p>When Called</p> <p>Called when registering DarkRP entities for compatibility with existing addons</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The display name of the entity</li> <li><code>data</code> (table): Table containing entity configuration data</li> <li><code>cmd</code> (string, optional): Command name for the entity</li> <li><code>model</code> (string, optional): Model path for the entity</li> <li><code>desc</code> (string, optional): Description of the entity</li> <li><code>category</code> (string, optional): Category for the entity</li> <li><code>ent</code> (string, optional): Entity class name</li> <li><code>price</code> (number, optional): Price of the entity</li> </ul> <p>Returns</p> <ul> <li>nil</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a basic entity\nlia.darkrp.createEntity(\"Chair\", {\nmodel = \"models/props_c17/FurnitureChair001a.mdl\",\nprice = 50\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create entity with full configuration\nlia.darkrp.createEntity(\"Advanced Computer\", {\ncmd = \"computer\",\nmodel = \"models/props_lab/monitor01b.mdl\",\ndesc = \"A high-tech computer for advanced operations\",\ncategory = \"Electronics\",\nent = \"prop_physics\",\nprice = 200\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create multiple entities from configuration table\nlocal entities = {\n{\nname = \"Office Desk\",\ndata = {\ncmd = \"desk\",\nmodel = \"models/props_c17/FurnitureTable002a.mdl\",\ndesc = \"A sturdy office desk\",\ncategory = \"Furniture\",\nprice = 100\n}\n},\n{\nname = \"Filing Cabinet\",\ndata = {\ncmd = \"cabinet\",\nmodel = \"models/props_c17/FurnitureDrawer001a.mdl\",\ndesc = \"Store important documents\",\ncategory = \"Furniture\",\nprice = 75\n}\n}\n}\nfor _, entity in ipairs(entities) do\n    lia.darkrp.createEntity(entity.name, entity.data)\nend\n</code></pre></p>"},{"location":"libraries/lia.darkrp/#createcategory","title":"createCategory","text":"<p>Purpose</p> <p>Creates a DarkRP-compatible category (placeholder function for compatibility)</p> <p>When Called</p> <p>Called by DarkRP addons that expect a createCategory function to exist</p> <p>Returns</p> <ul> <li>nil</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Call the function (no effect)\nlia.darkrp.createCategory()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in DarkRP compatibility code\nif DarkRP and DarkRP.createCategory then\n    lia.darkrp.createCategory()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in addon initialization\nlocal function initializeDarkRPCompatibility()\n    -- Ensure DarkRP compatibility functions exist\n    lia.darkrp.createCategory()\n    -- Other DarkRP compatibility setup\n    if DarkRP and DarkRP.createEntity then\n        print(\"DarkRP compatibility initialized\")\n    end\nend\ninitializeDarkRPCompatibility()\n</code></pre></p>"},{"location":"libraries/lia.darkrp/#liadarkrpremovechatcommand","title":"lia.DarkRP.removeChatCommand","text":"<p>Purpose</p> <p>Creates a DarkRP-compatible category (placeholder function for compatibility)</p> <p>When Called</p> <p>Called by DarkRP addons that expect a createCategory function to exist</p> <p>Returns</p> <ul> <li>nil</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Call the function (no effect)\nlia.darkrp.createCategory()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in DarkRP compatibility code\nif DarkRP and DarkRP.createCategory then\n    lia.darkrp.createCategory()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in addon initialization\nlocal function initializeDarkRPCompatibility()\n    -- Ensure DarkRP compatibility functions exist\n    lia.darkrp.createCategory()\n    -- Other DarkRP compatibility setup\n    if DarkRP and DarkRP.createEntity then\n        print(\"DarkRP compatibility initialized\")\n    end\nend\ninitializeDarkRPCompatibility()\n</code></pre></p>"},{"location":"libraries/lia.darkrp/#liadarkrpdefinechatcommand","title":"lia.DarkRP.defineChatCommand","text":"<p>Purpose</p> <p>Creates a DarkRP-compatible category (placeholder function for compatibility)</p> <p>When Called</p> <p>Called by DarkRP addons that expect a createCategory function to exist</p> <p>Returns</p> <ul> <li>nil</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Call the function (no effect)\nlia.darkrp.createCategory()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in DarkRP compatibility code\nif DarkRP and DarkRP.createCategory then\n    lia.darkrp.createCategory()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in addon initialization\nlocal function initializeDarkRPCompatibility()\n    -- Ensure DarkRP compatibility functions exist\n    lia.darkrp.createCategory()\n    -- Other DarkRP compatibility setup\n    if DarkRP and DarkRP.createEntity then\n        print(\"DarkRP compatibility initialized\")\n    end\nend\ninitializeDarkRPCompatibility()\n</code></pre></p>"},{"location":"libraries/lia.darkrp/#liadarkrpdefineprivilegedchatcommand","title":"lia.DarkRP.definePrivilegedChatCommand","text":"<p>Purpose</p> <p>Creates a DarkRP-compatible category (placeholder function for compatibility)</p> <p>When Called</p> <p>Called by DarkRP addons that expect a createCategory function to exist</p> <p>Returns</p> <ul> <li>nil</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Call the function (no effect)\nlia.darkrp.createCategory()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in DarkRP compatibility code\nif DarkRP and DarkRP.createCategory then\n    lia.darkrp.createCategory()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in addon initialization\nlocal function initializeDarkRPCompatibility()\n    -- Ensure DarkRP compatibility functions exist\n    lia.darkrp.createCategory()\n    -- Other DarkRP compatibility setup\n    if DarkRP and DarkRP.createEntity then\n        print(\"DarkRP compatibility initialized\")\n    end\nend\ninitializeDarkRPCompatibility()\n</code></pre></p>"},{"location":"libraries/lia.data/","title":"Data Library","text":"<p>Data persistence, serialization, and management system for the Lilia framework.</p> <p>Overview</p> <p>The data library provides comprehensive functionality for data persistence, serialization, and management within the Lilia framework. It handles encoding and decoding of complex data types including vectors, angles, colors, and nested tables for database storage. The library manages both general data storage with gamemode and map-specific scoping, as well as entity persistence for maintaining spawned entities across server restarts. It includes automatic serialization/deserialization, database integration, and caching mechanisms to ensure efficient data access and storage operations.</p>"},{"location":"libraries/lia.data/#encodetable","title":"encodetable","text":"<p>Purpose</p> <p>Converts complex data types (vectors, angles, colors, tables) into database-storable formats</p> <p>When Called</p> <p>Automatically called during data serialization before database storage</p> <p>Parameters</p> <ul> <li><code>value</code> (any): The value to encode (vector, angle, color table, or regular table)</li> </ul> <p>Returns</p> <ul> <li>table or any - Encoded representation suitable for JSON serialization</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Encode a vector\nlocal encoded = lia.data.encodetable(Vector(100, 200, 300))\n-- Returns: {100, 200, 300}\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Encode a color with alpha\nlocal color = Color(255, 128, 64, 200)\nlocal encoded = lia.data.encodetable(color)\n-- Returns: {255, 128, 64, 200}\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Encode nested table with mixed data types\nlocal complexData = {\nposition = Vector(0, 0, 0),\nrotation = Angle(0, 90, 0),\ncolor = Color(255, 0, 0),\nsettings = {enabled = true, count = 5}\n}\nlocal encoded = lia.data.encodetable(complexData)\n-- Returns: {position = {0, 0, 0}, rotation = {0, 90, 0}, color = {255, 0, 0, 255}, settings = {enabled = true, count = 5}}\n</code></pre></p>"},{"location":"libraries/lia.data/#decode","title":"decode","text":"<p>Purpose</p> <p>Converts encoded data back to original complex data types (vectors, angles, colors)</p> <p>When Called</p> <p>Automatically called during data deserialization after database retrieval</p> <p>Parameters</p> <ul> <li><code>value</code> (any): The encoded value to decode (table, string, or raw data)</li> </ul> <p>Returns</p> <ul> <li>any - Decoded value with proper data types restored</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Decode a vector from encoded format\nlocal decoded = lia.data.decode({100, 200, 300})\n-- Returns: Vector(100, 200, 300)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Decode an angle from encoded format\nlocal encodedAngle = {0, 90, 0}\nlocal decoded = lia.data.decode(encodedAngle)\n-- Returns: Angle(0, 90, 0)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Decode complex nested data structure\nlocal encodedData = {\nposition = {100, 200, 300},\nrotation = {0, 90, 0},\ncolor = {255, 0, 0, 255},\nsettings = {enabled = true, count = 5}\n}\nlocal decoded = lia.data.decode(encodedData)\n-- Returns: {position = Vector(100, 200, 300), rotation = Angle(0, 90, 0), color = Color(255, 0, 0, 255), settings = {enabled = true, count = 5}}\n</code></pre></p>"},{"location":"libraries/lia.data/#serialize","title":"serialize","text":"<p>Purpose</p> <p>Converts any data structure into a JSON string suitable for database storage</p> <p>When Called</p> <p>Called before storing data in the database to ensure proper serialization</p> <p>Parameters</p> <ul> <li><code>value</code> (any): The data to serialize (tables, vectors, angles, colors, etc.)</li> </ul> <p>Returns</p> <ul> <li>string - JSON string representation of the encoded data</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Serialize a basic table\nlocal serialized = lia.data.serialize({name = \"test\", value = 42})\n-- Returns: '{\"name\":\"test\",\"value\":42}'\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Serialize a vector\nlocal serialized = lia.data.serialize(Vector(100, 200, 300))\n-- Returns: '{\"value\":[100,200,300]}'\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Serialize complex nested data with mixed types\nlocal complexData = {\nposition = Vector(0, 0, 0),\nrotation = Angle(0, 90, 0),\ncolor = Color(255, 0, 0),\nsettings = {enabled = true, count = 5}\n}\nlocal serialized = lia.data.serialize(complexData)\n-- Returns: JSON string with all data properly encoded\n</code></pre></p>"},{"location":"libraries/lia.data/#deserialize","title":"deserialize","text":"<p>Purpose</p> <p>Converts serialized data (JSON strings or tables) back to original data structures</p> <p>When Called</p> <p>Called after retrieving data from database to restore original data types</p> <p>Parameters</p> <ul> <li><code>raw</code> (string|table): Serialized data from database (JSON string or table)</li> </ul> <p>Returns</p> <ul> <li>any - Deserialized data with proper types restored, or nil if invalid</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Deserialize a JSON string\nlocal deserialized = lia.data.deserialize('{\"name\":\"test\",\"value\":42}')\n-- Returns: {name = \"test\", value = 42}\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Deserialize encoded vector data\nlocal jsonData = '{\"value\":[100,200,300]}'\nlocal deserialized = lia.data.deserialize(jsonData)\n-- Returns: Vector(100, 200, 300)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Deserialize complex data with fallback handling\nlocal complexJson = '{\"position\":[0,0,0],\"rotation\":[0,90,0],\"color\":[255,0,0,255],\"settings\":{\"enabled\":true,\"count\":5}}'\nlocal deserialized = lia.data.deserialize(complexJson)\n-- Returns: {position = Vector(0, 0, 0), rotation = Angle(0, 90, 0), color = Color(255, 0, 0, 255), settings = {enabled = true, count = 5}}\n</code></pre></p>"},{"location":"libraries/lia.data/#decodevector","title":"decodeVector","text":"<p>Purpose</p> <p>Specifically decodes vector data from various formats (JSON, strings, tables)</p> <p>When Called</p> <p>Called when specifically needing to decode vector data from database or serialized format</p> <p>Parameters</p> <ul> <li><code>raw</code> (any): Raw data that should contain vector information</li> </ul> <p>Returns</p> <ul> <li>Vector or any - Decoded Vector object, or original data if not vector format</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Decode vector from array format\nlocal vector = lia.data.decodeVector({100, 200, 300})\n-- Returns: Vector(100, 200, 300)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Decode vector from JSON string\nlocal jsonString = '[100,200,300]'\nlocal vector = lia.data.decodeVector(jsonString)\n-- Returns: Vector(100, 200, 300)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Decode vector with multiple format fallbacks\nlocal vectorData = \"Vector(100, 200, 300)\"\nlocal vector = lia.data.decodeVector(vectorData)\n-- Returns: Vector(100, 200, 300) - handles string parsing\n</code></pre></p>"},{"location":"libraries/lia.data/#decodeangle","title":"decodeAngle","text":"<p>Purpose</p> <p>Specifically decodes angle data from various formats (JSON, strings, tables)</p> <p>When Called</p> <p>Called when specifically needing to decode angle data from database or serialized format</p> <p>Parameters</p> <ul> <li><code>raw</code> (any): Raw data that should contain angle information</li> </ul> <p>Returns</p> <ul> <li>Angle or any - Decoded Angle object, or original data if not angle format</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Decode angle from array format\nlocal angle = lia.data.decodeAngle({0, 90, 0})\n-- Returns: Angle(0, 90, 0)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Decode angle from JSON string\nlocal jsonString = '[0,90,0]'\nlocal angle = lia.data.decodeAngle(jsonString)\n-- Returns: Angle(0, 90, 0)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Decode angle with multiple format fallbacks\nlocal angleData = \"Angle(0, 90, 0)\"\nlocal angle = lia.data.decodeAngle(angleData)\n-- Returns: Angle(0, 90, 0) - handles string parsing\n</code></pre></p>"},{"location":"libraries/lia.data/#set","title":"set","text":"<p>Purpose</p> <p>Stores data in the database with gamemode and map-specific scoping</p> <p>When Called</p> <p>Called when storing persistent data that should survive server restarts</p> <p>Parameters</p> <ul> <li><code>key</code> (string): Unique identifier for the data, value (any) - Data to store, global (boolean, optional) - Store globally across all gamemodes/maps, ignoreMap (boolean, optional) - Store for all maps in current gamemode</li> </ul> <p>Returns</p> <ul> <li>string - Database path where data was stored</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Store basic data for current gamemode and map\nlia.data.set(\"playerCount\", 25)\n-- Stores data scoped to current gamemode and map\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Store data globally across all gamemodes and maps\nlia.data.set(\"serverVersion\", \"1.0.0\", true)\n-- Stores data globally, accessible from any gamemode/map\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Store complex data with custom scoping\nlocal playerData = {\nposition = Vector(100, 200, 300),\ninventory = {weapon = \"pistol\", ammo = 50},\nsettings = {volume = 0.8, graphics = \"high\"}\n}\nlia.data.set(\"player_\" .. player:SteamID64(), playerData, false, true)\n-- Stores player data for current gamemode but all maps\n</code></pre></p>"},{"location":"libraries/lia.data/#delete","title":"delete","text":"<p>Purpose</p> <p>Removes data from the database with gamemode and map-specific scoping</p> <p>When Called</p> <p>Called when removing persistent data that should no longer be stored</p> <p>Parameters</p> <ul> <li><code>key</code> (string): Unique identifier for the data to delete, global (boolean, optional) - Delete from global scope, ignoreMap (boolean, optional) - Delete from all maps in current gamemode</li> </ul> <p>Returns</p> <ul> <li>boolean - Always returns true</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Delete data for current gamemode and map\nlia.data.delete(\"playerCount\")\n-- Removes data scoped to current gamemode and map\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Delete data globally across all gamemodes and maps\nlia.data.delete(\"serverVersion\", true)\n-- Removes data from global scope\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Delete player data with custom scoping\nlocal playerID = \"player_\" .. player:SteamID64()\nlia.data.delete(playerID, false, true)\n-- Removes player data for current gamemode but all maps\n</code></pre></p>"},{"location":"libraries/lia.data/#loadtables","title":"loadTables","text":"<p>Purpose</p> <p>Loads all stored data from database into memory with hierarchical scoping</p> <p>When Called</p> <p>Called during server startup to restore all persistent data</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load all data tables\nlia.data.loadTables()\n-- Loads global, gamemode, and map-specific data\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load data with custom initialization\nlia.data.loadTables()\n-- After loading, access specific data\nlocal playerCount = lia.data.get(\"playerCount\", 0)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load data with validation and error handling\nlia.data.loadTables()\n-- Data is loaded hierarchically: global -&gt; gamemode -&gt; map-specific\n-- Later data overrides earlier data (map overrides gamemode overrides global)\n</code></pre></p>"},{"location":"libraries/lia.data/#loadpersistence","title":"loadPersistence","text":"<p>Purpose</p> <p>Ensures persistence table has required columns for entity storage</p> <p>When Called</p> <p>Called during server startup to prepare database schema for entity persistence</p> <p>Returns</p> <ul> <li>Promise - Database operation promise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load persistence schema\nlia.data.loadPersistence()\n-- Ensures all required columns exist in persistence table\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load persistence with error handling\nlia.data.loadPersistence():next(function()\nprint(\"Persistence schema loaded successfully\")\nend):catch(function(err)\nprint(\"Failed to load persistence schema: \" .. err)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load persistence as part of initialization sequence\nlia.data.loadPersistence():next(function()\nreturn lia.data.loadPersistenceData(function(entities)\n-- Process loaded entities\nfor _, ent in ipairs(entities) do\n    -- Spawn entities or process data\nend\nend)\nend)\n</code></pre></p>"},{"location":"libraries/lia.data/#savepersistence","title":"savePersistence","text":"<p>Purpose</p> <p>Saves entity data to database for persistence across server restarts</p> <p>When Called</p> <p>Called during server shutdown or periodic saves to persist entity states</p> <p>Parameters</p> <ul> <li><code>entities</code> (table): Array of entity data tables to save</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Save basic entity data\nlocal entities = {\n{class = \"prop_physics\", pos = Vector(0, 0, 0), angles = Angle(0, 0, 0), model = \"models/props_c17/FurnitureTable001a.mdl\"}\n}\nlia.data.savePersistence(entities)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save entities with custom properties\nlocal entities = {\n{\nclass = \"lia_vendor\",\npos = Vector(100, 200, 0),\nangles = Angle(0, 90, 0),\nmodel = \"models/player.mdl\",\nname = \"Weapon Vendor\",\nitems = {\"weapon_pistol\", \"weapon_shotgun\"}\n}\n}\nlia.data.savePersistence(entities)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Save complex entities with dynamic properties\nlocal entities = {}\nfor _, ent in ipairs(ents.GetAll()) do\n    if ent:GetClass() == \"lia_item\" then\n        table.insert(entities, {\n        class = ent:GetClass(),\n        pos = ent:GetPos(),\n        angles = ent:GetAngles(),\n        model = ent:GetModel(),\n        itemID = ent:GetItemID(),\n        amount = ent:GetAmount(),\n        data = ent:GetData()\n        })\n    end\nend\nlia.data.savePersistence(entities)\n</code></pre></p>"},{"location":"libraries/lia.data/#loadpersistencedata","title":"loadPersistenceData","text":"<p>Purpose</p> <p>Loads persisted entity data from database and optionally executes callback</p> <p>When Called</p> <p>Called during server startup to restore persisted entities</p> <p>Parameters</p> <ul> <li><code>callback</code> (function, optional): Function to call with loaded entity data</li> </ul> <p>Returns</p> <ul> <li>Promise - Database operation promise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load persistence data\nlia.data.loadPersistenceData()\n-- Loads entity data into cache\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load persistence data with callback\nlia.data.loadPersistenceData(function(entities)\nprint(\"Loaded \" .. #entities .. \" entities\")\nfor _, ent in ipairs(entities) do\n    print(\"Entity: \" .. ent.class .. \" at \" .. tostring(ent.pos))\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load persistence data with entity spawning\nlia.data.loadPersistenceData(function(entities)\nfor _, entData in ipairs(entities) do\n    local ent = ents.Create(entData.class)\n    if IsValid(ent) then\n        ent:SetPos(entData.pos)\n        ent:SetAngles(entData.angles)\n        ent:SetModel(entData.model)\n        ent:Spawn()\n        -- Restore custom properties\n        for k, v in pairs(entData) do\n            if not defaultCols[k] then\n                ent:SetNWVar(k, v)\n            end\n        end\n    end\nend\nend)\n</code></pre></p>"},{"location":"libraries/lia.data/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves stored data from memory cache with automatic deserialization</p> <p>When Called</p> <p>Called when accessing stored persistent data</p> <p>Parameters</p> <ul> <li><code>key</code> (string): Unique identifier for the data, default (any, optional) - Default value if key not found</li> </ul> <p>Returns</p> <ul> <li>any - Stored data or default value if not found</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get basic data\nlocal playerCount = lia.data.get(\"playerCount\", 0)\n-- Returns stored player count or 0 if not found\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get data with default fallback\nlocal serverSettings = lia.data.get(\"serverSettings\", {\nmaxPlayers = 32,\nmapRotation = {\"gm_flatgrass\", \"gm_construct\"}\n})\n-- Returns stored settings or default configuration\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get complex data with validation\nlocal playerData = lia.data.get(\"player_\" .. player:SteamID64(), {})\nif playerData.position then\n    player:SetPos(playerData.position)\nend\nif playerData.inventory then\n    player:GetInventory():LoadFromData(playerData.inventory)\nend\n-- Retrieves and processes complex player data\n</code></pre></p>"},{"location":"libraries/lia.data/#getpersistence","title":"getPersistence","text":"<p>Purpose</p> <p>Retrieves cached entity persistence data from memory</p> <p>When Called</p> <p>Called when accessing loaded entity persistence data</p> <p>Returns</p> <ul> <li>table - Array of entity data tables or empty table if none loaded</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get persistence data\nlocal entities = lia.data.getPersistence()\nprint(\"Loaded \" .. #entities .. \" entities\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get persistence data with filtering\nlocal entities = lia.data.getPersistence()\nlocal vendors = {}\nfor _, ent in ipairs(entities) do\n    if ent.class == \"lia_vendor\" then\n        table.insert(vendors, ent)\n    end\nend\nprint(\"Found \" .. #vendors .. \" vendors\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get persistence data with processing\nlocal entities = lia.data.getPersistence()\nlocal entityStats = {}\nfor _, ent in ipairs(entities) do\n    if not entityStats[ent.class] then\n        entityStats[ent.class] = 0\n    end\n    entityStats[ent.class] = entityStats[ent.class] + 1\nend\nfor class, count in pairs(entityStats) do\n    print(class .. \": \" .. count .. \" entities\")\nend\n</code></pre></p>"},{"location":"libraries/lia.database/","title":"Database Library","text":"<p>Comprehensive database management system with SQLite support for the Lilia framework.</p> <p>Overview</p> <p>The database library provides comprehensive database management functionality for the Lilia framework. It handles all database operations including connection management, table creation and modification, data insertion, updates, queries, and schema management. The library supports SQLite as the primary database engine with extensible module support for other database systems. It includes advanced features such as prepared statements, transactions, bulk operations, data type conversion, and database snapshots for backup and restore operations. The library ensures data persistence across server restarts and provides robust error handling with deferred promise-based operations for asynchronous database queries. It manages core gamemode tables for players, characters, inventories, items, configuration, logs, and administrative data while supporting dynamic schema modifications.</p>"},{"location":"libraries/lia.database/#connect","title":"connect","text":"<p>Purpose</p> <p>Establishes a connection to the database using the configured database module</p> <p>When Called</p> <p>During server startup, module initialization, or when reconnecting to database</p> <p>Parameters</p> <ul> <li><code>callback</code> (function, optional): Function to call after successful connection</li> <li><code>reconnect</code> (boolean, optional): Force reconnection even if already connected</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Connect to database with callback\nlia.db.connect(function()\nprint(\"Database connected successfully!\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Connect with error handling and reconnection\nlia.db.connect(function()\nlia.log.add(\"Database connection established\")\nlia.db.loadTables()\nend, true)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Connect with conditional logic and module validation\nif lia.db.module and lia.db.modules[lia.db.module] then\n    lia.db.connect(function()\n    lia.bootstrap(\"Database\", \"Connected to \" .. lia.db.module)\n    hook.Run(\"OnDatabaseConnected\")\nend, not lia.db.connected)\nelse\n    lia.error(\"Invalid database module: \" .. tostring(lia.db.module))\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#wipetables","title":"wipeTables","text":"<p>Purpose</p> <p>Removes all Lilia database tables and their data from the database</p> <p>When Called</p> <p>During database reset operations, development testing, or administrative cleanup</p> <p>Parameters</p> <ul> <li><code>callback</code> (function, optional): Function to call after all tables are wiped</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Wipe all tables with confirmation\nlia.db.wipeTables(function()\nprint(\"All database tables have been wiped!\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Wipe tables with logging and backup\nlia.log.add(\"Starting database wipe operation\")\nlia.db.wipeTables(function()\nlia.log.add(\"Database wipe completed successfully\")\nhook.Run(\"OnDatabaseWiped\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Wipe tables with confirmation and error handling\nlocal function confirmWipe()\n    lia.db.wipeTables(function()\n    lia.bootstrap(\"Database\", \"All tables wiped successfully\")\n    lia.db.loadTables() -- Reload empty tables\n    hook.Run(\"OnDatabaseReset\")\nend)\nend\nif lia.config.get(\"allowDatabaseWipe\", false) then\n    confirmWipe()\n    else\n        lia.error(\"Database wipe not allowed by configuration\")\n    end\n</code></pre></p>"},{"location":"libraries/lia.database/#loadtables","title":"loadTables","text":"<p>Purpose</p> <p>Creates all core Lilia database tables if they don't exist and initializes the database schema</p> <p>When Called</p> <p>During server startup after database connection, or when initializing a new database</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load tables after connection\nlia.db.connect(function()\nlia.db.loadTables()\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load tables with hook integration\nlia.db.connect(function()\nlia.db.loadTables()\nlia.log.add(\"Database tables loaded successfully\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load tables with conditional logic and error handling\nlocal function initializeDatabase()\n    lia.db.connect(function()\n    lia.db.loadTables()\n    hook.Run(\"OnDatabaseInitialized\")\n    lia.bootstrap(\"Database\", \"Schema loaded and ready\")\nend, true)\nend\nif lia.db.module and lia.db.modules[lia.db.module] then\n    initializeDatabase()\n    else\n        lia.error(\"Cannot initialize database: invalid module\")\n    end\n</code></pre></p>"},{"location":"libraries/lia.database/#waitfortablestoload","title":"waitForTablesToLoad","text":"<p>Purpose</p> <p>Returns a deferred promise that resolves when database tables have finished loading</p> <p>When Called</p> <p>Before performing database operations that require tables to be loaded</p> <p>Returns</p> <ul> <li>Deferred promise object</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Wait for tables to load before proceeding\nlia.db.waitForTablesToLoad():next(function()\nprint(\"Tables are ready!\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Wait for tables with error handling\nlia.db.waitForTablesToLoad():next(function()\nlia.log.add(\"Database tables loaded, proceeding with initialization\")\nhook.Run(\"OnTablesReady\")\nend):catch(function(err)\nlia.error(\"Failed to load database tables: \" .. tostring(err))\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Wait for tables with timeout and fallback\nlocal function initializeAfterTables()\n    lia.db.waitForTablesToLoad():next(function()\n    lia.char.loadCharacters()\n    lia.inventory.loadInventories()\n    lia.bootstrap(\"Database\", \"All systems initialized\")\nend):catch(function(err)\nlia.error(\"Critical database initialization failure: \" .. tostring(err))\nlia.db.connect(function()\nlia.db.loadTables()\ninitializeAfterTables()\nend, true)\nend)\nend\ninitializeAfterTables()\n</code></pre></p>"},{"location":"libraries/lia.database/#convertdatatype","title":"convertDataType","text":"<p>Purpose</p> <p>Converts Lua values to SQL-compatible format with proper escaping and type handling</p> <p>When Called</p> <p>Internally by database functions when preparing data for SQL queries</p> <p>Parameters</p> <ul> <li><code>value</code> (any): The value to convert to SQL format</li> <li><code>noEscape</code> (boolean, optional): Skip escaping for raw SQL values</li> </ul> <p>Returns</p> <ul> <li>String representation of the value in SQL format</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Convert basic data types\nlocal sqlString = lia.db.convertDataType(\"Hello World\")\nlocal sqlNumber = lia.db.convertDataType(42)\nlocal sqlBool = lia.db.convertDataType(true)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Convert complex data with escaping\nlocal playerData = {\nname = \"John Doe\",\nlevel = 25,\nisActive = true,\ninventory = {weapon = \"pistol\", ammo = 100}\n}\nlocal sqlData = {}\nfor key, value in pairs(playerData) do\n    sqlData[key] = lia.db.convertDataType(value)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Convert with conditional logic and error handling\nlocal function safeConvert(value, fieldName)\n    if value == nil then\n        return \"NULL\"\n        elseif type(value) == \"table\" then\n            local success, json = pcall(util.TableToJSON, value)\n            if success then\n                return \"'\" .. lia.db.escape(json) .. \"'\"\n                else\n                    lia.log.add(\"Failed to convert table for field: \" .. fieldName)\n                    return \"NULL\"\n                end\n                else\n                    return lia.db.convertDataType(value)\n                end\n            end\n</code></pre></p>"},{"location":"libraries/lia.database/#inserttable","title":"insertTable","text":"<p>Purpose</p> <p>Inserts a new record into a specified database table</p> <p>When Called</p> <p>When creating new database records for players, characters, items, etc.</p> <p>Parameters</p> <ul> <li><code>value</code> (table): Key-value pairs representing the data to insert</li> <li><code>callback</code> (function, optional): Function to call after successful insertion</li> <li><code>dbTable</code> (string, optional): Table name without 'lia_' prefix (defaults to 'characters')</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object with results and lastID</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Insert a new character\nlia.db.insertTable({\nsteamID = \"STEAM_0:1:12345678\",\nname = \"John Doe\",\nmodel = \"models/player/kleiner.mdl\"\n}, function(results, lastID)\nprint(\"Character created with ID:\", lastID)\nend, \"characters\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Insert with error handling and validation\nlocal characterData = {\nsteamID = player:SteamID(),\nname = player:Name(),\nmodel = player:GetModel(),\nfaction = \"citizen\",\nmoney = \"0\"\n}\nlia.db.insertTable(characterData, function(results, lastID)\nif lastID then\n    lia.log.add(\"Character created for \" .. player:Name())\n    hook.Run(\"OnCharacterCreated\", player, lastID)\nend\nend, \"characters\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Insert with validation, error handling, and rollback\nlocal function createCharacterWithValidation(playerData)\n    local validation = lia.char.validateData(playerData)\n    if not validation.valid then\n        return deferred.new():reject(\"Validation failed: \" .. validation.error)\n    end\n    return lia.db.insertTable(playerData, function(results, lastID)\n    if lastID then\n        lia.char.cache[lastID] = playerData\n        hook.Run(\"OnCharacterCreated\", lastID, playerData)\n    end\nend, \"characters\")\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#updatetable","title":"updateTable","text":"<p>Purpose</p> <p>Updates existing records in a specified database table based on conditions</p> <p>When Called</p> <p>When modifying existing database records for players, characters, items, etc.</p> <p>Parameters</p> <ul> <li><code>value</code> (table): Key-value pairs representing the data to update</li> <li><code>callback</code> (function, optional): Function to call after successful update</li> <li><code>dbTable</code> (string, optional): Table name without 'lia_' prefix (defaults to 'characters')</li> <li><code>condition</code> (table/string, optional): WHERE clause conditions for the update</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object with results and lastID</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Update character money\nlia.db.updateTable({\nmoney = \"1000\"\n}, function(results, lastID)\nprint(\"Character updated successfully!\")\nend, \"characters\", {id = 1})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update with complex conditions and logging\nlocal updateData = {\nlastJoinTime = os.date(\"%Y-%m-%d %H:%M:%S\"),\nmoney = tostring(character:getMoney())\n}\nlia.db.updateTable(updateData, function(results, lastID)\nif results then\n    lia.log.add(\"Character \" .. character:getName() .. \" updated\")\n    hook.Run(\"OnCharacterUpdated\", character)\nend\nend, \"characters\", {id = character:getID()})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Update with validation, transaction, and rollback\nlocal function updateCharacterWithValidation(charID, updateData)\n    return lia.db.transaction({\n    \"BEGIN TRANSACTION\",\n    \"UPDATE lia_characters SET \" ..\n    table.concat(lia.util.map(updateData, function(k, v)\n    return k .. \" = \" .. lia.db.convertDataType(v)\nend), \", \") ..\n\" WHERE id = \" .. charID,\n\"COMMIT\"\n}):next(function()\nlia.char.cache[charID] = lia.util.merge(lia.char.cache[charID] or {}, updateData)\nhook.Run(\"OnCharacterUpdated\", charID, updateData)\nend):catch(function(err)\nlia.error(\"Failed to update character \" .. charID .. \": \" .. tostring(err))\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#select","title":"select","text":"<p>Purpose</p> <p>Performs a SELECT query on a specified database table with optional conditions and limits</p> <p>When Called</p> <p>When retrieving data from database tables for players, characters, items, etc.</p> <p>Parameters</p> <ul> <li><code>fields</code> (string/table): Field names to select (string or table of strings)</li> <li><code>dbTable</code> (string, optional): Table name without 'lia_' prefix (defaults to 'characters')</li> <li><code>condition</code> (table/string, optional): WHERE clause conditions for the query</li> <li><code>limit</code> (number, optional): Maximum number of records to return</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object with results array</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Select all characters\nlia.db.select(\"*\", \"characters\"):next(function(results)\nprint(\"Found \" .. #results .. \" characters\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Select with conditions and specific fields\nlia.db.select({\"name\", \"money\", \"faction\"}, \"characters\", {\nsteamID = \"STEAM_0:1:12345678\"\n}, 10):next(function(results)\nfor _, char in ipairs(results) do\n    print(char.name .. \" has $\" .. char.money)\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Select with complex conditions, pagination, and error handling\nlocal function getCharactersByFaction(faction, page, pageSize)\n    local offset = (page - 1) * pageSize\n    return lia.db.select(\"*\", \"characters\", {\n    faction = faction,\n    lastJoinTime = {operator = \"&gt;\", value = os.date(\"%Y-%m-%d\", os.time() - 86400)}\n    }, pageSize):next(function(results)\n    local characters = {}\n    for _, char in ipairs(results) do\n        table.insert(characters, lia.char.new(char))\n    end\n    return characters\nend):catch(function(err)\nlia.error(\"Failed to load characters: \" .. tostring(err))\nreturn {}\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#selectwithcondition","title":"selectWithCondition","text":"<p>Purpose</p> <p>Performs a SELECT query with advanced condition handling and optional ordering</p> <p>When Called</p> <p>When retrieving data with complex WHERE clauses and ORDER BY requirements</p> <p>Parameters</p> <ul> <li><code>fields</code> (string/table): Field names to select (string or table of strings)</li> <li><code>dbTable</code> (string, optional): Table name without 'lia_' prefix (defaults to 'characters')</li> <li><code>conditions</code> (table/string, optional): WHERE clause conditions with operator support</li> <li><code>limit</code> (number, optional): Maximum number of records to return</li> <li><code>orderBy</code> (string, optional): ORDER BY clause for sorting results</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object with results array</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Select with basic condition\nlia.db.selectWithCondition(\"*\", \"characters\", {\nfaction = \"citizen\"\n}):next(function(results)\nprint(\"Found \" .. #results .. \" citizens\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Select with operators and ordering\nlia.db.selectWithCondition({\"name\", \"money\"}, \"characters\", {\nmoney = {operator = \"&gt;\", value = \"1000\"},\nfaction = \"citizen\"\n}, 5, \"money DESC\"):next(function(results)\nfor _, char in ipairs(results) do\n    print(char.name .. \" has $\" .. char.money)\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Select with complex conditions, pagination, and error handling\nlocal function searchCharacters(searchTerm, faction, minMoney, maxResults)\n    local conditions = {}\n    if searchTerm then\n        conditions.name = {operator = \"LIKE\", value = \"%\" .. searchTerm .. \"%\"}\n    end\n    if faction then\n        conditions.faction = faction\n    end\n    if minMoney then\n        conditions.money = {operator = \"&gt;=\", value = tostring(minMoney)}\n    end\n    return lia.db.selectWithCondition(\"*\", \"characters\", conditions,\n    maxResults, \"lastJoinTime DESC\"):next(function(results)\n    local characters = {}\n    for _, char in ipairs(results) do\n        table.insert(characters, lia.char.new(char))\n    end\n    return characters\nend):catch(function(err)\nlia.error(\"Character search failed: \" .. tostring(err))\nreturn {}\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#count","title":"count","text":"<p>Purpose</p> <p>Counts the number of records in a database table matching specified conditions</p> <p>When Called</p> <p>When checking record counts for statistics, validation, or pagination</p> <p>Parameters</p> <ul> <li><code>dbTable</code> (string): Table name without 'lia_' prefix</li> <li><code>condition</code> (table/string, optional): WHERE clause conditions for counting</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to the count number</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Count all characters\nlia.db.count(\"characters\"):next(function(count)\nprint(\"Total characters: \" .. count)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Count with conditions\nlia.db.count(\"characters\", {\nfaction = \"citizen\",\nmoney = {operator = \"&gt;\", value = \"1000\"}\n}):next(function(count)\nprint(\"Rich citizens: \" .. count)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Count with validation and error handling\nlocal function getPlayerStats(steamID)\n    return lia.db.count(\"characters\", {steamID = steamID}):next(function(charCount)\n    return lia.db.count(\"players\", {steamID = steamID}):next(function(playerCount)\n    return {\n    characters = charCount,\n    playerRecords = playerCount,\n    isNewPlayer = playerCount == 0\n    }\nend)\nend):catch(function(err)\nlia.error(\"Failed to get player stats: \" .. tostring(err))\nreturn {characters = 0, playerRecords = 0, isNewPlayer = true}\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#adddatabasefields","title":"addDatabaseFields","text":"<p>Purpose</p> <p>Dynamically adds new columns to the lia_characters table based on character variables</p> <p>When Called</p> <p>During database initialization to ensure character table has all required fields</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add fields after table creation\nlia.db.loadTables() -- This automatically calls addDatabaseFields()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add fields with logging\nlia.db.addDatabaseFields()\nlia.log.add(\"Database fields updated for character variables\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add fields with validation and error handling\nlocal function ensureCharacterFields()\n    if not istable(lia.char.vars) then\n        lia.log.add(\"Character variables not defined, skipping field addition\")\n        return\n    end\n    lia.db.addDatabaseFields()\n    lia.log.add(\"Character database fields synchronized\")\n    hook.Run(\"OnCharacterFieldsUpdated\")\nend\nensureCharacterFields()\n</code></pre></p>"},{"location":"libraries/lia.database/#exists","title":"exists","text":"<p>Purpose</p> <p>Checks if any records exist in a database table matching specified conditions</p> <p>When Called</p> <p>When validating data existence before operations or for conditional logic</p> <p>Parameters</p> <ul> <li><code>dbTable</code> (string): Table name without 'lia_' prefix</li> <li><code>condition</code> (table/string, optional): WHERE clause conditions for checking existence</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to boolean (true if records exist)</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player exists\nlia.db.exists(\"players\", {steamID = \"STEAM_0:1:12345678\"}):next(function(exists)\nif exists then\n    print(\"Player found in database\")\n    else\n        print(\"New player\")\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check with complex conditions\nlia.db.exists(\"characters\", {\nsteamID = player:SteamID(),\nfaction = \"citizen\",\nmoney = {operator = \"&gt;\", value = \"1000\"}\n}):next(function(exists)\nif exists then\n    lia.log.add(\"Player has wealthy citizen character\")\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check with validation and error handling\nlocal function validatePlayerData(steamID)\n    return lia.db.exists(\"players\", {steamID = steamID}):next(function(playerExists)\n    if not playerExists then\n        return lia.db.insertTable({\n        steamID = steamID,\n        steamName = \"Unknown\",\n        firstJoin = os.date(\"%Y-%m-%d %H:%M:%S\"),\n        userGroup = \"user\"\n        }, nil, \"players\")\n    end\n    return playerExists\nend):catch(function(err)\nlia.error(\"Failed to validate player data: \" .. tostring(err))\nreturn false\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#selectone","title":"selectOne","text":"<p>Purpose</p> <p>Retrieves a single record from a database table matching specified conditions</p> <p>When Called</p> <p>When fetching unique records like player data, character info, or single items</p> <p>Parameters</p> <ul> <li><code>fields</code> (string/table): Field names to select (string or table of strings)</li> <li><code>dbTable</code> (string): Table name without 'lia_' prefix</li> <li><code>condition</code> (table/string, optional): WHERE clause conditions for the query</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to the first matching record or nil</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get character by ID\nlia.db.selectOne(\"*\", \"characters\", {id = 1}):next(function(char)\nif char then\n    print(\"Character name: \" .. char.name)\nend\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get player data with specific fields\nlia.db.selectOne({\"steamName\", \"userGroup\", \"lastJoin\"}, \"players\", {\nsteamID = player:SteamID()\n}):next(function(playerData)\nif playerData then\n    player:SetUserGroup(playerData.userGroup)\n    lia.log.add(\"Loaded player: \" .. playerData.steamName)\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get with validation and error handling\nlocal function loadCharacter(charID)\n    return lia.db.selectOne(\"*\", \"characters\", {id = charID}):next(function(charData)\n    if not charData then\n        return deferred.new():reject(\"Character not found\")\n    end\n    local character = lia.char.new(charData)\n    lia.char.cache[charID] = character\n    hook.Run(\"OnCharacterLoaded\", character)\n    return character\nend):catch(function(err)\nlia.error(\"Failed to load character \" .. charID .. \": \" .. tostring(err))\nreturn nil\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#bulkinsert","title":"bulkInsert","text":"<p>Purpose</p> <p>Inserts multiple records into a database table in a single operation for better performance</p> <p>When Called</p> <p>When inserting large amounts of data like inventory items, logs, or batch operations</p> <p>Parameters</p> <ul> <li><code>dbTable</code> (string): Table name without 'lia_' prefix</li> <li><code>rows</code> (table): Array of tables containing the data to insert</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving when all records are inserted</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Insert multiple items\nlocal items = {\n{uniqueID = \"pistol\", quantity = 1, x = 1, y = 1},\n{uniqueID = \"ammo\", quantity = 50, x = 2, y = 1}\n}\nlia.db.bulkInsert(\"items\", items):next(function()\nprint(\"Items inserted successfully\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Insert with validation and error handling\nlocal function insertInventoryItems(invID, items)\n    local rows = {}\n    for _, item in ipairs(items) do\n        table.insert(rows, {\n        invID = invID,\n        uniqueID = item.uniqueID,\n        data = util.TableToJSON(item.data or {}),\n        quantity = item.quantity or 1,\n        x = item.x or 1,\n        y = item.y or 1\n        })\n    end\n    return lia.db.bulkInsert(\"items\", rows):next(function()\n    lia.log.add(\"Inserted \" .. #rows .. \" items into inventory \" .. invID)\nend):catch(function(err)\nlia.error(\"Failed to insert items: \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Insert with batching, validation, and progress tracking\nlocal function bulkInsertWithBatching(dbTable, data, batchSize)\n    batchSize = batchSize or 100\n    local batches = {}\n    for i = 1, #data, batchSize do\n        local batch = {}\n        for j = i, math.min(i + batchSize - 1, #data) do\n            table.insert(batch, data[j])\n        end\n        table.insert(batches, batch)\n    end\n    local currentBatch = 1\n    local function insertNextBatch()\n        if currentBatch &gt; #batches then\n            return deferred.new():resolve()\n        end\n        return lia.db.bulkInsert(dbTable, batches[currentBatch]):next(function()\n        lia.log.add(\"Batch \" .. currentBatch .. \"/\" .. #batches .. \" completed\")\n        currentBatch = currentBatch + 1\n        return insertNextBatch()\n    end)\nend\nreturn insertNextBatch()\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#bulkupsert","title":"bulkUpsert","text":"<p>Purpose</p> <p>Performs bulk INSERT OR REPLACE operations for updating existing records or inserting new ones</p> <p>When Called</p> <p>When synchronizing data that may already exist, like configuration updates or data imports</p> <p>Parameters</p> <ul> <li><code>dbTable</code> (string): Table name without 'lia_' prefix</li> <li><code>rows</code> (table): Array of tables containing the data to upsert</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving when all records are upserted</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Upsert configuration data\nlocal configs = {\n{schema = \"default\", key = \"maxPlayers\", value = \"32\"},\n{schema = \"default\", key = \"serverName\", value = \"My Server\"}\n}\nlia.db.bulkUpsert(\"config\", configs):next(function()\nprint(\"Configuration updated\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Upsert with validation and error handling\nlocal function syncPlayerData(players)\n    local rows = {}\n    for _, player in ipairs(players) do\n        table.insert(rows, {\n        steamID = player:SteamID(),\n        steamName = player:Name(),\n        lastJoin = os.date(\"%Y-%m-%d %H:%M:%S\"),\n        lastIP = player:IPAddress(),\n        userGroup = player:GetUserGroup()\n        })\n    end\n    return lia.db.bulkUpsert(\"players\", rows):next(function()\n    lia.log.add(\"Synchronized \" .. #rows .. \" player records\")\nend):catch(function(err)\nlia.error(\"Failed to sync player data: \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Upsert with conflict resolution and progress tracking\nlocal function bulkSyncWithConflictResolution(dbTable, data, conflictFields)\n    local batches = {}\n    local batchSize = 50\n    for i = 1, #data, batchSize do\n        local batch = {}\n        for j = i, math.min(i + batchSize - 1, #data) do\n            local record = data[j]\n            -- Add conflict resolution metadata\n            record._syncTimestamp = os.time()\n            record._conflictFields = conflictFields\n            table.insert(batch, record)\n        end\n        table.insert(batches, batch)\n    end\n    local completed = 0\n    local function processNextBatch()\n        if completed &gt;= #batches then\n            return deferred.new():resolve()\n        end\n        return lia.db.bulkUpsert(dbTable, batches[completed + 1]):next(function()\n        completed = completed + 1\n        lia.log.add(\"Batch \" .. completed .. \"/\" .. #batches .. \" synced\")\n        return processNextBatch()\n    end)\nend\nreturn processNextBatch()\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#insertorignore","title":"insertOrIgnore","text":"<p>Purpose</p> <p>Inserts a record into a database table, ignoring the operation if it would cause a constraint violation</p> <p>When Called</p> <p>When inserting data that may already exist, like unique configurations or duplicate-safe operations</p> <p>Parameters</p> <ul> <li><code>value</code> (table): Key-value pairs representing the data to insert</li> <li><code>dbTable</code> (string, optional): Table name without 'lia_' prefix (defaults to 'characters')</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object with results and lastID</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Insert configuration without duplicates\nlia.db.insertOrIgnore({\nschema = \"default\",\nkey = \"serverName\",\nvalue = \"My Server\"\n}, \"config\"):next(function(results, lastID)\nprint(\"Configuration inserted or ignored\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Insert with validation and logging\nlocal function ensureDefaultConfig(configs)\n    for _, config in ipairs(configs) do\n        lia.db.insertOrIgnore({\n        schema = config.schema,\n        key = config.key,\n        value = config.value\n        }, \"config\"):next(function(results, lastID)\n        if lastID then\n            lia.log.add(\"Added new config: \" .. config.key)\n        end\n    end)\nend\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Insert with conflict detection and fallback\nlocal function safeInsertWithFallback(data, dbTable, fallbackData)\n    return lia.db.insertOrIgnore(data, dbTable):next(function(results, lastID)\n    if lastID then\n        -- Successfully inserted new record\n        return {success = true, id = lastID, action = \"inserted\"}\n        else\n            -- Record already exists, try fallback operation\n            return lia.db.updateTable(fallbackData, nil, dbTable, {\n            [data.primaryKey or \"id\"] = data.id\n            }):next(function()\n            return {success = true, action = \"updated\"}\n        end)\n    end\nend):catch(function(err)\nlia.error(\"Insert or ignore failed: \" .. tostring(err))\nreturn {success = false, error = err}\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#tableexists","title":"tableExists","text":"<p>Purpose</p> <p>Checks if a database table exists in the current database</p> <p>When Called</p> <p>When validating table existence before operations or during schema validation</p> <p>Parameters</p> <ul> <li><code>tbl</code> (string): Table name to check for existence</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to boolean (true if table exists)</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if table exists\nlia.db.tableExists(\"lia_characters\"):next(function(exists)\nif exists then\n    print(\"Characters table exists\")\n    else\n        print(\"Characters table missing\")\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check with conditional logic\nlia.db.tableExists(\"lia_custom_table\"):next(function(exists)\nif not exists then\n    lia.log.add(\"Custom table missing, creating...\")\n    lia.db.createTable(\"custom_table\", \"id\", {\n    {name = \"id\", type = \"INTEGER\", not_null = true},\n    {name = \"data\", type = \"TEXT\"}\n    })\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check with validation and error handling\nlocal function validateDatabaseSchema()\n    local requiredTables = {\"characters\", \"players\", \"items\", \"inventories\"}\n    local missingTables = {}\n    local function checkNextTable(index)\n        if index &gt; #requiredTables then\n            if #missingTables &gt; 0 then\n                lia.error(\"Missing tables: \" .. table.concat(missingTables, \", \"))\n                return lia.db.loadTables()\n                else\n                    lia.log.add(\"All required tables exist\")\n                    return deferred.new():resolve()\n                end\n            end\n            local tableName = \"lia_\" .. requiredTables[index]\n            return lia.db.tableExists(tableName):next(function(exists)\n            if not exists then\n                table.insert(missingTables, tableName)\n            end\n            return checkNextTable(index + 1)\n        end)\n    end\n    return checkNextTable(1)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#fieldexists","title":"fieldExists","text":"<p>Purpose</p> <p>Checks if a specific field/column exists in a database table</p> <p>When Called</p> <p>When validating column existence before operations or during schema migrations</p> <p>Parameters</p> <ul> <li><code>tbl</code> (string): Table name to check</li> <li><code>field</code> (string): Field/column name to check for existence</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to boolean (true if field exists)</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if field exists\nlia.db.fieldExists(\"lia_characters\", \"money\"):next(function(exists)\nif exists then\n    print(\"Money field exists\")\n    else\n        print(\"Money field missing\")\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check with conditional field creation\nlia.db.fieldExists(\"lia_characters\", \"newField\"):next(function(exists)\nif not exists then\n    lia.log.add(\"Adding new field to characters table\")\n    lia.db.createColumn(\"characters\", \"newField\", \"VARCHAR(255)\", \"default_value\")\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check with validation and error handling\nlocal function validateCharacterFields()\n    local requiredFields = {\"name\", \"steamID\", \"money\", \"faction\", \"model\"}\n    local missingFields = {}\n    local function checkNextField(index)\n        if index &gt; #requiredFields then\n            if #missingFields &gt; 0 then\n                lia.error(\"Missing character fields: \" .. table.concat(missingFields, \", \"))\n                return lia.db.addDatabaseFields()\n                else\n                    lia.log.add(\"All required character fields exist\")\n                    return deferred.new():resolve()\n                end\n            end\n            return lia.db.fieldExists(\"lia_characters\", requiredFields[index]):next(function(exists)\n            if not exists then\n                table.insert(missingFields, requiredFields[index])\n            end\n            return checkNextField(index + 1)\n        end)\n    end\n    return checkNextField(1)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#gettables","title":"getTables","text":"<p>Purpose</p> <p>Retrieves a list of all Lilia database tables in the current database</p> <p>When Called</p> <p>When auditing database structure, generating reports, or managing tables</p> <p>Returns</p> <ul> <li>Deferred promise object resolving to array of table names</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all Lilia tables\nlia.db.getTables():next(function(tables)\nprint(\"Found \" .. #tables .. \" Lilia tables\")\nfor _, tableName in ipairs(tables) do\n    print(\"- \" .. tableName)\nend\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get tables with analysis\nlia.db.getTables():next(function(tables)\nlocal coreTables = {\"lia_characters\", \"lia_players\", \"lia_items\"}\nlocal missingTables = {}\nfor _, coreTable in ipairs(coreTables) do\n    if not table.HasValue(tables, coreTable) then\n        table.insert(missingTables, coreTable)\n    end\nend\nif #missingTables &gt; 0 then\n    lia.log.add(\"Missing core tables: \" .. table.concat(missingTables, \", \"))\n    else\n        lia.log.add(\"All core tables present\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get tables with validation and management\nlocal function auditDatabaseStructure()\n    return lia.db.getTables():next(function(tables)\n    local tableStats = {}\n    local function analyzeNextTable(index)\n        if index &gt; #tables then\n            lia.log.add(\"Database audit complete:\")\n            for tableName, stats in pairs(tableStats) do\n                lia.log.add(tableName .. \": \" .. stats.count .. \" records\")\n            end\n            return tableStats\n        end\n        local tableName = tables[index]\n        return lia.db.count(tableName:sub(5)):next(function(count)\n        tableStats[tableName] = {count = count}\n        return analyzeNextTable(index + 1)\n    end)\nend\nreturn analyzeNextTable(1)\nend):catch(function(err)\nlia.error(\"Database audit failed: \" .. tostring(err))\nreturn {}\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#transaction","title":"transaction","text":"<p>Purpose</p> <p>Executes multiple database queries as a single atomic transaction with rollback on failure</p> <p>When Called</p> <p>When performing complex operations that must succeed or fail together</p> <p>Parameters</p> <ul> <li><code>queries</code> (table): Array of SQL query strings to execute in sequence</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving when all queries succeed or rejecting on failure</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Transfer money between characters\nlia.db.transaction({\n\"UPDATE lia_characters SET money = money - 100 WHERE id = 1\",\n\"UPDATE lia_characters SET money = money + 100 WHERE id = 2\"\n}):next(function()\nprint(\"Money transfer completed\")\nend):catch(function(err)\nprint(\"Transfer failed: \" .. tostring(err))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create character with inventory\nlocal function createCharacterWithInventory(charData)\n    local queries = {\n    \"INSERT INTO lia_characters (steamID, name, faction) VALUES ('\" ..\n    charData.steamID .. \"', '\" .. charData.name .. \"', '\" .. charData.faction .. \"')\",\n    \"INSERT INTO lia_inventories (charID, invType) VALUES (last_insert_rowid(), 'pocket')\"\n    }\n    return lia.db.transaction(queries):next(function()\n    lia.log.add(\"Character and inventory created successfully\")\n    hook.Run(\"OnCharacterCreated\", charData)\nend):catch(function(err)\nlia.error(\"Failed to create character: \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex transaction with validation and rollback\nlocal function transferItemsWithValidation(fromChar, toChar, items)\n    local queries = {}\n    local validationQueries = {}\n    -- Build validation queries\n    for _, item in ipairs(items) do\n        table.insert(validationQueries,\n        \"SELECT COUNT(*) FROM lia_items WHERE invID = \" .. fromChar.invID ..\n        \" AND uniqueID = '\" .. item.uniqueID .. \"' AND quantity &gt;= \" .. item.quantity)\n    end\n    -- Build transfer queries\n    for _, item in ipairs(items) do\n        table.insert(queries,\n        \"UPDATE lia_items SET quantity = quantity - \" .. item.quantity ..\n        \" WHERE invID = \" .. fromChar.invID .. \" AND uniqueID = '\" .. item.uniqueID .. \"'\")\n        table.insert(queries,\n        \"INSERT OR REPLACE INTO lia_items (invID, uniqueID, quantity) VALUES (\" ..\n        toChar.invID .. \", '\" .. item.uniqueID .. \"', \" .. item.quantity .. \")\")\n    end\n    return lia.db.transaction(queries):next(function()\n    lia.log.add(\"Items transferred successfully\")\n    hook.Run(\"OnItemsTransferred\", fromChar, toChar, items)\nend):catch(function(err)\nlia.error(\"Item transfer failed: \" .. tostring(err))\nhook.Run(\"OnTransferFailed\", fromChar, toChar, items, err)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#escapeidentifier","title":"escapeIdentifier","text":"<p>Purpose</p> <p>Escapes database identifiers (table names, column names) to prevent SQL injection</p> <p>When Called</p> <p>Internally by database functions when building SQL queries with dynamic identifiers</p> <p>Parameters</p> <ul> <li><code>id</code> (string): Identifier to escape (table name, column name, etc.)</li> </ul> <p>Returns</p> <ul> <li>Escaped identifier string wrapped in backticks</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Escape a column name\nlocal escapedColumn = lia.db.escapeIdentifier(\"user_name\")\n-- Returns: `user_name`\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Escape multiple identifiers\nlocal function buildSelectQuery(tableName, columns)\n    local escapedTable = lia.db.escapeIdentifier(tableName)\n    local escapedColumns = {}\n    for _, column in ipairs(columns) do\n        table.insert(escapedColumns, lia.db.escapeIdentifier(column))\n    end\n    return \"SELECT \" .. table.concat(escapedColumns, \", \") .. \" FROM \" .. escapedTable\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Escape with validation and error handling\nlocal function safeEscapeIdentifiers(identifiers)\n    local escaped = {}\n    for _, id in ipairs(identifiers) do\n        if type(id) == \"string\" and id:match(\"^[a-zA-Z_][a-zA-Z0-9_]*$\") then\n            table.insert(escaped, lia.db.escapeIdentifier(id))\n            else\n                lia.log.add(\"Invalid identifier: \" .. tostring(id))\n                return nil\n            end\n        end\n        return escaped\n    end\n</code></pre></p>"},{"location":"libraries/lia.database/#upsert","title":"upsert","text":"<p>Purpose</p> <p>Inserts a new record or updates an existing one based on primary key conflicts</p> <p>When Called</p> <p>When synchronizing data that may already exist, like configuration updates or data imports</p> <p>Parameters</p> <ul> <li><code>value</code> (table): Key-value pairs representing the data to upsert</li> <li><code>dbTable</code> (string, optional): Table name without 'lia_' prefix (defaults to 'characters')</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object with results and lastID</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Upsert configuration\nlia.db.upsert({\nschema = \"default\",\nkey = \"serverName\",\nvalue = \"My Server\"\n}, \"config\"):next(function(results, lastID)\nprint(\"Configuration upserted\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Upsert with validation and logging\nlocal function syncPlayerData(player)\n    local playerData = {\n    steamID = player:SteamID(),\n    steamName = player:Name(),\n    lastJoin = os.date(\"%Y-%m-%d %H:%M:%S\"),\n    userGroup = player:GetUserGroup()\n    }\n    return lia.db.upsert(playerData, \"players\"):next(function(results, lastID)\n    lia.log.add(\"Player data synchronized: \" .. player:Name())\n    hook.Run(\"OnPlayerDataSynced\", player, lastID)\nend):catch(function(err)\nlia.error(\"Failed to sync player data: \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Upsert with conflict resolution and validation\nlocal function upsertWithValidation(data, dbTable, validationRules)\n    local validation = validateData(data, validationRules)\n    if not validation.valid then\n        return deferred.new():reject(\"Validation failed: \" .. validation.error)\n    end\n    return lia.db.upsert(data, dbTable):next(function(results, lastID)\n    local action = lastID and \"inserted\" or \"updated\"\n    lia.log.add(\"Record \" .. action .. \" in \" .. dbTable)\n    -- Update cache if applicable\n    if lia.char.cache and dbTable == \"characters\" then\n        lia.char.cache[data.id or lastID] = data\n    end\n    hook.Run(\"OnRecordUpserted\", dbTable, data, action)\n    return {success = true, action = action, id = lastID}\nend):catch(function(err)\nlia.error(\"Upsert failed: \" .. tostring(err))\nreturn {success = false, error = err}\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#delete","title":"delete","text":"<p>Purpose</p> <p>Deletes records from a database table based on specified conditions</p> <p>When Called</p> <p>When removing data like deleted characters, expired items, or cleanup operations</p> <p>Parameters</p> <ul> <li><code>dbTable</code> (string, optional): Table name without 'lia_' prefix (defaults to 'character')</li> <li><code>condition</code> (table/string, optional): WHERE clause conditions for the deletion</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object with results and lastID</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Delete character by ID\nlia.db.delete(\"characters\", {id = 1}):next(function(results, lastID)\nprint(\"Character deleted\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Delete with validation and logging\nlocal function deleteCharacter(charID)\n    return lia.db.delete(\"characters\", {id = charID}):next(function(results, lastID)\n    lia.log.add(\"Character \" .. charID .. \" deleted\")\n    hook.Run(\"OnCharacterDeleted\", charID)\n    -- Clean up related data\n    lia.db.delete(\"items\", {invID = charID})\n    lia.db.delete(\"inventories\", {charID = charID})\nend):catch(function(err)\nlia.error(\"Failed to delete character: \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Delete with cascade and transaction safety\nlocal function deleteCharacterWithCascade(charID)\n    return lia.db.transaction({\n    \"DELETE FROM lia_items WHERE invID IN (SELECT invID FROM lia_inventories WHERE charID = \" .. charID .. \")\",\n    \"DELETE FROM lia_inventories WHERE charID = \" .. charID,\n    \"DELETE FROM lia_chardata WHERE charID = \" .. charID,\n    \"DELETE FROM lia_characters WHERE id = \" .. charID\n    }):next(function()\n    lia.log.add(\"Character \" .. charID .. \" and all related data deleted\")\n    -- Update cache\n    if lia.char.cache then\n        lia.char.cache[charID] = nil\n    end\n    hook.Run(\"OnCharacterDeleted\", charID)\n    return {success = true, charID = charID}\nend):catch(function(err)\nlia.error(\"Failed to delete character with cascade: \" .. tostring(err))\nreturn {success = false, error = err}\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#createtable","title":"createTable","text":"<p>Purpose</p> <p>Creates a new database table with specified schema and primary key</p> <p>When Called</p> <p>When setting up custom tables for modules or extending the database schema</p> <p>Parameters</p> <ul> <li><code>dbName</code> (string): Table name without 'lia_' prefix</li> <li><code>primaryKey</code> (string, optional): Primary key column name</li> <li><code>schema</code> (table): Array of column definitions with name, type, not_null, and default properties</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to true on success</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a basic table\nlia.db.createTable(\"custom_data\", \"id\", {\n{name = \"id\", type = \"INTEGER\", not_null = true},\n{name = \"data\", type = \"TEXT\"}\n}):next(function(success)\nprint(\"Table created successfully\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create table with validation\nlocal function createPlayerStatsTable()\n    local schema = {\n    {name = \"id\", type = \"INTEGER\", not_null = true},\n    {name = \"steamID\", type = \"VARCHAR(255)\", not_null = true},\n    {name = \"kills\", type = \"INTEGER\", default = 0},\n    {name = \"deaths\", type = \"INTEGER\", default = 0},\n    {name = \"score\", type = \"INTEGER\", default = 0},\n    {name = \"lastUpdated\", type = \"DATETIME\", default = \"CURRENT_TIMESTAMP\"}\n    }\n    return lia.db.createTable(\"player_stats\", \"id\", schema):next(function(success)\n    if success then\n        lia.log.add(\"Player stats table created\")\n        hook.Run(\"OnPlayerStatsTableCreated\")\n    end\nend):catch(function(err)\nlia.error(\"Failed to create player stats table: \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create table with validation and error handling\nlocal function createModuleTable(moduleName, tableConfig)\n    local function validateSchema(schema)\n        for _, column in ipairs(schema) do\n            if not column.name or not column.type then\n                return false, \"Invalid column definition\"\n            end\n        end\n        return true\n    end\n    local valid, error = validateSchema(tableConfig.schema)\n    if not valid then\n        return deferred.new():reject(\"Schema validation failed: \" .. error)\n    end\n    return lia.db.tableExists(\"lia_\" .. moduleName .. \"_\" .. tableConfig.name):next(function(exists)\n    if exists then\n        lia.log.add(\"Table already exists: \" .. moduleName .. \"_\" .. tableConfig.name)\n        return true\n    end\n    return lia.db.createTable(moduleName .. \"_\" .. tableConfig.name,\n    tableConfig.primaryKey, tableConfig.schema):next(function(success)\n    if success then\n        lia.log.add(\"Module table created: \" .. moduleName .. \"_\" .. tableConfig.name)\n        hook.Run(\"OnModuleTableCreated\", moduleName, tableConfig.name)\n    end\n    return success\nend)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#createcolumn","title":"createColumn","text":"<p>Purpose</p> <p>Adds a new column to an existing database table</p> <p>When Called</p> <p>When extending table schemas, adding new fields, or during database migrations</p> <p>Parameters</p> <ul> <li><code>tableName</code> (string): Table name without 'lia_' prefix</li> <li><code>columnName</code> (string): Name of the new column to add</li> <li><code>columnType</code> (string): SQL data type for the column</li> <li><code>defaultValue</code> (any, optional): Default value for the column</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to true on success, false if column already exists</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a new column\nlia.db.createColumn(\"characters\", \"level\", \"INTEGER\", 1):next(function(success)\nif success then\n    print(\"Level column added\")\n    else\n        print(\"Column already exists\")\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add column with validation\nlocal function addPlayerStatsColumn()\n    return lia.db.createColumn(\"players\", \"totalPlayTime\", \"FLOAT\", 0):next(function(success)\n    if success then\n        lia.log.add(\"Added totalPlayTime column to players table\")\n        hook.Run(\"OnColumnAdded\", \"players\", \"totalPlayTime\")\n        else\n            lia.log.add(\"totalPlayTime column already exists\")\n        end\n    end):catch(function(err)\n    lia.error(\"Failed to add column: \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add column with validation and error handling\nlocal function migrateCharacterTable()\n    local newColumns = {\n    {name = \"level\", type = \"INTEGER\", default = 1},\n    {name = \"experience\", type = \"INTEGER\", default = 0},\n    {name = \"lastLevelUp\", type = \"DATETIME\", default = \"CURRENT_TIMESTAMP\"}\n    }\n    local function addNextColumn(index)\n        if index &gt; #newColumns then\n            lia.log.add(\"Character table migration completed\")\n            return deferred.new():resolve()\n        end\n        local column = newColumns[index]\n        return lia.db.createColumn(\"characters\", column.name, column.type, column.default):next(function(success)\n        if success then\n            lia.log.add(\"Added column: \" .. column.name)\n        end\n        return addNextColumn(index + 1)\n    end):catch(function(err)\n    lia.error(\"Failed to add column \" .. column.name .. \": \" .. tostring(err))\n    return addNextColumn(index + 1)\nend)\nend\nreturn addNextColumn(1)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#removetable","title":"removeTable","text":"<p>Purpose</p> <p>Removes a database table and all its data from the database</p> <p>When Called</p> <p>When cleaning up unused tables, removing modules, or during database maintenance</p> <p>Parameters</p> <ul> <li><code>tableName</code> (string): Table name without 'lia_' prefix</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to true on success, false if table doesn't exist</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove a table\nlia.db.removeTable(\"old_data\"):next(function(success)\nif success then\n    print(\"Table removed\")\n    else\n        print(\"Table doesn't exist\")\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Remove table with validation\nlocal function cleanupOldModule(moduleName)\n    return lia.db.removeTable(moduleName .. \"_data\"):next(function(success)\n    if success then\n        lia.log.add(\"Removed table for module: \" .. moduleName)\n        hook.Run(\"OnModuleTableRemoved\", moduleName)\n        else\n            lia.log.add(\"Table for module \" .. moduleName .. \" doesn't exist\")\n        end\n    end):catch(function(err)\n    lia.error(\"Failed to remove table: \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Remove table with backup and validation\nlocal function removeTableWithBackup(tableName)\n    return lia.db.tableExists(\"lia_\" .. tableName):next(function(exists)\n    if not exists then\n        lia.log.add(\"Table \" .. tableName .. \" doesn't exist\")\n        return false\n    end\n    -- Create backup before removal\n    return lia.db.createSnapshot(tableName):next(function(snapshot)\n    lia.log.add(\"Created backup: \" .. snapshot.file)\n    return lia.db.removeTable(tableName):next(function(success)\n    if success then\n        lia.log.add(\"Table \" .. tableName .. \" removed successfully\")\n        hook.Run(\"OnTableRemoved\", tableName, snapshot)\n    end\n    return success\nend)\nend):catch(function(err)\nlia.error(\"Failed to backup table \" .. tableName .. \": \" .. tostring(err))\nreturn false\nend)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#removecolumn","title":"removeColumn","text":"<p>Purpose</p> <p>Removes a column from an existing database table using table recreation</p> <p>When Called</p> <p>When removing unused columns, cleaning up schemas, or during database migrations</p> <p>Parameters</p> <ul> <li><code>tableName</code> (string): Table name without 'lia_' prefix</li> <li><code>columnName</code> (string): Name of the column to remove</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to true on success, false if column doesn't exist</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove a column\nlia.db.removeColumn(\"characters\", \"old_field\"):next(function(success)\nif success then\n    print(\"Column removed\")\n    else\n        print(\"Column doesn't exist\")\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Remove column with validation\nlocal function cleanupOldColumn(tableName, columnName)\n    return lia.db.removeColumn(tableName, columnName):next(function(success)\n    if success then\n        lia.log.add(\"Removed column \" .. columnName .. \" from \" .. tableName)\n        hook.Run(\"OnColumnRemoved\", tableName, columnName)\n        else\n            lia.log.add(\"Column \" .. columnName .. \" doesn't exist in \" .. tableName)\n        end\n    end):catch(function(err)\n    lia.error(\"Failed to remove column: \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Remove column with backup and validation\nlocal function removeColumnWithBackup(tableName, columnName)\n    return lia.db.tableExists(\"lia_\" .. tableName):next(function(tableExists)\n    if not tableExists then\n        lia.error(\"Table \" .. tableName .. \" doesn't exist\")\n        return false\n    end\n    return lia.db.fieldExists(\"lia_\" .. tableName, columnName):next(function(columnExists)\n    if not columnExists then\n        lia.log.add(\"Column \" .. columnName .. \" doesn't exist\")\n        return false\n    end\n    -- Create backup before removal\n    return lia.db.createSnapshot(tableName):next(function(snapshot)\n    lia.log.add(\"Created backup before column removal: \" .. snapshot.file)\n    return lia.db.removeColumn(tableName, columnName):next(function(success)\n    if success then\n        lia.log.add(\"Column \" .. columnName .. \" removed from \" .. tableName)\n        hook.Run(\"OnColumnRemoved\", tableName, columnName, snapshot)\n    end\n    return success\nend)\nend):catch(function(err)\nlia.error(\"Failed to backup table before column removal: \" .. tostring(err))\nreturn false\nend)\nend)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#getcharactertable","title":"getCharacterTable","text":"<p>Purpose</p> <p>Retrieves the column information for the lia_characters table</p> <p>When Called</p> <p>When analyzing character table structure, generating reports, or during schema validation</p> <p>Parameters</p> <ul> <li><code>callback</code> (function): Function to call with the column information array</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get character table columns\nlia.db.getCharacterTable(function(columns)\nprint(\"Character table has \" .. #columns .. \" columns\")\nfor _, column in ipairs(columns) do\n    print(\"- \" .. column)\nend\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get columns with analysis\nlocal function analyzeCharacterTable()\n    lia.db.getCharacterTable(function(columns)\n    local requiredColumns = {\"id\", \"steamID\", \"name\", \"model\", \"faction\", \"money\"}\n    local missingColumns = {}\n    for _, required in ipairs(requiredColumns) do\n        if not table.HasValue(columns, required) then\n            table.insert(missingColumns, required)\n        end\n    end\n    if #missingColumns &gt; 0 then\n        lia.log.add(\"Missing character columns: \" .. table.concat(missingColumns, \", \"))\n        else\n            lia.log.add(\"All required character columns present\")\n        end\n    end)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get columns with validation and error handling\nlocal function validateCharacterSchema()\n    return lia.db.waitForTablesToLoad():next(function()\n    lia.db.getCharacterTable(function(columns)\n    if not columns or #columns == 0 then\n        lia.error(\"Failed to get character table columns\")\n        return\n    end\n    local schemaValidation = {\n    required = {\"id\", \"steamID\", \"name\", \"model\", \"faction\", \"money\"},\n    optional = {\"desc\", \"attribs\", \"schema\", \"createTime\", \"lastJoinTime\", \"recognition\", \"fakenames\"}\n    }\n    local validationResults = {\n    valid = true,\n    missing = {},\n    extra = {}\n    }\n    -- Check for missing required columns\n    for _, required in ipairs(schemaValidation.required) do\n        if not table.HasValue(columns, required) then\n            table.insert(validationResults.missing, required)\n            validationResults.valid = false\n        end\n    end\n    -- Check for extra columns\n    for _, column in ipairs(columns) do\n        if not table.HasValue(schemaValidation.required, column) and\n        not table.HasValue(schemaValidation.optional, column) then\n        table.insert(validationResults.extra, column)\n    end\nend\nif validationResults.valid then\n    lia.log.add(\"Character table schema validation passed\")\n    else\n        lia.log.add(\"Character table schema issues found\")\n        if #validationResults.missing &gt; 0 then\n            lia.log.add(\"Missing columns: \" .. table.concat(validationResults.missing, \", \"))\n        end\n        if #validationResults.extra &gt; 0 then\n            lia.log.add(\"Extra columns: \" .. table.concat(validationResults.extra, \", \"))\n        end\n    end\n    hook.Run(\"OnCharacterSchemaValidated\", validationResults)\nend)\nend):catch(function(err)\nlia.error(\"Character schema validation failed: \" .. tostring(err))\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#createsnapshot","title":"createSnapshot","text":"<p>Purpose</p> <p>Creates a backup snapshot of a database table and saves it to a JSON file</p> <p>When Called</p> <p>When backing up data before major operations, creating restore points, or archiving data</p> <p>Parameters</p> <ul> <li><code>tableName</code> (string): Table name without 'lia_' prefix</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to snapshot information (file, path, records)</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a snapshot\nlia.db.createSnapshot(\"characters\"):next(function(snapshot)\nprint(\"Snapshot created: \" .. snapshot.file)\nprint(\"Records backed up: \" .. snapshot.records)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create snapshot with validation\nlocal function backupTable(tableName)\n    return lia.db.createSnapshot(tableName):next(function(snapshot)\n    lia.log.add(\"Backup created: \" .. snapshot.file .. \" (\" .. snapshot.records .. \" records)\")\n    hook.Run(\"OnTableBackedUp\", tableName, snapshot)\n    return snapshot\nend):catch(function(err)\nlia.error(\"Failed to backup table \" .. tableName .. \": \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create snapshot with validation and error handling\nlocal function createBackupWithValidation(tableName)\n    return lia.db.tableExists(\"lia_\" .. tableName):next(function(exists)\n    if not exists then\n        return deferred.new():reject(\"Table \" .. tableName .. \" doesn't exist\")\n    end\n    return lia.db.createSnapshot(tableName):next(function(snapshot)\n    -- Validate snapshot data\n    if snapshot.records == 0 then\n        lia.log.add(\"Snapshot created but table is empty\")\n    end\n    -- Create backup metadata\n    local metadata = {\n    table = tableName,\n    timestamp = snapshot.timestamp,\n    records = snapshot.records,\n    file = snapshot.file,\n    path = snapshot.path,\n    server = GetHostName(),\n    version = lia.version or \"unknown\"\n    }\n    -- Save metadata\n    local metadataFile = \"lilia/snapshots/\" .. snapshot.file .. \".meta\"\n    file.Write(metadataFile, util.TableToJSON(metadata, true))\n    lia.log.add(\"Backup completed: \" .. snapshot.file .. \" (\" .. snapshot.records .. \" records)\")\n    hook.Run(\"OnBackupCreated\", metadata)\n    return metadata\nend):catch(function(err)\nlia.error(\"Backup failed for \" .. tableName .. \": \" .. tostring(err))\nreturn {success = false, error = err}\nend)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#loadsnapshot","title":"loadSnapshot","text":"<p>Purpose</p> <p>Restores a database table from a previously created snapshot file</p> <p>When Called</p> <p>When restoring data from backups, recovering from errors, or migrating data</p> <p>Parameters</p> <ul> <li><code>fileName</code> (string): Name of the snapshot file to load</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to restore information (table, records, timestamp)</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a snapshot\nlia.db.loadSnapshot(\"snapshot_characters_1234567890.json\"):next(function(result)\nprint(\"Restored \" .. result.records .. \" records to \" .. result.table)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load snapshot with validation\nlocal function restoreTable(fileName)\n    return lia.db.loadSnapshot(fileName):next(function(result)\n    lia.log.add(\"Restored \" .. result.records .. \" records to \" .. result.table)\n    hook.Run(\"OnTableRestored\", result.table, result.records)\n    return result\nend):catch(function(err)\nlia.error(\"Failed to restore from \" .. fileName .. \": \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load snapshot with validation and error handling\nlocal function restoreWithValidation(fileName)\n    return lia.db.loadSnapshot(fileName):next(function(result)\n    -- Validate restore results\n    if result.records == 0 then\n        lia.log.add(\"Restore completed but no records were loaded\")\n    end\n    -- Verify table exists and has data\n    return lia.db.count(result.table):next(function(count)\n    if count ~= result.records then\n        lia.log.add(\"Record count mismatch: expected \" .. result.records .. \", got \" .. count)\n    end\n    -- Create restore log entry\n    local restoreLog = {\n    fileName = fileName,\n    table = result.table,\n    records = result.records,\n    timestamp = result.timestamp,\n    restoredAt = os.time(),\n    success = true\n    }\n    lia.log.add(\"Restore completed successfully: \" .. fileName)\n    hook.Run(\"OnRestoreCompleted\", restoreLog)\n    return restoreLog\nend)\nend):catch(function(err)\nlia.error(\"Restore failed: \" .. tostring(err))\n-- Log failed restore attempt\nlocal failedLog = {\nfileName = fileName,\nerror = tostring(err),\nfailedAt = os.time(),\nsuccess = false\n}\nhook.Run(\"OnRestoreFailed\", failedLog)\nreturn failedLog\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#liagmregisterpreparedstatements","title":"lia.GM:RegisterPreparedStatements","text":"<p>Purpose</p> <p>Restores a database table from a previously created snapshot file</p> <p>When Called</p> <p>When restoring data from backups, recovering from errors, or migrating data</p> <p>Parameters</p> <ul> <li><code>fileName</code> (string): Name of the snapshot file to load</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to restore information (table, records, timestamp)</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a snapshot\nlia.db.loadSnapshot(\"snapshot_characters_1234567890.json\"):next(function(result)\nprint(\"Restored \" .. result.records .. \" records to \" .. result.table)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load snapshot with validation\nlocal function restoreTable(fileName)\n    return lia.db.loadSnapshot(fileName):next(function(result)\n    lia.log.add(\"Restored \" .. result.records .. \" records to \" .. result.table)\n    hook.Run(\"OnTableRestored\", result.table, result.records)\n    return result\nend):catch(function(err)\nlia.error(\"Failed to restore from \" .. fileName .. \": \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load snapshot with validation and error handling\nlocal function restoreWithValidation(fileName)\n    return lia.db.loadSnapshot(fileName):next(function(result)\n    -- Validate restore results\n    if result.records == 0 then\n        lia.log.add(\"Restore completed but no records were loaded\")\n    end\n    -- Verify table exists and has data\n    return lia.db.count(result.table):next(function(count)\n    if count ~= result.records then\n        lia.log.add(\"Record count mismatch: expected \" .. result.records .. \", got \" .. count)\n    end\n    -- Create restore log entry\n    local restoreLog = {\n    fileName = fileName,\n    table = result.table,\n    records = result.records,\n    timestamp = result.timestamp,\n    restoredAt = os.time(),\n    success = true\n    }\n    lia.log.add(\"Restore completed successfully: \" .. fileName)\n    hook.Run(\"OnRestoreCompleted\", restoreLog)\n    return restoreLog\nend)\nend):catch(function(err)\nlia.error(\"Restore failed: \" .. tostring(err))\n-- Log failed restore attempt\nlocal failedLog = {\nfileName = fileName,\nerror = tostring(err),\nfailedAt = os.time(),\nsuccess = false\n}\nhook.Run(\"OnRestoreFailed\", failedLog)\nreturn failedLog\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#liagmsetupdatabase","title":"lia.GM:SetupDatabase","text":"<p>Purpose</p> <p>Restores a database table from a previously created snapshot file</p> <p>When Called</p> <p>When restoring data from backups, recovering from errors, or migrating data</p> <p>Parameters</p> <ul> <li><code>fileName</code> (string): Name of the snapshot file to load</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to restore information (table, records, timestamp)</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a snapshot\nlia.db.loadSnapshot(\"snapshot_characters_1234567890.json\"):next(function(result)\nprint(\"Restored \" .. result.records .. \" records to \" .. result.table)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load snapshot with validation\nlocal function restoreTable(fileName)\n    return lia.db.loadSnapshot(fileName):next(function(result)\n    lia.log.add(\"Restored \" .. result.records .. \" records to \" .. result.table)\n    hook.Run(\"OnTableRestored\", result.table, result.records)\n    return result\nend):catch(function(err)\nlia.error(\"Failed to restore from \" .. fileName .. \": \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load snapshot with validation and error handling\nlocal function restoreWithValidation(fileName)\n    return lia.db.loadSnapshot(fileName):next(function(result)\n    -- Validate restore results\n    if result.records == 0 then\n        lia.log.add(\"Restore completed but no records were loaded\")\n    end\n    -- Verify table exists and has data\n    return lia.db.count(result.table):next(function(count)\n    if count ~= result.records then\n        lia.log.add(\"Record count mismatch: expected \" .. result.records .. \", got \" .. count)\n    end\n    -- Create restore log entry\n    local restoreLog = {\n    fileName = fileName,\n    table = result.table,\n    records = result.records,\n    timestamp = result.timestamp,\n    restoredAt = os.time(),\n    success = true\n    }\n    lia.log.add(\"Restore completed successfully: \" .. fileName)\n    hook.Run(\"OnRestoreCompleted\", restoreLog)\n    return restoreLog\nend)\nend):catch(function(err)\nlia.error(\"Restore failed: \" .. tostring(err))\n-- Log failed restore attempt\nlocal failedLog = {\nfileName = fileName,\nerror = tostring(err),\nfailedAt = os.time(),\nsuccess = false\n}\nhook.Run(\"OnRestoreFailed\", failedLog)\nreturn failedLog\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.database/#liagmdatabaseconnected","title":"lia.GM:DatabaseConnected","text":"<p>Purpose</p> <p>Restores a database table from a previously created snapshot file</p> <p>When Called</p> <p>When restoring data from backups, recovering from errors, or migrating data</p> <p>Parameters</p> <ul> <li><code>fileName</code> (string): Name of the snapshot file to load</li> </ul> <p>Returns</p> <ul> <li>Deferred promise object resolving to restore information (table, records, timestamp)</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a snapshot\nlia.db.loadSnapshot(\"snapshot_characters_1234567890.json\"):next(function(result)\nprint(\"Restored \" .. result.records .. \" records to \" .. result.table)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load snapshot with validation\nlocal function restoreTable(fileName)\n    return lia.db.loadSnapshot(fileName):next(function(result)\n    lia.log.add(\"Restored \" .. result.records .. \" records to \" .. result.table)\n    hook.Run(\"OnTableRestored\", result.table, result.records)\n    return result\nend):catch(function(err)\nlia.error(\"Failed to restore from \" .. fileName .. \": \" .. tostring(err))\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load snapshot with validation and error handling\nlocal function restoreWithValidation(fileName)\n    return lia.db.loadSnapshot(fileName):next(function(result)\n    -- Validate restore results\n    if result.records == 0 then\n        lia.log.add(\"Restore completed but no records were loaded\")\n    end\n    -- Verify table exists and has data\n    return lia.db.count(result.table):next(function(count)\n    if count ~= result.records then\n        lia.log.add(\"Record count mismatch: expected \" .. result.records .. \", got \" .. count)\n    end\n    -- Create restore log entry\n    local restoreLog = {\n    fileName = fileName,\n    table = result.table,\n    records = result.records,\n    timestamp = result.timestamp,\n    restoredAt = os.time(),\n    success = true\n    }\n    lia.log.add(\"Restore completed successfully: \" .. fileName)\n    hook.Run(\"OnRestoreCompleted\", restoreLog)\n    return restoreLog\nend)\nend):catch(function(err)\nlia.error(\"Restore failed: \" .. tostring(err))\n-- Log failed restore attempt\nlocal failedLog = {\nfileName = fileName,\nerror = tostring(err),\nfailedAt = os.time(),\nsuccess = false\n}\nhook.Run(\"OnRestoreFailed\", failedLog)\nreturn failedLog\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.derma/","title":"Derma Library","text":"<p>Advanced UI rendering and interaction system for the Lilia framework.</p> <p>Overview</p> <p>The derma library provides comprehensive UI rendering and interaction functionality for the Lilia framework. It handles advanced drawing operations including rounded rectangles, circles, shadows, blur effects, and gradients using custom shaders. The library offers a fluent API for creating complex UI elements with smooth animations, color pickers, player selectors, and various input dialogs. It includes utility functions for text rendering with shadows and outlines, entity text display, and menu positioning. The library operates primarily on the client side and provides both low-level drawing functions and high-level UI components for creating modern, visually appealing interfaces.</p>"},{"location":"libraries/lia.derma/#dermamenu","title":"dermaMenu","text":"<p>Purpose</p> <p>Creates a context menu at the current mouse cursor position</p> <p>When Called</p> <p>When right-clicking or when a context menu is needed</p> <p>Returns</p> <ul> <li>Panel - The created context menu panel</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a basic context menu\nlocal menu = lia.derma.dermaMenu()\nmenu:AddOption(\"Option 1\", function() print(\"Option 1 clicked\") end)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create context menu with multiple options\nlocal menu = lia.derma.dermaMenu()\nmenu:AddOption(\"Edit\", function() editItem() end)\nmenu:AddOption(\"Delete\", function() deleteItem() end)\nmenu:AddSpacer()\nmenu:AddOption(\"Properties\", function() showProperties() end)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create dynamic context menu based on conditions\nlocal menu = lia.derma.dermaMenu()\nif player:IsAdmin() then\n    menu:AddOption(\"Admin Action\", function() adminAction() end)\nend\nif item:CanUse() then\n    menu:AddOption(\"Use Item\", function() item:Use() end)\nend\nmenu:AddOption(\"Inspect\", function() inspectItem(item) end)\n</code></pre></p>"},{"location":"libraries/lia.derma/#optionsmenu","title":"optionsMenu","text":"<p>Purpose</p> <p>Creates a generic options menu that can display interaction/action menus or arbitrary option lists</p> <p>When Called</p> <p>When displaying a menu with selectable options (interactions, actions, or custom options)</p> <p>Parameters</p> <ul> <li><code>rawOptions</code> (table): Options to display. Can be:</li> <li><code>config</code> (table, optional): Configuration options including:</li> <li><code>mode</code> (string, optional): \"interaction\", \"action\", or \"custom\" (defaults to \"custom\")</li> <li><code>title</code> (string, optional): Menu title text</li> <li><code>closeKey</code> (number, optional): Key code that closes menu when released</li> <li><code>netMsg</code> (string, optional): Network message name for server-only options</li> <li><code>preFiltered</code> (boolean, optional): Whether options are already filtered (defaults to false)</li> <li><code>entity</code> (Entity, optional): Target entity for interaction mode</li> <li><code>resolveEntity</code> (boolean, optional): Whether to resolve traced entity (defaults to true for non-custom modes)</li> <li><code>emitHooks</code> (boolean, optional): Whether to emit InteractionMenuOpened/Closed hooks (defaults to true for non-custom modes)</li> <li><code>registryKey</code> (string, optional): Key for storing menu in lia.gui (defaults to \"InteractionMenu\" or \"OptionsMenu\")</li> <li><code>fadeSpeed</code> (number, optional): Animation fade speed in seconds (defaults to 0.05)</li> <li><code>frameW</code> (number, optional): Frame width in pixels (defaults to 450)</li> <li><code>frameH</code> (number, optional): Frame height in pixels (auto-calculated if not provided)</li> <li><code>entryH</code> (number, optional): Height of each option button (defaults to 30)</li> <li><code>maxHeight</code> (number, optional): Maximum frame height (defaults to 60% of screen height)</li> <li><code>titleHeight</code> (number, optional): Title label height (defaults to 36 or 16 based on mode)</li> <li><code>titleOffsetY</code> (number, optional): Y offset for title (defaults to 2)</li> <li><code>verticalGap</code> (number, optional): Vertical spacing between title and scroll area (defaults to 24)</li> <li><code>screenPadding</code> (number, optional): Screen padding for frame positioning (defaults to 15% of screen width)</li> <li><code>x</code> (number, optional): Custom X position (auto-calculated if not provided)</li> <li><code>y</code> (number, optional): Custom Y position (auto-calculated if not provided)</li> <li><code>titleFont</code> (string, optional): Font for title text (defaults to \"liaSmallFont\")</li> <li><code>titleColor</code> (Color, optional): Color for title text (defaults to color_white)</li> <li><code>buttonFont</code> (string, optional): Font for option buttons (defaults to \"liaSmallFont\")</li> <li><code>buttonTextColor</code> (Color, optional): Color for button text (defaults to color_white)</li> <li><code>closeOnSelect</code> (boolean, optional): Whether to close menu when option is selected (defaults to true)</li> <li><code>timerName</code> (string, optional): Name for auto-close timer</li> <li><code>autoCloseDelay</code> (number, optional): Seconds until auto-close (defaults to 30, 0 to disable)</li> </ul> <p>Returns</p> <ul> <li>Panel - The created menu frame, or nil if no valid options or invalid client</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display a basic custom options menu\nlia.derma.optionsMenu({\n{name = \"Option 1\", callback = function() print(\"Selected 1\") end},\n{name = \"Option 2\", callback = function() print(\"Selected 2\") end}\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom menu with descriptions and custom positioning\nlia.derma.optionsMenu({\n{\nname = \"Save Game\",\ndescription = \"Save your current progress\",\ncallback = function() saveGame() end\n},\n{\nname = \"Load Game\",\ndescription = \"Load a previously saved game\",\ncallback = function() loadGame() end\n},\n{\nname = \"Settings\",\ndescription = \"Open game settings\",\ncallback = function() openSettings() end\n}\n}, {\ntitle = \"Main Menu\",\nx = ScrW() / 2 - 225,\ny = ScrH() / 2 - 150,\nframeW = 450,\ncloseOnSelect = false\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced menu with custom callbacks and network messaging\nlia.derma.optionsMenu({\n{\nname = \"Radio Preset 1\",\ndescription = \"Switch to preset frequency 1\",\ncallback = function(client, entity, entry, frame)\n-- Custom callback with context\nlia.radio.setFrequency(100.0)\nclient:notify(\"Switched to radio preset 1\")\nend,\npassContext = true -- Pass client, entity, entry, frame to callback\n},\n{\nname = \"Radio Preset 2\",\ndescription = \"Switch to preset frequency 2\",\nserverOnly = true,\nnetMessage = \"liaRadioSetPreset\",\nnetworkID = \"preset2\"\n},\n{\nname = \"Custom Frequency\",\ndescription = \"Enter a custom frequency\",\ncallback = function()\n-- Open frequency input dialog\nlia.derma.textBox(\"Enter Frequency\", \"Enter radio frequency (MHz):\", function(freq)\nlocal numFreq = tonumber(freq)\nif numFreq and numFreq &gt;= 80 and numFreq &lt;= 200 then\n    lia.radio.setFrequency(numFreq)\n    client:notify(\"Frequency set to \" .. freq .. \" MHz\")\n    else\n        client:notify(\"Invalid frequency range (80-200 MHz)\")\n    end\nend)\nend\n}\n}, {\ntitle = \"Radio Presets\",\nmode = \"custom\",\ncloseKey = KEY_R,\nfadeSpeed = 0.1,\nautoCloseDelay = 60\n})\n</code></pre></p>"},{"location":"libraries/lia.derma/#liaframepaint","title":"lia.frame:Paint","text":"<p>Purpose</p> <p>Creates a generic options menu that can display interaction/action menus or arbitrary option lists</p> <p>When Called</p> <p>When displaying a menu with selectable options (interactions, actions, or custom options)</p> <p>Parameters</p> <ul> <li><code>rawOptions</code> (table): Options to display. Can be:</li> <li><code>config</code> (table, optional): Configuration options including:</li> <li><code>mode</code> (string, optional): \"interaction\", \"action\", or \"custom\" (defaults to \"custom\")</li> <li><code>title</code> (string, optional): Menu title text</li> <li><code>closeKey</code> (number, optional): Key code that closes menu when released</li> <li><code>netMsg</code> (string, optional): Network message name for server-only options</li> <li><code>preFiltered</code> (boolean, optional): Whether options are already filtered (defaults to false)</li> <li><code>entity</code> (Entity, optional): Target entity for interaction mode</li> <li><code>resolveEntity</code> (boolean, optional): Whether to resolve traced entity (defaults to true for non-custom modes)</li> <li><code>emitHooks</code> (boolean, optional): Whether to emit InteractionMenuOpened/Closed hooks (defaults to true for non-custom modes)</li> <li><code>registryKey</code> (string, optional): Key for storing menu in lia.gui (defaults to \"InteractionMenu\" or \"OptionsMenu\")</li> <li><code>fadeSpeed</code> (number, optional): Animation fade speed in seconds (defaults to 0.05)</li> <li><code>frameW</code> (number, optional): Frame width in pixels (defaults to 450)</li> <li><code>frameH</code> (number, optional): Frame height in pixels (auto-calculated if not provided)</li> <li><code>entryH</code> (number, optional): Height of each option button (defaults to 30)</li> <li><code>maxHeight</code> (number, optional): Maximum frame height (defaults to 60% of screen height)</li> <li><code>titleHeight</code> (number, optional): Title label height (defaults to 36 or 16 based on mode)</li> <li><code>titleOffsetY</code> (number, optional): Y offset for title (defaults to 2)</li> <li><code>verticalGap</code> (number, optional): Vertical spacing between title and scroll area (defaults to 24)</li> <li><code>screenPadding</code> (number, optional): Screen padding for frame positioning (defaults to 15% of screen width)</li> <li><code>x</code> (number, optional): Custom X position (auto-calculated if not provided)</li> <li><code>y</code> (number, optional): Custom Y position (auto-calculated if not provided)</li> <li><code>titleFont</code> (string, optional): Font for title text (defaults to \"liaSmallFont\")</li> <li><code>titleColor</code> (Color, optional): Color for title text (defaults to color_white)</li> <li><code>buttonFont</code> (string, optional): Font for option buttons (defaults to \"liaSmallFont\")</li> <li><code>buttonTextColor</code> (Color, optional): Color for button text (defaults to color_white)</li> <li><code>closeOnSelect</code> (boolean, optional): Whether to close menu when option is selected (defaults to true)</li> <li><code>timerName</code> (string, optional): Name for auto-close timer</li> <li><code>autoCloseDelay</code> (number, optional): Seconds until auto-close (defaults to 30, 0 to disable)</li> </ul> <p>Returns</p> <ul> <li>Panel - The created menu frame, or nil if no valid options or invalid client</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display a basic custom options menu\nlia.derma.optionsMenu({\n{name = \"Option 1\", callback = function() print(\"Selected 1\") end},\n{name = \"Option 2\", callback = function() print(\"Selected 2\") end}\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom menu with descriptions and custom positioning\nlia.derma.optionsMenu({\n{\nname = \"Save Game\",\ndescription = \"Save your current progress\",\ncallback = function() saveGame() end\n},\n{\nname = \"Load Game\",\ndescription = \"Load a previously saved game\",\ncallback = function() loadGame() end\n},\n{\nname = \"Settings\",\ndescription = \"Open game settings\",\ncallback = function() openSettings() end\n}\n}, {\ntitle = \"Main Menu\",\nx = ScrW() / 2 - 225,\ny = ScrH() / 2 - 150,\nframeW = 450,\ncloseOnSelect = false\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced menu with custom callbacks and network messaging\nlia.derma.optionsMenu({\n{\nname = \"Radio Preset 1\",\ndescription = \"Switch to preset frequency 1\",\ncallback = function(client, entity, entry, frame)\n-- Custom callback with context\nlia.radio.setFrequency(100.0)\nclient:notify(\"Switched to radio preset 1\")\nend,\npassContext = true -- Pass client, entity, entry, frame to callback\n},\n{\nname = \"Radio Preset 2\",\ndescription = \"Switch to preset frequency 2\",\nserverOnly = true,\nnetMessage = \"liaRadioSetPreset\",\nnetworkID = \"preset2\"\n},\n{\nname = \"Custom Frequency\",\ndescription = \"Enter a custom frequency\",\ncallback = function()\n-- Open frequency input dialog\nlia.derma.textBox(\"Enter Frequency\", \"Enter radio frequency (MHz):\", function(freq)\nlocal numFreq = tonumber(freq)\nif numFreq and numFreq &gt;= 80 and numFreq &lt;= 200 then\n    lia.radio.setFrequency(numFreq)\n    client:notify(\"Frequency set to \" .. freq .. \" MHz\")\n    else\n        client:notify(\"Invalid frequency range (80-200 MHz)\")\n    end\nend)\nend\n}\n}, {\ntitle = \"Radio Presets\",\nmode = \"custom\",\ncloseKey = KEY_R,\nfadeSpeed = 0.1,\nautoCloseDelay = 60\n})\n</code></pre></p>"},{"location":"libraries/lia.derma/#liaframeonremove","title":"lia.frame:OnRemove","text":"<p>Purpose</p> <p>Creates a generic options menu that can display interaction/action menus or arbitrary option lists</p> <p>When Called</p> <p>When displaying a menu with selectable options (interactions, actions, or custom options)</p> <p>Parameters</p> <ul> <li><code>rawOptions</code> (table): Options to display. Can be:</li> <li><code>config</code> (table, optional): Configuration options including:</li> <li><code>mode</code> (string, optional): \"interaction\", \"action\", or \"custom\" (defaults to \"custom\")</li> <li><code>title</code> (string, optional): Menu title text</li> <li><code>closeKey</code> (number, optional): Key code that closes menu when released</li> <li><code>netMsg</code> (string, optional): Network message name for server-only options</li> <li><code>preFiltered</code> (boolean, optional): Whether options are already filtered (defaults to false)</li> <li><code>entity</code> (Entity, optional): Target entity for interaction mode</li> <li><code>resolveEntity</code> (boolean, optional): Whether to resolve traced entity (defaults to true for non-custom modes)</li> <li><code>emitHooks</code> (boolean, optional): Whether to emit InteractionMenuOpened/Closed hooks (defaults to true for non-custom modes)</li> <li><code>registryKey</code> (string, optional): Key for storing menu in lia.gui (defaults to \"InteractionMenu\" or \"OptionsMenu\")</li> <li><code>fadeSpeed</code> (number, optional): Animation fade speed in seconds (defaults to 0.05)</li> <li><code>frameW</code> (number, optional): Frame width in pixels (defaults to 450)</li> <li><code>frameH</code> (number, optional): Frame height in pixels (auto-calculated if not provided)</li> <li><code>entryH</code> (number, optional): Height of each option button (defaults to 30)</li> <li><code>maxHeight</code> (number, optional): Maximum frame height (defaults to 60% of screen height)</li> <li><code>titleHeight</code> (number, optional): Title label height (defaults to 36 or 16 based on mode)</li> <li><code>titleOffsetY</code> (number, optional): Y offset for title (defaults to 2)</li> <li><code>verticalGap</code> (number, optional): Vertical spacing between title and scroll area (defaults to 24)</li> <li><code>screenPadding</code> (number, optional): Screen padding for frame positioning (defaults to 15% of screen width)</li> <li><code>x</code> (number, optional): Custom X position (auto-calculated if not provided)</li> <li><code>y</code> (number, optional): Custom Y position (auto-calculated if not provided)</li> <li><code>titleFont</code> (string, optional): Font for title text (defaults to \"liaSmallFont\")</li> <li><code>titleColor</code> (Color, optional): Color for title text (defaults to color_white)</li> <li><code>buttonFont</code> (string, optional): Font for option buttons (defaults to \"liaSmallFont\")</li> <li><code>buttonTextColor</code> (Color, optional): Color for button text (defaults to color_white)</li> <li><code>closeOnSelect</code> (boolean, optional): Whether to close menu when option is selected (defaults to true)</li> <li><code>timerName</code> (string, optional): Name for auto-close timer</li> <li><code>autoCloseDelay</code> (number, optional): Seconds until auto-close (defaults to 30, 0 to disable)</li> </ul> <p>Returns</p> <ul> <li>Panel - The created menu frame, or nil if no valid options or invalid client</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display a basic custom options menu\nlia.derma.optionsMenu({\n{name = \"Option 1\", callback = function() print(\"Selected 1\") end},\n{name = \"Option 2\", callback = function() print(\"Selected 2\") end}\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom menu with descriptions and custom positioning\nlia.derma.optionsMenu({\n{\nname = \"Save Game\",\ndescription = \"Save your current progress\",\ncallback = function() saveGame() end\n},\n{\nname = \"Load Game\",\ndescription = \"Load a previously saved game\",\ncallback = function() loadGame() end\n},\n{\nname = \"Settings\",\ndescription = \"Open game settings\",\ncallback = function() openSettings() end\n}\n}, {\ntitle = \"Main Menu\",\nx = ScrW() / 2 - 225,\ny = ScrH() / 2 - 150,\nframeW = 450,\ncloseOnSelect = false\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced menu with custom callbacks and network messaging\nlia.derma.optionsMenu({\n{\nname = \"Radio Preset 1\",\ndescription = \"Switch to preset frequency 1\",\ncallback = function(client, entity, entry, frame)\n-- Custom callback with context\nlia.radio.setFrequency(100.0)\nclient:notify(\"Switched to radio preset 1\")\nend,\npassContext = true -- Pass client, entity, entry, frame to callback\n},\n{\nname = \"Radio Preset 2\",\ndescription = \"Switch to preset frequency 2\",\nserverOnly = true,\nnetMessage = \"liaRadioSetPreset\",\nnetworkID = \"preset2\"\n},\n{\nname = \"Custom Frequency\",\ndescription = \"Enter a custom frequency\",\ncallback = function()\n-- Open frequency input dialog\nlia.derma.textBox(\"Enter Frequency\", \"Enter radio frequency (MHz):\", function(freq)\nlocal numFreq = tonumber(freq)\nif numFreq and numFreq &gt;= 80 and numFreq &lt;= 200 then\n    lia.radio.setFrequency(numFreq)\n    client:notify(\"Frequency set to \" .. freq .. \" MHz\")\n    else\n        client:notify(\"Invalid frequency range (80-200 MHz)\")\n    end\nend)\nend\n}\n}, {\ntitle = \"Radio Presets\",\nmode = \"custom\",\ncloseKey = KEY_R,\nfadeSpeed = 0.1,\nautoCloseDelay = 60\n})\n</code></pre></p>"},{"location":"libraries/lia.derma/#liaframethink","title":"lia.frame:Think","text":"<p>Purpose</p> <p>Creates a generic options menu that can display interaction/action menus or arbitrary option lists</p> <p>When Called</p> <p>When displaying a menu with selectable options (interactions, actions, or custom options)</p> <p>Parameters</p> <ul> <li><code>rawOptions</code> (table): Options to display. Can be:</li> <li><code>config</code> (table, optional): Configuration options including:</li> <li><code>mode</code> (string, optional): \"interaction\", \"action\", or \"custom\" (defaults to \"custom\")</li> <li><code>title</code> (string, optional): Menu title text</li> <li><code>closeKey</code> (number, optional): Key code that closes menu when released</li> <li><code>netMsg</code> (string, optional): Network message name for server-only options</li> <li><code>preFiltered</code> (boolean, optional): Whether options are already filtered (defaults to false)</li> <li><code>entity</code> (Entity, optional): Target entity for interaction mode</li> <li><code>resolveEntity</code> (boolean, optional): Whether to resolve traced entity (defaults to true for non-custom modes)</li> <li><code>emitHooks</code> (boolean, optional): Whether to emit InteractionMenuOpened/Closed hooks (defaults to true for non-custom modes)</li> <li><code>registryKey</code> (string, optional): Key for storing menu in lia.gui (defaults to \"InteractionMenu\" or \"OptionsMenu\")</li> <li><code>fadeSpeed</code> (number, optional): Animation fade speed in seconds (defaults to 0.05)</li> <li><code>frameW</code> (number, optional): Frame width in pixels (defaults to 450)</li> <li><code>frameH</code> (number, optional): Frame height in pixels (auto-calculated if not provided)</li> <li><code>entryH</code> (number, optional): Height of each option button (defaults to 30)</li> <li><code>maxHeight</code> (number, optional): Maximum frame height (defaults to 60% of screen height)</li> <li><code>titleHeight</code> (number, optional): Title label height (defaults to 36 or 16 based on mode)</li> <li><code>titleOffsetY</code> (number, optional): Y offset for title (defaults to 2)</li> <li><code>verticalGap</code> (number, optional): Vertical spacing between title and scroll area (defaults to 24)</li> <li><code>screenPadding</code> (number, optional): Screen padding for frame positioning (defaults to 15% of screen width)</li> <li><code>x</code> (number, optional): Custom X position (auto-calculated if not provided)</li> <li><code>y</code> (number, optional): Custom Y position (auto-calculated if not provided)</li> <li><code>titleFont</code> (string, optional): Font for title text (defaults to \"liaSmallFont\")</li> <li><code>titleColor</code> (Color, optional): Color for title text (defaults to color_white)</li> <li><code>buttonFont</code> (string, optional): Font for option buttons (defaults to \"liaSmallFont\")</li> <li><code>buttonTextColor</code> (Color, optional): Color for button text (defaults to color_white)</li> <li><code>closeOnSelect</code> (boolean, optional): Whether to close menu when option is selected (defaults to true)</li> <li><code>timerName</code> (string, optional): Name for auto-close timer</li> <li><code>autoCloseDelay</code> (number, optional): Seconds until auto-close (defaults to 30, 0 to disable)</li> </ul> <p>Returns</p> <ul> <li>Panel - The created menu frame, or nil if no valid options or invalid client</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display a basic custom options menu\nlia.derma.optionsMenu({\n{name = \"Option 1\", callback = function() print(\"Selected 1\") end},\n{name = \"Option 2\", callback = function() print(\"Selected 2\") end}\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom menu with descriptions and custom positioning\nlia.derma.optionsMenu({\n{\nname = \"Save Game\",\ndescription = \"Save your current progress\",\ncallback = function() saveGame() end\n},\n{\nname = \"Load Game\",\ndescription = \"Load a previously saved game\",\ncallback = function() loadGame() end\n},\n{\nname = \"Settings\",\ndescription = \"Open game settings\",\ncallback = function() openSettings() end\n}\n}, {\ntitle = \"Main Menu\",\nx = ScrW() / 2 - 225,\ny = ScrH() / 2 - 150,\nframeW = 450,\ncloseOnSelect = false\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced menu with custom callbacks and network messaging\nlia.derma.optionsMenu({\n{\nname = \"Radio Preset 1\",\ndescription = \"Switch to preset frequency 1\",\ncallback = function(client, entity, entry, frame)\n-- Custom callback with context\nlia.radio.setFrequency(100.0)\nclient:notify(\"Switched to radio preset 1\")\nend,\npassContext = true -- Pass client, entity, entry, frame to callback\n},\n{\nname = \"Radio Preset 2\",\ndescription = \"Switch to preset frequency 2\",\nserverOnly = true,\nnetMessage = \"liaRadioSetPreset\",\nnetworkID = \"preset2\"\n},\n{\nname = \"Custom Frequency\",\ndescription = \"Enter a custom frequency\",\ncallback = function()\n-- Open frequency input dialog\nlia.derma.textBox(\"Enter Frequency\", \"Enter radio frequency (MHz):\", function(freq)\nlocal numFreq = tonumber(freq)\nif numFreq and numFreq &gt;= 80 and numFreq &lt;= 200 then\n    lia.radio.setFrequency(numFreq)\n    client:notify(\"Frequency set to \" .. freq .. \" MHz\")\n    else\n        client:notify(\"Invalid frequency range (80-200 MHz)\")\n    end\nend)\nend\n}\n}, {\ntitle = \"Radio Presets\",\nmode = \"custom\",\ncloseKey = KEY_R,\nfadeSpeed = 0.1,\nautoCloseDelay = 60\n})\n</code></pre></p>"},{"location":"libraries/lia.derma/#colorpicker","title":"colorPicker","text":"<p>Purpose</p> <p>Opens a color picker dialog for selecting colors</p> <p>When Called</p> <p>When user needs to select a color from a visual picker interface</p> <p>Parameters</p> <ul> <li><code>func</code> (function): Callback function called when color is selected</li> <li><code>color_standart</code> (Color, optional): Default color to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open color picker with callback\nlia.derma.colorPicker(function(color)\nprint(\"Selected color:\", color.r, color.g, color.b)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Open color picker with default color\nlocal defaultColor = Color(255, 0, 0)\nlia.derma.colorPicker(function(color)\nmyPanel:SetColor(color)\nend, defaultColor)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Color picker with validation and multiple callbacks\nlocal currentColor = settings:GetColor(\"theme_color\")\nlia.derma.colorPicker(function(color)\nif color:Distance(currentColor) &gt; 50 then\n    settings:SetColor(\"theme_color\", color)\n    updateTheme(color)\n    notify(\"Theme color updated!\")\nend\nend, currentColor)\n</code></pre></p>"},{"location":"libraries/lia.derma/#radialmenu","title":"radialMenu","text":"<p>Purpose</p> <p>Creates a radial menu interface with circular option selection</p> <p>When Called</p> <p>When user needs to select from multiple options in a circular menu format</p> <p>Parameters</p> <ul> <li><code>options</code> (table, optional): Configuration table with the following optional fields:</li> <li><code>radius</code> (number): Outer radius of the radial menu (default: 280)</li> <li><code>inner_radius</code> (number): Inner radius of the radial menu (default: 96)</li> <li><code>disable_background</code> (boolean): Whether to disable the background overlay (default: false)</li> <li><code>hover_sound</code> (string): Sound file to play on hover (default: \"ratio_button.wav\")</li> <li><code>scale_animation</code> (boolean): Whether to enable scale animation on open (default: true)</li> </ul> <p>Returns</p> <ul> <li>Panel - The created radial menu panel with methods for adding options</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a basic radial menu\nlocal menu = lia.derma.radialMenu()\nmenu:AddOption(\"Option 1\", function() print(\"Option 1 selected\") end)\nmenu:AddOption(\"Option 2\", function() print(\"Option 2 selected\") end)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create radial menu with icons and descriptions\nlocal menu = lia.derma.radialMenu()\nmenu:AddOption(\"Edit\", function() editItem() end, \"icon16/pencil.png\", \"Edit this item\")\nmenu:AddOption(\"Delete\", function() deleteItem() end, \"icon16/delete.png\", \"Delete this item\")\nmenu:AddOption(\"Copy\", function() copyItem() end, \"icon16/copy.png\", \"Copy this item\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create radial menu with custom options and submenus\nlocal options = {\nradius = 320,\ninner_radius = 120,\nhover_sound = \"ui/buttonclick.wav\",\nscale_animation = true\n}\nlocal menu = lia.derma.radialMenu(options)\n-- Add main options\nmenu:AddOption(\"Actions\", nil, \"icon16/gear.png\", \"Perform actions\", nil)\n-- Create submenu\nlocal submenu = menu:CreateSubMenu(\"Actions\", \"Choose an action\")\nsubmenu:AddOption(\"Attack\", function() attackTarget() end, \"icon16/sword.png\", \"Attack target\")\nsubmenu:AddOption(\"Defend\", function() defendPosition() end, \"icon16/shield.png\", \"Defend position\")\n-- Add submenu option\nmenu:AddSubMenuOption(\"Actions\", submenu, \"icon16/gear.png\", \"Access action menu\")\n</code></pre></p>"},{"location":"libraries/lia.derma/#playerselector","title":"playerSelector","text":"<p>Purpose</p> <p>Opens a player selection dialog showing all connected players</p> <p>When Called</p> <p>When user needs to select a player from a list</p> <p>Parameters</p> <ul> <li><code>do_click</code> (function): Callback function called when player is selected</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open player selector with callback\nlia.derma.playerSelector(function(player)\nprint(\"Selected player:\", player:Name())\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Player selector with validation\nlia.derma.playerSelector(function(player)\nif IsValid(player) and player:IsPlayer() then\n    sendMessage(player, \"Hello!\")\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Player selector with admin checks and multiple actions\nlia.derma.playerSelector(function(player)\nif not IsValid(player) then return end\n    local menu = lia.derma.dermaMenu()\n    menu:AddOption(\"Teleport\", function() teleportToPlayer(player) end)\n    menu:AddOption(\"Spectate\", function() spectatePlayer(player) end)\n    if player:IsAdmin() then\n        menu:AddOption(\"Admin Panel\", function() openAdminPanel(player) end)\n    end\n    menu:Open()\nend)\n</code></pre></p>"},{"location":"libraries/lia.derma/#textbox","title":"textBox","text":"<p>Purpose</p> <p>Opens a text input dialog for user text entry</p> <p>When Called</p> <p>When user needs to input text through a dialog</p> <p>Parameters</p> <ul> <li><code>title</code> (string): Title of the dialog window</li> <li><code>desc</code> (string): Description/placeholder text for the input field</li> <li><code>func</code> (function): Callback function called with the entered text</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open text input dialog\nlia.derma.textBox(\"Enter Name\", \"Type your name here\", function(text)\nprint(\"Entered:\", text)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Text input with validation\nlia.derma.textBox(\"Set Password\", \"Enter new password\", function(text)\nif string.len(text) &gt;= 6 then\n    setPassword(text)\n    else\n        notify(\"Password too short!\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Text input with multiple validations and processing\nlia.derma.textBox(\"Create Item\", \"Enter item name\", function(text)\nif not text or text == \"\" then return end\n    local cleanText = string.Trim(text)\n    if string.len(cleanText) &lt; 3 then\n        notify(\"Name too short!\")\n        return\n    end\n    if itemExists(cleanText) then\n        notify(\"Item already exists!\")\n        return\n    end\n    createItem(cleanText)\n    refreshItemList()\nend)\n</code></pre></p>"},{"location":"libraries/lia.derma/#lianewflag","title":"lia.newFlag","text":"<p>Purpose</p> <p>Opens a text input dialog for user text entry</p> <p>When Called</p> <p>When user needs to input text through a dialog</p> <p>Parameters</p> <ul> <li><code>title</code> (string): Title of the dialog window</li> <li><code>desc</code> (string): Description/placeholder text for the input field</li> <li><code>func</code> (function): Callback function called with the entered text</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open text input dialog\nlia.derma.textBox(\"Enter Name\", \"Type your name here\", function(text)\nprint(\"Entered:\", text)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Text input with validation\nlia.derma.textBox(\"Set Password\", \"Enter new password\", function(text)\nif string.len(text) &gt;= 6 then\n    setPassword(text)\n    else\n        notify(\"Password too short!\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Text input with multiple validations and processing\nlia.derma.textBox(\"Create Item\", \"Enter item name\", function(text)\nif not text or text == \"\" then return end\n    local cleanText = string.Trim(text)\n    if string.len(cleanText) &lt; 3 then\n        notify(\"Name too short!\")\n        return\n    end\n    if itemExists(cleanText) then\n        notify(\"Item already exists!\")\n        return\n    end\n    createItem(cleanText)\n    refreshItemList()\nend)\n</code></pre></p>"},{"location":"libraries/lia.derma/#lianormalizecornerradii","title":"lia.normalizeCornerRadii","text":"<p>Purpose</p> <p>Opens a text input dialog for user text entry</p> <p>When Called</p> <p>When user needs to input text through a dialog</p> <p>Parameters</p> <ul> <li><code>title</code> (string): Title of the dialog window</li> <li><code>desc</code> (string): Description/placeholder text for the input field</li> <li><code>func</code> (function): Callback function called with the entered text</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open text input dialog\nlia.derma.textBox(\"Enter Name\", \"Type your name here\", function(text)\nprint(\"Entered:\", text)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Text input with validation\nlia.derma.textBox(\"Set Password\", \"Enter new password\", function(text)\nif string.len(text) &gt;= 6 then\n    setPassword(text)\n    else\n        notify(\"Password too short!\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Text input with multiple validations and processing\nlia.derma.textBox(\"Create Item\", \"Enter item name\", function(text)\nif not text or text == \"\" then return end\n    local cleanText = string.Trim(text)\n    if string.len(cleanText) &lt; 3 then\n        notify(\"Name too short!\")\n        return\n    end\n    if itemExists(cleanText) then\n        notify(\"Item already exists!\")\n        return\n    end\n    createItem(cleanText)\n    refreshItemList()\nend)\n</code></pre></p>"},{"location":"libraries/lia.derma/#draw","title":"draw","text":"<p>Purpose</p> <p>Draws a rounded rectangle with specified parameters</p> <p>When Called</p> <p>When rendering UI elements that need rounded corners</p> <p>Parameters</p> <ul> <li><code>radius</code> (number): Corner radius for all corners</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>w</code> (number): Width</li> <li><code>h</code> (number): Height</li> <li><code>col</code> (Color, optional): Color to draw with</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> </ul> <p>Returns</p> <ul> <li>boolean - Success status</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw a basic rounded rectangle\nlia.derma.draw(8, 100, 100, 200, 100, Color(255, 0, 0))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom flags and color\nlocal flags = lia.derma.SHAPE_IOS\nlia.derma.draw(12, 50, 50, 300, 150, Color(0, 255, 0, 200), flags)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic drawing with conditions\nlocal radius = isHovered and 16 or 8\nlocal color = isSelected and Color(255, 255, 0) or Color(100, 100, 100)\nlocal flags = bit.bor(lia.derma.SHAPE_FIGMA, lia.derma.BLUR)\nlia.derma.draw(radius, x, y, w, h, color, flags)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawoutlined","title":"drawOutlined","text":"<p>Purpose</p> <p>Draws a rounded rectangle with an outline border</p> <p>When Called</p> <p>When rendering UI elements that need outlined rounded corners</p> <p>Parameters</p> <ul> <li><code>radius</code> (number): Corner radius for all corners</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>w</code> (number): Width</li> <li><code>h</code> (number): Height</li> <li><code>col</code> (Color, optional): Color to draw with</li> <li><code>thickness</code> (number, optional): Outline thickness (default: 1)</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> </ul> <p>Returns</p> <ul> <li>boolean - Success status</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw outlined rounded rectangle\nlia.derma.drawOutlined(8, 100, 100, 200, 100, Color(255, 0, 0), 2)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom thickness and flags\nlocal flags = lia.derma.SHAPE_IOS\nlia.derma.drawOutlined(12, 50, 50, 300, 150, Color(0, 255, 0), 3, flags)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic outlined drawing with hover effects\nlocal thickness = isHovered and 3 or 1\nlocal color = isActive and Color(255, 255, 0) or Color(100, 100, 100)\nlia.derma.drawOutlined(radius, x, y, w, h, color, thickness, flags)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawtexture","title":"drawTexture","text":"<p>Purpose</p> <p>Draws a rounded rectangle with a texture applied</p> <p>When Called</p> <p>When rendering UI elements that need textured rounded backgrounds</p> <p>Parameters</p> <ul> <li><code>radius</code> (number): Corner radius for all corners</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>w</code> (number): Width</li> <li><code>h</code> (number): Height</li> <li><code>col</code> (Color, optional): Color tint to apply</li> <li><code>texture</code> (ITexture): Texture to draw</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> </ul> <p>Returns</p> <ul> <li>boolean - Success status</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw textured rounded rectangle\nlocal texture = Material(\"icon16/user.png\"):GetTexture(\"$basetexture\")\nlia.derma.drawTexture(8, 100, 100, 200, 100, Color(255, 255, 255), texture)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with color tint and custom flags\nlocal texture = Material(\"gui/button.png\"):GetTexture(\"$basetexture\")\nlocal flags = lia.derma.SHAPE_IOS\nlia.derma.drawTexture(12, 50, 50, 300, 150, Color(200, 200, 200), texture, flags)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic textured drawing with multiple textures\nlocal texture = isHovered and hoverTexture or normalTexture\nlocal color = isActive and Color(255, 255, 255) or Color(150, 150, 150)\nlia.derma.drawTexture(radius, x, y, w, h, color, texture, flags)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawmaterial","title":"drawMaterial","text":"<p>Purpose</p> <p>Draws a rounded rectangle with a material applied</p> <p>When Called</p> <p>When rendering UI elements that need material-based rounded backgrounds</p> <p>Parameters</p> <ul> <li><code>radius</code> (number): Corner radius for all corners</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>w</code> (number): Width</li> <li><code>h</code> (number): Height</li> <li><code>col</code> (Color, optional): Color tint to apply</li> <li><code>mat</code> (IMaterial): Material to draw</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> </ul> <p>Returns</p> <ul> <li>boolean - Success status (if material has valid texture)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw material-based rounded rectangle\nlocal mat = Material(\"gui/button.png\")\nlia.derma.drawMaterial(8, 100, 100, 200, 100, Color(255, 255, 255), mat)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with color tint and validation\nlocal mat = Material(\"effects/fire_cloud1\")\nif mat and mat:IsValid() then\n    lia.derma.drawMaterial(12, 50, 50, 300, 150, Color(255, 200, 0), mat)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic material drawing with fallback\nlocal mat = getMaterialForState(currentState)\nif mat and mat:IsValid() then\n    local color = isActive and Color(255, 255, 255) or Color(150, 150, 150)\n    lia.derma.drawMaterial(radius, x, y, w, h, color, mat, flags)\n    else\n        -- Fallback to solid color\n        lia.derma.draw(radius, x, y, w, h, fallbackColor, flags)\n    end\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawcircle","title":"drawCircle","text":"<p>Purpose</p> <p>Draws a filled circle with specified parameters</p> <p>When Called</p> <p>When rendering circular UI elements like buttons or indicators</p> <p>Parameters</p> <ul> <li><code>x</code> (number): Center X position</li> <li><code>y</code> (number): Center Y position</li> <li><code>radius</code> (number): Circle radius</li> <li><code>col</code> (Color, optional): Color to draw with</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> </ul> <p>Returns</p> <ul> <li>boolean - Success status</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw a basic circle\nlia.derma.drawCircle(100, 100, 50, Color(255, 0, 0))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw circle with custom flags\nlocal flags = lia.derma.SHAPE_CIRCLE\nlia.derma.drawCircle(200, 200, 75, Color(0, 255, 0, 200), flags)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic circle drawing with hover effects\nlocal radius = isHovered and 60 or 50\nlocal color = isActive and Color(255, 255, 0) or Color(100, 100, 100)\nlia.derma.drawCircle(x, y, radius, color, flags)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawcircleoutlined","title":"drawCircleOutlined","text":"<p>Purpose</p> <p>Draws a circle with an outline border</p> <p>When Called</p> <p>When rendering circular UI elements that need outlined borders</p> <p>Parameters</p> <ul> <li><code>x</code> (number): Center X position</li> <li><code>y</code> (number): Center Y position</li> <li><code>radius</code> (number): Circle radius</li> <li><code>col</code> (Color, optional): Color to draw with</li> <li><code>thickness</code> (number, optional): Outline thickness (default: 1)</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> </ul> <p>Returns</p> <ul> <li>boolean - Success status</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw outlined circle\nlia.derma.drawCircleOutlined(100, 100, 50, Color(255, 0, 0), 2)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom thickness and flags\nlocal flags = lia.derma.SHAPE_CIRCLE\nlia.derma.drawCircleOutlined(200, 200, 75, Color(0, 255, 0), 3, flags)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic outlined circle with hover effects\nlocal thickness = isHovered and 3 or 1\nlocal color = isActive and Color(255, 255, 0) or Color(100, 100, 100)\nlia.derma.drawCircleOutlined(x, y, radius, color, thickness, flags)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawcircletexture","title":"drawCircleTexture","text":"<p>Purpose</p> <p>Draws a circle with a texture applied</p> <p>When Called</p> <p>When rendering circular UI elements that need textured backgrounds</p> <p>Parameters</p> <ul> <li><code>x</code> (number): Center X position</li> <li><code>y</code> (number): Center Y position</li> <li><code>radius</code> (number): Circle radius</li> <li><code>col</code> (Color, optional): Color tint to apply</li> <li><code>texture</code> (ITexture): Texture to draw</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> </ul> <p>Returns</p> <ul> <li>boolean - Success status</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw textured circle\nlocal texture = Material(\"icon16/user.png\"):GetTexture(\"$basetexture\")\nlia.derma.drawCircleTexture(100, 100, 50, Color(255, 255, 255), texture)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with color tint and custom flags\nlocal texture = Material(\"gui/button.png\"):GetTexture(\"$basetexture\")\nlocal flags = lia.derma.SHAPE_CIRCLE\nlia.derma.drawCircleTexture(200, 200, 75, Color(200, 200, 200), texture, flags)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic textured circle with multiple textures\nlocal texture = isHovered and hoverTexture or normalTexture\nlocal color = isActive and Color(255, 255, 255) or Color(150, 150, 150)\nlia.derma.drawCircleTexture(x, y, radius, color, texture, flags)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawcirclematerial","title":"drawCircleMaterial","text":"<p>Purpose</p> <p>Draws a circle with a material applied</p> <p>When Called</p> <p>When rendering circular UI elements that need material-based backgrounds</p> <p>Parameters</p> <ul> <li><code>x</code> (number): Center X position</li> <li><code>y</code> (number): Center Y position</li> <li><code>radius</code> (number): Circle radius</li> <li><code>col</code> (Color, optional): Color tint to apply</li> <li><code>mat</code> (IMaterial): Material to draw</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> </ul> <p>Returns</p> <ul> <li>boolean - Success status (if material has valid texture)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw material-based circle\nlocal mat = Material(\"gui/button.png\")\nlia.derma.drawCircleMaterial(100, 100, 50, Color(255, 255, 255), mat)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with color tint and validation\nlocal mat = Material(\"effects/fire_cloud1\")\nif mat and mat:IsValid() then\n    lia.derma.drawCircleMaterial(200, 200, 75, Color(255, 200, 0), mat)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic material circle with fallback\nlocal mat = getMaterialForState(currentState)\nif mat and mat:IsValid() then\n    local color = isActive and Color(255, 255, 255) or Color(150, 150, 150)\n    lia.derma.drawCircleMaterial(x, y, radius, color, mat, flags)\n    else\n        -- Fallback to solid color circle\n        lia.derma.drawCircle(x, y, radius, fallbackColor, flags)\n    end\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawblur","title":"drawBlur","text":"<p>Purpose</p> <p>Draws a blurred rounded rectangle using custom shaders</p> <p>When Called</p> <p>When rendering UI elements that need blur effects</p> <p>Parameters</p> <ul> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>w</code> (number): Width</li> <li><code>h</code> (number): Height</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> <li><code>tl</code> (number, optional): Top-left corner radius</li> <li><code>tr</code> (number, optional): Top-right corner radius</li> <li><code>bl</code> (number, optional): Bottom-left corner radius</li> <li><code>br</code> (number, optional): Bottom-right corner radius</li> <li><code>thickness</code> (number, optional): Outline thickness</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw blurred rectangle\nlia.derma.drawBlur(100, 100, 200, 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom corner radii and flags\nlocal flags = lia.derma.SHAPE_IOS\nlia.derma.drawBlur(50, 50, 300, 150, flags, 12, 12, 12, 12)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic blur with different corner radii\nlocal tl = isTopLeft and 16 or 8\nlocal tr = isTopRight and 16 or 8\nlocal bl = isBottomLeft and 16 or 8\nlocal br = isBottomRight and 16 or 8\nlia.derma.drawBlur(x, y, w, h, flags, tl, tr, bl, br, thickness)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawshadowsex","title":"drawShadowsEx","text":"<p>Purpose</p> <p>Draws shadows for rounded rectangles with extensive customization</p> <p>When Called</p> <p>When rendering UI elements that need shadow effects</p> <p>Parameters</p> <ul> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>w</code> (number): Width</li> <li><code>h</code> (number): Height</li> <li><code>col</code> (Color, optional): Shadow color</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> <li><code>tl</code> (number, optional): Top-left corner radius</li> <li><code>tr</code> (number, optional): Top-right corner radius</li> <li><code>bl</code> (number, optional): Bottom-left corner radius</li> <li><code>br</code> (number, optional): Bottom-right corner radius</li> <li><code>spread</code> (number, optional): Shadow spread distance (default: 30)</li> <li><code>intensity</code> (number, optional): Shadow intensity (default: spread * 1.2)</li> <li><code>thickness</code> (number, optional): Outline thickness</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw basic shadow\nlia.derma.drawShadowsEx(100, 100, 200, 100, Color(0, 0, 0, 100))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom spread and intensity\nlia.derma.drawShadowsEx(50, 50, 300, 150, Color(0, 0, 0, 150), flags, 12, 12, 12, 12, 20, 25)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic shadow with different corner radii\nlocal spread = isHovered and 40 or 20\nlocal intensity = spread * 1.5\nlia.derma.drawShadowsEx(x, y, w, h, shadowColor, flags, tl, tr, bl, br, spread, intensity, thickness)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawshadows","title":"drawShadows","text":"<p>Purpose</p> <p>Draws shadows for rounded rectangles with uniform corner radius</p> <p>When Called</p> <p>When rendering UI elements that need shadow effects with same corner radius</p> <p>Parameters</p> <ul> <li><code>radius</code> (number): Corner radius for all corners</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>w</code> (number): Width</li> <li><code>h</code> (number): Height</li> <li><code>col</code> (Color, optional): Shadow color</li> <li><code>spread</code> (number, optional): Shadow spread distance (default: 30)</li> <li><code>intensity</code> (number, optional): Shadow intensity (default: spread * 1.2)</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw basic shadow with uniform radius\nlia.derma.drawShadows(8, 100, 100, 200, 100, Color(0, 0, 0, 100))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom spread and intensity\nlia.derma.drawShadows(12, 50, 50, 300, 150, Color(0, 0, 0, 150), 20, 25)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic shadow with hover effects\nlocal radius = isHovered and 16 or 8\nlocal spread = isHovered and 40 or 20\nlocal intensity = spread * 1.5\nlia.derma.drawShadows(radius, x, y, w, h, shadowColor, spread, intensity, flags)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawshadowsoutlined","title":"drawShadowsOutlined","text":"<p>Purpose</p> <p>Draws outlined shadows for rounded rectangles with uniform corner radius</p> <p>When Called</p> <p>When rendering UI elements that need outlined shadow effects</p> <p>Parameters</p> <ul> <li><code>radius</code> (number): Corner radius for all corners</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>w</code> (number): Width</li> <li><code>h</code> (number): Height</li> <li><code>col</code> (Color, optional): Shadow color</li> <li><code>thickness</code> (number, optional): Outline thickness (default: 1)</li> <li><code>spread</code> (number, optional): Shadow spread distance (default: 30)</li> <li><code>intensity</code> (number, optional): Shadow intensity (default: spread * 1.2)</li> <li><code>flags</code> (number, optional): Drawing flags for customization</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw outlined shadow\nlia.derma.drawShadowsOutlined(8, 100, 100, 200, 100, Color(0, 0, 0, 100), 2)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom thickness and spread\nlia.derma.drawShadowsOutlined(12, 50, 50, 300, 150, Color(0, 0, 0, 150), 3, 20, 25)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic outlined shadow with hover effects\nlocal thickness = isHovered and 3 or 1\nlocal spread = isHovered and 40 or 20\nlocal intensity = spread * 1.5\nlia.derma.drawShadowsOutlined(radius, x, y, w, h, shadowColor, thickness, spread, intensity, flags)\n</code></pre></p>"},{"location":"libraries/lia.derma/#rect","title":"rect","text":"<p>Purpose</p> <p>Creates a fluent rectangle drawing object for chained operations</p> <p>When Called</p> <p>When creating complex UI elements with multiple drawing operations</p> <p>Parameters</p> <ul> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>w</code> (number): Width</li> <li><code>h</code> (number): Height</li> </ul> <p>Returns</p> <ul> <li>Table - Fluent drawing object with methods for chaining</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create and draw a rectangle\nlia.derma.rect(100, 100, 200, 100):Color(Color(255, 0, 0)):Draw()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create rectangle with multiple properties\nlia.derma.rect(50, 50, 300, 150)\n:Color(Color(0, 255, 0, 200))\n:Rad(12)\n:Shape(lia.derma.SHAPE_IOS)\n:Draw()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex rectangle with shadows and clipping\nlia.derma.rect(x, y, w, h)\n:Color(backgroundColor)\n:Radii(16, 8, 16, 8)\n:Shadow(20, 25)\n:Clip(parentPanel)\n:Draw()\n</code></pre></p>"},{"location":"libraries/lia.derma/#circle","title":"circle","text":"<p>Purpose</p> <p>Creates a fluent circle drawing object for chained operations</p> <p>When Called</p> <p>When creating complex circular UI elements with multiple drawing operations</p> <p>Parameters</p> <ul> <li><code>x</code> (number): Center X position</li> <li><code>y</code> (number): Center Y position</li> <li><code>r</code> (number): Circle radius</li> </ul> <p>Returns</p> <ul> <li>Table - Fluent drawing object with methods for chaining</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create and draw a circle\nlia.derma.circle(100, 100, 50):Color(Color(255, 0, 0)):Draw()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create circle with multiple properties\nlia.derma.circle(200, 200, 75)\n:Color(Color(0, 255, 0, 200))\n:Outline(2)\n:Draw()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex circle with shadows and textures\nlia.derma.circle(x, y, radius)\n:Color(circleColor)\n:Texture(circleTexture)\n:Shadow(15, 20)\n:Blur(1.5)\n:Draw()\n</code></pre></p>"},{"location":"libraries/lia.derma/#setflag","title":"setFlag","text":"<p>Purpose</p> <p>Creates a fluent circle drawing object for chained operations</p> <p>When Called</p> <p>When creating complex circular UI elements with multiple drawing operations</p> <p>Parameters</p> <ul> <li><code>x</code> (number): Center X position</li> <li><code>y</code> (number): Center Y position</li> <li><code>r</code> (number): Circle radius</li> </ul> <p>Returns</p> <ul> <li>Table - Fluent drawing object with methods for chaining</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create and draw a circle\nlia.derma.circle(100, 100, 50):Color(Color(255, 0, 0)):Draw()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create circle with multiple properties\nlia.derma.circle(200, 200, 75)\n:Color(Color(0, 255, 0, 200))\n:Outline(2)\n:Draw()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex circle with shadows and textures\nlia.derma.circle(x, y, radius)\n:Color(circleColor)\n:Texture(circleTexture)\n:Shadow(15, 20)\n:Blur(1.5)\n:Draw()\n</code></pre></p>"},{"location":"libraries/lia.derma/#setdefaultshape","title":"setDefaultShape","text":"<p>Purpose</p> <p>Creates a fluent circle drawing object for chained operations</p> <p>When Called</p> <p>When creating complex circular UI elements with multiple drawing operations</p> <p>Parameters</p> <ul> <li><code>x</code> (number): Center X position</li> <li><code>y</code> (number): Center Y position</li> <li><code>r</code> (number): Circle radius</li> </ul> <p>Returns</p> <ul> <li>Table - Fluent drawing object with methods for chaining</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create and draw a circle\nlia.derma.circle(100, 100, 50):Color(Color(255, 0, 0)):Draw()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create circle with multiple properties\nlia.derma.circle(200, 200, 75)\n:Color(Color(0, 255, 0, 200))\n:Outline(2)\n:Draw()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex circle with shadows and textures\nlia.derma.circle(x, y, radius)\n:Color(circleColor)\n:Texture(circleTexture)\n:Shadow(15, 20)\n:Blur(1.5)\n:Draw()\n</code></pre></p>"},{"location":"libraries/lia.derma/#shadowtext","title":"shadowText","text":"<p>Purpose</p> <p>Draws text with a shadow effect for better readability</p> <p>When Called</p> <p>When rendering text that needs to stand out against backgrounds</p> <p>Parameters</p> <ul> <li><code>text</code> (string): Text to draw</li> <li><code>font</code> (string): Font to use</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>colortext</code> (Color): Color of the main text</li> <li><code>colorshadow</code> (Color): Color of the shadow</li> <li><code>dist</code> (number): Shadow distance/offset</li> <li><code>xalign</code> (number, optional): Horizontal text alignment</li> <li><code>yalign</code> (number, optional): Vertical text alignment</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw text with shadow\nlia.derma.shadowText(\"Hello World\", \"DermaDefault\", 100, 100, Color(255, 255, 255), Color(0, 0, 0), 2)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom alignment\nlia.derma.shadowText(\"Centered Text\", \"LiliaFont.20\", 200, 200, Color(255, 255, 255), Color(0, 0, 0, 150), 3, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic shadow text with hover effects\nlocal shadowDist = isHovered and 4 or 2\nlocal shadowColor = Color(0, 0, 0, isHovered and 200 or 100)\nlia.derma.shadowText(text, font, x, y, textColor, shadowColor, shadowDist, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawtextoutlined","title":"drawTextOutlined","text":"<p>Purpose</p> <p>Draws text with an outline border for better visibility</p> <p>When Called</p> <p>When rendering text that needs to stand out with outline effects</p> <p>Parameters</p> <ul> <li><code>text</code> (string): Text to draw</li> <li><code>font</code> (string): Font to use</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>colour</code> (Color): Color of the main text</li> <li><code>xalign</code> (number, optional): Horizontal text alignment</li> <li><code>outlinewidth</code> (number): Width of the outline</li> <li><code>outlinecolour</code> (Color): Color of the outline</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw outlined text\nlia.derma.drawTextOutlined(\"Hello World\", \"DermaDefault\", 100, 100, Color(255, 255, 255), TEXT_ALIGN_LEFT, 2, Color(0, 0, 0))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom alignment and outline\nlia.derma.drawTextOutlined(\"Centered Text\", \"LiliaFont.20\", 200, 200, Color(255, 255, 255), TEXT_ALIGN_CENTER, 3, Color(0, 0, 0, 200))\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic outlined text with hover effects\nlocal outlineWidth = isHovered and 4 or 2\nlocal outlineColor = Color(0, 0, 0, isHovered and 255 or 150)\nlia.derma.drawTextOutlined(text, font, x, y, textColor, TEXT_ALIGN_CENTER, outlineWidth, outlineColor)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawtip","title":"drawTip","text":"<p>Purpose</p> <p>Draws a tooltip-style speech bubble with text</p> <p>When Called</p> <p>When rendering tooltips or help text in speech bubble format</p> <p>Parameters</p> <ul> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>w</code> (number): Width of the bubble</li> <li><code>h</code> (number): Height of the bubble</li> <li><code>text</code> (string): Text to display in the bubble</li> <li><code>font</code> (string): Font to use for the text</li> <li><code>textCol</code> (Color): Color of the text</li> <li><code>outlineCol</code> (Color): Color of the bubble outline</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw basic tooltip\nlia.derma.drawTip(100, 100, 200, 80, \"Help text\", \"DermaDefault\", Color(255, 255, 255), Color(0, 0, 0))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom styling\nlia.derma.drawTip(50, 50, 300, 100, \"This is a tooltip\", \"LiliaFont.16\", Color(255, 255, 255), Color(100, 100, 100))\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic tooltip with hover effects\nlocal w = math.max(200, surface.GetTextSize(text) + 40)\nlocal h = 60\nlocal textColor = Color(255, 255, 255)\nlocal outlineColor = Color(0, 0, 0, isHovered and 200 or 100)\nlia.derma.drawTip(x, y, w, h, text, font, textColor, outlineColor)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawtext","title":"drawText","text":"<p>Purpose</p> <p>Draws text with automatic shadow effect for better readability</p> <p>When Called</p> <p>When rendering text that needs consistent shadow styling</p> <p>Parameters</p> <ul> <li><code>text</code> (string): Text to draw</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>color</code> (Color, optional): Color of the text (default: white)</li> <li><code>alignX</code> (number, optional): Horizontal text alignment</li> <li><code>alignY</code> (number, optional): Vertical text alignment</li> <li><code>font</code> (string, optional): Font to use (default: \"LiliaFont.16\")</li> <li><code>alpha</code> (number, optional): Alpha multiplier for shadow</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw text with automatic shadow\nlia.derma.drawText(\"Hello World\", 100, 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom color and alignment\nlia.derma.drawText(\"Centered Text\", 200, 200, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic text with hover effects\nlocal textColor = Color(255, 255, 255)\nlocal alpha = isHovered and 1.0 or 0.7\nlia.derma.drawText(text, x, y, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, font, alpha)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawboxwithtext","title":"drawBoxWithText","text":"<p>Purpose</p> <p>Draws text with automatic shadow effect for better readability</p> <p>When Called</p> <p>When rendering text that needs consistent shadow styling</p> <p>Parameters</p> <ul> <li><code>text</code> (string): Text to draw</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>color</code> (Color, optional): Color of the text (default: white)</li> <li><code>alignX</code> (number, optional): Horizontal text alignment</li> <li><code>alignY</code> (number, optional): Vertical text alignment</li> <li><code>font</code> (string, optional): Font to use (default: \"LiliaFont.16\")</li> <li><code>alpha</code> (number, optional): Alpha multiplier for shadow</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw text with automatic shadow\nlia.derma.drawText(\"Hello World\", 100, 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom color and alignment\nlia.derma.drawText(\"Centered Text\", 200, 200, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic text with hover effects\nlocal textColor = Color(255, 255, 255)\nlocal alpha = isHovered and 1.0 or 0.7\nlia.derma.drawText(text, x, y, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, font, alpha)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawsurfacetexture","title":"drawSurfaceTexture","text":"<p>Purpose</p> <p>Draws text with automatic shadow effect for better readability</p> <p>When Called</p> <p>When rendering text that needs consistent shadow styling</p> <p>Parameters</p> <ul> <li><code>text</code> (string): Text to draw</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>color</code> (Color, optional): Color of the text (default: white)</li> <li><code>alignX</code> (number, optional): Horizontal text alignment</li> <li><code>alignY</code> (number, optional): Vertical text alignment</li> <li><code>font</code> (string, optional): Font to use (default: \"LiliaFont.16\")</li> <li><code>alpha</code> (number, optional): Alpha multiplier for shadow</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw text with automatic shadow\nlia.derma.drawText(\"Hello World\", 100, 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom color and alignment\nlia.derma.drawText(\"Centered Text\", 200, 200, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic text with hover effects\nlocal textColor = Color(255, 255, 255)\nlocal alpha = isHovered and 1.0 or 0.7\nlia.derma.drawText(text, x, y, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, font, alpha)\n</code></pre></p>"},{"location":"libraries/lia.derma/#skinfunc","title":"skinFunc","text":"<p>Purpose</p> <p>Draws text with automatic shadow effect for better readability</p> <p>When Called</p> <p>When rendering text that needs consistent shadow styling</p> <p>Parameters</p> <ul> <li><code>text</code> (string): Text to draw</li> <li><code>x</code> (number): X position</li> <li><code>y</code> (number): Y position</li> <li><code>color</code> (Color, optional): Color of the text (default: white)</li> <li><code>alignX</code> (number, optional): Horizontal text alignment</li> <li><code>alignY</code> (number, optional): Vertical text alignment</li> <li><code>font</code> (string, optional): Font to use (default: \"LiliaFont.16\")</li> <li><code>alpha</code> (number, optional): Alpha multiplier for shadow</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw text with automatic shadow\nlia.derma.drawText(\"Hello World\", 100, 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom color and alignment\nlia.derma.drawText(\"Centered Text\", 200, 200, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic text with hover effects\nlocal textColor = Color(255, 255, 255)\nlocal alpha = isHovered and 1.0 or 0.7\nlia.derma.drawText(text, x, y, textColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, font, alpha)\n</code></pre></p>"},{"location":"libraries/lia.derma/#approachexp","title":"approachExp","text":"<p>Purpose</p> <p>Performs exponential interpolation between current and target values</p> <p>When Called</p> <p>When smooth animation transitions are needed</p> <p>Parameters</p> <ul> <li><code>current</code> (number): Current value</li> <li><code>target</code> (number): Target value to approach</li> <li><code>speed</code> (number): Animation speed multiplier</li> <li><code>dt</code> (number): Delta time (FrameTime())</li> </ul> <p>Returns</p> <ul> <li>number - New interpolated value</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Smooth value transition\nlocal currentValue = lia.derma.approachExp(currentValue, targetValue, 5, FrameTime())\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Animate panel alpha\nlocal targetAlpha = isVisible and 255 or 0\npanel:SetAlpha(lia.derma.approachExp(panel:GetAlpha(), targetAlpha, 8, FrameTime()))\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex animation with multiple properties\nlocal dt = FrameTime()\nlocal targetX = isHovered and hoverX or normalX\nlocal targetY = isHovered and hoverY or normalY\nlocal targetScale = isHovered and 1.1 or 1.0\npanel:SetPos(\nlia.derma.approachExp(panel:GetPos(), targetX, 6, dt),\nlia.derma.approachExp(panel:GetPos(), targetY, 6, dt)\n)\npanel:SetSize(\nlia.derma.approachExp(panel:GetWide(), targetW * targetScale, 4, dt),\nlia.derma.approachExp(panel:GetTall(), targetH * targetScale, 4, dt)\n)\n</code></pre></p>"},{"location":"libraries/lia.derma/#easeoutcubic","title":"easeOutCubic","text":"<p>Purpose</p> <p>Applies cubic ease-out easing function to a normalized time value</p> <p>When Called</p> <p>When smooth deceleration animations are needed</p> <p>Parameters</p> <ul> <li><code>t</code> (number): Normalized time value (0 to 1)</li> </ul> <p>Returns</p> <ul> <li>number - Eased value</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Apply ease-out to animation progress\nlocal eased = lia.derma.easeOutCubic(animationProgress)\npanel:SetAlpha(eased * 255)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Smooth panel movement with ease-out\nlocal progress = math.Clamp((CurTime() - startTime) / duration, 0, 1)\nlocal eased = lia.derma.easeOutCubic(progress)\npanel:SetPos(startX + (endX - startX) * eased, startY + (endY - startY) * eased)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex animation with multiple eased properties\nlocal progress = math.Clamp((CurTime() - startTime) / duration, 0, 1)\nlocal eased = lia.derma.easeOutCubic(progress)\npanel:SetPos(\nstartX + (endX - startX) * eased,\nstartY + (endY - startY) * eased\n)\npanel:SetSize(\nstartW + (endW - startW) * eased,\nstartH + (endH - startH) * eased\n)\npanel:SetAlpha(startAlpha + (endAlpha - startAlpha) * eased)\n</code></pre></p>"},{"location":"libraries/lia.derma/#easeinoutcubic","title":"easeInOutCubic","text":"<p>Purpose</p> <p>Applies cubic ease-in-out easing function to a normalized time value</p> <p>When Called</p> <p>When smooth acceleration and deceleration animations are needed</p> <p>Parameters</p> <ul> <li><code>t</code> (number): Normalized time value (0 to 1)</li> </ul> <p>Returns</p> <ul> <li>number - Eased value</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Apply ease-in-out to animation progress\nlocal eased = lia.derma.easeInOutCubic(animationProgress)\npanel:SetAlpha(eased * 255)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Smooth panel scaling with ease-in-out\nlocal progress = math.Clamp((CurTime() - startTime) / duration, 0, 1)\nlocal eased = lia.derma.easeInOutCubic(progress)\nlocal scale = startScale + (endScale - startScale) * eased\npanel:SetSize(baseW * scale, baseH * scale)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex UI animation with ease-in-out\nlocal progress = math.Clamp((CurTime() - startTime) / duration, 0, 1)\nlocal eased = lia.derma.easeInOutCubic(progress)\n-- Animate position, size, and rotation\npanel:SetPos(\nstartX + (endX - startX) * eased,\nstartY + (endY - startY) * eased\n)\npanel:SetSize(\nstartW + (endW - startW) * eased,\nstartH + (endH - startH) * eased\n)\npanel:SetRotation(startRotation + (endRotation - startRotation) * eased)\n</code></pre></p>"},{"location":"libraries/lia.derma/#animateappearance","title":"animateAppearance","text":"<p>Purpose</p> <p>Animates panel appearance with scaling and fade effects</p> <p>When Called</p> <p>When panels need smooth entrance animations</p> <p>Parameters</p> <ul> <li><code>panel</code> (Panel): Panel to animate</li> <li><code>target_w</code> (number): Target width</li> <li><code>target_h</code> (number): Target height</li> <li><code>duration</code> (number, optional): Animation duration (default: 0.18)</li> <li><code>alpha_dur</code> (number, optional): Alpha animation duration (default: same as duration)</li> <li><code>callback</code> (function, optional): Callback function called when animation completes</li> <li><code>scale_factor</code> (number, optional): Initial scale factor (default: 0.8)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Animate panel appearance\nlia.derma.animateAppearance(myPanel, 300, 200)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Animate with custom duration and callback\nlia.derma.animateAppearance(myPanel, 400, 300, 0.3, 0.2, function(panel)\nprint(\"Animation completed!\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex animation with validation and effects\nif IsValid(panel) then\n    local targetW = isExpanded and 500 or 300\n    local targetH = isExpanded and 400 or 200\n    local duration = isExpanded and 0.25 or 0.15\n    local scaleFactor = isExpanded and 0.9 or 0.7\n    lia.derma.animateAppearance(panel, targetW, targetH, duration, duration * 0.8, function(animPanel)\n    if IsValid(animPanel) then\n        onAnimationComplete(animPanel)\n    end\nend, scaleFactor)\nend\n</code></pre></p>"},{"location":"libraries/lia.derma/#clampmenuposition","title":"clampMenuPosition","text":"<p>Purpose</p> <p>Animates panel appearance with scaling and fade effects</p> <p>When Called</p> <p>When panels need smooth entrance animations</p> <p>Parameters</p> <ul> <li><code>panel</code> (Panel): Panel to animate</li> <li><code>target_w</code> (number): Target width</li> <li><code>target_h</code> (number): Target height</li> <li><code>duration</code> (number, optional): Animation duration (default: 0.18)</li> <li><code>alpha_dur</code> (number, optional): Alpha animation duration (default: same as duration)</li> <li><code>callback</code> (function, optional): Callback function called when animation completes</li> <li><code>scale_factor</code> (number, optional): Initial scale factor (default: 0.8)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Animate panel appearance\nlia.derma.animateAppearance(myPanel, 300, 200)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Animate with custom duration and callback\nlia.derma.animateAppearance(myPanel, 400, 300, 0.3, 0.2, function(panel)\nprint(\"Animation completed!\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex animation with validation and effects\nif IsValid(panel) then\n    local targetW = isExpanded and 500 or 300\n    local targetH = isExpanded and 400 or 200\n    local duration = isExpanded and 0.25 or 0.15\n    local scaleFactor = isExpanded and 0.9 or 0.7\n    lia.derma.animateAppearance(panel, targetW, targetH, duration, duration * 0.8, function(animPanel)\n    if IsValid(animPanel) then\n        onAnimationComplete(animPanel)\n    end\nend, scaleFactor)\nend\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawgradient","title":"drawGradient","text":"<p>Purpose</p> <p>Animates panel appearance with scaling and fade effects</p> <p>When Called</p> <p>When panels need smooth entrance animations</p> <p>Parameters</p> <ul> <li><code>panel</code> (Panel): Panel to animate</li> <li><code>target_w</code> (number): Target width</li> <li><code>target_h</code> (number): Target height</li> <li><code>duration</code> (number, optional): Animation duration (default: 0.18)</li> <li><code>alpha_dur</code> (number, optional): Alpha animation duration (default: same as duration)</li> <li><code>callback</code> (function, optional): Callback function called when animation completes</li> <li><code>scale_factor</code> (number, optional): Initial scale factor (default: 0.8)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Animate panel appearance\nlia.derma.animateAppearance(myPanel, 300, 200)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Animate with custom duration and callback\nlia.derma.animateAppearance(myPanel, 400, 300, 0.3, 0.2, function(panel)\nprint(\"Animation completed!\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex animation with validation and effects\nif IsValid(panel) then\n    local targetW = isExpanded and 500 or 300\n    local targetH = isExpanded and 400 or 200\n    local duration = isExpanded and 0.25 or 0.15\n    local scaleFactor = isExpanded and 0.9 or 0.7\n    lia.derma.animateAppearance(panel, targetW, targetH, duration, duration * 0.8, function(animPanel)\n    if IsValid(animPanel) then\n        onAnimationComplete(animPanel)\n    end\nend, scaleFactor)\nend\n</code></pre></p>"},{"location":"libraries/lia.derma/#wraptext","title":"wrapText","text":"<p>Purpose</p> <p>Animates panel appearance with scaling and fade effects</p> <p>When Called</p> <p>When panels need smooth entrance animations</p> <p>Parameters</p> <ul> <li><code>panel</code> (Panel): Panel to animate</li> <li><code>target_w</code> (number): Target width</li> <li><code>target_h</code> (number): Target height</li> <li><code>duration</code> (number, optional): Animation duration (default: 0.18)</li> <li><code>alpha_dur</code> (number, optional): Alpha animation duration (default: same as duration)</li> <li><code>callback</code> (function, optional): Callback function called when animation completes</li> <li><code>scale_factor</code> (number, optional): Initial scale factor (default: 0.8)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Animate panel appearance\nlia.derma.animateAppearance(myPanel, 300, 200)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Animate with custom duration and callback\nlia.derma.animateAppearance(myPanel, 400, 300, 0.3, 0.2, function(panel)\nprint(\"Animation completed!\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex animation with validation and effects\nif IsValid(panel) then\n    local targetW = isExpanded and 500 or 300\n    local targetH = isExpanded and 400 or 200\n    local duration = isExpanded and 0.25 or 0.15\n    local scaleFactor = isExpanded and 0.9 or 0.7\n    lia.derma.animateAppearance(panel, targetW, targetH, duration, duration * 0.8, function(animPanel)\n    if IsValid(animPanel) then\n        onAnimationComplete(animPanel)\n    end\nend, scaleFactor)\nend\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawblur_1","title":"drawBlur","text":"<p>Purpose</p> <p>Draws blur effect behind a panel using screen space effects</p> <p>When Called</p> <p>When rendering panel backgrounds that need blur effects</p> <p>Parameters</p> <ul> <li><code>panel</code> (Panel): Panel to draw blur behind</li> <li><code>amount</code> (number, optional): Blur intensity (default: 5)</li> <li><code>passes</code> (number, optional): Number of blur passes (default: 0.2)</li> <li><code>alpha</code> (number, optional): Blur alpha (default: 255)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw blur behind panel\nlia.derma.drawBlur(myPanel)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom blur settings\nlia.derma.drawBlur(myPanel, 8, 0.3, 200)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic blur with panel validation\nif IsValid(panel) and panel:IsVisible() then\n    local amount = isHovered and 10 or 5\n    local alpha = isActive and 255 or 150\n    lia.derma.drawBlur(panel, amount, 0.2, alpha)\nend\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawblackblur","title":"drawBlackBlur","text":"<p>Purpose</p> <p>Draws blur effect behind a panel using screen space effects</p> <p>When Called</p> <p>When rendering panel backgrounds that need blur effects</p> <p>Parameters</p> <ul> <li><code>panel</code> (Panel): Panel to draw blur behind</li> <li><code>amount</code> (number, optional): Blur intensity (default: 5)</li> <li><code>passes</code> (number, optional): Number of blur passes (default: 0.2)</li> <li><code>alpha</code> (number, optional): Blur alpha (default: 255)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw blur behind panel\nlia.derma.drawBlur(myPanel)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom blur settings\nlia.derma.drawBlur(myPanel, 8, 0.3, 200)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic blur with panel validation\nif IsValid(panel) and panel:IsVisible() then\n    local amount = isHovered and 10 or 5\n    local alpha = isActive and 255 or 150\n    lia.derma.drawBlur(panel, amount, 0.2, alpha)\nend\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawblurat","title":"drawBlurAt","text":"<p>Purpose</p> <p>Draws blur effect at specific screen coordinates</p> <p>When Called</p> <p>When rendering blur effects at specific screen positions</p> <p>Parameters</p> <ul> <li><code>x</code> (number): X position on screen</li> <li><code>y</code> (number): Y position on screen</li> <li><code>w</code> (number): Width of blur area</li> <li><code>h</code> (number): Height of blur area</li> <li><code>amount</code> (number, optional): Blur intensity (default: 5)</li> <li><code>passes</code> (number, optional): Number of blur passes (default: 0.2)</li> <li><code>alpha</code> (number, optional): Blur alpha (default: 255)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw blur at specific position\nlia.derma.drawBlurAt(100, 100, 200, 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom blur settings\nlia.derma.drawBlurAt(50, 50, 300, 150, 8, 0.3, 200)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic blur with screen bounds checking\nlocal x, y = getScreenPosition()\nlocal w, h = getBlurSize()\nif x &gt;= 0 and y &gt;= 0 and x + w &lt;= ScrW() and y + h &lt;= ScrH() then\n    local amount = isHovered and 10 or 5\n    lia.derma.drawBlurAt(x, y, w, h, amount, 0.2, 255)\nend\n</code></pre></p>"},{"location":"libraries/lia.derma/#requestarguments","title":"requestArguments","text":"<p>Purpose</p> <p>Creates a dialog for requesting multiple arguments from the user</p> <p>When Called</p> <p>When user input is needed for multiple fields with different types</p> <p>Parameters</p> <ul> <li><code>title</code> (string, optional): Title of the dialog</li> <li><code>argTypes</code> (table): Table defining argument types and properties</li> <li><code>onSubmit</code> (function): Callback function called with results</li> <li><code>defaults</code> (table, optional): Default values for arguments</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request basic arguments\nlocal argTypes = {\nname = \"string\",\nage = \"number\",\nisActive = \"boolean\"\n}\nlia.derma.requestArguments(\"User Info\", argTypes, function(success, results)\nif success then\n    print(\"Name:\", results.name, \"Age:\", results.age)\nend\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with dropdown and defaults\nlocal argTypes = {\n{name = \"player\", type = \"player\"},\n{name = \"action\", type = \"table\", data = {\"kick\", \"ban\", \"mute\"}},\n{name = \"reason\", type = \"string\"}\n}\nlocal defaults = {reason = \"No reason provided\"}\nlia.derma.requestArguments(\"Admin Action\", argTypes, onSubmit, defaults)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex argument validation with ordered fields\nlocal argTypes = {\n{name = \"itemName\", type = \"string\"},\n{name = \"itemType\", type = \"table\", data = {{\"Weapon\", \"weapon\"}, {\"Tool\", \"tool\"}}},\n{name = \"quantity\", type = \"number\"},\n{name = \"isStackable\", type = \"boolean\"}\n}\nlia.derma.requestArguments(\"Create Item\", argTypes, function(success, results)\nif success and validateItemData(results) then\n    createItem(results)\nend\nend)\n</code></pre></p>"},{"location":"libraries/lia.derma/#createtableui","title":"createTableUI","text":"<p>Purpose</p> <p>Creates a dialog for requesting multiple arguments from the user</p> <p>When Called</p> <p>When user input is needed for multiple fields with different types</p> <p>Parameters</p> <ul> <li><code>title</code> (string, optional): Title of the dialog</li> <li><code>argTypes</code> (table): Table defining argument types and properties</li> <li><code>onSubmit</code> (function): Callback function called with results</li> <li><code>defaults</code> (table, optional): Default values for arguments</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request basic arguments\nlocal argTypes = {\nname = \"string\",\nage = \"number\",\nisActive = \"boolean\"\n}\nlia.derma.requestArguments(\"User Info\", argTypes, function(success, results)\nif success then\n    print(\"Name:\", results.name, \"Age:\", results.age)\nend\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with dropdown and defaults\nlocal argTypes = {\n{name = \"player\", type = \"player\"},\n{name = \"action\", type = \"table\", data = {\"kick\", \"ban\", \"mute\"}},\n{name = \"reason\", type = \"string\"}\n}\nlocal defaults = {reason = \"No reason provided\"}\nlia.derma.requestArguments(\"Admin Action\", argTypes, onSubmit, defaults)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex argument validation with ordered fields\nlocal argTypes = {\n{name = \"itemName\", type = \"string\"},\n{name = \"itemType\", type = \"table\", data = {{\"Weapon\", \"weapon\"}, {\"Tool\", \"tool\"}}},\n{name = \"quantity\", type = \"number\"},\n{name = \"isStackable\", type = \"boolean\"}\n}\nlia.derma.requestArguments(\"Create Item\", argTypes, function(success, results)\nif success and validateItemData(results) then\n    createItem(results)\nend\nend)\n</code></pre></p>"},{"location":"libraries/lia.derma/#openoptionsmenu","title":"openOptionsMenu","text":"<p>Purpose</p> <p>Creates a dialog for requesting multiple arguments from the user</p> <p>When Called</p> <p>When user input is needed for multiple fields with different types</p> <p>Parameters</p> <ul> <li><code>title</code> (string, optional): Title of the dialog</li> <li><code>argTypes</code> (table): Table defining argument types and properties</li> <li><code>onSubmit</code> (function): Callback function called with results</li> <li><code>defaults</code> (table, optional): Default values for arguments</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request basic arguments\nlocal argTypes = {\nname = \"string\",\nage = \"number\",\nisActive = \"boolean\"\n}\nlia.derma.requestArguments(\"User Info\", argTypes, function(success, results)\nif success then\n    print(\"Name:\", results.name, \"Age:\", results.age)\nend\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with dropdown and defaults\nlocal argTypes = {\n{name = \"player\", type = \"player\"},\n{name = \"action\", type = \"table\", data = {\"kick\", \"ban\", \"mute\"}},\n{name = \"reason\", type = \"string\"}\n}\nlocal defaults = {reason = \"No reason provided\"}\nlia.derma.requestArguments(\"Admin Action\", argTypes, onSubmit, defaults)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex argument validation with ordered fields\nlocal argTypes = {\n{name = \"itemName\", type = \"string\"},\n{name = \"itemType\", type = \"table\", data = {{\"Weapon\", \"weapon\"}, {\"Tool\", \"tool\"}}},\n{name = \"quantity\", type = \"number\"},\n{name = \"isStackable\", type = \"boolean\"}\n}\nlia.derma.requestArguments(\"Create Item\", argTypes, function(success, results)\nif success and validateItemData(results) then\n    createItem(results)\nend\nend)\n</code></pre></p>"},{"location":"libraries/lia.derma/#drawenttext","title":"drawEntText","text":"<p>Purpose</p> <p>Draws text above entities in 3D space with distance-based scaling</p> <p>When Called</p> <p>When rendering entity labels or information in 3D space</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): Entity to draw text above</li> <li><code>text</code> (string): Text to display</li> <li><code>posY</code> (number, optional): Y offset from entity center (default: 0)</li> <li><code>alphaOverride</code> (number, optional): Alpha override for the text</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw entity name\nlia.derma.drawEntText(entity, entity:GetName())\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw with custom offset and alpha\nlia.derma.drawEntText(entity, \"Custom Text\", 20, 200)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic entity text with conditions\nif IsValid(entity) and entity:IsPlayer() then\n    local text = entity:Name()\n    if entity:IsAdmin() then\n        text = \"[ADMIN] \" .. text\n    end\n    local alpha = entity:IsTyping() and 150 or 255\n    lia.derma.drawEntText(entity, text, 0, alpha)\nend\n</code></pre></p>"},{"location":"libraries/lia.derma/#requestdropdown","title":"requestDropdown","text":"<p>Purpose</p> <p>Creates a dropdown selection dialog for user choice</p> <p>When Called</p> <p>When user needs to select from a list of options</p> <p>Parameters</p> <ul> <li><code>title</code> (string, optional): Title of the dialog</li> <li><code>options</code> (table): Array of options (strings or {text, data} tables)</li> <li><code>callback</code> (function): Callback function called with selected option</li> <li><code>defaultValue</code> (string/table, optional): Default selected value</li> </ul> <p>Returns</p> <ul> <li>Panel - The created dialog frame</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request dropdown selection\nlocal options = {\"Option 1\", \"Option 2\", \"Option 3\"}\nlia.derma.requestDropdown(\"Choose Option\", options, function(selected)\nprint(\"Selected:\", selected)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with data values and default\nlocal options = {\n{\"Kick Player\", \"kick\"},\n{\"Ban Player\", \"ban\"},\n{\"Mute Player\", \"mute\"}\n}\nlia.derma.requestDropdown(\"Admin Action\", options, function(text, data)\nperformAction(data)\nend, \"kick\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic options with validation\nlocal options = {}\nfor _, player in pairs(player.GetAll()) do\n    if IsValid(player) then\n        table.insert(options, {player:Name(), player:SteamID()})\n    end\nend\nlia.derma.requestDropdown(\"Select Player\", options, function(name, steamid)\nif steamid and steamid ~= \"\" then\n    processPlayerSelection(steamid)\nend\nend)\n</code></pre></p>"},{"location":"libraries/lia.derma/#requeststring","title":"requestString","text":"<p>Purpose</p> <p>Creates a text input dialog for user string entry</p> <p>When Called</p> <p>When user needs to input text through a dialog</p> <p>Parameters</p> <ul> <li><code>title</code> (string, optional): Title of the dialog</li> <li><code>description</code> (string, optional): Description text for the input</li> <li><code>callback</code> (function): Callback function called with entered text</li> <li><code>defaultValue</code> (string, optional): Default text value</li> <li><code>maxLength</code> (number, optional): Maximum text length</li> </ul> <p>Returns</p> <ul> <li>Panel - The created dialog frame</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request text input\nlia.derma.requestString(\"Enter Name\", \"Type your name:\", function(text)\nif text and text ~= \"\" then\n    print(\"Name:\", text)\nend\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with default value and max length\nlia.derma.requestString(\"Set Password\", \"Enter new password:\", function(password)\nif string.len(password) &gt;= 6 then\n    setPassword(password)\nend\nend, \"\", 20)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Request with validation and processing\nlia.derma.requestString(\"Create Item\", \"Enter item name:\", function(name)\nif not name or name == \"\" then return end\n    local cleanName = string.Trim(name)\n    if string.len(cleanName) &lt; 3 then\n        notify(\"Name too short!\")\n        return\n    end\n    if itemExists(cleanName) then\n        notify(\"Item already exists!\")\n        return\n    end\n    createItem(cleanName)\nend, \"\", 50)\n</code></pre></p>"},{"location":"libraries/lia.derma/#requestoptions","title":"requestOptions","text":"<p>Purpose</p> <p>Creates a multi-select dialog for choosing multiple options</p> <p>When Called</p> <p>When user needs to select multiple options from a list</p> <p>Parameters</p> <ul> <li><code>title</code> (string, optional): Title of the dialog</li> <li><code>options</code> (table): Array of options (strings or {text, data} tables)</li> <li><code>callback</code> (function): Callback function called with selected options array</li> <li><code>defaults</code> (table, optional): Array of default selected values</li> </ul> <p>Returns</p> <ul> <li>Panel - The created dialog frame</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request multiple selections\nlocal options = {\"Option 1\", \"Option 2\", \"Option 3\"}\nlia.derma.requestOptions(\"Choose Options\", options, function(selected)\nprint(\"Selected:\", table.concat(selected, \", \"))\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with data values and defaults\nlocal options = {\n{\"Admin\", \"admin\"},\n{\"Moderator\", \"moderator\"},\n{\"VIP\", \"vip\"}\n}\nlocal defaults = {\"admin\"}\nlia.derma.requestOptions(\"Select Roles\", options, function(selected)\nassignRoles(selected)\nend, defaults)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic options with validation\nlocal options = {}\nfor _, permission in pairs(availablePermissions) do\n    table.insert(options, {permission.displayName, permission.id})\nend\nlia.derma.requestOptions(\"Select Permissions\", options, function(selected)\nif #selected &gt; 0 then\n    validateAndAssignPermissions(selected)\n    else\n        notify(\"Please select at least one permission!\")\n    end\nend, userPermissions)\n</code></pre></p>"},{"location":"libraries/lia.derma/#requestbinaryquestion","title":"requestBinaryQuestion","text":"<p>Purpose</p> <p>Creates a yes/no confirmation dialog</p> <p>When Called</p> <p>When user confirmation is needed for an action</p> <p>Parameters</p> <ul> <li><code>title</code> (string, optional): Title of the dialog</li> <li><code>question</code> (string, optional): Question text to display</li> <li><code>callback</code> (function): Callback function called with boolean result</li> <li><code>yesText</code> (string, optional): Text for yes button</li> <li><code>noText</code> (string, optional): Text for no button</li> </ul> <p>Returns</p> <ul> <li>Panel - The created dialog frame</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request confirmation\nlia.derma.requestBinaryQuestion(\"Confirm\", \"Are you sure?\", function(result)\nif result then\n    print(\"User confirmed\")\n    else\n        print(\"User cancelled\")\n    end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with custom button text\nlia.derma.requestBinaryQuestion(\"Delete Item\", \"Delete this item permanently?\", function(result)\nif result then\n    deleteItem(item)\nend\nend, \"Delete\", \"Cancel\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Request with validation and logging\nlia.derma.requestBinaryQuestion(\"Admin Action\", \"Execute admin command: \" .. command .. \"?\", function(result)\nif result then\n    if validateAdminCommand(command) then\n        executeAdminCommand(command)\n        logAdminAction(command)\n        else\n            notify(\"Invalid command!\")\n        end\n    end\nend, \"Execute\", \"Cancel\")\n</code></pre></p>"},{"location":"libraries/lia.derma/#liadescription","title":"lia.description","text":"<p>Purpose</p> <p>Creates a dialog with multiple action buttons</p> <p>When Called</p> <p>When user needs to choose from multiple actions</p> <p>Parameters</p> <ul> <li><code>title</code> (string, optional): Title of the dialog</li> <li><code>buttons</code> (table): Array of button definitions (strings or {text, callback, icon} tables)</li> <li><code>callback</code> (function, optional): Default callback function</li> <li><code>description</code> (string, optional): Description text for the dialog</li> </ul> <p>Returns</p> <ul> <li>Panel, Table - The created dialog frame and button panels array</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request button selection\nlocal buttons = {\"Option 1\", \"Option 2\", \"Option 3\"}\nlia.derma.requestButtons(\"Choose Action\", buttons, function(index, text)\nprint(\"Selected:\", text)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with custom callbacks and icons\nlocal buttons = {\n{text = \"Edit\", callback = function() editItem() end, icon = \"icon16/pencil.png\"},\n{text = \"Delete\", callback = function() deleteItem() end, icon = \"icon16/delete.png\"},\n{text = \"Copy\", callback = function() copyItem() end, icon = \"icon16/copy.png\"}\n}\nlia.derma.requestButtons(\"Item Actions\", buttons, nil, \"Choose an action for this item\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic buttons with validation\nlocal buttons = {}\nif player:IsAdmin() then\n    table.insert(buttons, {text = \"Admin Panel\", callback = function() openAdminPanel() end})\nend\nif item:CanEdit() then\n    table.insert(buttons, {text = \"Edit\", callback = function() editItem(item) end})\nend\ntable.insert(buttons, {text = \"View\", callback = function() viewItem(item) end})\nlia.derma.requestButtons(\"Item Options\", buttons, function(index, text)\nlogAction(\"Button clicked: \" .. text)\nend, \"Available actions for \" .. item:GetName())\n</code></pre></p>"},{"location":"libraries/lia.derma/#requestbuttons","title":"requestButtons","text":"<p>Purpose</p> <p>Creates a dialog with multiple action buttons</p> <p>When Called</p> <p>When user needs to choose from multiple actions</p> <p>Parameters</p> <ul> <li><code>title</code> (string, optional): Title of the dialog</li> <li><code>buttons</code> (table): Array of button definitions (strings or {text, callback, icon} tables)</li> <li><code>callback</code> (function, optional): Default callback function</li> <li><code>description</code> (string, optional): Description text for the dialog</li> </ul> <p>Returns</p> <ul> <li>Panel, Table - The created dialog frame and button panels array</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request button selection\nlocal buttons = {\"Option 1\", \"Option 2\", \"Option 3\"}\nlia.derma.requestButtons(\"Choose Action\", buttons, function(index, text)\nprint(\"Selected:\", text)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with custom callbacks and icons\nlocal buttons = {\n{text = \"Edit\", callback = function() editItem() end, icon = \"icon16/pencil.png\"},\n{text = \"Delete\", callback = function() deleteItem() end, icon = \"icon16/delete.png\"},\n{text = \"Copy\", callback = function() copyItem() end, icon = \"icon16/copy.png\"}\n}\nlia.derma.requestButtons(\"Item Actions\", buttons, nil, \"Choose an action for this item\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic buttons with validation\nlocal buttons = {}\nif player:IsAdmin() then\n    table.insert(buttons, {text = \"Admin Panel\", callback = function() openAdminPanel() end})\nend\nif item:CanEdit() then\n    table.insert(buttons, {text = \"Edit\", callback = function() editItem(item) end})\nend\ntable.insert(buttons, {text = \"View\", callback = function() viewItem(item) end})\nlia.derma.requestButtons(\"Item Options\", buttons, function(index, text)\nlogAction(\"Button clicked: \" .. text)\nend, \"Available actions for \" .. item:GetName())\n</code></pre></p>"},{"location":"libraries/lia.doors/","title":"Doors Library Server","text":"<p>Server-side door management and configuration system for the Lilia framework.</p> <p>Overview</p> <p>The doors library server component provides comprehensive door management functionality including preset configuration, database schema verification, and data cleanup operations. It handles door data persistence, loading door configurations from presets, and maintaining database integrity. The library manages door ownership, access permissions, faction and class restrictions, and provides utilities for door data validation and corruption cleanup. It operates primarily on the server side and integrates with the database system to persist door configurations across server restarts. The library also handles door locking/unlocking mechanics and provides hooks for custom door behavior integration.</p>"},{"location":"libraries/lia.doors/#addpreset","title":"addPreset","text":"<p>Purpose</p> <p>Adds a door preset configuration for a specific map</p> <p>When Called</p> <p>When setting up predefined door configurations for maps</p> <p>Parameters</p> <ul> <li><code>mapName</code> (string): The name of the map to apply the preset to</li> <li><code>presetData</code> (table): Table containing door configuration data with the following structure:</li> <li><code>name</code> (string, optional): Custom name for the door</li> <li><code>price</code> (number, optional): Price to purchase the door</li> <li><code>locked</code> (boolean, optional): Whether the door starts locked</li> <li><code>disabled</code> (boolean, optional): Whether the door is disabled</li> <li><code>hidden</code> (boolean, optional): Whether the door info is hidden</li> <li><code>noSell</code> (boolean, optional): Whether the door cannot be sold</li> <li><code>factions</code> (table, optional): Array of faction uniqueIDs that can access the door</li> <li><code>classes</code> (table, optional): Array of class uniqueIDs that can access the door</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic door preset for a map\nlia.doors.addPreset(\"rp_downtown_v4c_v2\", {\n[123] = {\nname = \"Police Station Door\",\nprice = 1000,\nlocked = true\n}\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add preset with faction restrictions\nlia.doors.addPreset(\"rp_downtown_v4c_v2\", {\n[123] = {\nname = \"Police Station\",\nprice = 5000,\nlocked = false,\nfactions = {\"police\", \"mayor\"}\n},\n[124] = {\nname = \"Evidence Room\",\nprice = 0,\nlocked = true,\nfactions = {\"police\"}\n}\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex preset with multiple doors and restrictions\nlocal policeDoors = {\n[123] = {\nname = \"Police Station Main\",\nprice = 10000,\nlocked = false,\nfactions = {\"police\", \"mayor\", \"chief\"}\n},\n[124] = {\nname = \"Evidence Room\",\nprice = 0,\nlocked = true,\nfactions = {\"police\"},\nclasses = {\"detective\", \"chief\"}\n},\n[125] = {\nname = \"Interrogation Room\",\nprice = 0,\nlocked = true,\nfactions = {\"police\"},\nclasses = {\"detective\", \"chief\", \"officer\"}\n}\n}\nlia.doors.addPreset(\"rp_downtown_v4c_v2\", policeDoors)\n</code></pre></p>"},{"location":"libraries/lia.doors/#getpreset","title":"getPreset","text":"<p>Purpose</p> <p>Retrieves a door preset configuration for a specific map</p> <p>When Called</p> <p>When loading door data or checking for existing presets</p> <p>Parameters</p> <ul> <li><code>mapName</code> (string): The name of the map to get the preset for</li> </ul> <p>Returns</p> <ul> <li>Table or nil - The preset data table if found, nil otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get preset for current map\nlocal preset = lia.doors.getPreset(game.GetMap())\nif preset then\n    print(\"Found preset for map\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check and use preset data\nlocal mapName = game.GetMap()\nlocal preset = lia.doors.getPreset(mapName)\nif preset then\n    for doorID, doorData in pairs(preset) do\n        print(\"Door \" .. doorID .. \" has preset: \" .. (doorData.name or \"Unnamed\"))\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic preset loading with validation\nlocal function loadMapPresets(mapName)\n    local preset = lia.doors.getPreset(mapName)\n    if not preset then\n        lia.warning(\"No door preset found for map: \" .. mapName)\n        return false\n    end\n    local validDoors = 0\n    for doorID, doorData in pairs(preset) do\n        local ent = ents.GetMapCreatedEntity(doorID)\n        if IsValid(ent) and ent:isDoor() then\n            validDoors = validDoors + 1\n            -- Apply preset data to door\n            ent:setNetVar(\"doorData\", doorData)\n        end\n    end\n    lia.information(\"Loaded \" .. validDoors .. \" doors from preset for \" .. mapName)\n    return true\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liacustomschemacheck","title":"lia.customSchemaCheck","text":"<p>Purpose</p> <p>Verifies the database schema for the doors table matches expected structure</p> <p>When Called</p> <p>During server initialization or when checking database integrity</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Verify schema on server start\nlia.doors.verifyDatabaseSchema()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Verify schema with custom handling\nhook.Add(\"InitPostEntity\", \"VerifyDoorSchema\", function()\ntimer.Simple(5, function()\nlia.doors.verifyDatabaseSchema()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom schema verification with migration\nfunction customSchemaCheck()\n    lia.doors.verifyDatabaseSchema()\n    -- Check for missing columns and add them\n    local missingColumns = {\n    door_group = \"text\"\n    }\n    for column, type in pairs(missingColumns) do\n        lia.db.query(\"ALTER TABLE lia_doors ADD COLUMN \" .. column .. \" \" .. type)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#verifydatabaseschema","title":"verifyDatabaseSchema","text":"<p>Purpose</p> <p>Verifies the database schema for the doors table matches expected structure</p> <p>When Called</p> <p>During server initialization or when checking database integrity</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Verify schema on server start\nlia.doors.verifyDatabaseSchema()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Verify schema with custom handling\nhook.Add(\"InitPostEntity\", \"VerifyDoorSchema\", function()\ntimer.Simple(5, function()\nlia.doors.verifyDatabaseSchema()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom schema verification with migration\nfunction customSchemaCheck()\n    lia.doors.verifyDatabaseSchema()\n    -- Check for missing columns and add them\n    local missingColumns = {\n    door_group = \"text\"\n    }\n    for column, type in pairs(missingColumns) do\n        lia.db.query(\"ALTER TABLE lia_doors ADD COLUMN \" .. column .. \" \" .. type)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liaadvanceddoorcleanup","title":"lia.advancedDoorCleanup","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#cleanupcorrupteddata","title":"cleanupCorruptedData","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liamoduleinitpostentity","title":"lia.MODULE:InitPostEntity","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liamoduleplayeruse","title":"lia.MODULE:PlayerUse","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liamodulecanplayerusedoor","title":"lia.MODULE:CanPlayerUseDoor","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liamodulecanplayeraccessdoor","title":"lia.MODULE:CanPlayerAccessDoor","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liamodulepostplayerloadout","title":"lia.MODULE:PostPlayerLoadout","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liamoduleshowteam","title":"lia.MODULE:ShowTeam","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liamoduleplayerdisconnected","title":"lia.MODULE:PlayerDisconnected","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liamodulekeylock","title":"lia.MODULE:KeyLock","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liamodulekeyunlock","title":"lia.MODULE:KeyUnlock","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.doors/#liamoduletogglelock","title":"lia.MODULE:ToggleLock","text":"<p>Purpose</p> <p>Cleans up corrupted door data in the database by removing invalid faction/class data</p> <p>When Called</p> <p>During server initialization or when data corruption is detected</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Run cleanup on server start\nlia.doors.cleanupCorruptedData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Schedule cleanup with delay\nhook.Add(\"InitPostEntity\", \"CleanupDoorData\", function()\ntimer.Simple(2, function()\nlia.doors.cleanupCorruptedData()\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom cleanup with logging and validation\nfunction advancedDoorCleanup()\n    lia.information(\"Starting door data cleanup...\")\n    lia.doors.cleanupCorruptedData()\n    -- Additional validation\n    local gamemode = SCHEMA and SCHEMA.folder or engine.ActiveGamemode()\n    local map = game.GetMap()\n    local condition = \"gamemode = \" .. lia.db.convertDataType(gamemode) .. \" AND map = \" .. lia.db.convertDataType(map)\n    lia.db.query(\"SELECT COUNT(*) as count FROM lia_doors WHERE \" .. condition):next(function(res)\n    local count = res.results[1].count\n    lia.information(\"Door cleanup completed. Total doors in database: \" .. count)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.factions/","title":"Faction Library","text":"<p>Comprehensive faction (team) management and registration system for the Lilia framework.</p> <p>Overview</p> <p>The faction library provides comprehensive functionality for managing factions (teams) in the Lilia framework. It handles registration, loading, and management of faction data including models, colors, descriptions, and team setup. The library operates on both server and client sides, with server handling faction registration and client handling whitelist checks. It includes functionality for loading factions from directories, managing faction models with bodygroup support, and providing utilities for faction categorization and player management. The library ensures proper team setup and model precaching for all registered factions, supporting both simple string models and complex model data with bodygroup configurations.</p>"},{"location":"libraries/lia.factions/#register","title":"register","text":"<p>Purpose</p> <p>Registers a new faction with the specified unique ID and data</p> <p>When Called</p> <p>During faction initialization, module loading, or when creating custom factions</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): Unique identifier for the faction</li> <li><code>data</code> (table): Faction data containing name, desc, color, models, etc.</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>index (number): The faction's team index</li> </ul> </li> <li>faction (table): The complete faction data table</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic faction\nlia.faction.register(\"citizen\", {\nname = \"Citizen\",\ndesc = \"A regular citizen\",\ncolor = Color(150, 150, 150)\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register faction with custom models and weapons\nlia.faction.register(\"police\", {\nname = \"Police Officer\",\ndesc = \"Law enforcement officer\",\ncolor = Color(0, 0, 255),\nmodels = {\"models/player/police.mdl\"},\nweapons = {\"weapon_pistol\", \"weapon_stunstick\"},\nisDefault = false\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register faction with complex model data and bodygroups\nlia.faction.register(\"medic\", {\nname = \"Medical Staff\",\ndesc = \"Emergency medical personnel\",\ncolor = Color(255, 0, 0),\nmodels = {\n\"male\" = {\n{\"models/player/medic_male.mdl\", \"Male Medic\", {1, 2, 3}},\n{\"models/player/doctor_male.mdl\", \"Male Doctor\", {0, 1, 2}}\n},\n\"female\" = {\n{\"models/player/medic_female.mdl\", \"Female Medic\", {1, 2}},\n{\"models/player/doctor_female.mdl\", \"Female Doctor\", {0, 1}}\n}\n},\nweapons = {\"weapon_medkit\", \"weapon_defibrillator\"},\nisDefault = false,\nindex = 5\n})\n</code></pre></p>"},{"location":"libraries/lia.factions/#cachemodels","title":"cacheModels","text":"<p>Purpose</p> <p>Precaches faction models to ensure they are loaded before use</p> <p>When Called</p> <p>Automatically called during faction registration, or manually when adding models</p> <p>Parameters</p> <ul> <li><code>models</code> (table): Table of model data (strings or tables with model paths)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Cache basic string models\nlia.faction.cacheModels({\"models/player/police.mdl\", \"models/player/swat.mdl\"})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Cache mixed model data types\nlocal models = {\n\"models/player/police.mdl\",\n{\"models/player/swat.mdl\", \"SWAT Officer\"},\n{\"models/player/fbi.mdl\", \"FBI Agent\", {1, 2, 3}}\n}\nlia.faction.cacheModels(models)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Cache categorized models with bodygroup data\nlocal models = {\n\"male\" = {\n{\"models/player/police_male.mdl\", \"Male Officer\", {1, 2}},\n{\"models/player/swat_male.mdl\", \"Male SWAT\", {0, 1, 2, 3}}\n},\n\"female\" = {\n{\"models/player/police_female.mdl\", \"Female Officer\", {1}},\n{\"models/player/swat_female.mdl\", \"Female SWAT\", {0, 1, 2}}\n}\n}\nlia.faction.cacheModels(models)\n</code></pre></p>"},{"location":"libraries/lia.factions/#loadfromdir","title":"loadFromDir","text":"<p>Purpose</p> <p>Loads all faction files from a specified directory</p> <p>When Called</p> <p>During gamemode initialization to load faction files from modules or custom directories</p> <p>Parameters</p> <ul> <li><code>directory</code> (string): Path to the directory containing faction files</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load factions from a basic directory\nlia.faction.loadFromDir(\"gamemode/factions\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load factions from module directory with error handling\nlocal factionDir = \"gamemode/modules/customfactions/factions\"\nif file.Exists(factionDir, \"LUA\") then\n    lia.faction.loadFromDir(factionDir)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load factions from multiple directories with validation\nlocal factionDirs = {\n\"gamemode/factions\",\n\"gamemode/modules/customfactions/factions\",\n\"gamemode/schema/factions\"\n}\nfor _, dir in ipairs(factionDirs) do\n    if file.Exists(dir, \"LUA\") then\n        print(\"Loading factions from: \" .. dir)\n        lia.faction.loadFromDir(dir)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.factions/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves a faction by its identifier (index or uniqueID)</p> <p>When Called</p> <p>When you need to get faction data by either team index or unique ID</p> <p>Parameters</p> <ul> <li><code>identifier</code> (number/string): Either the faction's team index or unique ID</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>faction (table): The faction data table, or nil if not found</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get faction by unique ID\nlocal faction = lia.faction.get(\"citizen\")\nif faction then\n    print(\"Faction name: \" .. faction.name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get faction by index with validation\nlocal factionIndex = 1\nlocal faction = lia.faction.get(factionIndex)\nif faction then\n    print(\"Faction: \" .. faction.name .. \" (Index: \" .. faction.index .. \")\")\n    else\n        print(\"Faction not found\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get faction with fallback and error handling\nlocal function getFactionSafely(identifier)\n    local faction = lia.faction.get(identifier)\n    if not faction then\n        if isnumber(identifier) then\n            error(\"Faction with index \" .. identifier .. \" not found\")\n            else\n                error(\"Faction with ID '\" .. identifier .. \"' not found\")\n            end\n        end\n        return faction\n    end\n    local faction = getFactionSafely(\"police\")\n</code></pre></p>"},{"location":"libraries/lia.factions/#getindex","title":"getIndex","text":"<p>Purpose</p> <p>Gets the team index of a faction by its unique ID</p> <p>When Called</p> <p>When you need to convert a faction's unique ID to its team index</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): The faction's unique identifier</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>index (number): The faction's team index, or nil if not found</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get faction index\nlocal index = lia.faction.getIndex(\"citizen\")\nif index then\n    print(\"Citizen faction index: \" .. index)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get faction index with validation\nlocal factionID = \"police\"\nlocal index = lia.faction.getIndex(factionID)\nif index then\n    print(\"Faction '\" .. factionID .. \"' has index: \" .. index)\n    else\n        print(\"Faction '\" .. factionID .. \"' not found\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get multiple faction indices with error handling\nlocal factionIDs = {\"citizen\", \"police\", \"medic\", \"staff\"}\nlocal indices = {}\nfor _, id in ipairs(factionIDs) do\n    local index = lia.faction.getIndex(id)\n    if index then\n        indices[id] = index\n        else\n            print(\"Warning: Faction '\" .. id .. \"' not found\")\n        end\n    end\n    return indices\n</code></pre></p>"},{"location":"libraries/lia.factions/#getclasses","title":"getClasses","text":"<p>Purpose</p> <p>Gets all classes that belong to a specific faction</p> <p>When Called</p> <p>When you need to retrieve all classes associated with a faction</p> <p>Parameters</p> <ul> <li><code>faction</code> (string/number): The faction's unique ID or team index</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>classes (table): Table of class objects belonging to the faction</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all classes for a faction\nlocal classes = lia.faction.getClasses(\"citizen\")\nprint(\"Citizen classes: \" .. #classes)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get classes with validation and display\nlocal factionID = \"police\"\nlocal classes = lia.faction.getClasses(factionID)\nif #classes &gt; 0 then\n    print(\"Classes for \" .. factionID .. \":\")\n    for _, class in ipairs(classes) do\n        print(\"- \" .. class.name)\n    end\n    else\n        print(\"No classes found for \" .. factionID)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get classes for multiple factions with filtering\nlocal function getFactionClasses(factionID)\n    local faction = lia.faction.get(factionID)\n    if not faction then\n        return {}\n    end\n    local classes = lia.faction.getClasses(factionID)\n    local result = {}\n    for _, class in ipairs(classes) do\n        if class.isDefault or not class.isDefault then -- Include all classes\n            table.insert(result, {\n            name = class.name,\n            desc = class.desc,\n            isDefault = class.isDefault\n            })\n        end\n    end\n    return result\nend\nlocal policeClasses = getFactionClasses(\"police\")\n</code></pre></p>"},{"location":"libraries/lia.factions/#getplayers","title":"getPlayers","text":"<p>Purpose</p> <p>Gets all players currently in a specific faction</p> <p>When Called</p> <p>When you need to retrieve all players belonging to a faction</p> <p>Parameters</p> <ul> <li><code>faction</code> (string/number): The faction's unique ID or team index</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>players (table): Table of player entities in the faction</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all players in a faction\nlocal players = lia.faction.getPlayers(\"citizen\")\nprint(\"Citizen players: \" .. #players)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get players with validation and display\nlocal factionID = \"police\"\nlocal players = lia.faction.getPlayers(factionID)\nif #players &gt; 0 then\n    print(\"Players in \" .. factionID .. \":\")\n    for _, ply in ipairs(players) do\n        print(\"- \" .. ply:Name())\n    end\n    else\n        print(\"No players in \" .. factionID)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get players with additional character data\nlocal function getFactionPlayers(factionID)\n    local players = lia.faction.getPlayers(factionID)\n    local result = {}\n    for _, ply in ipairs(players) do\n        local char = ply:getChar()\n        if char then\n            table.insert(result, {\n            player = ply,\n            name = ply:Name(),\n            charName = char:getName(),\n            steamID = ply:SteamID(),\n            isAlive = ply:Alive()\n            })\n        end\n    end\n    return result\nend\nlocal policePlayers = getFactionPlayers(\"police\")\n</code></pre></p>"},{"location":"libraries/lia.factions/#getplayercount","title":"getPlayerCount","text":"<p>Purpose</p> <p>Gets the count of players currently in a specific faction</p> <p>When Called</p> <p>When you need to know how many players are in a faction without getting the actual player objects</p> <p>Parameters</p> <ul> <li><code>faction</code> (string/number): The faction's unique ID or team index</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>count (number): Number of players in the faction</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player count for a faction\nlocal count = lia.faction.getPlayerCount(\"citizen\")\nprint(\"Citizen players: \" .. count)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get player count with validation\nlocal factionID = \"police\"\nlocal count = lia.faction.getPlayerCount(factionID)\nif count &gt; 0 then\n    print(\"There are \" .. count .. \" players in \" .. factionID)\n    else\n        print(\"No players in \" .. factionID)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get player counts for multiple factions with statistics\nlocal function getFactionStatistics()\n    local factions = {\"citizen\", \"police\", \"medic\", \"staff\"}\n    local stats = {}\n    local totalPlayers = 0\n    for _, factionID in ipairs(factions) do\n        local count = lia.faction.getPlayerCount(factionID)\n        stats[factionID] = count\n        totalPlayers = totalPlayers + count\n    end\n    stats.total = totalPlayers\n    return stats\nend\nlocal stats = getFactionStatistics()\nprint(\"Total players: \" .. stats.total)\n</code></pre></p>"},{"location":"libraries/lia.factions/#isfactioncategory","title":"isFactionCategory","text":"<p>Purpose</p> <p>Checks if a faction belongs to a specific category of factions</p> <p>When Called</p> <p>When you need to check if a faction is part of a group of related factions</p> <p>Parameters</p> <ul> <li><code>faction</code> (string/number): The faction's unique ID or team index</li> <li><code>categoryFactions</code> (table): Table of faction identifiers to check against</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>isCategory (boolean): True if the faction is in the category, false otherwise</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if faction is in a category\nlocal lawEnforcement = {\"police\", \"swat\", \"fbi\"}\nlocal isLawEnforcement = lia.faction.isFactionCategory(\"police\", lawEnforcement)\nprint(\"Is police law enforcement: \" .. tostring(isLawEnforcement))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction category with validation\nlocal medicalFactions = {\"medic\", \"doctor\", \"paramedic\"}\nlocal factionID = \"medic\"\nif lia.faction.isFactionCategory(factionID, medicalFactions) then\n    print(factionID .. \" is a medical faction\")\n    else\n        print(factionID .. \" is not a medical faction\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check multiple factions against multiple categories\nlocal function categorizeFactions(factionIDs)\n    local categories = {\n    lawEnforcement = {\"police\", \"swat\", \"fbi\", \"security\"},\n    medical = {\"medic\", \"doctor\", \"paramedic\", \"nurse\"},\n    civilian = {\"citizen\", \"businessman\", \"unemployed\"}\n    }\n    local results = {}\n    for _, factionID in ipairs(factionIDs) do\n        local category = \"unknown\"\n        for catName, catFactions in pairs(categories) do\n            if lia.faction.isFactionCategory(factionID, catFactions) then\n                category = catName\n                break\n            end\n        end\n        results[factionID] = category\n    end\n    return results\nend\nlocal factionCategories = categorizeFactions({\"police\", \"medic\", \"citizen\"})\n</code></pre></p>"},{"location":"libraries/lia.factions/#jobgenerate","title":"jobGenerate","text":"<p>Purpose</p> <p>Generates a faction/job with the specified parameters (legacy compatibility function)</p> <p>When Called</p> <p>For backward compatibility with older faction systems or when creating simple factions</p> <p>Parameters</p> <ul> <li><code>index</code> (number): The team index for the faction</li> <li><code>name</code> (string): The faction's display name</li> <li><code>color</code> (Color): The faction's team color</li> <li><code>default</code> (boolean): Whether this is a default faction</li> <li><code>models</code> (table): Optional table of models for the faction</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>faction (table): The generated faction data table</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Generate a basic faction\nlocal faction = lia.faction.jobGenerate(1, \"Citizen\", Color(150, 150, 150), true)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Generate faction with custom models\nlocal models = {\"models/player/police.mdl\", \"models/player/swat.mdl\"}\nlocal faction = lia.faction.jobGenerate(2, \"Police\", Color(0, 0, 255), false, models)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Generate faction with complex model data\nlocal function generateCustomFaction(index, name, color, isDefault)\n    local models = {\n    {\"models/player/police_male.mdl\", \"Male Officer\", {1, 2}},\n    {\"models/player/police_female.mdl\", \"Female Officer\", {1}},\n    {\"models/player/swat.mdl\", \"SWAT Officer\", {0, 1, 2, 3}}\n    }\n    local faction = lia.faction.jobGenerate(index, name, color, isDefault, models)\n    faction.uniqueID = string.lower(name:gsub(\" \", \"_\"))\n    faction.desc = \"A \" .. name .. \" faction\"\n    return faction\nend\nlocal policeFaction = generateCustomFaction(2, \"Police Officer\", Color(0, 0, 255), false)\n</code></pre></p>"},{"location":"libraries/lia.factions/#formatmodeldata","title":"formatModelData","text":"<p>Purpose</p> <p>Formats and processes model data for all factions, converting bodygroup strings to proper format</p> <p>When Called</p> <p>During faction initialization or when model data needs to be processed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Format all faction model data\nlia.faction.formatModelData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Format model data with validation\nif lia.faction.teams and table.Count(lia.faction.teams) &gt; 0 then\n    print(\"Formatting model data for \" .. table.Count(lia.faction.teams) .. \" factions\")\n    lia.faction.formatModelData()\n    print(\"Model data formatting complete\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Format model data with progress tracking and error handling\nlocal function formatFactionModels()\n    local factionCount = table.Count(lia.faction.teams)\n    local processed = 0\n    print(\"Starting model data formatting for \" .. factionCount .. \" factions\")\n    local success, err = pcall(lia.faction.formatModelData)\n    if success then\n        print(\"Successfully formatted model data for all factions\")\n        else\n            print(\"Error formatting model data: \" .. tostring(err))\n        end\n        return success\n    end\n    local success = formatFactionModels()\n</code></pre></p>"},{"location":"libraries/lia.factions/#getcategories","title":"getCategories","text":"<p>Purpose</p> <p>Gets all model categories for a specific faction</p> <p>When Called</p> <p>When you need to retrieve the model categories available for a faction</p> <p>Parameters</p> <ul> <li><code>teamName</code> (string): The faction's unique ID</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>categories (table): Table of category names for the faction's models</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get categories for a faction\nlocal categories = lia.faction.getCategories(\"police\")\nprint(\"Police categories: \" .. table.concat(categories, \", \"))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get categories with validation\nlocal factionID = \"medic\"\nlocal categories = lia.faction.getCategories(factionID)\nif #categories &gt; 0 then\n    print(\"Categories for \" .. factionID .. \":\")\n    for _, category in ipairs(categories) do\n        print(\"- \" .. category)\n    end\n    else\n        print(\"No categories found for \" .. factionID)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get categories for multiple factions with detailed info\nlocal function getFactionCategories(factionIDs)\n    local results = {}\n    for _, factionID in ipairs(factionIDs) do\n        local faction = lia.faction.get(factionID)\n        if faction then\n            local categories = lia.faction.getCategories(factionID)\n            results[factionID] = {\n            name = faction.name,\n            categories = categories,\n            categoryCount = #categories\n            }\n        end\n    end\n    return results\nend\nlocal factionData = getFactionCategories({\"police\", \"medic\", \"citizen\"})\n</code></pre></p>"},{"location":"libraries/lia.factions/#getmodelsfromcategory","title":"getModelsFromCategory","text":"<p>Purpose</p> <p>Gets all models from a specific category within a faction</p> <p>When Called</p> <p>When you need to retrieve models from a specific category of a faction</p> <p>Parameters</p> <ul> <li><code>teamName</code> (string): The faction's unique ID</li> <li><code>category</code> (string): The category name to get models from</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>models (table): Table of models in the specified category</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get models from a category\nlocal models = lia.faction.getModelsFromCategory(\"police\", \"male\")\nprint(\"Male police models: \" .. table.Count(models))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get models with validation\nlocal factionID = \"medic\"\nlocal category = \"female\"\nlocal models = lia.faction.getModelsFromCategory(factionID, category)\nif table.Count(models) &gt; 0 then\n    print(\"Female medic models:\")\n    for index, model in pairs(models) do\n        print(\"- \" .. index .. \": \" .. tostring(model))\n    end\n    else\n        print(\"No models found in \" .. category .. \" category for \" .. factionID)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get models from multiple categories with detailed processing\nlocal function getFactionModelsByCategory(factionID, categories)\n    local results = {}\n    for _, category in ipairs(categories) do\n        local models = lia.faction.getModelsFromCategory(factionID, category)\n        if table.Count(models) &gt; 0 then\n            results[category] = {}\n            for index, model in pairs(models) do\n                table.insert(results[category], {\n                index = index,\n                model = model,\n                modelPath = istable(model) and model[1] or model\n                })\n            end\n        end\n    end\n    return results\nend\nlocal modelData = getFactionModelsByCategory(\"police\", {\"male\", \"female\", \"special\"})\n</code></pre></p>"},{"location":"libraries/lia.factions/#getdefaultclass","title":"getDefaultClass","text":"<p>Purpose</p> <p>Gets the default class for a specific faction</p> <p>When Called</p> <p>When you need to find the default class that players spawn as in a faction</p> <p>Parameters</p> <ul> <li><code>id</code> (string/number): The faction's unique ID or team index</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>defaultClass (table): The default class object, or nil if not found</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get default class for a faction\nlocal defaultClass = lia.faction.getDefaultClass(\"citizen\")\nif defaultClass then\n    print(\"Default citizen class: \" .. defaultClass.name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get default class with validation\nlocal factionID = \"police\"\nlocal defaultClass = lia.faction.getDefaultClass(factionID)\nif defaultClass then\n    print(\"Default class for \" .. factionID .. \": \" .. defaultClass.name)\n    print(\"Description: \" .. defaultClass.desc)\n    else\n        print(\"No default class found for \" .. factionID)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get default classes for multiple factions with fallback handling\nlocal function getDefaultClasses(factionIDs)\n    local results = {}\n    for _, factionID in ipairs(factionIDs) do\n        local defaultClass = lia.faction.getDefaultClass(factionID)\n        if defaultClass then\n            results[factionID] = {\n            name = defaultClass.name,\n            desc = defaultClass.desc,\n            class = defaultClass\n            }\n            else\n                -- Fallback to first available class\n                local classes = lia.faction.getClasses(factionID)\n                if #classes &gt; 0 then\n                    results[factionID] = {\n                    name = classes[1].name,\n                    desc = classes[1].desc,\n                    class = classes[1],\n                    isFallback = true\n                    }\n                end\n            end\n        end\n        return results\n    end\n    local defaultClasses = getDefaultClasses({\"citizen\", \"police\", \"medic\"})\n</code></pre></p>"},{"location":"libraries/lia.factions/#haswhitelist","title":"hasWhitelist","text":"<p>Purpose</p> <p>Checks if a faction has whitelist restrictions (client-side implementation)</p> <p>When Called</p> <p>When checking if a player can access a faction based on whitelist status</p> <p>Parameters</p> <ul> <li><code>faction</code> (string/number): The faction's unique ID or team index</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>hasWhitelist (boolean): True if the faction has whitelist restrictions, false otherwise</li> </ul> </li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if faction has whitelist\nlocal hasWhitelist = lia.faction.hasWhitelist(\"police\")\nprint(\"Police has whitelist: \" .. tostring(hasWhitelist))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check whitelist with validation\nlocal factionID = \"medic\"\nlocal hasWhitelist = lia.faction.hasWhitelist(factionID)\nif hasWhitelist then\n    print(\"Faction \" .. factionID .. \" requires whitelist\")\n    else\n        print(\"Faction \" .. factionID .. \" is open to all players\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check whitelist for multiple factions with detailed info\nlocal function checkFactionWhitelists(factionIDs)\n    local results = {}\n    for _, factionID in ipairs(factionIDs) do\n        local faction = lia.faction.get(factionID)\n        if faction then\n            local hasWhitelist = lia.faction.hasWhitelist(factionID)\n            results[factionID] = {\n            name = faction.name,\n            hasWhitelist = hasWhitelist,\n            isDefault = faction.isDefault,\n            canAccess = not hasWhitelist or faction.isDefault\n            }\n        end\n    end\n    return results\nend\nlocal whitelistInfo = checkFactionWhitelists({\"citizen\", \"police\", \"medic\", \"staff\"})\n</code></pre></p>"},{"location":"libraries/lia.factions/#haswhitelist_1","title":"hasWhitelist","text":"<p>Purpose</p> <p>Checks if a faction has whitelist restrictions (server-side implementation)</p> <p>When Called</p> <p>When checking if a faction has whitelist restrictions on the server</p> <p>Parameters</p> <ul> <li><code>faction</code> (string/number): The faction's unique ID or team index</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>hasWhitelist (boolean): True if the faction has whitelist restrictions, false otherwise</li> </ul> </li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if faction has whitelist\nlocal hasWhitelist = lia.faction.hasWhitelist(\"police\")\nprint(\"Police has whitelist: \" .. tostring(hasWhitelist))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check whitelist with validation\nlocal factionID = \"medic\"\nlocal hasWhitelist = lia.faction.hasWhitelist(factionID)\nif hasWhitelist then\n    print(\"Faction \" .. factionID .. \" requires whitelist\")\n    else\n        print(\"Faction \" .. factionID .. \" is open to all players\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check whitelist for multiple factions with detailed info\nlocal function checkFactionWhitelists(factionIDs)\n    local results = {}\n    for _, factionID in ipairs(factionIDs) do\n        local faction = lia.faction.get(factionID)\n        if faction then\n            local hasWhitelist = lia.faction.hasWhitelist(factionID)\n            results[factionID] = {\n            name = faction.name,\n            hasWhitelist = hasWhitelist,\n            isDefault = faction.isDefault,\n            canAccess = not hasWhitelist or faction.isDefault\n            }\n        end\n    end\n    return results\nend\nlocal whitelistInfo = checkFactionWhitelists({\"citizen\", \"police\", \"medic\", \"staff\"})\n</code></pre></p>"},{"location":"libraries/lia.flags/","title":"Flags Library","text":"<p>Character permission and access control system for the Lilia framework.</p> <p>Overview</p> <p>The flags library provides a comprehensive permission system for managing character abilities and access rights in the Lilia framework. It allows administrators to assign specific flags to characters that grant or restrict various gameplay features and tools. The library operates on both server and client sides, with the server handling flag assignment and callback execution during character spawning, while the client provides user interface elements for viewing and managing flags. Flags can have associated callbacks that execute when granted or removed, enabling dynamic behavior changes based on permission levels. The system includes built-in flags for common administrative tools like physgun, toolgun, and various spawn permissions. The library ensures proper flag validation and prevents duplicate flag assignments.</p>"},{"location":"libraries/lia.flags/#add","title":"add","text":"<p>Purpose</p> <p>Adds a new flag to the flag system with optional description and callback function</p> <p>When Called</p> <p>During module initialization or when registering new permission flags</p> <p>Parameters</p> <ul> <li><code>flag</code> (string): Single character flag identifier (e.g., \"C\", \"p\", \"t\")</li> <li><code>desc</code> (string, optional): Localized description key for the flag</li> <li><code>callback</code> (function, optional): Function to execute when flag is granted/removed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a basic flag with description\nlia.flag.add(\"A\", \"flagAdmin\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add flag with callback for weapon management\nlia.flag.add(\"w\", \"flagWeapon\", function(client, isGiven)\nif isGiven then\n    client:Give(\"weapon_pistol\")\n    else\n        client:StripWeapon(\"weapon_pistol\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add flag with complex callback and validation\nlia.flag.add(\"M\", \"flagModerator\", function(client, isGiven)\nif isGiven then\n    client:SetNWBool(\"isModerator\", true)\n    client:ChatPrint(\"Moderator privileges granted!\")\n    -- Additional setup logic here\n    else\n        client:SetNWBool(\"isModerator\", false)\n        client:ChatPrint(\"Moderator privileges revoked!\")\n        -- Cleanup logic here\n    end\nend)\n</code></pre></p>"},{"location":"libraries/lia.flags/#onspawn","title":"onSpawn","text":"<p>Purpose</p> <p>Processes and executes callbacks for all flags assigned to a character when they spawn</p> <p>When Called</p> <p>Automatically called when a character spawns on the server</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose character is spawning</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Called automatically when player spawns\n-- No direct usage needed - handled by framework\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Manual flag processing for specific cases\nlocal client = Player(1)\nif client and client:IsValid() then\n    lia.flag.onSpawn(client)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom spawn handling with flag validation\nhook.Add(\"PlayerSpawn\", \"CustomFlagHandler\", function(client)\nif client:getChar() then\n    -- Custom pre-spawn logic\n    lia.flag.onSpawn(client)\n    -- Custom post-spawn logic\nend\nend)\n</code></pre></p>"},{"location":"libraries/lia.fonts/","title":"Font Library","text":"<p>Comprehensive font management system for the Lilia framework.</p> <p>Overview</p> <p>The font library provides comprehensive functionality for managing custom fonts in the Lilia framework. It handles font registration, loading, and automatic font creation for UI elements throughout the gamemode. The library operates on both server and client sides, with the server storing font metadata and the client handling actual font creation and rendering. It includes automatic font generation for various sizes and styles, dynamic font loading based on configuration, and intelligent font name parsing for automatic font creation. The library ensures consistent typography across all UI elements and provides easy access to predefined font variants for different use cases.</p>"},{"location":"libraries/lia.fonts/#loadfonts","title":"loadFonts","text":"<p>Purpose</p> <p>Loads all registered fonts into the game's font system by iterating through stored fonts and creating them</p> <p>When Called</p> <p>Called during initialization after font registration and during font refresh operations</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client-side only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load all fonts after registration\nlia.font.loadFonts()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load fonts after a delay to ensure config is ready\ntimer.Simple(0.2, function()\nlia.font.loadFonts()\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Refresh fonts when configuration changes\nhook.Add(\"ConfigUpdated\", \"ReloadFonts\", function(key)\nif key == \"Font\" then\n    lia.font.registerFonts()\n    timer.Simple(0.1, function()\n    lia.font.loadFonts()\n    hook.Run(\"RefreshFonts\")\nend)\nend\nend)\n</code></pre></p>"},{"location":"libraries/lia.fonts/#register","title":"register","text":"<p>Purpose</p> <p>Registers a custom font with the framework's font system</p> <p>When Called</p> <p>Called when defining new fonts for UI elements or during font initialization</p> <p>Parameters</p> <ul> <li><code>fontName</code> (string): The unique identifier for the font</li> <li><code>fontData</code> (table): Font configuration table containing font properties (font, size, weight, etc.)</li> </ul> <p>Returns</p> <ul> <li>None (calls lia.error if parameters are invalid)</li> </ul> <p>Realm</p> <p>Shared (server stores metadata, client creates actual font)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic font\nlia.font.register(\"MyFont\", {\nfont = \"Roboto\",\nsize = 16\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register a font with multiple properties\nlia.font.register(\"MyCustomFont\", {\nfont = \"Arial\",\nsize = 20,\nweight = 600,\nantialias = true,\nextended = true\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register multiple fonts with different styles\nlocal fontConfig = {\n{name = \"MenuTitle\", size = 32, weight = 700},\n{name = \"MenuText\", size = 18, weight = 400},\n{name = \"MenuSmall\", size = 14, weight = 300}\n}\nfor _, config in ipairs(fontConfig) do\n    lia.font.register(config.name, {\n    font = \"Montserrat\",\n    size = config.size,\n    weight = config.weight,\n    extended = true,\n    antialias = true\n    })\nend\n</code></pre></p>"},{"location":"libraries/lia.fonts/#getavailablefonts","title":"getAvailableFonts","text":"<p>Purpose</p> <p>Retrieves a sorted list of all registered font names in the framework</p> <p>When Called</p> <p>Used for populating font selection menus or displaying available fonts to users</p> <p>Returns</p> <ul> <li> <ul> <li>list (table): An alphabetically sorted table of font name strings</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all available fonts\nlocal fonts = lia.font.getAvailableFonts()\nprint(table.concat(fonts, \", \"))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Populate a dropdown menu with available fonts\nlocal fontList = lia.font.getAvailableFonts()\nlocal dropdown = vgui.Create(\"DComboBox\")\nfor _, fontName in ipairs(fontList) do\n    dropdown:AddChoice(fontName)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a font preview panel with all available fonts\nlocal fonts = lia.font.getAvailableFonts()\nlocal panel = vgui.Create(\"DScrollPanel\")\nfor i, fontName in ipairs(fonts) do\n    local label = panel:Add(\"DLabel\")\n    label:SetText(fontName .. \" - Preview Text\")\n    label:SetFont(fontName)\n    label:Dock(TOP)\n    label:DockMargin(5, 5, 5, 0)\nend\n</code></pre></p>"},{"location":"libraries/lia.fonts/#getboldfontname","title":"getBoldFontName","text":"<p>Purpose</p> <p>Converts a font name to its bold variant by replacing Medium with Bold in the name</p> <p>When Called</p> <p>Used when registering bold font variants or dynamically generating bold fonts</p> <p>Parameters</p> <ul> <li><code>fontName</code> (string): The base font name to convert to bold</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>(string): The bold variant of the font name</li> </ul> </li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get bold version of a font\nlocal boldFont = lia.font.getBoldFontName(\"Montserrat Medium\")\n-- Returns: \"Montserrat Bold\"\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register both normal and bold variants\nlocal baseFontName = \"Montserrat Medium\"\nlia.font.register(\"NormalText\", {font = baseFontName, size = 16})\nlia.font.register(\"BoldText\", {font = lia.font.getBoldFontName(baseFontName), size = 16, weight = 700})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create matching pairs of normal and bold fonts for multiple sizes\nlocal baseFontName = \"Montserrat Medium\"\nlocal sizes = {14, 18, 24, 32}\nfor _, size in ipairs(sizes) do\n    -- Normal variant\n    lia.font.register(\"CustomFont\" .. size, {\n    font = baseFontName,\n    size = size,\n    weight = 500\n    })\n    -- Bold variant\n    lia.font.register(\"CustomFont\" .. size .. \"Bold\", {\n    font = lia.font.getBoldFontName(baseFontName),\n    size = size,\n    weight = 700\n    })\nend\n</code></pre></p>"},{"location":"libraries/lia.fonts/#registerfonts","title":"registerFonts","text":"<p>Purpose</p> <p>Registers all default fonts used by the Lilia framework including size variants, bold, and italic styles</p> <p>When Called</p> <p>Called during initialization and when the font configuration changes</p> <p>Parameters</p> <ul> <li><code>fontName</code> (string, optional): The base font name to use. If not provided, uses the configured font setting</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register default fonts\nlia.font.registerFonts()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register fonts with a custom base font\nlia.font.registerFonts(\"Roboto\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register fonts and hook into completion\nlia.font.registerFonts(\"Montserrat Medium\")\nhook.Add(\"PostLoadFonts\", \"MyFontHook\", function(mainFont, configuredFont)\nprint(\"Fonts loaded with: \" .. mainFont)\n-- Perform additional font-related setup\nfor i = 10, 50, 2 do\n    lia.font.register(\"MyCustomFont\" .. i, {\n    font = mainFont,\n    size = i,\n    extended = true,\n    antialias = true\n    })\nend\nend)\n</code></pre></p>"},{"location":"libraries/lia.fonts/#liasurfacesetfont","title":"lia.surface.SetFont","text":"<p>Purpose</p> <p>Registers all default fonts used by the Lilia framework including size variants, bold, and italic styles</p> <p>When Called</p> <p>Called during initialization and when the font configuration changes</p> <p>Parameters</p> <ul> <li><code>fontName</code> (string, optional): The base font name to use. If not provided, uses the configured font setting</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register default fonts\nlia.font.registerFonts()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register fonts with a custom base font\nlia.font.registerFonts(\"Roboto\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register fonts and hook into completion\nlia.font.registerFonts(\"Montserrat Medium\")\nhook.Add(\"PostLoadFonts\", \"MyFontHook\", function(mainFont, configuredFont)\nprint(\"Fonts loaded with: \" .. mainFont)\n-- Perform additional font-related setup\nfor i = 10, 50, 2 do\n    lia.font.register(\"MyCustomFont\" .. i, {\n    font = mainFont,\n    size = i,\n    extended = true,\n    antialias = true\n    })\nend\nend)\n</code></pre></p>"},{"location":"libraries/lia.inventory/","title":"Inventory Library","text":"<p>Comprehensive inventory system management with multiple storage types for the Lilia framework.</p> <p>Overview</p> <p>The inventory library provides comprehensive functionality for managing inventory systems in the Lilia framework. It handles inventory type registration, instance creation, storage management, and database persistence. The library operates on both server and client sides, with the server managing inventory data persistence, loading, and storage registration, while the client handles inventory panel display and user interaction. It supports multiple inventory types, storage containers, vehicle trunks, and character-based inventory management. The library ensures proper data validation, caching, and cleanup for optimal performance.</p>"},{"location":"libraries/lia.inventory/#newtype","title":"newType","text":"<p>Purpose</p> <p>Registers a new inventory type with the system</p> <p>When Called</p> <p>During module initialization or when defining custom inventory types</p> <p>Parameters</p> <ul> <li><code>typeID</code> (string): Unique identifier for the inventory type</li> <li><code>invTypeStruct</code> (table): Structure containing inventory type configuration</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic inventory type\nlia.inventory.newType(\"player\", {\nclassName = \"PlayerInventory\",\ntypeID = \"player\",\nconfig = {w = 10, h = 5}\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register inventory type with custom methods\nlocal playerInvType = {\nclassName = \"PlayerInventory\",\ntypeID = \"player\",\nconfig = {w = 10, h = 5},\nadd = function(self, item) -- custom add method\n-- custom logic here\nend\n}\nlia.inventory.newType(\"player\", playerInvType)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register complex inventory type with validation\nlocal complexInvType = {\nclassName = \"ComplexInventory\",\ntypeID = \"complex\",\nconfig = {\nw = 20, h = 10,\nmaxWeight = 100,\nrestrictions = {\"weapons\", \"drugs\"}\n},\nadd = function(self, item)\nif self:canAddItem(item) then\n    return self:doAddItem(item)\nend\nreturn false\nend,\nremove = function(self, item)\nreturn self:doRemoveItem(item)\nend\n}\nlia.inventory.newType(\"complex\", complexInvType)\n</code></pre></p>"},{"location":"libraries/lia.inventory/#new","title":"new","text":"<p>Purpose</p> <p>Creates a new inventory instance of the specified type</p> <p>When Called</p> <p>When creating inventory instances for players, storage containers, or vehicles</p> <p>Parameters</p> <ul> <li><code>typeID</code> (string): The inventory type identifier to create an instance of</li> </ul> <p>Returns</p> <ul> <li>Inventory instance (table) with items and config properties</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a basic player inventory\nlocal playerInv = lia.inventory.new(\"player\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create inventory and configure it\nlocal storageInv = lia.inventory.new(\"storage\")\nstorageInv.config.w = 15\nstorageInv.config.h = 8\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create inventory with custom configuration\nlocal customInv = lia.inventory.new(\"player\")\ncustomInv.config.w = 12\ncustomInv.config.h = 6\ncustomInv.config.maxWeight = 50\ncustomInv.items = {}\n</code></pre></p>"},{"location":"libraries/lia.inventory/#loadbyid","title":"loadByID","text":"<p>Purpose</p> <p>Loads an inventory instance by its ID from storage or cache</p> <p>When Called</p> <p>When accessing an existing inventory that may be cached or needs to be loaded from database</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The inventory ID to load</li> <li><code>noCache</code> (boolean, optional): If true, bypasses cache and forces reload from storage</li> </ul> <p>Returns</p> <ul> <li>Deferred promise that resolves to inventory instance</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load inventory by ID\nlia.inventory.loadByID(123):next(function(inv)\nprint(\"Loaded inventory:\", inv.id)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load inventory with error handling\nlia.inventory.loadByID(123):next(function(inv)\nif inv then\n    print(\"Successfully loaded inventory:\", inv.id)\nend\nend):catch(function(err)\nprint(\"Failed to load inventory:\", err)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load inventory with cache bypass and validation\nlocal function loadInventorySafely(id)\n    return lia.inventory.loadByID(id, true):next(function(inv)\n    if not inv then\n        return deferred.reject(\"Inventory not found\")\n    end\n    -- Validate inventory data\n    if not inv.data or not inv.items then\n        return deferred.reject(\"Invalid inventory data\")\n    end\n    return inv\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#loadfromdefaultstorage","title":"loadFromDefaultStorage","text":"<p>Purpose</p> <p>Loads an inventory from the default database storage system</p> <p>When Called</p> <p>When loadByID cannot find a custom loader and needs to use default storage</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The inventory ID to load from database</li> <li><code>noCache</code> (boolean, optional): If true, bypasses cache and forces reload from database</li> </ul> <p>Returns</p> <ul> <li>Deferred promise that resolves to inventory instance</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load inventory from default storage\nlia.inventory.loadFromDefaultStorage(123):next(function(inv)\nprint(\"Loaded from database:\", inv.id)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load with cache bypass\nlia.inventory.loadFromDefaultStorage(123, true):next(function(inv)\nif inv then\n    print(\"Fresh load from database:\", inv.id)\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load with comprehensive error handling and validation\nlocal function loadFromDatabase(id)\n    return lia.inventory.loadFromDefaultStorage(id, true):next(function(inv)\n    if not inv then\n        lia.error(\"Failed to load inventory \" .. id .. \" from database\")\n        return deferred.reject(\"Inventory not found in database\")\n    end\n    -- Validate inventory structure\n    if not inv.data or not inv.items then\n        lia.error(\"Invalid inventory structure for ID: \" .. id)\n        return deferred.reject(\"Corrupted inventory data\")\n    end\n    -- Log successful load\n    lia.log(\"Successfully loaded inventory \" .. id .. \" from database\")\n    return inv\nend):catch(function(err)\nlia.error(\"Database load error for inventory \" .. id .. \": \" .. tostring(err))\nreturn deferred.reject(err)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#instance","title":"instance","text":"<p>Purpose</p> <p>Creates a new inventory instance and initializes it in storage</p> <p>When Called</p> <p>When creating new inventories that need to be persisted to database</p> <p>Parameters</p> <ul> <li><code>typeID</code> (string): The inventory type identifier</li> <li><code>initialData</code> (table, optional): Initial data to store with the inventory</li> </ul> <p>Returns</p> <ul> <li>Deferred promise that resolves to the created inventory instance</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a new inventory instance\nlia.inventory.instance(\"player\"):next(function(inv)\nprint(\"Created inventory:\", inv.id)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create inventory with initial data\nlocal initialData = {owner = \"player123\", maxWeight = 50}\nlia.inventory.instance(\"storage\", initialData):next(function(inv)\nprint(\"Created storage inventory:\", inv.id)\nprint(\"Owner:\", inv.data.owner)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create inventory with validation and error handling\nlocal function createInventorySafely(typeID, data)\n    if not lia.inventory.types[typeID] then\n        return deferred.reject(\"Invalid inventory type: \" .. typeID)\n    end\n    return lia.inventory.instance(typeID, data):next(function(inv)\n    if not inv or not inv.id then\n        return deferred.reject(\"Failed to create inventory instance\")\n    end\n    -- Validate created inventory\n    if not inv.data or not inv.items then\n        return deferred.reject(\"Invalid inventory structure\")\n    end\n    lia.log(\"Successfully created inventory \" .. inv.id .. \" of type \" .. typeID)\n    return inv\nend):catch(function(err)\nlia.error(\"Failed to create inventory: \" .. tostring(err))\nreturn deferred.reject(err)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#loadallfromcharid","title":"loadAllFromCharID","text":"<p>Purpose</p> <p>Loads all inventories associated with a specific character ID</p> <p>When Called</p> <p>When a character logs in or when accessing all character inventories</p> <p>Parameters</p> <ul> <li><code>charID</code> (number): The character ID to load inventories for</li> </ul> <p>Returns</p> <ul> <li>Deferred promise that resolves to array of inventory instances</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load all inventories for a character\nlia.inventory.loadAllFromCharID(123):next(function(inventories)\nprint(\"Loaded\", #inventories, \"inventories\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load inventories with error handling\nlia.inventory.loadAllFromCharID(123):next(function(inventories)\nif inventories and #inventories &gt; 0 then\n    print(\"Successfully loaded\", #inventories, \"inventories\")\n    for _, inv in ipairs(inventories) do\n        print(\"Inventory ID:\", inv.id, \"Type:\", inv.data.invType)\n    end\nend\nend):catch(function(err)\nprint(\"Failed to load character inventories:\", err)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load inventories with validation and processing\nlocal function loadCharacterInventories(charID)\n    return lia.inventory.loadAllFromCharID(charID):next(function(inventories)\n    if not inventories then\n        return deferred.reject(\"No inventories found for character \" .. charID)\n    end\n    local validInventories = {}\n    for _, inv in ipairs(inventories) do\n        if inv and inv.id and inv.data then\n            -- Validate inventory structure\n            if inv.items and inv.config then\n                table.insert(validInventories, inv)\n                else\n                    lia.warning(\"Invalid inventory structure for ID: \" .. inv.id)\n                end\n            end\n        end\n        lia.log(\"Loaded \" .. #validInventories .. \" valid inventories for character \" .. charID)\n        return validInventories\n    end):catch(function(err)\n    lia.error(\"Failed to load inventories for character \" .. charID .. \": \" .. tostring(err))\n    return deferred.reject(err)\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#deletebyid","title":"deleteByID","text":"<p>Purpose</p> <p>Permanently deletes an inventory and all its associated data from the database</p> <p>When Called</p> <p>When removing inventories that are no longer needed or during cleanup operations</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The inventory ID to delete</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Delete an inventory by ID\nlia.inventory.deleteByID(123)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Delete inventory with validation\nlocal function deleteInventory(id)\n    if not isnumber(id) or id &lt;= 0 then\n        lia.error(\"Invalid inventory ID for deletion: \" .. tostring(id))\n        return false\n    end\n    lia.inventory.deleteByID(id)\n    lia.log(\"Deleted inventory ID: \" .. id)\n    return true\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Delete inventory with comprehensive cleanup\nlocal function deleteInventorySafely(id)\n    if not isnumber(id) or id &lt;= 0 then\n        return deferred.reject(\"Invalid inventory ID: \" .. tostring(id))\n    end\n    -- Check if inventory exists before deletion\n    return lia.inventory.loadByID(id):next(function(inv)\n    if not inv then\n        lia.warning(\"Attempted to delete non-existent inventory: \" .. id)\n        return false\n    end\n    -- Clean up any items in the inventory\n    if inv.items then\n        for _, item in pairs(inv.items) do\n            if item and item.destroy then\n                item:destroy()\n            end\n        end\n    end\n    -- Delete from database\n    lia.inventory.deleteByID(id)\n    lia.log(\"Successfully deleted inventory \" .. id .. \" and all associated data\")\n    return true\nend):catch(function(err)\nlia.error(\"Failed to delete inventory \" .. id .. \": \" .. tostring(err))\nreturn false\nend)\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#cleanupforcharacter","title":"cleanUpForCharacter","text":"<p>Purpose</p> <p>Destroys all inventory instances associated with a character</p> <p>When Called</p> <p>When a character is deleted or during character cleanup operations</p> <p>Parameters</p> <ul> <li><code>character</code> (table): The character object containing inventory references</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Clean up character inventories\nlia.inventory.cleanUpForCharacter(character)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up with validation\nlocal function cleanupCharacterInventories(character)\n    if not character or not character.getInv then\n        lia.error(\"Invalid character object for cleanup\")\n        return false\n    end\n    lia.inventory.cleanUpForCharacter(character)\n    lia.log(\"Cleaned up inventories for character: \" .. character:getName())\n    return true\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Clean up with comprehensive logging and validation\nlocal function cleanupCharacterInventoriesSafely(character)\n    if not character or not character.getInv then\n        lia.error(\"Invalid character object for inventory cleanup\")\n        return false\n    end\n    local inventories = character:getInv(true)\n    if not inventories or table.IsEmpty(inventories) then\n        lia.log(\"No inventories to clean up for character: \" .. character:getName())\n        return true\n    end\n    local count = 0\n    for _, inv in pairs(inventories) do\n        if inv and inv.destroy then\n            inv:destroy()\n            count = count + 1\n        end\n    end\n    lia.log(\"Cleaned up \" .. count .. \" inventories for character: \" .. character:getName())\n    return true\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#checkoverflow","title":"checkOverflow","text":"<p>Purpose</p> <p>Checks for and handles inventory overflow when inventory size changes</p> <p>When Called</p> <p>When an inventory's dimensions are reduced and items may no longer fit</p> <p>Parameters</p> <ul> <li><code>inv</code> (table): The inventory instance to check for overflow</li> <li><code>character</code> (table): The character object to store overflow items with</li> <li><code>oldW</code> (number): The previous width of the inventory</li> <li><code>oldH</code> (number): The previous height of the inventory</li> </ul> <p>Returns</p> <ul> <li>Boolean indicating whether overflow items were found and stored</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check for overflow after inventory resize\nlocal hadOverflow = lia.inventory.checkOverflow(inventory, character, 10, 8)\nif hadOverflow then\n    lia.notify.add(\"Some items were moved to overflow storage\", NOTIFY_GENERIC)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Comprehensive overflow handling with validation\nlocal function handleInventoryResize(inventory, character, oldWidth, oldHeight)\n    if not inventory or not character then\n        lia.error(\"Invalid parameters for inventory overflow check\")\n        return false\n    end\n    local overflowDetected = lia.inventory.checkOverflow(inventory, character, oldWidth, oldHeight)\n    if overflowDetected then\n        local overflowData = character:getData(\"overflowItems\")\n        lia.log(\"Overflow detected: \" .. #overflowData.items .. \" items stored for character \" .. character:getName())\n        -- Notify player about overflow\n        lia.notify.add(\"Inventory resized - some items moved to overflow storage\", NOTIFY_WARNING)\n        return true\n    end\n    return false\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#registerstorage","title":"registerStorage","text":"<p>Purpose</p> <p>Registers a storage container model with inventory configuration</p> <p>When Called</p> <p>During module initialization to register storage containers like crates, lockers, etc.</p> <p>Parameters</p> <ul> <li><code>model</code> (string): The model path of the storage container</li> <li><code>data</code> (table): Configuration data containing name, invType, and invData</li> </ul> <p>Returns</p> <ul> <li>The registered storage data table</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic storage container\nlia.inventory.registerStorage(\"models/props_c17/lockers001a.mdl\", {\nname = \"Locker\",\ninvType = \"storage\",\ninvData = {w = 5, h = 3}\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register storage with custom configuration\nlocal storageData = {\nname = \"Medical Cabinet\",\ninvType = \"medical\",\ninvData = {\nw = 8,\nh = 4,\nmaxWeight = 30,\nrestrictions = {\"medical\", \"drugs\"}\n}\n}\nlia.inventory.registerStorage(\"models/props_c17/furnituremedicinecabinet001a.mdl\", storageData)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register multiple storage types with validation\nlocal function registerStorageContainers()\n    local storages = {\n    {\n    model = \"models/props_c17/lockers001a.mdl\",\n    data = {\n    name = \"Security Locker\",\n    invType = \"security\",\n    invData = {w = 6, h = 4, maxWeight = 50, restricted = true}\n    }\n    },\n    {\n    model = \"models/props_c17/furnituremedicinecabinet001a.mdl\",\n    data = {\n    name = \"Medical Cabinet\",\n    invType = \"medical\",\n    invData = {w = 8, h = 4, maxWeight = 30, medicalOnly = true}\n    }\n    }\n    }\n    for _, storage in ipairs(storages) do\n        if storage.model and storage.data then\n            lia.inventory.registerStorage(storage.model, storage.data)\n            lia.log(\"Registered storage: \" .. storage.data.name)\n        end\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#getstorage","title":"getStorage","text":"<p>Purpose</p> <p>Retrieves storage configuration data for a specific model</p> <p>When Called</p> <p>When checking if a model has registered storage or accessing storage configuration</p> <p>Parameters</p> <ul> <li><code>model</code> (string): The model path to look up storage data for</li> </ul> <p>Returns</p> <ul> <li>Storage data table if found, nil otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get storage data for a model\nlocal storageData = lia.inventory.getStorage(\"models/props_c17/lockers001a.mdl\")\nif storageData then\n    print(\"Storage name:\", storageData.name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get storage with validation\nlocal function getStorageInfo(model)\n    if not model or not isstring(model) then\n        return nil\n    end\n    local storageData = lia.inventory.getStorage(model)\n    if storageData then\n        return {\n        name = storageData.name,\n        type = storageData.invType,\n        size = storageData.invData.w * storageData.invData.h\n        }\n    end\n    return nil\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get storage with comprehensive validation and processing\nlocal function getStorageConfiguration(model)\n    if not model or not isstring(model) then\n        lia.warning(\"Invalid model provided to getStorageConfiguration: \" .. tostring(model))\n        return nil\n    end\n    local storageData = lia.inventory.getStorage(model)\n    if not storageData then\n        lia.log(\"No storage configuration found for model: \" .. model)\n        return nil\n    end\n    -- Validate storage data structure\n    if not storageData.name or not storageData.invType or not storageData.invData then\n        lia.error(\"Invalid storage data structure for model: \" .. model)\n        return nil\n    end\n    -- Process and return validated data\n    return {\n    name = storageData.name,\n    type = storageData.invType,\n    width = storageData.invData.w or 5,\n    height = storageData.invData.h or 3,\n    maxWeight = storageData.invData.maxWeight,\n    restrictions = storageData.invData.restrictions,\n    isTrunk = storageData.isTrunk or false\n    }\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#registertrunk","title":"registerTrunk","text":"<p>Purpose</p> <p>Registers a vehicle class with trunk inventory configuration</p> <p>When Called</p> <p>During module initialization to register vehicle trunks</p> <p>Parameters</p> <ul> <li><code>vehicleClass</code> (string): The vehicle class name</li> <li><code>data</code> (table): Configuration data containing name, invType, and invData</li> </ul> <p>Returns</p> <ul> <li>The registered trunk data table</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic vehicle trunk\nlia.inventory.registerTrunk(\"prop_vehicle_jeep\", {\nname = \"Jeep Trunk\",\ninvType = \"trunk\",\ninvData = {w = 8, h = 3}\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register trunk with custom configuration\nlocal trunkData = {\nname = \"Police Car Trunk\",\ninvType = \"police_trunk\",\ninvData = {\nw = 10,\nh = 4,\nmaxWeight = 100,\nrestricted = true,\nallowedItems = {\"weapons\", \"evidence\"}\n}\n}\nlia.inventory.registerTrunk(\"prop_vehicle_police\", trunkData)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register multiple vehicle trunks with validation\nlocal function registerVehicleTrunks()\n    local vehicles = {\n    {\n    class = \"prop_vehicle_jeep\",\n    data = {\n    name = \"Civilian Vehicle Trunk\",\n    invType = \"civilian_trunk\",\n    invData = {w = 8, h = 3, maxWeight = 50}\n    }\n    },\n    {\n    class = \"prop_vehicle_police\",\n    data = {\n    name = \"Police Vehicle Trunk\",\n    invType = \"police_trunk\",\n    invData = {w = 10, h = 4, maxWeight = 100, restricted = true}\n    }\n    },\n    {\n    class = \"prop_vehicle_ambulance\",\n    data = {\n    name = \"Ambulance Storage\",\n    invType = \"medical_trunk\",\n    invData = {w = 12, h = 5, maxWeight = 75, medicalOnly = true}\n    }\n    }\n    }\n    for _, vehicle in ipairs(vehicles) do\n        if vehicle.class and vehicle.data then\n            lia.inventory.registerTrunk(vehicle.class, vehicle.data)\n            lia.log(\"Registered trunk for vehicle: \" .. vehicle.data.name)\n        end\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#gettrunk","title":"getTrunk","text":"<p>Purpose</p> <p>Retrieves trunk configuration data for a specific vehicle class</p> <p>When Called</p> <p>When checking if a vehicle has a trunk or accessing trunk configuration</p> <p>Parameters</p> <ul> <li><code>vehicleClass</code> (string): The vehicle class name to look up trunk data for</li> </ul> <p>Returns</p> <ul> <li>Trunk data table if found, nil otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get trunk data for a vehicle\nlocal trunkData = lia.inventory.getTrunk(\"prop_vehicle_jeep\")\nif trunkData then\n    print(\"Trunk name:\", trunkData.name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get trunk with validation\nlocal function getVehicleTrunk(vehicleClass)\n    if not vehicleClass or not isstring(vehicleClass) then\n        return nil\n    end\n    local trunkData = lia.inventory.getTrunk(vehicleClass)\n    if trunkData then\n        return {\n        name = trunkData.name,\n        type = trunkData.invType,\n        size = trunkData.invData.w * trunkData.invData.h,\n        maxWeight = trunkData.invData.maxWeight\n        }\n    end\n    return nil\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get trunk with comprehensive validation and processing\nlocal function getVehicleTrunkConfiguration(vehicleClass)\n    if not vehicleClass or not isstring(vehicleClass) then\n        lia.warning(\"Invalid vehicle class provided: \" .. tostring(vehicleClass))\n        return nil\n    end\n    local trunkData = lia.inventory.getTrunk(vehicleClass)\n    if not trunkData then\n        lia.log(\"No trunk configuration found for vehicle: \" .. vehicleClass)\n        return nil\n    end\n    -- Validate trunk data structure\n    if not trunkData.name or not trunkData.invType or not trunkData.invData then\n        lia.error(\"Invalid trunk data structure for vehicle: \" .. vehicleClass)\n        return nil\n    end\n    -- Process and return validated data\n    return {\n    name = trunkData.name,\n    type = trunkData.invType,\n    width = trunkData.invData.w or 10,\n    height = trunkData.invData.h or 2,\n    maxWeight = trunkData.invData.maxWeight,\n    restrictions = trunkData.invData.restrictions,\n    isTrunk = trunkData.isTrunk or true,\n    trunkKey = trunkData.trunkKey\n    }\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#getalltrunks","title":"getAllTrunks","text":"<p>Purpose</p> <p>Retrieves all registered storage configurations with optional trunk filtering</p> <p>When Called</p> <p>When needing to iterate through all available storage containers</p> <p>Parameters</p> <ul> <li><code>includeTrunks</code> (boolean, optional): If false, excludes vehicle trunks from results</li> </ul> <p>Returns</p> <ul> <li>Table containing all storage configurations indexed by model/class</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all trunks\nlocal trunks = lia.inventory.getAllTrunks()\nfor vehicleClass, trunkData in pairs(trunks) do\n    print(\"Vehicle:\", vehicleClass, \"Trunk:\", trunkData.name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get trunks with processing\nlocal function getAllTrunkInfo()\n    local trunks = lia.inventory.getAllTrunks()\n    local trunkList = {}\n    for vehicleClass, trunkData in pairs(trunks) do\n        table.insert(trunkList, {\n        vehicleClass = vehicleClass,\n        name = trunkData.name,\n        size = trunkData.invData.w * trunkData.invData.h\n        })\n    end\n    return trunkList\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get trunks with comprehensive validation and categorization\nlocal function getCategorizedTrunks()\n    local trunks = lia.inventory.getAllTrunks()\n    local categorized = {\n    civilian = {},\n    emergency = {},\n    military = {},\n    other = {}\n    }\n    for vehicleClass, trunkData in pairs(trunks) do\n        if not trunkData or not trunkData.name or not trunkData.invData then\n            lia.warning(\"Invalid trunk data for vehicle: \" .. vehicleClass)\n            goto continue\n        end\n        local trunkInfo = {\n            vehicleClass = vehicleClass,\n            name = trunkData.name,\n            type = trunkData.invType,\n            width = trunkData.invData.w,\n            height = trunkData.invData.h,\n            maxWeight = trunkData.invData.maxWeight,\n            restricted = trunkData.invData.restricted or false\n        }\n        -- Categorize based on vehicle class\n        local lowerClass = vehicleClass:lower()\n        if string.find(lowerClass, \"police\") or string.find(lowerClass, \"ambulance\") then\n            table.insert(categorized.emergency, trunkInfo)\n        elseif string.find(lowerClass, \"military\") or string.find(lowerClass, \"tank\") then\n            table.insert(categorized.military, trunkInfo)\n        elseif string.find(lowerClass, \"civilian\") or string.find(lowerClass, \"jeep\") then\n            table.insert(categorized.civilian, trunkInfo)\n        else\n            table.insert(categorized.other, trunkInfo)\n        end\n        ::continue::\n    end\n    return categorized\nend\nfunction lia.inventory.getAllTrunks()\n    local trunks = {}\n    for key, data in pairs(lia.inventory.storage) do\n        if data.isTrunk then trunks[key] = data end\n    end\n    return trunks\nend\nLow Complexity:\n\nMedium Complexity:\n\nHigh Complexity:\n\n]]\n</code></pre></p>"},{"location":"libraries/lia.inventory/#getallstorage","title":"getAllStorage","text":"<p>Purpose</p> <p>Retrieves all registered storage configurations with optional trunk filtering</p> <p>When Called</p> <p>When needing to iterate through all available storage containers</p> <p>Parameters</p> <ul> <li><code>includeTrunks</code> (boolean, optional): If false, excludes vehicle trunks from results</li> </ul> <p>Returns</p> <ul> <li>Table containing all storage configurations indexed by model/class</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all trunks\nlocal trunks = lia.inventory.getAllTrunks()\nfor vehicleClass, trunkData in pairs(trunks) do\n    print(\"Vehicle:\", vehicleClass, \"Trunk:\", trunkData.name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get trunks with processing\nlocal function getAllTrunkInfo()\n    local trunks = lia.inventory.getAllTrunks()\n    local trunkList = {}\n    for vehicleClass, trunkData in pairs(trunks) do\n        table.insert(trunkList, {\n        vehicleClass = vehicleClass,\n        name = trunkData.name,\n        size = trunkData.invData.w * trunkData.invData.h\n        })\n    end\n    return trunkList\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get trunks with comprehensive validation and categorization\nlocal function getCategorizedTrunks()\n    local trunks = lia.inventory.getAllTrunks()\n    local categorized = {\n    civilian = {},\n    emergency = {},\n    military = {},\n    other = {}\n    }\n    for vehicleClass, trunkData in pairs(trunks) do\n        if not trunkData or not trunkData.name or not trunkData.invData then\n            lia.warning(\"Invalid trunk data for vehicle: \" .. vehicleClass)\n            goto continue\n        end\n        local trunkInfo = {\n            vehicleClass = vehicleClass,\n            name = trunkData.name,\n            type = trunkData.invType,\n            width = trunkData.invData.w,\n            height = trunkData.invData.h,\n            maxWeight = trunkData.invData.maxWeight,\n            restricted = trunkData.invData.restricted or false\n        }\n        -- Categorize based on vehicle class\n        local lowerClass = vehicleClass:lower()\n        if string.find(lowerClass, \"police\") or string.find(lowerClass, \"ambulance\") then\n            table.insert(categorized.emergency, trunkInfo)\n        elseif string.find(lowerClass, \"military\") or string.find(lowerClass, \"tank\") then\n            table.insert(categorized.military, trunkInfo)\n        elseif string.find(lowerClass, \"civilian\") or string.find(lowerClass, \"jeep\") then\n            table.insert(categorized.civilian, trunkInfo)\n        else\n            table.insert(categorized.other, trunkInfo)\n        end\n        ::continue::\n    end\n    return categorized\nend\nfunction lia.inventory.getAllTrunks()\n    local trunks = {}\n    for key, data in pairs(lia.inventory.storage) do\n        if data.isTrunk then trunks[key] = data end\n    end\n    return trunks\nend\nLow Complexity:\n\nMedium Complexity:\n\nHigh Complexity:\n\n]]\n</code></pre></p>"},{"location":"libraries/lia.inventory/#show","title":"show","text":"<p>Purpose</p> <p>Displays an inventory panel to the client</p> <p>When Called</p> <p>When a player opens an inventory (player inventory, storage container, etc.)</p> <p>Parameters</p> <ul> <li><code>inventory</code> (table): The inventory instance to display</li> <li><code>parent</code> (panel, optional): Parent panel to attach the inventory panel to</li> </ul> <p>Returns</p> <ul> <li>The created inventory panel</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Show inventory panel\nlocal panel = lia.inventory.show(inventory)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Show inventory with parent panel\nlocal function showInventoryInFrame(inventory)\n    local frame = vgui.Create(\"DFrame\")\n    frame:SetSize(400, 300)\n    frame:Center()\n    frame:MakePopup()\n    local invPanel = lia.inventory.show(inventory, frame)\n    return invPanel\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Show inventory with comprehensive validation and error handling\nlocal function showInventorySafely(inventory, parent)\n    if not inventory or not inventory.id then\n        lia.notify(\"Invalid inventory provided\", \"error\")\n        return nil\n    end\n    -- Check if inventory is already open\n    local globalName = \"inv\" .. inventory.id\n    if IsValid(lia.gui[globalName]) then\n        lia.gui[globalName]:Remove()\n    end\n    -- Validate parent panel\n    if parent and not IsValid(parent) then\n        lia.warning(\"Invalid parent panel provided to showInventorySafely\")\n        parent = nil\n    end\n    -- Create inventory panel\n    local panel = lia.inventory.show(inventory, parent)\n    if not panel or not IsValid(panel) then\n        lia.error(\"Failed to create inventory panel for inventory \" .. inventory.id)\n        return nil\n    end\n    -- Add custom styling and behavior\n    panel:SetPos(50, 50)\n    panel:SetSize(600, 400)\n    -- Add close button\n    local closeBtn = panel:Add(\"DButton\")\n    closeBtn:SetText(\"Close\")\n    closeBtn:SetPos(panel:GetWide() - 80, 10)\n    closeBtn:SetSize(70, 25)\n    closeBtn.DoClick = function()\n    panel:Remove()\nend\nlia.log(\"Successfully displayed inventory panel for inventory \" .. inventory.id)\nreturn panel\nend\n</code></pre></p>"},{"location":"libraries/lia.inventory/#liapanelonremove","title":"lia.panel:OnRemove","text":"<p>Purpose</p> <p>Displays an inventory panel to the client</p> <p>When Called</p> <p>When a player opens an inventory (player inventory, storage container, etc.)</p> <p>Parameters</p> <ul> <li><code>inventory</code> (table): The inventory instance to display</li> <li><code>parent</code> (panel, optional): Parent panel to attach the inventory panel to</li> </ul> <p>Returns</p> <ul> <li>The created inventory panel</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Show inventory panel\nlocal panel = lia.inventory.show(inventory)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Show inventory with parent panel\nlocal function showInventoryInFrame(inventory)\n    local frame = vgui.Create(\"DFrame\")\n    frame:SetSize(400, 300)\n    frame:Center()\n    frame:MakePopup()\n    local invPanel = lia.inventory.show(inventory, frame)\n    return invPanel\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Show inventory with comprehensive validation and error handling\nlocal function showInventorySafely(inventory, parent)\n    if not inventory or not inventory.id then\n        lia.notify(\"Invalid inventory provided\", \"error\")\n        return nil\n    end\n    -- Check if inventory is already open\n    local globalName = \"inv\" .. inventory.id\n    if IsValid(lia.gui[globalName]) then\n        lia.gui[globalName]:Remove()\n    end\n    -- Validate parent panel\n    if parent and not IsValid(parent) then\n        lia.warning(\"Invalid parent panel provided to showInventorySafely\")\n        parent = nil\n    end\n    -- Create inventory panel\n    local panel = lia.inventory.show(inventory, parent)\n    if not panel or not IsValid(panel) then\n        lia.error(\"Failed to create inventory panel for inventory \" .. inventory.id)\n        return nil\n    end\n    -- Add custom styling and behavior\n    panel:SetPos(50, 50)\n    panel:SetSize(600, 400)\n    -- Add close button\n    local closeBtn = panel:Add(\"DButton\")\n    closeBtn:SetText(\"Close\")\n    closeBtn:SetPos(panel:GetWide() - 80, 10)\n    closeBtn:SetSize(70, 25)\n    closeBtn.DoClick = function()\n    panel:Remove()\nend\nlia.log(\"Successfully displayed inventory panel for inventory \" .. inventory.id)\nreturn panel\nend\n</code></pre></p>"},{"location":"libraries/lia.item/","title":"Item Library","text":"<p>Comprehensive item registration, instantiation, and management system for the Lilia framework.</p> <p>Overview</p> <p>The item library provides comprehensive functionality for managing items in the Lilia framework. It handles item registration, instantiation, inventory management, and item operations such as dropping, taking, rotating, and transferring items between players. The library operates on both server and client sides, with server-side functions handling database operations, item spawning, and data persistence, while client-side functions manage item interactions and UI operations. It includes automatic weapon and ammunition generation from Garry's Mod weapon lists, inventory type registration, and item entity management. The library ensures proper item lifecycle management from creation to deletion, with support for custom item functions, hooks, and data persistence.</p>"},{"location":"libraries/lia.item/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves an item definition by its unique identifier from either base items or registered items</p> <p>When Called</p> <p>When you need to get an item definition for registration, instantiation, or reference</p> <p>Parameters</p> <ul> <li><code>identifier</code> (string): The unique identifier of the item to retrieve</li> </ul> <p>Returns</p> <ul> <li>table - The item definition table, or nil if not found</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a basic item definition\nlocal itemDef = lia.item.get(\"base_weapons\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get item definition with validation\nlocal itemDef = lia.item.get(\"weapon_pistol\")\nif itemDef then\n    print(\"Found item:\", itemDef.name)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get item definition and check inheritance\nlocal itemDef = lia.item.get(\"custom_rifle\")\nif itemDef and itemDef.base == \"base_weapons\" then\n    local baseDef = lia.item.get(itemDef.base)\n    print(\"Item inherits from:\", baseDef.name)\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#getitembyid","title":"getItemByID","text":"<p>Purpose</p> <p>Retrieves an item instance by its ID along with location information</p> <p>When Called</p> <p>When you need to find an item instance and know where it's located (inventory or world)</p> <p>Parameters</p> <ul> <li><code>itemID</code> (number): The unique ID of the item instance</li> </ul> <p>Returns</p> <ul> <li>table - Contains 'item' (the item instance) and 'location' (string: \"inventory\", \"world\", or \"unknown\"), or nil, error message</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get item with location\nlocal result = lia.item.getItemByID(123)\nif result then\n    print(\"Item location:\", result.location)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get item and handle different locations\nlocal result = lia.item.getItemByID(456)\nif result then\n    if result.location == \"inventory\" then\n        print(\"Item is in inventory\")\n    elseif result.location == \"world\" then\n        print(\"Item is in world\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get item and perform location-specific actions\nlocal result = lia.item.getItemByID(789)\nif result then\n    local item = result.item\n    if result.location == \"inventory\" then\n        local inv = lia.item.getInv(item.invID)\n        if inv then\n            print(\"Item in inventory:\", inv:getName())\n        end\n    elseif result.location == \"world\" and IsValid(item.entity) then\n        print(\"Item entity position:\", item.entity:GetPos())\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#getinstanceditembyid","title":"getInstancedItemByID","text":"<p>Purpose</p> <p>Retrieves an item instance by its ID without location information</p> <p>When Called</p> <p>When you only need the item instance and don't care about its location</p> <p>Parameters</p> <ul> <li><code>itemID</code> (number): The unique ID of the item instance</li> </ul> <p>Returns</p> <ul> <li>table - The item instance, or nil, error message</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get item instance\nlocal item = lia.item.getInstancedItemByID(123)\nif item then\n    print(\"Item name:\", item.name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get item and access properties\nlocal item = lia.item.getInstancedItemByID(456)\nif item then\n    print(\"Item ID:\", item.id)\n    print(\"Item uniqueID:\", item.uniqueID)\n    print(\"Item quantity:\", item.quantity)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get item and perform operations\nlocal item = lia.item.getInstancedItemByID(789)\nif item then\n    if item.player and IsValid(item.player) then\n        local char = item.player:getChar()\n        if char then\n            print(\"Item owner:\", char:getName())\n        end\n    end\n    if item:getData(\"customProperty\") then\n        print(\"Custom property:\", item:getData(\"customProperty\"))\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#getitemdatabyid","title":"getItemDataByID","text":"<p>Purpose</p> <p>Retrieves the data table of an item instance by its ID</p> <p>When Called</p> <p>When you need to access the custom data stored in an item instance</p> <p>Parameters</p> <ul> <li><code>itemID</code> (number): The unique ID of the item instance</li> </ul> <p>Returns</p> <ul> <li>table - The item's data table, or nil, error message</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get item data\nlocal data = lia.item.getItemDataByID(123)\nif data then\n    print(\"Item has data\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get item data and access specific fields\nlocal data = lia.item.getItemDataByID(456)\nif data then\n    if data.x and data.y then\n        print(\"Item position:\", data.x, data.y)\n    end\n    if data.rotated then\n        print(\"Item is rotated\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get item data and perform complex operations\nlocal data = lia.item.getItemDataByID(789)\nif data then\n    local customData = data.customData or {}\n    for key, value in pairs(customData) do\n        if type(value) == \"table\" then\n            print(\"Complex data for\", key, \":\", util.TableToJSON(value))\n            else\n                print(\"Simple data for\", key, \":\", value)\n            end\n        end\n        if data.lastUsed then\n            local timeDiff = os.time() - data.lastUsed\n            print(\"Item last used\", timeDiff, \"seconds ago\")\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.item/#load","title":"load","text":"<p>Purpose</p> <p>Loads an item definition from a file path and registers it</p> <p>When Called</p> <p>During item loading process, typically called by lia.item.loadFromDir</p> <p>Parameters</p> <ul> <li><code>path</code> (string): The file path to the item definition, baseID (string, optional) - Base item to inherit from, isBaseItem (boolean, optional) - Whether this is a base item</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a basic item file\nlia.item.load(\"lilia/gamemode/items/weapon_pistol.lua\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load item with base inheritance\nlia.item.load(\"lilia/gamemode/items/custom_rifle.lua\", \"base_weapons\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load base item and derived items\nlia.item.load(\"lilia/gamemode/items/base/weapons.lua\", nil, true)\nlia.item.load(\"lilia/gamemode/items/weapons/assault_rifle.lua\", \"base_weapons\")\n</code></pre></p>"},{"location":"libraries/lia.item/#isitem","title":"isItem","text":"<p>Purpose</p> <p>Checks if an object is a valid item instance</p> <p>When Called</p> <p>When you need to validate that an object is an item before performing operations</p> <p>Parameters</p> <ul> <li><code>object</code> (any): The object to check</li> </ul> <p>Returns</p> <ul> <li>boolean - True if the object is an item, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if object is an item\nif lia.item.isItem(someObject) then\n    print(\"This is an item!\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate item before operations\nlocal function processItem(item)\n    if not lia.item.isItem(item) then\n        print(\"Invalid item provided\")\n        return false\n    end\n    print(\"Processing item:\", item.name)\n    return true\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check multiple objects and filter items\nlocal function filterItems(objects)\n    local items = {}\n    for _, obj in ipairs(objects) do\n        if lia.item.isItem(obj) then\n            table.insert(items, obj)\n        end\n    end\n    return items\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#getinv","title":"getInv","text":"<p>Purpose</p> <p>Retrieves an inventory instance by its ID</p> <p>When Called</p> <p>When you need to access an inventory instance for item operations</p> <p>Parameters</p> <ul> <li><code>invID</code> (number): The unique ID of the inventory</li> </ul> <p>Returns</p> <ul> <li>table - The inventory instance, or nil if not found</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get inventory by ID\nlocal inv = lia.item.getInv(123)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get inventory and check if valid\nlocal inv = lia.item.getInv(456)\nif inv then\n    print(\"Inventory size:\", inv:getWidth(), \"x\", inv:getHeight())\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get inventory and perform operations\nlocal inv = lia.item.getInv(789)\nif inv then\n    local items = inv:getItems()\n    for _, item in pairs(items) do\n        print(\"Item in inventory:\", item.name)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#register","title":"register","text":"<p>Purpose</p> <p>Registers a new item definition with the item system</p> <p>When Called</p> <p>During item loading or when creating custom items programmatically</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): Unique identifier for the item, baseID (string, optional) - Base item to inherit from, isBaseItem (boolean, optional) - Whether this is a base item, path (string, optional) - File path for loading, luaGenerated (boolean, optional) - Whether this is generated from Lua code</li> </ul> <p>Returns</p> <ul> <li>table - The registered item definition</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic item\nlia.item.register(\"my_item\", \"base_stackable\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register item with custom properties\nlocal ITEM = lia.item.register(\"custom_weapon\", \"base_weapons\")\nITEM.name = \"Custom Weapon\"\nITEM.desc = \"A custom weapon\"\nITEM.model = \"models/weapons/w_pistol.mdl\"\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register complex item with inheritance\nlocal ITEM = lia.item.register(\"advanced_rifle\", \"base_weapons\", false, nil, true)\nITEM.name = \"Advanced Rifle\"\nITEM.desc = \"A high-tech assault rifle\"\nITEM.model = \"models/weapons/w_rif_ak47.mdl\"\nITEM.width = 3\nITEM.height = 1\nITEM.category = \"weapons\"\nITEM.functions = table.Copy(ITEM.functions)\nITEM.functions.customAction = {\nname = \"Custom Action\",\nonRun = function(item) print(\"Custom action executed\") end\n}\n</code></pre></p>"},{"location":"libraries/lia.item/#loadfromdir","title":"loadFromDir","text":"<p>Purpose</p> <p>Loads all item definitions from a directory structure</p> <p>When Called</p> <p>During gamemode initialization to load all items from the items directory</p> <p>Parameters</p> <ul> <li><code>directory</code> (string): The directory path to load items from</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load items from default directory\nlia.item.loadFromDir(\"lilia/gamemode/items\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load items from custom directory\nlia.item.loadFromDir(\"addons/myaddon/items\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load items from multiple directories\nlocal itemDirs = {\n\"lilia/gamemode/items\",\n\"addons/customitems/items\",\n\"gamemodes/mygamemode/items\"\n}\nfor _, dir in ipairs(itemDirs) do\n    if file.Exists(dir, \"LUA\") then\n        lia.item.loadFromDir(dir)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#new","title":"new","text":"<p>Purpose</p> <p>Creates a new item instance from an item definition</p> <p>When Called</p> <p>When you need to create a specific instance of an item with a unique ID</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): The unique identifier of the item definition, id (number) - The unique ID for this item instance</li> </ul> <p>Returns</p> <ul> <li>table - The new item instance, or error if item definition not found</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a new item instance\nlocal item = lia.item.new(\"weapon_pistol\", 123)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create item with validation\nlocal item = lia.item.new(\"custom_rifle\", 456)\nif item then\n    print(\"Created item:\", item.name)\n    print(\"Item ID:\", item.id)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create item and set up initial data\nlocal item = lia.item.new(\"stackable_item\", 789)\nif item then\n    item.data.customProperty = \"initial_value\"\n    item.data.createdBy = \"system\"\n    item.data.createdAt = os.time()\n    print(\"Item created with custom data\")\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#registerinv","title":"registerInv","text":"<p>Purpose</p> <p>Registers a new inventory type with specified dimensions</p> <p>When Called</p> <p>During initialization to register custom inventory types</p> <p>Parameters</p> <ul> <li><code>invType</code> (string): The inventory type identifier, w (number) - Width of the inventory, h (number) - Height of the inventory</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic inventory type\nlia.item.registerInv(\"player\", 5, 4)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register inventory with custom properties\nlia.item.registerInv(\"storage_box\", 8, 6)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register multiple inventory types\nlocal inventoryTypes = {\n{type = \"player\", w = 5, h = 4},\n{type = \"storage\", w = 10, h = 8},\n{type = \"vehicle\", w = 6, h = 3}\n}\nfor _, inv in ipairs(inventoryTypes) do\n    lia.item.registerInv(inv.type, inv.w, inv.h)\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#liainventorygetwidth","title":"lia.inventory:getWidth","text":"<p>Purpose</p> <p>Registers a new inventory type with specified dimensions</p> <p>When Called</p> <p>During initialization to register custom inventory types</p> <p>Parameters</p> <ul> <li><code>invType</code> (string): The inventory type identifier, w (number) - Width of the inventory, h (number) - Height of the inventory</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic inventory type\nlia.item.registerInv(\"player\", 5, 4)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register inventory with custom properties\nlia.item.registerInv(\"storage_box\", 8, 6)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register multiple inventory types\nlocal inventoryTypes = {\n{type = \"player\", w = 5, h = 4},\n{type = \"storage\", w = 10, h = 8},\n{type = \"vehicle\", w = 6, h = 3}\n}\nfor _, inv in ipairs(inventoryTypes) do\n    lia.item.registerInv(inv.type, inv.w, inv.h)\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#liainventorygetheight","title":"lia.inventory:getHeight","text":"<p>Purpose</p> <p>Registers a new inventory type with specified dimensions</p> <p>When Called</p> <p>During initialization to register custom inventory types</p> <p>Parameters</p> <ul> <li><code>invType</code> (string): The inventory type identifier, w (number) - Width of the inventory, h (number) - Height of the inventory</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic inventory type\nlia.item.registerInv(\"player\", 5, 4)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register inventory with custom properties\nlia.item.registerInv(\"storage_box\", 8, 6)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register multiple inventory types\nlocal inventoryTypes = {\n{type = \"player\", w = 5, h = 4},\n{type = \"storage\", w = 10, h = 8},\n{type = \"vehicle\", w = 6, h = 3}\n}\nfor _, inv in ipairs(inventoryTypes) do\n    lia.item.registerInv(inv.type, inv.w, inv.h)\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#newinv","title":"newInv","text":"<p>Purpose</p> <p>Creates a new inventory instance for a specific owner</p> <p>When Called</p> <p>When you need to create a new inventory instance for a player or entity</p> <p>Parameters</p> <ul> <li><code>owner</code> (number): The character ID of the owner, invType (string) - The inventory type, callback (function, optional) - Function to call when inventory is created</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create inventory for player\nlia.item.newInv(player:getChar():getID(), \"player\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create inventory with callback\nlia.item.newInv(charID, \"storage\", function(inv)\nprint(\"Inventory created:\", inv.id)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create inventory and populate with items\nlia.item.newInv(charID, \"player\", function(inv)\n-- Add starting items\nlia.item.instance(inv.id, \"weapon_pistol\", {}, 1, 1)\nlia.item.instance(inv.id, \"ammo_pistol\", {}, 2, 1)\nprint(\"Player inventory created and populated\")\nend)\n</code></pre></p>"},{"location":"libraries/lia.item/#createinv","title":"createInv","text":"<p>Purpose</p> <p>Creates a new inventory instance with specified dimensions and ID</p> <p>When Called</p> <p>When you need to create a custom inventory with specific dimensions</p> <p>Parameters</p> <ul> <li><code>w</code> (number): Width of the inventory, h (number) - Height of the inventory, id (number) - The ID for the inventory</li> </ul> <p>Returns</p> <ul> <li>table - The created inventory instance</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create basic inventory\nlocal inv = lia.item.createInv(5, 4, 123)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create inventory and validate\nlocal inv = lia.item.createInv(8, 6, 456)\nif inv then\n    print(\"Created inventory:\", inv.id)\n    print(\"Size:\", inv:getWidth(), \"x\", inv:getHeight())\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create inventory and set up data\nlocal inv = lia.item.createInv(10, 8, 789)\nif inv then\n    inv:setData(\"name\", \"Custom Storage\")\n    inv:setData(\"owner\", \"system\")\n    inv:setData(\"createdAt\", os.time())\n    print(\"Custom inventory created with metadata\")\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#addweaponoverride","title":"addWeaponOverride","text":"<p>Purpose</p> <p>Adds override data for a specific weapon class during automatic weapon generation</p> <p>When Called</p> <p>Before calling lia.item.generateWeapons to customize weapon properties</p> <p>Parameters</p> <ul> <li><code>className</code> (string): The weapon class name, data (table) - Override data containing name, desc, model, etc.</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Override weapon name\nlia.item.addWeaponOverride(\"weapon_pistol\", {\nname = \"Custom Pistol\"\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Override multiple weapon properties\nlia.item.addWeaponOverride(\"weapon_ak47\", {\nname = \"AK-47 Assault Rifle\",\ndesc = \"A powerful assault rifle\",\nmodel = \"models/weapons/w_rif_ak47.mdl\",\ncategory = \"assault_rifles\"\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Override multiple weapons with custom properties\nlocal weaponOverrides = {\n[\"weapon_pistol\"] = {\nname = \"Combat Pistol\",\ndesc = \"A reliable sidearm\",\nmodel = \"models/weapons/w_pistol.mdl\",\nwidth = 1,\nheight = 1,\nweaponCategory = \"sidearm\"\n},\n[\"weapon_ak47\"] = {\nname = \"AK-47\",\ndesc = \"Soviet assault rifle\",\nmodel = \"models/weapons/w_rif_ak47.mdl\",\nwidth = 3,\nheight = 1,\nweaponCategory = \"primary\"\n}\n}\nfor className, data in pairs(weaponOverrides) do\n    lia.item.addWeaponOverride(className, data)\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#addweapontoblacklist","title":"addWeaponToBlacklist","text":"<p>Purpose</p> <p>Adds a weapon class to the blacklist to prevent it from being automatically generated</p> <p>When Called</p> <p>Before calling lia.item.generateWeapons to exclude specific weapons</p> <p>Parameters</p> <ul> <li><code>className</code> (string): The weapon class name to blacklist</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Blacklist a single weapon\nlia.item.addWeaponToBlacklist(\"weapon_crowbar\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Blacklist multiple weapons\nlia.item.addWeaponToBlacklist(\"weapon_crowbar\")\nlia.item.addWeaponToBlacklist(\"weapon_physcannon\")\nlia.item.addWeaponToBlacklist(\"weapon_physgun\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Blacklist weapons based on conditions\nlocal weaponsToBlacklist = {\n\"weapon_crowbar\",\n\"weapon_physcannon\",\n\"weapon_physgun\",\n\"weapon_tool\",\n\"weapon_camera\"\n}\nfor _, weaponClass in ipairs(weaponsToBlacklist) do\n    lia.item.addWeaponToBlacklist(weaponClass)\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#generateweapons","title":"generateWeapons","text":"<p>Purpose</p> <p>Automatically generates item definitions for all weapons in Garry's Mod</p> <p>When Called</p> <p>During gamemode initialization or when weapons need to be regenerated</p> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Generate all weapons\nlia.item.generateWeapons()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Generate weapons with custom overrides\nlia.item.addWeaponOverride(\"weapon_pistol\", {\nname = \"Custom Pistol\",\ndesc = \"A modified pistol\"\n})\nlia.item.generateWeapons()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Generate weapons with blacklist and overrides\nlocal blacklistedWeapons = {\n\"weapon_crowbar\",\n\"weapon_physcannon\",\n\"weapon_physgun\"\n}\nfor _, weapon in ipairs(blacklistedWeapons) do\n    lia.item.addWeaponToBlacklist(weapon)\nend\nlocal weaponOverrides = {\n[\"weapon_pistol\"] = {name = \"Combat Pistol\"},\n[\"weapon_ak47\"] = {name = \"AK-47\", width = 3}\n}\nfor className, data in pairs(weaponOverrides) do\n    lia.item.addWeaponOverride(className, data)\nend\nlia.item.generateWeapons()\n</code></pre></p>"},{"location":"libraries/lia.item/#generateammo","title":"generateAmmo","text":"<p>Purpose</p> <p>Automatically generates item definitions for ammunition entities (ARC9 and ARCCW)</p> <p>When Called</p> <p>During gamemode initialization or when ammunition items need to be regenerated</p> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Generate all ammunition items\nlia.item.generateAmmo()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Generate ammunition with custom overrides\nlia.item.addWeaponOverride(\"arc9_ammo_9mm\", {\nname = \"9mm Ammunition\",\ndesc = \"Standard pistol ammunition\"\n})\nlia.item.generateAmmo()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Generate ammunition with filtering and overrides\nlocal ammoOverrides = {\n[\"arc9_ammo_9mm\"] = {\nname = \"9mm Rounds\",\ndesc = \"Standard pistol ammunition\",\nwidth = 2,\nheight = 1\n},\n[\"arccw_ammo_rifle\"] = {\nname = \"Rifle Ammunition\",\ndesc = \"High-powered rifle rounds\",\nwidth = 3,\nheight = 1\n}\n}\nfor className, data in pairs(ammoOverrides) do\n    lia.item.addWeaponOverride(className, data)\nend\nlia.item.generateAmmo()\n</code></pre></p>"},{"location":"libraries/lia.item/#setitemdatabyid","title":"setItemDataByID","text":"<p>Purpose</p> <p>Sets data for an item instance by its ID on the server</p> <p>When Called</p> <p>When you need to modify item data from server-side code</p> <p>Parameters</p> <ul> <li><code>itemID</code> (number): The unique ID of the item instance, key (string) - The data key to set, value (any) - The value to set, receivers (table, optional) - Players to sync to, noSave (boolean, optional) - Whether to skip database save, noCheckEntity (boolean, optional) - Whether to skip entity validation</li> </ul> <p>Returns</p> <ul> <li>boolean, string - Success status and error message if failed</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set item data\nlia.item.setItemDataByID(123, \"customProperty\", \"value\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set item data with validation\nlocal success, error = lia.item.setItemDataByID(456, \"lastUsed\", os.time())\nif success then\n    print(\"Item data updated successfully\")\n    else\n        print(\"Failed to update item data:\", error)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Set item data with custom sync and save options\nlocal function updateItemData(itemID, data, players)\n    local success, error = lia.item.setItemDataByID(\n    itemID,\n    \"customData\",\n    data,\n    players,\n    false, -- Save to database\n    true   -- Skip entity check\n    )\n    return success, error\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#instance","title":"instance","text":"<p>Purpose</p> <p>Creates a new item instance in a specific inventory with database persistence</p> <p>When Called</p> <p>When you need to create a new item instance that will be saved to the database</p> <p>Parameters</p> <ul> <li><code>index</code> (string/number): Inventory ID or character ID, uniqueID (string) - Item definition ID, itemData (table, optional) - Initial item data, x (number, optional) - X position in inventory, y (number, optional) - Y position in inventory, callback (function, optional) - Function to call when item is created</li> </ul> <p>Returns</p> <ul> <li>Promise - Resolves with the created item instance</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create item in inventory\nlia.item.instance(invID, \"weapon_pistol\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create item with position and callback\nlia.item.instance(invID, \"weapon_pistol\", {}, 1, 1, function(item)\nprint(\"Created item:\", item.name)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create item with complex data and error handling\nlocal promise = lia.item.instance(charID, \"custom_item\", {\ncustomProperty = \"value\",\ncreatedBy = \"admin\",\ncreatedAt = os.time()\n}, 2, 3, function(item)\nprint(\"Item created with ID:\", item.id)\nend)\npromise:next(function(item)\nprint(\"Successfully created item\")\nend):catch(function(error)\nprint(\"Failed to create item:\", error)\nend)\n</code></pre></p>"},{"location":"libraries/lia.item/#deletebyid","title":"deleteByID","text":"<p>Purpose</p> <p>Deletes an item instance by its ID from both memory and database</p> <p>When Called</p> <p>When you need to permanently remove an item from the game</p> <p>Parameters</p> <ul> <li><code>id</code> (number): The unique ID of the item instance to delete</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Delete an item\nlia.item.deleteByID(123)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Delete item with validation\nlocal item = lia.item.getInstancedItemByID(456)\nif item then\n    print(\"Deleting item:\", item.name)\n    lia.item.deleteByID(456)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Delete multiple items with error handling\nlocal function deleteItems(itemIDs)\n    for _, id in ipairs(itemIDs) do\n        local item = lia.item.getInstancedItemByID(id)\n        if item then\n            print(\"Deleting item:\", item.name, \"ID:\", id)\n            lia.item.deleteByID(id)\n            else\n                print(\"Item not found:\", id)\n            end\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.item/#loaditembyid","title":"loadItemByID","text":"<p>Purpose</p> <p>Loads item instances from the database by their IDs</p> <p>When Called</p> <p>During server startup or when specific items need to be restored from database</p> <p>Parameters</p> <ul> <li><code>itemIndex</code> (number/table): Single item ID or table of item IDs to load</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a single item\nlia.item.loadItemByID(123)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load multiple items\nlia.item.loadItemByID({123, 456, 789})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load items with validation and error handling\nlocal function loadPlayerItems(player)\n    local char = player:getChar()\n    if char then\n        local inv = char:getInv()\n        if inv then\n            -- Load all items for this character\n            lia.db.query(\"SELECT itemID FROM lia_items WHERE invID = \" .. inv.id, function(results)\n            if results then\n                local itemIDs = {}\n                for _, row in ipairs(results) do\n                    table.insert(itemIDs, tonumber(row.itemID))\n                end\n                lia.item.loadItemByID(itemIDs)\n            end\n        end)\n    end\nend\nend\n</code></pre></p>"},{"location":"libraries/lia.item/#spawn","title":"spawn","text":"<p>Purpose</p> <p>Spawns an item entity in the world at a specific position</p> <p>When Called</p> <p>When you need to create an item that exists as a world entity</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): The item definition ID, position (Vector) - World position to spawn at, callback (function, optional) - Function to call when item is spawned, angles (Angle, optional) - Rotation angles for the entity, data (table, optional) - Initial item data</li> </ul> <p>Returns</p> <ul> <li>Promise - Resolves with the spawned item instance</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Spawn item at position\nlia.item.spawn(\"weapon_pistol\", Vector(0, 0, 0))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Spawn item with angles and callback\nlia.item.spawn(\"weapon_pistol\", Vector(100, 200, 50), function(item)\nprint(\"Spawned item:\", item.name)\nend, Angle(0, 90, 0))\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Spawn item with complex data and error handling\nlocal promise = lia.item.spawn(\"custom_item\", Vector(0, 0, 0), function(item)\nif item then\n    item:setData(\"spawnedBy\", \"admin\")\n    item:setData(\"spawnTime\", os.time())\n    print(\"Item spawned successfully\")\nend\nend, Angle(0, 0, 0), {\ncustomProperty = \"value\",\ndurability = 100\n})\npromise:next(function(item)\nprint(\"Item spawned at:\", item.entity:GetPos())\nend):catch(function(error)\nprint(\"Failed to spawn item:\", error)\nend)\n</code></pre></p>"},{"location":"libraries/lia.item/#restoreinv","title":"restoreInv","text":"<p>Purpose</p> <p>Restores an inventory from the database with specified dimensions</p> <p>When Called</p> <p>During server startup or when restoring inventories from database</p> <p>Parameters</p> <ul> <li><code>invID</code> (number): The inventory ID to restore, w (number) - Width of the inventory, h (number) - Height of the inventory, callback (function, optional) - Function to call when inventory is restored</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Restore inventory\nlia.item.restoreInv(123, 5, 4)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Restore inventory with callback\nlia.item.restoreInv(456, 8, 6, function(inv)\nprint(\"Restored inventory:\", inv.id)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Restore multiple inventories with error handling\nlocal function restorePlayerInventories(player)\n    local char = player:getChar()\n    if char then\n        local inventories = {\n        {id = char:getInv().id, w = 5, h = 4},\n        {id = char:getStorage().id, w = 10, h = 8}\n        }\n        for _, invData in ipairs(inventories) do\n            lia.item.restoreInv(invData.id, invData.w, invData.h, function(inv)\n            if inv then\n                print(\"Restored inventory:\", inv.id)\n                else\n                    print(\"Failed to restore inventory:\", invData.id)\n                end\n            end)\n        end\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.keybind/","title":"Keybind Library","text":"<p>Keyboard binding registration, storage, and execution system for the Lilia framework.</p> <p>Overview</p> <p>The keybind library provides comprehensive functionality for managing keyboard bindings in the Lilia framework. It handles registration, storage, and execution of custom keybinds that can be triggered by players. The library supports both client-side and server-side keybind execution, with automatic networking for server-only keybinds. It includes persistent storage of keybind configurations, user interface for keybind management, and validation to prevent key conflicts. The library operates on both client and server sides, with the client handling input detection and UI, while the server processes server-only keybind actions. It ensures proper key mapping, callback execution, and provides a complete keybind management system for the gamemode.</p>"},{"location":"libraries/lia.keybind/#add","title":"add","text":"<p>Purpose</p> <p>Registers a new keybind with the keybind system, allowing players to bind custom actions to keyboard keys</p> <p>When Called</p> <p>During initialization of modules or when registering custom keybinds for gameplay features</p> <p>Parameters</p> <ul> <li><code>k</code> (string|number): Either the action name (string) or key code (number) depending on parameter format</li> <li><code>d</code> (table|string): Either configuration table with keyBind, desc, onPress, etc. or action name (string)</li> <li><code>desc</code> (string, optional): Description of the keybind action (used when d is action name)</li> <li><code>cb</code> (table, optional): Callback table with onPress, onRelease, shouldRun, serverOnly functions (used when d is action name)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a basic keybind with table configuration\nlia.keybind.add(\"openInventory\", {\nkeyBind = KEY_I,\ndesc = \"openInventoryDesc\",\nonPress = function()\nlocal f1Menu = vgui.Create(\"liaMenu\")\nf1Menu:setActiveTab(L(\"inv\"))\nend\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add keybind with conditional execution and server-only flag\nlia.keybind.add(\"adminMode\", {\nkeyBind = KEY_F1,\ndesc = \"adminModeDesc\",\nserverOnly = true,\nonPress = function(client)\nif not IsValid(client) then return end\n    client:ChatPrint(L(\"adminModeToggle\"))\n    -- Admin mode logic here\nend,\nshouldRun = function(client)\nreturn client:IsAdmin()\nend\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add keybind with multiple callbacks and complex validation\nlia.keybind.add(\"convertEntity\", {\nkeyBind = KEY_E,\ndesc = \"convertEntityDesc\",\nonPress = function(client)\nif not IsValid(client) or not client:getChar() then return end\n    local trace = client:GetEyeTrace()\n    local targetEntity = trace.Entity\n    -- Complex entity conversion logic\nend,\nonRelease = function(client)\n-- Handle key release if needed\nend,\nshouldRun = function(client)\nreturn client:getChar() ~= nil and client:GetEyeTrace().Entity:IsValid()\nend,\nserverOnly = true\n})\n</code></pre></p>"},{"location":"libraries/lia.keybind/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves the current key code bound to a specific keybind action</p> <p>When Called</p> <p>When checking what key is currently bound to an action, typically in UI or validation code</p> <p>Parameters</p> <ul> <li><code>a</code> (string): The action name to get the key for</li> <li><code>df</code> (number, optional): Default key code to return if no key is bound</li> </ul> <p>Returns</p> <ul> <li>number - The key code bound to the action, or the default value if none is set</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get the key bound to open inventory\nlocal inventoryKey = lia.keybind.get(\"openInventory\")\nprint(\"Inventory key:\", inventoryKey)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get key with fallback default\nlocal adminKey = lia.keybind.get(\"adminMode\", KEY_F1)\nif adminKey == KEY_NONE then\n    print(\"Admin mode not bound to any key\")\n    else\n        print(\"Admin mode bound to:\", input.GetKeyName(adminKey))\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check multiple keybinds and handle different states\nlocal keybinds = {\"openInventory\", \"adminMode\", \"quickTakeItem\"}\nlocal boundKeys = {}\nfor _, action in ipairs(keybinds) do\n    local key = lia.keybind.get(action, KEY_NONE)\n    if key ~= KEY_NONE then\n        boundKeys[action] = {\n        key = key,\n        name = input.GetKeyName(key) or \"Unknown\"\n        }\n    end\nend\n-- Process bound keys...\n</code></pre></p>"},{"location":"libraries/lia.keybind/#save","title":"save","text":"<p>Purpose</p> <p>Saves all current keybind configurations to a JSON file for persistent storage</p> <p>When Called</p> <p>When keybind settings are changed by the player or during shutdown to preserve settings</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Save keybinds after player changes settings\nlia.keybind.save()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save keybinds with validation\nlocal function saveKeybindsSafely()\n    local success = pcall(function()\n    lia.keybind.save()\nend)\nif success then\n    print(\"Keybinds saved successfully\")\n    else\n        print(\"Failed to save keybinds\")\n    end\nend\nsaveKeybindsSafely()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Save keybinds with backup and error handling\nlocal function saveKeybindsWithBackup()\n    -- Create backup of current settings\n    local backupPath = \"lilia/keybinds_backup.json\"\n    local currentPath = \"lilia/keybinds.json\"\n    if file.Exists(currentPath, \"DATA\") then\n        local currentData = file.Read(currentPath, \"DATA\")\n        file.Write(backupPath, currentData)\n    end\n    -- Save new settings\n    local success = pcall(function()\n    lia.keybind.save()\nend)\nif not success then\n    -- Restore from backup if save failed\n    if file.Exists(backupPath, \"DATA\") then\n        local backupData = file.Read(backupPath, \"DATA\")\n        file.Write(currentPath, backupData)\n    end\nend\nend\nsaveKeybindsWithBackup()\n</code></pre></p>"},{"location":"libraries/lia.keybind/#load","title":"load","text":"<p>Purpose</p> <p>Loads keybind configurations from a JSON file and applies them to the keybind system</p> <p>When Called</p> <p>During client initialization to restore previously saved keybind settings</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load keybinds during initialization\nlia.keybind.load()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load keybinds with validation and fallback\nlocal function loadKeybindsSafely()\n    local success = pcall(function()\n    lia.keybind.load()\nend)\nif success then\n    print(\"Keybinds loaded successfully\")\n    hook.Run(\"KeybindsLoaded\")\n    else\n        print(\"Failed to load keybinds, using defaults\")\n        -- Reset to default keybinds\n        for action, data in pairs(lia.keybind.stored) do\n            if istable(data) and data.default then\n                data.value = data.default\n            end\n        end\n    end\nend\nloadKeybindsSafely()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load keybinds with migration and validation\nlocal function loadKeybindsWithMigration()\n    local keybindPath = \"lilia/keybinds.json\"\n    local oldPath = \"lilia/old_keybinds.json\"\n    -- Check for old format and migrate if needed\n    if file.Exists(oldPath, \"DATA\") and not file.Exists(keybindPath, \"DATA\") then\n        local oldData = file.Read(oldPath, \"DATA\")\n        if oldData then\n            file.Write(keybindPath, oldData)\n            file.Delete(oldPath)\n        end\n    end\n    -- Load with error handling\n    local success = pcall(function()\n    lia.keybind.load()\nend)\nif not success then\n    -- Create default keybind file\n    local defaultKeybinds = {}\n    for action, data in pairs(lia.keybind.stored) do\n        if istable(data) and data.default then\n            defaultKeybinds[action] = data.default\n        end\n    end\n    local json = util.TableToJSON(defaultKeybinds, true)\n    if json then\n        file.Write(keybindPath, json)\n        lia.keybind.load()\n    end\nend\n-- Validate loaded keybinds\nfor action, data in pairs(lia.keybind.stored) do\n    if istable(data) and data.value then\n        if not KeybindKeys[data.value] and data.value ~= KEY_NONE then\n            data.value = data.default or KEY_NONE\n        end\n    end\nend\nend\nloadKeybindsWithMigration()\n</code></pre></p>"},{"location":"libraries/lia.languages/","title":"Languages Library","text":"<p>Internationalization (i18n) and localization system for the Lilia framework.</p> <p>Overview</p> <p>The languages library provides comprehensive internationalization (i18n) functionality for the Lilia framework. It handles loading, storing, and retrieving localized strings from language files, supporting multiple languages with fallback mechanisms. The library automatically loads language files from directories, processes them into a unified storage system, and provides string formatting with parameter substitution. It includes functions for adding custom language tables, retrieving available languages, and getting localized strings with proper error handling. The library operates on both server and client sides, ensuring consistent localization across the entire gamemode. It supports dynamic language switching and provides the global L() function for easy access to localized strings throughout the codebase.</p>"},{"location":"libraries/lia.languages/#loadfromdir","title":"loadFromDir","text":"<p>Purpose</p> <p>Loads language files from a specified directory and processes them into the language storage system</p> <p>When Called</p> <p>During gamemode initialization or when manually loading language files</p> <p>Parameters</p> <ul> <li><code>directory</code> (string): The directory path containing language files</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server/Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load languages from default directory\nlia.lang.loadFromDir(\"lilia/gamemode/languages\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load languages from custom module directory\nlocal moduleDir = \"lilia/gamemode/modules/mymodule/languages\"\nif file.Exists(moduleDir, \"LUA\") then\n    lia.lang.loadFromDir(moduleDir)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load languages from multiple directories with validation\nlocal languageDirs = {\n\"lilia/gamemode/languages\",\n\"lilia/gamemode/modules/custom/languages\",\n\"addons/mycustomaddon/languages\"\n}\nfor _, dir in ipairs(languageDirs) do\n    if file.Exists(dir, \"LUA\") then\n        lia.lang.loadFromDir(dir)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.languages/#addtable","title":"addTable","text":"<p>Purpose</p> <p>Adds a custom language table to the language storage system</p> <p>When Called</p> <p>When manually adding language strings or when modules need to register their own translations</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The language name/key, tbl (table) - Table containing key-value pairs of translations</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server/Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic language strings\nlia.lang.addTable(\"english\", {\nhello = \"Hello\",\ngoodbye = \"Goodbye\"\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add module-specific language strings\nlocal moduleLang = {\nmoduleTitle = \"My Module\",\nmoduleDescription = \"This is a custom module\",\nmoduleError = \"An error occurred: %s\"\n}\nlia.lang.addTable(\"english\", moduleLang)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add multiple language tables with validation\nlocal languages = {\nenglish = { title = \"Title\", desc = \"Description\" },\nspanish = { title = \"T\u00edtulo\", desc = \"Descripci\u00f3n\" },\nfrench = { title = \"Titre\", desc = \"Description\" }\n}\nfor lang, strings in pairs(languages) do\n    if type(strings) == \"table\" then\n        lia.lang.addTable(lang, strings)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.languages/#getlanguages","title":"getLanguages","text":"<p>Purpose</p> <p>Retrieves a sorted list of all available language names</p> <p>When Called</p> <p>When building language selection menus or when checking available languages</p> <p>Returns</p> <ul> <li>table - Sorted array of language names with proper capitalization</li> </ul> <p>Realm</p> <p>Server/Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get list of available languages\nlocal languages = lia.lang.getLanguages()\nprint(\"Available languages:\", table.concat(languages, \", \"))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create language selection menu\nlocal languages = lia.lang.getLanguages()\nlocal menu = vgui.Create(\"DFrame\")\nlocal combo = vgui.Create(\"DComboBox\", menu)\nfor _, lang in ipairs(languages) do\n    combo:AddChoice(lang)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Validate language selection with fallback\nlocal function setLanguage(langName)\n    local languages = lia.lang.getLanguages()\n    local found = false\n    for _, lang in ipairs(languages) do\n        if lang:lower() == langName:lower() then\n            found = true\n            break\n        end\n    end\n    if found then\n        lia.config.set(\"Language\", langName:lower())\n        else\n            lia.notice.add(\"Invalid language selected, using English\", NOTIFY_ERROR)\n            lia.config.set(\"Language\", \"english\")\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.languages/#getlocalizedstring","title":"getLocalizedString","text":"<p>Purpose</p> <p>Retrieves a localized string with parameter substitution and formatting</p> <p>When Called</p> <p>When displaying text to users or when any localized string is needed</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The language key to look up, ... (variadic) - Parameters for string formatting</li> </ul> <p>Returns</p> <ul> <li>string - The localized and formatted string, or the key if not found</li> </ul> <p>Realm</p> <p>Server/Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get basic localized string\nlocal message = lia.lang.getLocalizedString(\"hello\")\nprint(message) -- Outputs: \"Hello\" (in current language)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get localized string with parameters\nlocal playerName = \"John\"\nlocal welcomeMsg = lia.lang.getLocalizedString(\"welcomePlayer\", playerName)\nprint(welcomeMsg) -- Outputs: \"Welcome, John!\" (if template is \"Welcome, %s!\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex localized string with multiple parameters and error handling\nlocal function displayItemInfo(itemName, quantity, price)\n    local lang = lia.config and lia.config.get(\"Language\", \"english\") or \"english\"\n    local langTable = lia.lang.stored and lia.lang.stored[lang:lower()]\n    local template = langTable and langTable[\"itemInfo\"] or \"itemInfo\"\n    if template then\n        local message = lia.lang.getLocalizedString(\"itemInfo\", itemName, \"No description available\")\n        lia.notice.add(message, NOTIFY_GENERIC)\n        else\n            lia.notice.add(\"Item: \" .. itemName .. \" x\" .. quantity .. \" - $\" .. price, NOTIFY_GENERIC)\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.loader/","title":"Loader Library","text":"<p>Core initialization and module loading system for the Lilia framework.</p> <p>Overview</p> <p>The loader library is the core initialization system for the Lilia framework, responsible for managing the loading sequence of all framework components, modules, and dependencies. It handles file inclusion with proper realm detection (client, server, shared), manages module loading order, provides compatibility layer support for third-party addons, and includes update checking functionality. The library ensures that all framework components are loaded in the correct order and context, handles hot-reloading during development, and provides comprehensive logging and error handling throughout the initialization process. It also manages entity registration for weapons, tools, effects, and custom entities, and provides Discord webhook integration for logging and notifications.</p>"},{"location":"libraries/lia.loader/#include","title":"include","text":"<p>Purpose</p> <p>Includes a Lua file with automatic realm detection and proper client/server handling</p> <p>When Called</p> <p>During framework initialization, module loading, or when manually including files</p> <p>Parameters</p> <ul> <li><code>path</code> (string): The file path to include (e.g., \"lilia/gamemode/core/libraries/util.lua\")</li> <li><code>realm</code> (string, optional): The realm to load the file in (\"client\", \"server\", \"shared\")</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Include a shared library file\nlia.loader.include(\"lilia/gamemode/core/libraries/util.lua\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Include a file with explicit realm specification\nlia.loader.include(\"lilia/gamemode/core/libraries/logger.lua\", \"server\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Include files based on conditions with error handling\nlocal filesToLoad = {\n\"lilia/gamemode/core/libraries/net.lua\",\n\"lilia/gamemode/core/libraries/commands.lua\"\n}\nfor _, filePath in ipairs(filesToLoad) do\n    if file.Exists(filePath, \"LUA\") then\n        lia.loader.include(filePath)\n        else\n            lia.warning(\"File not found: \" .. filePath)\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.loader/#includedir","title":"includeDir","text":"<p>Purpose</p> <p>Recursively includes all Lua files in a directory with optional deep traversal</p> <p>When Called</p> <p>During framework initialization to load entire directories of files</p> <p>Parameters</p> <ul> <li><code>dir</code> (string): The directory path to scan for Lua files</li> <li><code>raw</code> (boolean, optional): If true, uses the exact path; if false, resolves relative to gamemode/schema</li> <li><code>deep</code> (boolean, optional): If true, recursively searches subdirectories</li> <li><code>realm</code> (string, optional): The realm to load files in (\"client\", \"server\", \"shared\")</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Include all files in a directory\nlia.loader.includeDir(\"lilia/gamemode/core/libraries\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Include files with specific realm and deep search\nlia.loader.includeDir(\"lilia/gamemode/modules\", false, true, \"shared\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Include multiple directories with different settings\nlocal dirsToLoad = {\n{path = \"lilia/gamemode/core/libraries\", raw = false, deep = false, realm = \"shared\"},\n{path = \"lilia/gamemode/modules\", raw = false, deep = true, realm = \"shared\"},\n{path = \"custom/scripts\", raw = true, deep = true, realm = \"client\"}\n}\nfor _, dir in ipairs(dirsToLoad) do\n    lia.loader.includeDir(dir.path, dir.raw, dir.deep, dir.realm)\nend\n</code></pre></p>"},{"location":"libraries/lia.loader/#includegroupeddir","title":"includeGroupedDir","text":"<p>Purpose</p> <p>Includes files from a directory with automatic realm detection based on filename prefixes</p> <p>When Called</p> <p>During framework initialization to load files with automatic realm detection</p> <p>Parameters</p> <ul> <li><code>dir</code> (string): The directory path to scan for Lua files</li> <li><code>raw</code> (boolean, optional): If true, uses the exact path; if false, resolves relative to gamemode/schema</li> <li><code>recursive</code> (boolean, optional): If true, recursively searches subdirectories</li> <li><code>forceRealm</code> (string, optional): Forces all files to be loaded in this realm instead of auto-detection</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Include files with automatic realm detection\nlia.loader.includeGroupedDir(\"lilia/gamemode/core/libraries\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Include files recursively with forced realm\nlia.loader.includeGroupedDir(\"lilia/gamemode/modules\", false, true, \"shared\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Include multiple directories with different settings and error handling\nlocal dirsToLoad = {\n{path = \"lilia/gamemode/core/libraries\", raw = false, recursive = false, forceRealm = nil},\n{path = \"lilia/gamemode/modules\", raw = false, recursive = true, forceRealm = \"shared\"},\n{path = \"custom/scripts\", raw = true, recursive = true, forceRealm = \"client\"}\n}\nfor _, dir in ipairs(dirsToLoad) do\n    if file.Exists(dir.path, \"LUA\") then\n        lia.loader.includeGroupedDir(dir.path, dir.raw, dir.recursive, dir.forceRealm)\n        else\n            lia.warning(\"Directory not found: \" .. dir.path)\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.loader/#checkforupdates","title":"checkForUpdates","text":"<p>Purpose</p> <p>Checks for updates to both the Lilia framework and installed modules by querying remote version data</p> <p>When Called</p> <p>During server startup or when manually triggered to check for available updates</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check for updates during server startup\nlia.loader.checkForUpdates()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check for updates with custom error handling\nlocal function safeUpdateCheck()\n    local success, err = pcall(lia.loader.checkForUpdates)\n    if not success then\n        lia.error(\"Update check failed: \" .. tostring(err))\n    end\nend\nsafeUpdateCheck()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check for updates with custom timing and logging\nlocal function scheduledUpdateCheck()\n    timer.Create(\"update_checker\", 3600, 0, function() -- Check every hour\n    lia.information(\"Checking for updates...\")\n    lia.loader.checkForUpdates()\n    lia.information(\"Update check completed\")\nend)\nend\nscheduledUpdateCheck()\n</code></pre></p>"},{"location":"libraries/lia.loader/#error","title":"error","text":"<p>Purpose</p> <p>Outputs error messages to the console with Lilia branding and red color formatting</p> <p>When Called</p> <p>When critical errors occur during framework operation or module loading</p> <p>Parameters</p> <ul> <li><code>msg</code> (string): The error message to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display a basic error message\nlia.error(\"Failed to load module\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display error with context information\nlocal function loadConfig()\n    local success, err = pcall(function()\n    -- Config loading code here\nend)\nif not success then\n    lia.error(\"Config loading failed: \" .. tostring(err))\nend\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display detailed error with stack trace and context\nlocal function safeModuleLoad(moduleName)\n    local success, err = pcall(function()\n    -- Module loading code here\nend)\nif not success then\n    local errorMsg = string.format(\n    \"Module '%s' failed to load: %s\\nStack trace: %s\",\n    moduleName,\n    tostring(err),\n    debug.traceback()\n    )\n    lia.error(errorMsg)\nend\nend\n</code></pre></p>"},{"location":"libraries/lia.loader/#warning","title":"warning","text":"<p>Purpose</p> <p>Outputs warning messages to the console with Lilia branding and yellow color formatting</p> <p>When Called</p> <p>When non-critical issues occur that should be brought to attention</p> <p>Parameters</p> <ul> <li><code>msg</code> (string): The warning message to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display a basic warning message\nlia.warning(\"Module version mismatch detected\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display warning with context information\nlocal function checkModuleCompatibility(module)\n    if module.version &lt; \"1.0.0\" then\n        lia.warning(\"Module '\" .. module.name .. \"' is using an outdated version\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display warning with detailed information and conditional logic\nlocal function validateModuleDependencies(module)\n    local missingDeps = {}\n    for _, dep in ipairs(module.dependencies or {}) do\n        if not lia.module.list[dep] then\n            table.insert(missingDeps, dep)\n        end\n    end\n    if #missingDeps &gt; 0 then\n        local warningMsg = string.format(\n        \"Module '%s' is missing dependencies: %s\",\n        module.name,\n        table.concat(missingDeps, \", \")\n        )\n        lia.warning(warningMsg)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.loader/#information","title":"information","text":"<p>Purpose</p> <p>Outputs informational messages to the console with Lilia branding and blue color formatting</p> <p>When Called</p> <p>When providing general information about framework operations or status updates</p> <p>Parameters</p> <ul> <li><code>msg</code> (string): The informational message to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display a basic information message\nlia.information(\"Framework initialized successfully\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display information with context\nlocal function reportModuleStatus(module)\n    lia.information(\"Module '\" .. module.name .. \"' loaded successfully\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display detailed information with statistics\nlocal function reportFrameworkStatus()\n    local moduleCount = table.Count(lia.module.list)\n    local loadedModules = 0\n    for _, module in pairs(lia.module.list) do\n        if module.loaded then loadedModules = loadedModules + 1 end\n        end\n        local statusMsg = string.format(\n        \"Framework Status: %d/%d modules loaded, %d entities registered\",\n        loadedModules,\n        moduleCount,\n        table.Count(scripted_ents.GetList())\n        )\n        lia.information(statusMsg)\n    end\n</code></pre></p>"},{"location":"libraries/lia.loader/#bootstrap","title":"bootstrap","text":"<p>Purpose</p> <p>Outputs bootstrap progress messages to the console with Lilia branding and section-specific formatting</p> <p>When Called</p> <p>During framework initialization to report progress of different bootstrap phases</p> <p>Parameters</p> <ul> <li><code>section</code> (string): The bootstrap section name (e.g., \"Database\", \"Modules\", \"HotReload\")</li> <li><code>msg</code> (string): The bootstrap message to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display a basic bootstrap message\nlia.bootstrap(\"Database\", \"Connection established\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display bootstrap progress with context\nlocal function reportModuleLoading(moduleName, status)\n    lia.bootstrap(\"Modules\", \"Loading \" .. moduleName .. \": \" .. status)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display detailed bootstrap progress with timing and statistics\nlocal function reportBootstrapProgress(section, current, total, startTime)\n    local elapsed = CurTime() - startTime\n    local progress = math.floor((current / total) * 100)\n    local msg = string.format(\n    \"Progress: %d/%d (%d%%) - Elapsed: %.2fs\",\n    current,\n    total,\n    progress,\n    elapsed\n    )\n    lia.bootstrap(section, msg)\nend\n</code></pre></p>"},{"location":"libraries/lia.loader/#relaydiscordmessage","title":"relaydiscordMessage","text":"<p>Purpose</p> <p>Sends formatted messages to Discord webhook with embed support and automatic fallback handling</p> <p>When Called</p> <p>When logging important events or sending notifications to Discord channels</p> <p>Parameters</p> <ul> <li><code>embed</code> (table): Discord embed object containing message data (title, description, color, fields, etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send a basic Discord message\nlia.relaydiscordMessage({\ntitle = \"Server Started\",\ndescription = \"The server has been initialized successfully\"\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send a detailed Discord message with custom formatting\nlocal function notifyPlayerJoin(player)\n    lia.relaydiscordMessage({\n    title = \"Player Joined\",\n    description = player:Name() .. \" has joined the server\",\n    color = 0x00ff00,\n    fields = {\n    {name = \"Steam ID\", value = player:SteamID(), inline = true},\n    {name = \"IP Address\", value = player:IPAddress(), inline = true}\n    }\n    })\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send complex Discord message with error handling and custom logic\nlocal function sendServerStatus()\n    local players = player.GetAll()\n    local embed = {\n    title = \"Server Status Report\",\n    description = \"Current server statistics and health\",\n    color = 0x0099ff,\n    timestamp = os.date(\"!%Y-%m-%dT%H:%M:%SZ\"),\n    fields = {\n    {name = \"Players Online\", value = #players, inline = true},\n    {name = \"Server Uptime\", value = string.format(\"%.1f hours\", CurTime() / 3600), inline = true},\n    {name = \"Map\", value = game.GetMap(), inline = true}\n    },\n    footer = {text = \"Lilia Framework Status Bot\"}\n    }\n    if #players &gt; 0 then\n        local playerList = {}\n        for _, ply in ipairs(players) do\n            table.insert(playerList, ply:Name())\n        end\n        embed.fields[#embed.fields + 1] = {\n        name = \"Player List\",\n        value = table.concat(playerList, \"\\n\"),\n        inline = false\n        }\n    end\n    lia.relaydiscordMessage(embed)\nend\n</code></pre></p>"},{"location":"libraries/lia.loader/#includeentities","title":"includeEntities","text":"<p>Purpose</p> <p>Registers and includes all entity types (entities, weapons, tools, effects) from a specified path</p> <p>When Called</p> <p>During framework initialization to register all custom entities, weapons, and tools</p> <p>Parameters</p> <ul> <li><code>path</code> (string): The base path containing entity folders (e.g., \"lilia/gamemode/entities\")</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Include entities from the default gamemode path\nlia.loader.includeEntities(\"lilia/gamemode/entities\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Include entities from multiple paths with error handling\nlocal entityPaths = {\n\"lilia/gamemode/entities\",\n\"custom/entities\"\n}\nfor _, path in ipairs(entityPaths) do\n    if file.Exists(path, \"LUA\") then\n        lia.loader.includeEntities(path)\n        else\n            lia.warning(\"Entity path not found: \" .. path)\n        end\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Include entities with custom registration and validation\nlocal function safeEntityInclusion(path)\n    local success, err = pcall(function()\n    lia.loader.includeEntities(path)\nend)\nif not success then\n    lia.error(\"Failed to include entities from \" .. path .. \": \" .. tostring(err))\n    else\n        lia.information(\"Successfully loaded entities from \" .. path)\n    end\nend\nsafeEntityInclusion(\"lilia/gamemode/entities\")\n</code></pre></p>"},{"location":"libraries/lia.loader/#lialocalplayer","title":"lia.LocalPlayer","text":"<p>Purpose</p> <p>Registers and includes all entity types (entities, weapons, tools, effects) from a specified path</p> <p>When Called</p> <p>During framework initialization to register all custom entities, weapons, and tools</p> <p>Parameters</p> <ul> <li><code>path</code> (string): The base path containing entity folders (e.g., \"lilia/gamemode/entities\")</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Include entities from the default gamemode path\nlia.loader.includeEntities(\"lilia/gamemode/entities\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Include entities from multiple paths with error handling\nlocal entityPaths = {\n\"lilia/gamemode/entities\",\n\"custom/entities\"\n}\nfor _, path in ipairs(entityPaths) do\n    if file.Exists(path, \"LUA\") then\n        lia.loader.includeEntities(path)\n        else\n            lia.warning(\"Entity path not found: \" .. path)\n        end\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Include entities with custom registration and validation\nlocal function safeEntityInclusion(path)\n    local success, err = pcall(function()\n    lia.loader.includeEntities(path)\nend)\nif not success then\n    lia.error(\"Failed to include entities from \" .. path .. \": \" .. tostring(err))\n    else\n        lia.information(\"Successfully loaded entities from \" .. path)\n    end\nend\nsafeEntityInclusion(\"lilia/gamemode/entities\")\n</code></pre></p>"},{"location":"libraries/lia.loader/#liagminitialize","title":"lia.GM:Initialize","text":"<p>Purpose</p> <p>Registers and includes all entity types (entities, weapons, tools, effects) from a specified path</p> <p>When Called</p> <p>During framework initialization to register all custom entities, weapons, and tools</p> <p>Parameters</p> <ul> <li><code>path</code> (string): The base path containing entity folders (e.g., \"lilia/gamemode/entities\")</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Include entities from the default gamemode path\nlia.loader.includeEntities(\"lilia/gamemode/entities\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Include entities from multiple paths with error handling\nlocal entityPaths = {\n\"lilia/gamemode/entities\",\n\"custom/entities\"\n}\nfor _, path in ipairs(entityPaths) do\n    if file.Exists(path, \"LUA\") then\n        lia.loader.includeEntities(path)\n        else\n            lia.warning(\"Entity path not found: \" .. path)\n        end\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Include entities with custom registration and validation\nlocal function safeEntityInclusion(path)\n    local success, err = pcall(function()\n    lia.loader.includeEntities(path)\nend)\nif not success then\n    lia.error(\"Failed to include entities from \" .. path .. \": \" .. tostring(err))\n    else\n        lia.information(\"Successfully loaded entities from \" .. path)\n    end\nend\nsafeEntityInclusion(\"lilia/gamemode/entities\")\n</code></pre></p>"},{"location":"libraries/lia.loader/#liagmonreloaded","title":"lia.GM:OnReloaded","text":"<p>Purpose</p> <p>Registers and includes all entity types (entities, weapons, tools, effects) from a specified path</p> <p>When Called</p> <p>During framework initialization to register all custom entities, weapons, and tools</p> <p>Parameters</p> <ul> <li><code>path</code> (string): The base path containing entity folders (e.g., \"lilia/gamemode/entities\")</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Include entities from the default gamemode path\nlia.loader.includeEntities(\"lilia/gamemode/entities\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Include entities from multiple paths with error handling\nlocal entityPaths = {\n\"lilia/gamemode/entities\",\n\"custom/entities\"\n}\nfor _, path in ipairs(entityPaths) do\n    if file.Exists(path, \"LUA\") then\n        lia.loader.includeEntities(path)\n        else\n            lia.warning(\"Entity path not found: \" .. path)\n        end\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Include entities with custom registration and validation\nlocal function safeEntityInclusion(path)\n    local success, err = pcall(function()\n    lia.loader.includeEntities(path)\nend)\nif not success then\n    lia.error(\"Failed to include entities from \" .. path .. \": \" .. tostring(err))\n    else\n        lia.information(\"Successfully loaded entities from \" .. path)\n    end\nend\nsafeEntityInclusion(\"lilia/gamemode/entities\")\n</code></pre></p>"},{"location":"libraries/lia.logger/","title":"Logger Library","text":"<p>Comprehensive logging and audit trail system for the Lilia framework.</p> <p>Overview</p> <p>The logger library provides comprehensive logging functionality for the Lilia framework, enabling detailed tracking and recording of player actions, administrative activities, and system events. It operates on the server side and automatically categorizes log entries into predefined categories such as character management, combat, world interactions, chat communications, item transactions, administrative actions, and security events. The library stores all log entries in a database table with timestamps, player information, and categorized messages. It supports dynamic log type registration and provides hooks for external systems to process log events. The logger ensures accountability and provides administrators with detailed audit trails for server management and moderation.</p>"},{"location":"libraries/lia.logger/#addtype","title":"addType","text":"<p>Purpose</p> <p>Registers a new log type with a custom formatting function and category</p> <p>When Called</p> <p>When modules or external systems need to add custom log types</p> <p>Parameters</p> <ul> <li><code>logType</code> (string): Unique identifier for the log type</li> <li><code>func</code> (function): Function that formats the log message, receives client and additional parameters</li> <li><code>category</code> (string): Category name for organizing log entries</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a basic custom log type\nlia.log.addType(\"customAction\", function(client, action)\nreturn client:Name() .. \" performed \" .. action\nend, \"Custom\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add log type with validation and localization\nlia.log.addType(\"moduleEvent\", function(client, moduleName, event, data)\nif not IsValid(client) then return \"System: \" .. moduleName .. \" - \" .. event end\n    return L(\"logModuleEvent\", client:Name(), moduleName, event, data or \"\")\nend, \"Modules\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add complex log type with multiple parameters and error handling\nlia.log.addType(\"advancedAction\", function(client, target, action, amount, reason)\nlocal clientName = IsValid(client) and client:Name() or \"Console\"\nlocal targetName = IsValid(target) and target:Name() or tostring(target)\nlocal timestamp = os.date(\"%H:%M:%S\")\nreturn string.format(\"[%s] %s %s %s (Amount: %s, Reason: %s)\",\ntimestamp, clientName, action, targetName, amount or \"N/A\", reason or \"None\")\nend, \"Advanced\")\n</code></pre></p>"},{"location":"libraries/lia.logger/#getstring","title":"getString","text":"<p>Purpose</p> <p>Generates a formatted log string from a log type and parameters</p> <p>When Called</p> <p>Internally by lia.log.add() or when manually retrieving log messages</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who triggered the log event (can be nil for system events)</li> <li><code>logType</code> (string): The log type identifier to format</li> </ul> <p>Returns</p> <ul> <li> <ul> <li>result (string): The formatted log message, or nil if log type doesn't exist or function fails</li> </ul> </li> <li>category (string): The category of the log type, or nil if log type doesn't exist</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a basic log string\nlocal message, category = lia.log.getString(client, \"charCreate\", character)\nif message then\n    print(\"Log: \" .. message)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get log string with multiple parameters\nlocal message, category = lia.log.getString(client, \"itemTransfer\", itemName, fromID, toID)\nif message then\n    hook.Run(\"CustomLogHandler\", message, category)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get log string with error handling and validation\nlocal function safeGetLogString(client, logType, ...)\n    local success, message, category = pcall(lia.log.getString, client, logType, ...)\n    if success and message then\n        return message, category\n        else\n            return \"Failed to generate log: \" .. tostring(logType), \"Error\"\n        end\n    end\n    local message, category = safeGetLogString(client, \"adminAction\", target, action, reason)\n</code></pre></p>"},{"location":"libraries/lia.logger/#add","title":"add","text":"<p>Purpose</p> <p>Adds a log entry to the database and displays it in the server console</p> <p>When Called</p> <p>When any significant player action or system event occurs that needs logging</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who triggered the log event (can be nil for system events)</li> <li><code>logType</code> (string): The log type identifier to use for formatting</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Log a basic player action\nlia.log.add(client, \"charCreate\", character)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Log with multiple parameters and validation\nif IsValid(target) then\n    lia.log.add(client, \"itemTransfer\", itemName, fromID, toID)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Log with conditional parameters and error handling\nlocal function logAdminAction(client, target, action, reason, amount)\n    local logType = \"adminAction\"\n    local params = {target, action}\n    if reason then table.insert(params, reason) end\n        if amount then table.insert(params, amount) end\n            lia.log.add(client, logType, unpack(params))\n        end\n        logAdminAction(client, target, \"kick\", \"Rule violation\", nil)\n</code></pre></p>"},{"location":"libraries/lia.menu/","title":"Menu Library","text":"<p>Interactive 3D context menu system for world and entity interactions in the Lilia framework.</p> <p>Overview</p> <p>The menu library provides a comprehensive context menu system for the Lilia framework. It enables the creation of interactive context menus that appear in 3D world space or attached to entities, allowing players to interact with objects and perform actions through a visual interface. The library handles menu positioning, animation, collision detection, and user interaction. Menus automatically fade in when the player looks at them and fade out when they look away, with smooth animations and proper range checking. The system supports both world-positioned menus and entity-attached menus with automatic screen space conversion and boundary clamping to ensure menus remain visible and accessible.</p>"},{"location":"libraries/lia.menu/#add","title":"add","text":"<p>Purpose</p> <p>Creates and adds a new context menu to the menu system</p> <p>When Called</p> <p>When you need to display a context menu with options for player interaction</p> <p>Parameters</p> <ul> <li><code>opts</code> (table): Table of menu options where keys are display text and values are callback functions</li> <li><code>pos</code> (Vector|Entity, optional): World position or entity to attach menu to. If entity, menu attaches to entity's local position</li> <li><code>onRemove</code> (function, optional): Callback function called when menu is removed</li> </ul> <p>Returns</p> <ul> <li>(number) Index of the created menu in the menu list</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a basic context menu\nlia.menu.add({\n[\"Use\"] = function() print(\"Used item\") end,\n[\"Drop\"] = function() print(\"Dropped item\") end\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create menu attached to an entity\nlocal ent = Entity(1)\nlia.menu.add({\n[\"Open\"] = function() ent:Use() end,\n[\"Examine\"] = function() print(\"Examining entity\") end,\n[\"Destroy\"] = function() ent:Remove() end\n}, ent)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create menu with custom position and cleanup\nlocal menuData = {\n[\"Option 1\"] = function()\nRunConsoleCommand(\"say\", \"Selected option 1\")\nend,\n[\"Option 2\"] = function()\nRunConsoleCommand(\"say\", \"Selected option 2\")\nend,\n[\"Cancel\"] = function()\nprint(\"Menu cancelled\")\nend\n}\nlocal cleanupFunc = function()\nprint(\"Menu was removed\")\nend\nlocal menuIndex = lia.menu.add(menuData, Vector(100, 200, 50), cleanupFunc)\n</code></pre></p>"},{"location":"libraries/lia.menu/#drawall","title":"drawAll","text":"<p>Purpose</p> <p>Renders all active context menus with animations and interaction detection</p> <p>When Called</p> <p>Called every frame from the HUD rendering system to draw all menus</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Called automatically by the framework\n-- This function is typically called from hooks like HUDPaint\nhook.Add(\"HUDPaint\", \"MenuDraw\", lia.menu.drawAll)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom rendering with additional checks\nhook.Add(\"HUDPaint\", \"CustomMenuDraw\", function()\nif not LocalPlayer():Alive() then return end\n    lia.menu.drawAll()\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Conditional rendering with performance optimization\nlocal lastDrawTime = 0\nhook.Add(\"HUDPaint\", \"OptimizedMenuDraw\", function()\nlocal currentTime = RealTime()\nif currentTime - lastDrawTime &lt; 0.016 then return end -- Limit to ~60fps\n    if #lia.menu.list &gt; 0 then\n        lia.menu.drawAll()\n        lastDrawTime = currentTime\n    end\nend)\n</code></pre></p>"},{"location":"libraries/lia.menu/#getactivemenu","title":"getActiveMenu","text":"<p>Purpose</p> <p>Gets the currently active menu item that the player is hovering over</p> <p>When Called</p> <p>When checking for menu interaction, typically from input handling systems</p> <p>Returns</p> <ul> <li>(number, function|nil) Menu index and callback function if menu item is hovered, nil otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player is hovering over a menu\nlocal menuIndex, callback = lia.menu.getActiveMenu()\nif callback then\n    print(\"Player is hovering over menu item\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle menu interaction with validation\nhook.Add(\"PlayerButtonDown\", \"MenuInteraction\", function(ply, button)\nif button == MOUSE_LEFT then\n    local menuIndex, callback = lia.menu.getActiveMenu()\n    if callback then\n        callback()\n        print(\"Menu item activated\")\n    end\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced menu interaction with cooldown and logging\nlocal lastMenuTime = 0\nhook.Add(\"PlayerButtonDown\", \"AdvancedMenuInteraction\", function(ply, button)\nif button == MOUSE_LEFT then\n    local currentTime = RealTime()\n    if currentTime - lastMenuTime &lt; 0.1 then return end -- Prevent spam\n        local menuIndex, callback = lia.menu.getActiveMenu()\n        if callback then\n            lastMenuTime = currentTime\n            callback()\n            -- Log the interaction\n            print(string.format(\"Menu interaction at time %f, menu index %d\", currentTime, menuIndex))\n        end\n    end\nend)\n</code></pre></p>"},{"location":"libraries/lia.menu/#onbuttonpressed","title":"onButtonPressed","text":"<p>Purpose</p> <p>Handles button press events for menu items and removes the menu</p> <p>When Called</p> <p>When a menu item is clicked or activated by player input</p> <p>Parameters</p> <ul> <li><code>id</code> (number): Index of the menu to remove from the menu list</li> <li><code>cb</code> (function, optional): Callback function to execute when button is pressed</li> </ul> <p>Returns</p> <ul> <li>(boolean) True if callback was executed, false otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove menu and execute callback\nlocal menuIndex = 1\nlocal success = lia.menu.onButtonPressed(menuIndex, function()\nprint(\"Menu button pressed!\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle menu interaction with validation\nhook.Add(\"PlayerButtonDown\", \"MenuButtonPress\", function(ply, button)\nif button == MOUSE_LEFT then\n    local menuIndex, callback = lia.menu.getActiveMenu()\n    if menuIndex and callback then\n        local success = lia.menu.onButtonPressed(menuIndex, callback)\n        if success then\n            print(\"Menu interaction successful\")\n        end\n    end\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced menu handling with error checking and logging\nlocal function handleMenuPress(menuIndex, callback)\n    if not menuIndex or menuIndex &lt;= 0 then\n        print(\"Invalid menu index\")\n        return false\n    end\n    if not callback or type(callback) ~= \"function\" then\n        print(\"Invalid callback function\")\n        return false\n    end\n    local success = lia.menu.onButtonPressed(menuIndex, function()\n    local success, err = pcall(callback)\n    if not success then\n        print(\"Menu callback error: \" .. tostring(err))\n    end\nend)\nreturn success\nend\n-- Usage\nlocal menuIndex, callback = lia.menu.getActiveMenu()\nif menuIndex then\n    handleMenuPress(menuIndex, callback)\nend\n</code></pre></p>"},{"location":"libraries/lia.modularity/","title":"Modularity Library","text":"<p>Module loading, initialization, and lifecycle management system for the Lilia framework.</p> <p>Overview</p> <p>The modularity library provides comprehensive functionality for managing modules in the Lilia framework. It handles loading, initialization, and management of modules including schemas, preload modules, and regular modules. The library operates on both server and client sides, managing module dependencies, permissions, and lifecycle events. It includes functionality for loading modules from directories, handling module-specific data storage, and ensuring proper initialization order. The library also manages submodules, handles module validation, and provides hooks for module lifecycle events. It ensures that all modules are properly loaded and initialized before gameplay begins.</p>"},{"location":"libraries/lia.modularity/#load","title":"load","text":"<p>Purpose</p> <p>Loads a module from the specified path with the given unique identifier</p> <p>When Called</p> <p>Called during module initialization, when loading modules from directories, or when manually loading specific modules</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): Unique identifier for the module</li> <li><code>path</code> (string): File system path to the module directory</li> <li><code>variable</code> (string, optional): Global variable name to use (defaults to \"MODULE\")</li> <li><code>skipSubmodules</code> (boolean, optional): Whether to skip loading submodules</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a basic module\nlia.module.load(\"mymodule\", \"gamemodes/lilia/modules/mymodule\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load module with custom variable name\nlia.module.load(\"custommodule\", \"gamemodes/lilia/modules/custom\", \"CUSTOM_MODULE\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load module with submodule skipping\nlia.module.load(\"singlemode\", \"gamemodes/lilia/modules/singlemode\", \"SINGLE_MODULE\", true)\n</code></pre></p>"},{"location":"libraries/lia.modularity/#liamoduleisvalid","title":"lia.MODULE:IsValid","text":"<p>Purpose</p> <p>Loads a module from the specified path with the given unique identifier</p> <p>When Called</p> <p>Called during module initialization, when loading modules from directories, or when manually loading specific modules</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): Unique identifier for the module</li> <li><code>path</code> (string): File system path to the module directory</li> <li><code>variable</code> (string, optional): Global variable name to use (defaults to \"MODULE\")</li> <li><code>skipSubmodules</code> (boolean, optional): Whether to skip loading submodules</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a basic module\nlia.module.load(\"mymodule\", \"gamemodes/lilia/modules/mymodule\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load module with custom variable name\nlia.module.load(\"custommodule\", \"gamemodes/lilia/modules/custom\", \"CUSTOM_MODULE\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load module with submodule skipping\nlia.module.load(\"singlemode\", \"gamemodes/lilia/modules/singlemode\", \"SINGLE_MODULE\", true)\n</code></pre></p>"},{"location":"libraries/lia.modularity/#liamodulesetdata","title":"lia.MODULE:setData","text":"<p>Purpose</p> <p>Loads a module from the specified path with the given unique identifier</p> <p>When Called</p> <p>Called during module initialization, when loading modules from directories, or when manually loading specific modules</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): Unique identifier for the module</li> <li><code>path</code> (string): File system path to the module directory</li> <li><code>variable</code> (string, optional): Global variable name to use (defaults to \"MODULE\")</li> <li><code>skipSubmodules</code> (boolean, optional): Whether to skip loading submodules</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a basic module\nlia.module.load(\"mymodule\", \"gamemodes/lilia/modules/mymodule\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load module with custom variable name\nlia.module.load(\"custommodule\", \"gamemodes/lilia/modules/custom\", \"CUSTOM_MODULE\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load module with submodule skipping\nlia.module.load(\"singlemode\", \"gamemodes/lilia/modules/singlemode\", \"SINGLE_MODULE\", true)\n</code></pre></p>"},{"location":"libraries/lia.modularity/#liamodulegetdata","title":"lia.MODULE:getData","text":"<p>Purpose</p> <p>Loads a module from the specified path with the given unique identifier</p> <p>When Called</p> <p>Called during module initialization, when loading modules from directories, or when manually loading specific modules</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (string): Unique identifier for the module</li> <li><code>path</code> (string): File system path to the module directory</li> <li><code>variable</code> (string, optional): Global variable name to use (defaults to \"MODULE\")</li> <li><code>skipSubmodules</code> (boolean, optional): Whether to skip loading submodules</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load a basic module\nlia.module.load(\"mymodule\", \"gamemodes/lilia/modules/mymodule\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load module with custom variable name\nlia.module.load(\"custommodule\", \"gamemodes/lilia/modules/custom\", \"CUSTOM_MODULE\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load module with submodule skipping\nlia.module.load(\"singlemode\", \"gamemodes/lilia/modules/singlemode\", \"SINGLE_MODULE\", true)\n</code></pre></p>"},{"location":"libraries/lia.modularity/#initialize","title":"initialize","text":"<p>Purpose</p> <p>Initializes the entire module system, loading schemas, preload modules, and regular modules in proper order</p> <p>When Called</p> <p>Called during gamemode initialization to set up the complete module ecosystem</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Initialize modules (typically called automatically)\nlia.module.initialize()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize with custom schema path\nlocal schemaPath = \"gamemodes/mygamemode\"\nlia.module.load(\"schema\", schemaPath .. \"/schema\", false, \"schema\")\nlia.module.initialize()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Initialize with custom module loading order\nlia.module.initialize()\n-- Custom post-initialization logic\nfor id, mod in pairs(lia.module.list) do\n    if mod.PostInitialize then\n        mod:PostInitialize()\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.modularity/#loadfromdir","title":"loadFromDir","text":"<p>Purpose</p> <p>Loads all modules from a specified directory</p> <p>When Called</p> <p>Called during module initialization to load multiple modules from a directory, or when manually loading modules from a specific folder</p> <p>Parameters</p> <ul> <li><code>directory</code> (string): Path to the directory containing modules</li> <li><code>group</code> (string): Type of module group (\"module\", \"schema\", etc.)</li> <li><code>skip</code> (table, optional): Table of module IDs to skip loading</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load all modules from a directory\nlia.module.loadFromDir(\"gamemodes/lilia/modules\", \"module\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load modules with specific group type\nlia.module.loadFromDir(\"gamemodes/mygamemode/modules\", \"module\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load modules with skip list\nlocal skipModules = {[\"disabledmodule\"] = true, [\"testmodule\"] = true}\nlia.module.loadFromDir(\"gamemodes/lilia/modules\", \"module\", skipModules)\n</code></pre></p>"},{"location":"libraries/lia.modularity/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves a loaded module by its unique identifier</p> <p>When Called</p> <p>Called when you need to access a specific module's data or functions, or to check if a module is loaded</p> <p>Parameters</p> <ul> <li><code>identifier</code> (string): Unique identifier of the module to retrieve</li> </ul> <p>Returns</p> <ul> <li>Module table or nil if not found</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a module\nlocal myModule = lia.module.get(\"mymodule\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check if module exists and use it\nlocal module = lia.module.get(\"inventory\")\nif module and module.GetItem then\n    local item = module:GetItem(\"weapon_pistol\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Iterate through all modules and perform operations\nfor id, module in pairs(lia.module.list) do\n    local mod = lia.module.get(id)\n    if mod and mod.OnPlayerSpawn then\n        mod:OnPlayerSpawn(player)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.net/","title":"Network Library","text":"<p>Network communication and data streaming system for the Lilia framework.</p> <p>Overview</p> <p>The network library provides comprehensive functionality for managing network communication in the Lilia framework. It handles both simple message passing and complex data streaming between server and client. The library includes support for registering network message handlers, sending messages to specific targets or broadcasting to all clients, and managing large data transfers through chunked streaming. It also provides global variable synchronization across the network, allowing server-side variables to be automatically synchronized with clients. The library operates on both server and client sides, with server handling message broadcasting and client handling message reception and acknowledgment.</p>"},{"location":"libraries/lia.net/#register","title":"register","text":"<p>Purpose</p> <p>Registers a network message handler for receiving messages sent via lia.net.send</p> <p>When Called</p> <p>During initialization or when setting up network message handlers</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name identifier for the network message</li> <li><code>callback</code> (function): Function to call when this message is received</li> </ul> <p>Returns</p> <ul> <li>boolean - true if registration successful, false if invalid arguments</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a basic message handler\nlia.net.register(\"playerMessage\", function(data)\n    print(\"Received message:\", data)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register handler with validation\nlia.net.register(\"updateHealth\", function(data)\n    if data and data.health then\n        LocalPlayer():SetHealth(data.health)\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register handler with multiple data types and error handling\nlia.net.register(\"syncInventory\", function(data)\n    if not data or not data.items then return end\n    local inventory = LocalPlayer():GetCharacter():GetInventory()\n    if not inventory then return end\n    for _, itemData in ipairs(data.items) do\n        if itemData.id and itemData.uniqueID then\n            inventory:Add(itemData.uniqueID, itemData.id)\n        end\n    end\nend)\n</code></pre></p>"},{"location":"libraries/lia.net/#send","title":"send","text":"<p>Purpose</p> <p>Sends a network message to specified targets or broadcasts to all clients</p> <p>When Called</p> <p>When you need to send data from server to client(s) or client to server</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The registered message name to send</li> <li><code>target</code> (Player/table/nil): Target player(s) - nil broadcasts to all, table sends to multiple players</li> </ul> <p>Returns</p> <ul> <li>boolean - true if message sent successfully, false if invalid name or target</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send message to all clients\nlia.net.send(\"playerMessage\", nil, \"Hello everyone!\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send message to specific player\nlocal targetPlayer = player.GetByID(1)\nif targetPlayer then\n    lia.net.send(\"updateHealth\", targetPlayer, {health = 100})\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send message to multiple players with complex data\nlocal admins = {}\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        table.insert(admins, ply)\n    end\nend\nlia.net.send(\"adminNotification\", admins, {\ntype = \"warning\",\nmessage = \"Server restart in 5 minutes\",\ntimestamp = os.time()\n})\n</code></pre></p>"},{"location":"libraries/lia.net/#readbigtable","title":"readBigTable","text":"<p>Purpose</p> <p>Sets up a receiver for large table data that is sent in chunks via lia.net.writeBigTable</p> <p>When Called</p> <p>During initialization to set up handlers for receiving large data transfers</p> <p>Parameters</p> <ul> <li><code>netStr</code> (string): The network string identifier for the message</li> <li><code>callback</code> (function): Function to call when all chunks are received and data is reconstructed</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (works on both server and client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set up receiver for large data\nlia.net.readBigTable(\"largeData\", function(data)\n    print(\"Received large table with\", #data, \"entries\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set up receiver with validation\nlia.net.readBigTable(\"playerData\", function(data)\n    if data and data.players then\n        for _, playerData in ipairs(data.players) do\n            if playerData.name and playerData.id then\n                -- Process player data\n            end\n        end\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Set up receiver with error handling and processing\nlia.net.readBigTable(\"inventorySync\", function(data)\n    if not data or not data.items then return end\n    local inventory = LocalPlayer():GetCharacter():GetInventory()\n    if not inventory then return end\n    -- Clear existing items\n    inventory:Clear()\n    -- Add new items with validation\n    for _, itemData in ipairs(data.items) do\n        if itemData.uniqueID and itemData.id then\n            local success = inventory:Add(itemData.uniqueID, itemData.id)\n            if not success then\n                lia.log.add(\"Failed to add item: \" .. tostring(itemData.uniqueID))\n            end\n        end\n    end\n    -- Update UI\n    if IsValid(inventory.panel) then\n        inventory.panel:Rebuild()\n    end\nend)\n</code></pre></p>"},{"location":"libraries/lia.net/#writebigtable","title":"writeBigTable","text":"<p>Purpose</p> <p>Sends large table data to clients in chunks to avoid network limits</p> <p>When Called</p> <p>When you need to send large amounts of data that exceed normal network limits</p> <p>Parameters</p> <ul> <li><code>targets</code> (Player/table/nil): Target player(s) - nil sends to all players</li> <li><code>netStr</code> (string): The network string identifier for the message</li> <li><code>tbl</code> (table): The table data to send</li> <li><code>chunkSize</code> (number, optional): Size of each chunk in bytes (default: 2048, 512 during reload)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send large table to all players\nlocal largeData = {}\nfor i = 1, 1000 do\n    largeData[i] = { id = i, name = \"Item \" .. i }\nend\nlia.net.writeBigTable(nil, \"largeData\", largeData)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send to specific players with custom chunk size\nlocal playerData = {}\nfor _, ply in ipairs(player.GetAll()) do\n    playerData[ply:SteamID()] = {\n        name = ply:Name(),\n        health = ply:Health(),\n        armor = ply:Armor()\n    }\nend\nlocal admins = {}\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        table.insert(admins, ply)\n    end\nend\nlia.net.writeBigTable(admins, \"adminPlayerData\", playerData, 1024)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send complex inventory data with validation and error handling\nlocal function sendInventoryData(targets)\n    local inventoryData = {}\n    for _, ply in ipairs(player.GetAll()) do\n        local char = ply:GetCharacter()\n        if char then\n            local inv = char:GetInventory()\n            if inv then\n                inventoryData[ply:SteamID()] = {\n                    items = {},\n                    slots = inv:GetSlots(),\n                    weight = inv:GetWeight()\n                }\n                for _, item in ipairs(inv:GetItems()) do\n                    table.insert(inventoryData[ply:SteamID()].items, {\n                        uniqueID = item.uniqueID,\n                        id = item.id,\n                        data = item.data\n                    })\n                end\n            end\n        end\n    end\n    if next(inventoryData) then\n        lia.net.writeBigTable(targets, \"inventorySync\", inventoryData, 1536)\n    end\nend\n-- Send to specific players or all\nlocal targetPlayers = player.GetByID(1) -- Specific player\nsendInventoryData(targetPlayers)\n</code></pre></p>"},{"location":"libraries/lia.net/#liacheckbadtype","title":"lia.checkBadType","text":"<p>Purpose</p> <p>Sends large table data to clients in chunks to avoid network limits</p> <p>When Called</p> <p>When you need to send large amounts of data that exceed normal network limits</p> <p>Parameters</p> <ul> <li><code>targets</code> (Player/table/nil): Target player(s) - nil sends to all players</li> <li><code>netStr</code> (string): The network string identifier for the message</li> <li><code>tbl</code> (table): The table data to send</li> <li><code>chunkSize</code> (number, optional): Size of each chunk in bytes (default: 2048, 512 during reload)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send large table to all players\nlocal largeData = {}\nfor i = 1, 1000 do\n    largeData[i] = { id = i, name = \"Item \" .. i }\nend\nlia.net.writeBigTable(nil, \"largeData\", largeData)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send to specific players with custom chunk size\nlocal playerData = {}\nfor _, ply in ipairs(player.GetAll()) do\n    playerData[ply:SteamID()] = {\n        name = ply:Name(),\n        health = ply:Health(),\n        armor = ply:Armor()\n    }\nend\nlocal admins = {}\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        table.insert(admins, ply)\n    end\nend\nlia.net.writeBigTable(admins, \"adminPlayerData\", playerData, 1024)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send complex inventory data with validation and error handling\nlocal function sendInventoryData(targets)\n    local inventoryData = {}\n    for _, ply in ipairs(player.GetAll()) do\n        local char = ply:GetCharacter()\n        if char then\n            local inv = char:GetInventory()\n            if inv then\n                inventoryData[ply:SteamID()] = {\n                    items = {},\n                    slots = inv:GetSlots(),\n                    weight = inv:GetWeight()\n                }\n                for _, item in ipairs(inv:GetItems()) do\n                    table.insert(inventoryData[ply:SteamID()].items, {\n                        uniqueID = item.uniqueID,\n                        id = item.id,\n                        data = item.data\n                    })\n                end\n            end\n        end\n    end\n    if next(inventoryData) then\n        lia.net.writeBigTable(targets, \"inventorySync\", inventoryData, 1536)\n    end\nend\n-- Send to specific players or all\nlocal targetPlayers = player.GetByID(1) -- Specific player\nsendInventoryData(targetPlayers)\n</code></pre></p>"},{"location":"libraries/lia.net/#liasetnetvar","title":"lia.setNetVar","text":"<p>Purpose</p> <p>Sends large table data to clients in chunks to avoid network limits</p> <p>When Called</p> <p>When you need to send large amounts of data that exceed normal network limits</p> <p>Parameters</p> <ul> <li><code>targets</code> (Player/table/nil): Target player(s) - nil sends to all players</li> <li><code>netStr</code> (string): The network string identifier for the message</li> <li><code>tbl</code> (table): The table data to send</li> <li><code>chunkSize</code> (number, optional): Size of each chunk in bytes (default: 2048, 512 during reload)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send large table to all players\nlocal largeData = {}\nfor i = 1, 1000 do\n    largeData[i] = { id = i, name = \"Item \" .. i }\nend\nlia.net.writeBigTable(nil, \"largeData\", largeData)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send to specific players with custom chunk size\nlocal playerData = {}\nfor _, ply in ipairs(player.GetAll()) do\n    playerData[ply:SteamID()] = {\n        name = ply:Name(),\n        health = ply:Health(),\n        armor = ply:Armor()\n    }\nend\nlocal admins = {}\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        table.insert(admins, ply)\n    end\nend\nlia.net.writeBigTable(admins, \"adminPlayerData\", playerData, 1024)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send complex inventory data with validation and error handling\nlocal function sendInventoryData(targets)\n    local inventoryData = {}\n    for _, ply in ipairs(player.GetAll()) do\n        local char = ply:GetCharacter()\n        if char then\n            local inv = char:GetInventory()\n            if inv then\n                inventoryData[ply:SteamID()] = {\n                    items = {},\n                    slots = inv:GetSlots(),\n                    weight = inv:GetWeight()\n                }\n                for _, item in ipairs(inv:GetItems()) do\n                    table.insert(inventoryData[ply:SteamID()].items, {\n                        uniqueID = item.uniqueID,\n                        id = item.id,\n                        data = item.data\n                    })\n                end\n            end\n        end\n    end\n    if next(inventoryData) then\n        lia.net.writeBigTable(targets, \"inventorySync\", inventoryData, 1536)\n    end\nend\n-- Send to specific players or all\nlocal targetPlayers = player.GetByID(1) -- Specific player\nsendInventoryData(targetPlayers)\n</code></pre></p>"},{"location":"libraries/lia.net/#liagetnetvar","title":"lia.getNetVar","text":"<p>Purpose</p> <p>Sends large table data to clients in chunks to avoid network limits</p> <p>When Called</p> <p>When you need to send large amounts of data that exceed normal network limits</p> <p>Parameters</p> <ul> <li><code>targets</code> (Player/table/nil): Target player(s) - nil sends to all players</li> <li><code>netStr</code> (string): The network string identifier for the message</li> <li><code>tbl</code> (table): The table data to send</li> <li><code>chunkSize</code> (number, optional): Size of each chunk in bytes (default: 2048, 512 during reload)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send large table to all players\nlocal largeData = {}\nfor i = 1, 1000 do\n    largeData[i] = { id = i, name = \"Item \" .. i }\nend\nlia.net.writeBigTable(nil, \"largeData\", largeData)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send to specific players with custom chunk size\nlocal playerData = {}\nfor _, ply in ipairs(player.GetAll()) do\n    playerData[ply:SteamID()] = {\n        name = ply:Name(),\n        health = ply:Health(),\n        armor = ply:Armor()\n    }\nend\nlocal admins = {}\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        table.insert(admins, ply)\n    end\nend\nlia.net.writeBigTable(admins, \"adminPlayerData\", playerData, 1024)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send complex inventory data with validation and error handling\nlocal function sendInventoryData(targets)\n    local inventoryData = {}\n    for _, ply in ipairs(player.GetAll()) do\n        local char = ply:GetCharacter()\n        if char then\n            local inv = char:GetInventory()\n            if inv then\n                inventoryData[ply:SteamID()] = {\n                    items = {},\n                    slots = inv:GetSlots(),\n                    weight = inv:GetWeight()\n                }\n                for _, item in ipairs(inv:GetItems()) do\n                    table.insert(inventoryData[ply:SteamID()].items, {\n                        uniqueID = item.uniqueID,\n                        id = item.id,\n                        data = item.data\n                    })\n                end\n            end\n        end\n    end\n    if next(inventoryData) then\n        lia.net.writeBigTable(targets, \"inventorySync\", inventoryData, 1536)\n    end\nend\n-- Send to specific players or all\nlocal targetPlayers = player.GetByID(1) -- Specific player\nsendInventoryData(targetPlayers)\n</code></pre></p>"},{"location":"libraries/lia.net/#liagetnetvar_1","title":"lia.getNetVar","text":"<p>Purpose</p> <p>Sends large table data to clients in chunks to avoid network limits</p> <p>When Called</p> <p>When you need to send large amounts of data that exceed normal network limits</p> <p>Parameters</p> <ul> <li><code>targets</code> (Player/table/nil): Target player(s) - nil sends to all players</li> <li><code>netStr</code> (string): The network string identifier for the message</li> <li><code>tbl</code> (table): The table data to send</li> <li><code>chunkSize</code> (number, optional): Size of each chunk in bytes (default: 2048, 512 during reload)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send large table to all players\nlocal largeData = {}\nfor i = 1, 1000 do\n    largeData[i] = { id = i, name = \"Item \" .. i }\nend\nlia.net.writeBigTable(nil, \"largeData\", largeData)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send to specific players with custom chunk size\nlocal playerData = {}\nfor _, ply in ipairs(player.GetAll()) do\n    playerData[ply:SteamID()] = {\n        name = ply:Name(),\n        health = ply:Health(),\n        armor = ply:Armor()\n    }\nend\nlocal admins = {}\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        table.insert(admins, ply)\n    end\nend\nlia.net.writeBigTable(admins, \"adminPlayerData\", playerData, 1024)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send complex inventory data with validation and error handling\nlocal function sendInventoryData(targets)\n    local inventoryData = {}\n    for _, ply in ipairs(player.GetAll()) do\n        local char = ply:GetCharacter()\n        if char then\n            local inv = char:GetInventory()\n            if inv then\n                inventoryData[ply:SteamID()] = {\n                    items = {},\n                    slots = inv:GetSlots(),\n                    weight = inv:GetWeight()\n                }\n                for _, item in ipairs(inv:GetItems()) do\n                    table.insert(inventoryData[ply:SteamID()].items, {\n                        uniqueID = item.uniqueID,\n                        id = item.id,\n                        data = item.data\n                    })\n                end\n            end\n        end\n    end\n    if next(inventoryData) then\n        lia.net.writeBigTable(targets, \"inventorySync\", inventoryData, 1536)\n    end\nend\n-- Send to specific players or all\nlocal targetPlayers = player.GetByID(1) -- Specific player\nsendInventoryData(targetPlayers)\n</code></pre></p>"},{"location":"libraries/lia.notice/","title":"Notice Library","text":"<p>Player notification and messaging system for the Lilia framework.</p> <p>Overview</p> <p>The notice library provides comprehensive functionality for displaying notifications and messages to players in the Lilia framework. It handles both server-side and client-side notification systems, supporting both direct text messages and localized messages with parameter substitution. The library operates across server and client realms, with the server sending notification data to clients via network messages, while the client handles the visual display of notifications using VGUI panels. It includes automatic organization of multiple notifications, sound effects, and console output for debugging purposes. The library also provides compatibility with Garry's Mod's legacy notification system.</p>"},{"location":"libraries/lia.notice/#notify","title":"notify","text":"<p>Purpose</p> <p>Sends a notification message to a specific client or all clients</p> <p>When Called</p> <p>When server needs to display a notification to player(s)</p> <p>Parameters</p> <ul> <li><code>client</code> (Player|nil): Target player to send notification to, or nil for all players</li> <li><code>message</code> (string): The notification message text to display</li> <li><code>notifType</code> (string|nil): Type of notification (\"default\", \"error\", \"success\", \"info\", etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send basic notification to all players\nlia.notices.notify(nil, \"Server restarting in 5 minutes!\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send error notification to specific player\nlocal player = Player(1)\nif IsValid(player) then\n    lia.notices.notify(player, \"You don't have permission to do that!\", \"error\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send notifications to multiple players with different types\nlocal players = player.GetAll()\nfor _, ply in ipairs(players) do\n    if ply:IsAdmin() then\n        lia.notices.notify(ply, \"Admin panel updated\", \"info\")\n        else\n            lia.notices.notify(ply, \"Welcome to the server!\", \"success\")\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.notice/#notifylocalized","title":"notifyLocalized","text":"<p>Purpose</p> <p>Sends a localized notification message to a specific client or all clients</p> <p>When Called</p> <p>When server needs to display a localized notification with parameter substitution</p> <p>Parameters</p> <ul> <li><code>client</code> (Player|nil): Target player to send notification to, or nil for all players</li> <li><code>key</code> (string): Localization key for the message</li> <li><code>notifType</code> (string|nil): Type of notification (\"default\", \"error\", \"success\", \"info\", etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send localized notification to all players\nlia.notices.notifyInfoLocalized(nil, \"server.restart\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send localized notification with one parameter\nlocal player = Player(1)\nlia.notices.notifySuccessLocalized(player, \"player.welcome\", player:Name())\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send localized notifications with multiple parameters\nlocal players = player.GetAll()\nfor _, ply in ipairs(players) do\n    local timeLeft = math.max(0, 300 - CurTime())\n    lia.notices.notifyWarningLocalized(ply, \"server.restart.time\",\n    ply:Name(), math.floor(timeLeft / 60), timeLeft % 60)\nend\n</code></pre></p>"},{"location":"libraries/lia.notice/#liaoriginalreceivenotify","title":"lia.originalReceiveNotify","text":"<p>Purpose</p> <p>Receives and displays notification messages from the server</p> <p>When Called</p> <p>Automatically called when server sends notification data via network</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Function is called automatically when server sends notification\n-- No direct usage needed - handled by network receiver\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom network receiver with additional processing\nnet.Receive(\"liaNotificationData\", function()\nlia.notices.receiveNotify()\n-- Additional custom processing here\nprint(\"Notification received from server\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Override default behavior with custom notification handling\nlocal originalReceiveNotify = lia.notices.receiveNotify\nlia.notices.receiveNotify = function()\nlocal msg = net.ReadString() or \"\"\nlocal ntype = net.ReadString() or \"default\"\n-- Custom processing before creating notice\nif ntype == \"error\" then\n    -- Log errors to file\n    file.Append(\"notifications.log\", os.date() .. \": \" .. msg .. \"\\n\")\nend\n-- Call original function\noriginalReceiveNotify()\nend\n</code></pre></p>"},{"location":"libraries/lia.notice/#receivenotify","title":"receiveNotify","text":"<p>Purpose</p> <p>Receives and displays notification messages from the server</p> <p>When Called</p> <p>Automatically called when server sends notification data via network</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Function is called automatically when server sends notification\n-- No direct usage needed - handled by network receiver\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom network receiver with additional processing\nnet.Receive(\"liaNotificationData\", function()\nlia.notices.receiveNotify()\n-- Additional custom processing here\nprint(\"Notification received from server\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Override default behavior with custom notification handling\nlocal originalReceiveNotify = lia.notices.receiveNotify\nlia.notices.receiveNotify = function()\nlocal msg = net.ReadString() or \"\"\nlocal ntype = net.ReadString() or \"default\"\n-- Custom processing before creating notice\nif ntype == \"error\" then\n    -- Log errors to file\n    file.Append(\"notifications.log\", os.date() .. \": \" .. msg .. \"\\n\")\nend\n-- Call original function\noriginalReceiveNotify()\nend\n</code></pre></p>"},{"location":"libraries/lia.notice/#liaoriginalreceivenotifyl","title":"lia.originalReceiveNotifyL","text":"<p>Purpose</p> <p>Receives and displays localized notification messages from the server</p> <p>When Called</p> <p>Automatically called when server sends localized notification data via network</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Function is called automatically when server sends localized notification\n-- No direct usage needed - handled by network receiver\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom network receiver with additional processing\nnet.Receive(\"liaNotifyLocal\", function()\nlia.notices.receiveNotifyL()\n-- Additional custom processing here\nprint(\"Localized notification received from server\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Override default behavior with custom localized notification handling\nlocal originalReceiveNotifyL = lia.notices.receiveNotifyL\nlia.notices.receiveNotifyL = function()\nlocal key = net.ReadString() or \"\"\nlocal argc = net.ReadUInt(8) or 0\nlocal args = {}\nfor i = 1, argc do\n    args[i] = net.ReadString()\nend\n-- Custom processing before creating notice\nlocal msg = L(key, unpack(args))\nif string.find(msg, \"error\") then\n    -- Log errors to file\n    file.Append(\"notifications.log\", os.date() .. \": \" .. msg .. \"\\n\")\nend\n-- Call original function\noriginalReceiveNotifyL()\nend\n</code></pre></p>"},{"location":"libraries/lia.notice/#receivenotifyl","title":"receiveNotifyL","text":"<p>Purpose</p> <p>Receives and displays localized notification messages from the server</p> <p>When Called</p> <p>Automatically called when server sends localized notification data via network</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Function is called automatically when server sends localized notification\n-- No direct usage needed - handled by network receiver\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Custom network receiver with additional processing\nnet.Receive(\"liaNotifyLocal\", function()\nlia.notices.receiveNotifyL()\n-- Additional custom processing here\nprint(\"Localized notification received from server\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Override default behavior with custom localized notification handling\nlocal originalReceiveNotifyL = lia.notices.receiveNotifyL\nlia.notices.receiveNotifyL = function()\nlocal key = net.ReadString() or \"\"\nlocal argc = net.ReadUInt(8) or 0\nlocal args = {}\nfor i = 1, argc do\n    args[i] = net.ReadString()\nend\n-- Custom processing before creating notice\nlocal msg = L(key, unpack(args))\nif string.find(msg, \"error\") then\n    -- Log errors to file\n    file.Append(\"notifications.log\", os.date() .. \": \" .. msg .. \"\\n\")\nend\n-- Call original function\noriginalReceiveNotifyL()\nend\n</code></pre></p>"},{"location":"libraries/lia.notice/#notify_1","title":"notify","text":"<p>Purpose</p> <p>Creates and displays a notification message directly on the client</p> <p>When Called</p> <p>When client needs to display a notification without server communication</p> <p>Parameters</p> <ul> <li><code>_</code> (any): Ignored parameter (for compatibility with server version)</li> <li><code>message</code> (string): The notification message text to display</li> <li><code>notifType</code> (string|nil): Type of notification (\"default\", \"error\", \"success\", \"info\", etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display basic notification\nlia.notices.notify(nil, \"Settings saved!\", \"success\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display notification with dynamic content\nlocal playerName = LocalPlayer():Name()\nlia.notices.notify(nil, \"Welcome back, \" .. playerName .. \"!\", \"info\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display notifications based on conditions\nlocal player = LocalPlayer()\nif player:GetNWInt(\"health\") &lt; 25 then\n    lia.notices.notify(nil, \"Health critical! Find medical attention!\", \"error\")\n    elseif player:GetNWInt(\"health\") &lt; 50 then\n        lia.notices.notify(nil, \"Health low - be careful!\", \"warning\")\n        else\n            lia.notices.notify(nil, \"Health status: Good\", \"success\")\n        end\n</code></pre></p>"},{"location":"libraries/lia.notice/#notifylocalized_1","title":"notifyLocalized","text":"<p>Purpose</p> <p>Creates and displays a localized notification message directly on the client</p> <p>When Called</p> <p>When client needs to display a localized notification without server communication</p> <p>Parameters</p> <ul> <li><code>client</code> (any): Ignored parameter (for compatibility with server version)</li> <li><code>key</code> (string): Localization key for the message</li> <li><code>notifType</code> (string|nil): Type of notification (\"default\", \"error\", \"success\", \"info\", etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display localized notification\nlia.notices.notifySuccessLocalized(nil, \"ui.settings.saved\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display localized notification with one parameter\nlocal playerName = LocalPlayer():Name()\nlia.notices.notifyInfoLocalized(nil, \"ui.welcome.back\", playerName)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display localized notifications with multiple parameters\nlocal player = LocalPlayer()\nlocal health = player:GetNWInt(\"health\")\nlocal maxHealth = player:GetMaxHealth()\nlocal healthPercent = math.floor((health / maxHealth) * 100)\nif health &lt; 25 then\n    lia.notices.notifyErrorLocalized(nil, \"ui.health.critical\",\n    health, maxHealth, healthPercent)\n    elseif health &lt; 50 then\n        lia.notices.notifyWarningLocalized(nil, \"ui.health.low\",\n        health, maxHealth, healthPercent)\n        else\n            lia.notices.notifySuccessLocalized(nil, \"ui.health.good\",\n            health, maxHealth, healthPercent)\n        end\n</code></pre></p>"},{"location":"libraries/lia.notice/#notifyinfolocalized","title":"notifyInfoLocalized","text":"<p>Purpose</p> <p>Creates and displays a localized notification message directly on the client</p> <p>When Called</p> <p>When client needs to display a localized notification without server communication</p> <p>Parameters</p> <ul> <li><code>client</code> (any): Ignored parameter (for compatibility with server version)</li> <li><code>key</code> (string): Localization key for the message</li> <li><code>notifType</code> (string|nil): Type of notification (\"default\", \"error\", \"success\", \"info\", etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display localized notification\nlia.notices.notifySuccessLocalized(nil, \"ui.settings.saved\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display localized notification with one parameter\nlocal playerName = LocalPlayer():Name()\nlia.notices.notifyInfoLocalized(nil, \"ui.welcome.back\", playerName)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display localized notifications with multiple parameters\nlocal player = LocalPlayer()\nlocal health = player:GetNWInt(\"health\")\nlocal maxHealth = player:GetMaxHealth()\nlocal healthPercent = math.floor((health / maxHealth) * 100)\nif health &lt; 25 then\n    lia.notices.notifyErrorLocalized(nil, \"ui.health.critical\",\n    health, maxHealth, healthPercent)\n    elseif health &lt; 50 then\n        lia.notices.notifyWarningLocalized(nil, \"ui.health.low\",\n        health, maxHealth, healthPercent)\n        else\n            lia.notices.notifySuccessLocalized(nil, \"ui.health.good\",\n            health, maxHealth, healthPercent)\n        end\n</code></pre></p>"},{"location":"libraries/lia.notice/#notifywarninglocalized","title":"notifyWarningLocalized","text":"<p>Purpose</p> <p>Creates and displays a localized notification message directly on the client</p> <p>When Called</p> <p>When client needs to display a localized notification without server communication</p> <p>Parameters</p> <ul> <li><code>client</code> (any): Ignored parameter (for compatibility with server version)</li> <li><code>key</code> (string): Localization key for the message</li> <li><code>notifType</code> (string|nil): Type of notification (\"default\", \"error\", \"success\", \"info\", etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display localized notification\nlia.notices.notifySuccessLocalized(nil, \"ui.settings.saved\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display localized notification with one parameter\nlocal playerName = LocalPlayer():Name()\nlia.notices.notifyInfoLocalized(nil, \"ui.welcome.back\", playerName)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display localized notifications with multiple parameters\nlocal player = LocalPlayer()\nlocal health = player:GetNWInt(\"health\")\nlocal maxHealth = player:GetMaxHealth()\nlocal healthPercent = math.floor((health / maxHealth) * 100)\nif health &lt; 25 then\n    lia.notices.notifyErrorLocalized(nil, \"ui.health.critical\",\n    health, maxHealth, healthPercent)\n    elseif health &lt; 50 then\n        lia.notices.notifyWarningLocalized(nil, \"ui.health.low\",\n        health, maxHealth, healthPercent)\n        else\n            lia.notices.notifySuccessLocalized(nil, \"ui.health.good\",\n            health, maxHealth, healthPercent)\n        end\n</code></pre></p>"},{"location":"libraries/lia.notice/#notifyerrorlocalized","title":"notifyErrorLocalized","text":"<p>Purpose</p> <p>Creates and displays a localized notification message directly on the client</p> <p>When Called</p> <p>When client needs to display a localized notification without server communication</p> <p>Parameters</p> <ul> <li><code>client</code> (any): Ignored parameter (for compatibility with server version)</li> <li><code>key</code> (string): Localization key for the message</li> <li><code>notifType</code> (string|nil): Type of notification (\"default\", \"error\", \"success\", \"info\", etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display localized notification\nlia.notices.notifySuccessLocalized(nil, \"ui.settings.saved\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display localized notification with one parameter\nlocal playerName = LocalPlayer():Name()\nlia.notices.notifyInfoLocalized(nil, \"ui.welcome.back\", playerName)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display localized notifications with multiple parameters\nlocal player = LocalPlayer()\nlocal health = player:GetNWInt(\"health\")\nlocal maxHealth = player:GetMaxHealth()\nlocal healthPercent = math.floor((health / maxHealth) * 100)\nif health &lt; 25 then\n    lia.notices.notifyErrorLocalized(nil, \"ui.health.critical\",\n    health, maxHealth, healthPercent)\n    elseif health &lt; 50 then\n        lia.notices.notifyWarningLocalized(nil, \"ui.health.low\",\n        health, maxHealth, healthPercent)\n        else\n            lia.notices.notifySuccessLocalized(nil, \"ui.health.good\",\n            health, maxHealth, healthPercent)\n        end\n</code></pre></p>"},{"location":"libraries/lia.notice/#notifysuccesslocalized","title":"notifySuccessLocalized","text":"<p>Purpose</p> <p>Creates and displays a localized notification message directly on the client</p> <p>When Called</p> <p>When client needs to display a localized notification without server communication</p> <p>Parameters</p> <ul> <li><code>client</code> (any): Ignored parameter (for compatibility with server version)</li> <li><code>key</code> (string): Localization key for the message</li> <li><code>notifType</code> (string|nil): Type of notification (\"default\", \"error\", \"success\", \"info\", etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display localized notification\nlia.notices.notifySuccessLocalized(nil, \"ui.settings.saved\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display localized notification with one parameter\nlocal playerName = LocalPlayer():Name()\nlia.notices.notifyInfoLocalized(nil, \"ui.welcome.back\", playerName)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display localized notifications with multiple parameters\nlocal player = LocalPlayer()\nlocal health = player:GetNWInt(\"health\")\nlocal maxHealth = player:GetMaxHealth()\nlocal healthPercent = math.floor((health / maxHealth) * 100)\nif health &lt; 25 then\n    lia.notices.notifyErrorLocalized(nil, \"ui.health.critical\",\n    health, maxHealth, healthPercent)\n    elseif health &lt; 50 then\n        lia.notices.notifyWarningLocalized(nil, \"ui.health.low\",\n        health, maxHealth, healthPercent)\n        else\n            lia.notices.notifySuccessLocalized(nil, \"ui.health.good\",\n            health, maxHealth, healthPercent)\n        end\n</code></pre></p>"},{"location":"libraries/lia.notice/#notifymoneylocalized","title":"notifyMoneyLocalized","text":"<p>Purpose</p> <p>Creates and displays a localized notification message directly on the client</p> <p>When Called</p> <p>When client needs to display a localized notification without server communication</p> <p>Parameters</p> <ul> <li><code>client</code> (any): Ignored parameter (for compatibility with server version)</li> <li><code>key</code> (string): Localization key for the message</li> <li><code>notifType</code> (string|nil): Type of notification (\"default\", \"error\", \"success\", \"info\", etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display localized notification\nlia.notices.notifySuccessLocalized(nil, \"ui.settings.saved\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display localized notification with one parameter\nlocal playerName = LocalPlayer():Name()\nlia.notices.notifyInfoLocalized(nil, \"ui.welcome.back\", playerName)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display localized notifications with multiple parameters\nlocal player = LocalPlayer()\nlocal health = player:GetNWInt(\"health\")\nlocal maxHealth = player:GetMaxHealth()\nlocal healthPercent = math.floor((health / maxHealth) * 100)\nif health &lt; 25 then\n    lia.notices.notifyErrorLocalized(nil, \"ui.health.critical\",\n    health, maxHealth, healthPercent)\n    elseif health &lt; 50 then\n        lia.notices.notifyWarningLocalized(nil, \"ui.health.low\",\n        health, maxHealth, healthPercent)\n        else\n            lia.notices.notifySuccessLocalized(nil, \"ui.health.good\",\n            health, maxHealth, healthPercent)\n        end\n</code></pre></p>"},{"location":"libraries/lia.notice/#notifyadminlocalized","title":"notifyAdminLocalized","text":"<p>Purpose</p> <p>Creates and displays a localized notification message directly on the client</p> <p>When Called</p> <p>When client needs to display a localized notification without server communication</p> <p>Parameters</p> <ul> <li><code>client</code> (any): Ignored parameter (for compatibility with server version)</li> <li><code>key</code> (string): Localization key for the message</li> <li><code>notifType</code> (string|nil): Type of notification (\"default\", \"error\", \"success\", \"info\", etc.)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display localized notification\nlia.notices.notifySuccessLocalized(nil, \"ui.settings.saved\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display localized notification with one parameter\nlocal playerName = LocalPlayer():Name()\nlia.notices.notifyInfoLocalized(nil, \"ui.welcome.back\", playerName)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Display localized notifications with multiple parameters\nlocal player = LocalPlayer()\nlocal health = player:GetNWInt(\"health\")\nlocal maxHealth = player:GetMaxHealth()\nlocal healthPercent = math.floor((health / maxHealth) * 100)\nif health &lt; 25 then\n    lia.notices.notifyErrorLocalized(nil, \"ui.health.critical\",\n    health, maxHealth, healthPercent)\n    elseif health &lt; 50 then\n        lia.notices.notifyWarningLocalized(nil, \"ui.health.low\",\n        health, maxHealth, healthPercent)\n        else\n            lia.notices.notifySuccessLocalized(nil, \"ui.health.good\",\n            health, maxHealth, healthPercent)\n        end\n</code></pre></p>"},{"location":"libraries/lia.notice/#liaoriginaladdlegacy","title":"lia.originalAddLegacy","text":"<p>Purpose</p> <p>Provides compatibility with Garry's Mod's legacy notification system</p> <p>When Called</p> <p>When legacy notification functions are used (e.g., notification.AddLegacy)</p> <p>Parameters</p> <ul> <li><code>text</code> (string): The notification message text to display</li> <li><code>typeId</code> (number): Legacy notification type ID (0=info, 1=error, 2=success)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Use legacy notification system\nnotification.AddLegacy(\"Server restarting!\", 0)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Convert legacy notifications to new system\nlocal legacyTypes = {[0] = \"info\", [1] = \"error\", [2] = \"success\"}\nlocal message = \"Player disconnected\"\nlocal typeId = 1\nnotification.AddLegacy(message, typeId)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Override legacy notification with custom handling\nlocal originalAddLegacy = notification.AddLegacy\nnotification.AddLegacy = function(text, typeId)\nlocal map = {[0] = \"info\", [1] = \"error\", [2] = \"success\"}\nlocal notifType = map[tonumber(typeId) or -1] or \"default\"\n-- Custom processing\nif notifType == \"error\" then\n    -- Log errors to file\n    file.Append(\"legacy_notifications.log\", os.date() .. \": \" .. text .. \"\\n\")\nend\n-- Call original function\noriginalAddLegacy(text, typeId)\nend\n</code></pre></p>"},{"location":"libraries/lia.notice/#lianotificationaddlegacy","title":"lia.notification.AddLegacy","text":"<p>Purpose</p> <p>Provides compatibility with Garry's Mod's legacy notification system</p> <p>When Called</p> <p>When legacy notification functions are used (e.g., notification.AddLegacy)</p> <p>Parameters</p> <ul> <li><code>text</code> (string): The notification message text to display</li> <li><code>typeId</code> (number): Legacy notification type ID (0=info, 1=error, 2=success)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Use legacy notification system\nnotification.AddLegacy(\"Server restarting!\", 0)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Convert legacy notifications to new system\nlocal legacyTypes = {[0] = \"info\", [1] = \"error\", [2] = \"success\"}\nlocal message = \"Player disconnected\"\nlocal typeId = 1\nnotification.AddLegacy(message, typeId)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Override legacy notification with custom handling\nlocal originalAddLegacy = notification.AddLegacy\nnotification.AddLegacy = function(text, typeId)\nlocal map = {[0] = \"info\", [1] = \"error\", [2] = \"success\"}\nlocal notifType = map[tonumber(typeId) or -1] or \"default\"\n-- Custom processing\nif notifType == \"error\" then\n    -- Log errors to file\n    file.Append(\"legacy_notifications.log\", os.date() .. \": \" .. text .. \"\\n\")\nend\n-- Call original function\noriginalAddLegacy(text, typeId)\nend\n</code></pre></p>"},{"location":"libraries/lia.notice/#liaorganizenotices","title":"lia.OrganizeNotices","text":"<p>Purpose</p> <p>Organizes and positions notification panels on the screen</p> <p>When Called</p> <p>Automatically called when new notifications are created</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Function is called automatically when notifications are created\n-- No direct usage needed - handled internally\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Manually organize notices after bulk creation\nfor i = 1, 5 do\n    lia.notices.notify(nil, \"Notification \" .. i, \"info\")\nend\nOrganizeNotices() -- Ensure proper positioning\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom notice organization with different positioning\nlocal originalOrganizeNotices = OrganizeNotices\nOrganizeNotices = function()\nlocal scale = ScrH() / 1080\nlocal baseY = ScrH() - 300 * scale -- Different base position\nlocal spacing = 8 * scale -- Different spacing\nlocal y = baseY\nfor _, v in ipairs(lia.notices) do\n    if IsValid(v) then\n        v.targetY = y\n        -- Add custom animation\n        v:MoveTo(v:GetX(), y, 0.3, 0, 0.5)\n        y = y - (v:GetTall() + spacing)\n    end\nend\nend\n</code></pre></p>"},{"location":"libraries/lia.option/","title":"Option Library","text":"<p>User-configurable settings management system for the Lilia framework.</p> <p>Overview</p> <p>The option library provides comprehensive functionality for managing user-configurable settings in the Lilia framework. It handles the creation, storage, retrieval, and persistence of various types of options including boolean toggles, numeric sliders, color pickers, text inputs, and dropdown selections. The library operates on both client and server sides, with automatic persistence to JSON files and optional networking capabilities for server-side options. It includes a complete user interface system for displaying and modifying options through the configuration menu, with support for categories, visibility conditions, and real-time updates. The library ensures that all user preferences are maintained across sessions and provides hooks for modules to react to option changes.</p>"},{"location":"libraries/lia.option/#add","title":"add","text":"<p>Purpose</p> <p>Registers a new configurable option in the Lilia framework with automatic type detection and UI generation</p> <p>When Called</p> <p>During module initialization or when adding new user-configurable settings</p> <p>Parameters</p> <ul> <li><code>key</code> (string): Unique identifier for the option</li> <li><code>name</code> (string): Display name for the option (can be localized)</li> <li><code>desc</code> (string): Description text for the option (can be localized)</li> <li><code>default</code> (any): Default value for the option</li> <li><code>callback</code> (function, optional): Function called when option value changes (oldValue, newValue)</li> <li><code>data</code> (table): Configuration data containing type, category, min/max values, etc.</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a boolean toggle option\nlia.option.add(\"showHUD\", \"Show HUD\", \"Toggle HUD visibility\", true, nil, {\ncategory = \"categoryGeneral\",\nisQuick = true\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add a numeric slider with callback\nlia.option.add(\"volume\", \"Volume\", \"Master volume level\", 0.8, function(oldVal, newVal)\nRunConsoleCommand(\"volume\", tostring(newVal))\nend, {\ncategory = \"categoryAudio\",\nmin = 0,\nmax = 1,\ndecimals = 2\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add a color picker with visibility condition and networking\nlia.option.add(\"espColor\", \"ESP Color\", \"Color for ESP display\", Color(255, 0, 0), nil, {\ncategory = \"categoryESP\",\nvisible = function()\nreturn LocalPlayer():isStaffOnDuty()\nend,\nshouldNetwork = true,\ntype = \"Color\"\n})\n</code></pre></p>"},{"location":"libraries/lia.option/#getoptions","title":"getOptions","text":"<p>Purpose</p> <p>Retrieves the available options for a dropdown/selection type option, handling both static and dynamic option lists</p> <p>When Called</p> <p>When rendering dropdown options in the UI or when modules need to access option choices</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The option key to get choices for</li> </ul> <p>Returns</p> <ul> <li>table - Array of available option choices (localized strings)</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get static options for a dropdown\nlocal options = lia.option.getOptions(\"weaponSelectorPosition\")\n-- Returns: {\"Left\", \"Right\", \"Center\"}\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use options in UI creation\nlocal combo = vgui.Create(\"liaComboBox\")\nlocal options = lia.option.getOptions(\"language\")\nfor _, option in pairs(options) do\n    combo:AddChoice(option, option)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic options with validation\nlocal options = lia.option.getOptions(\"teamSelection\")\nif #options &gt; 0 then\n    for i, option in ipairs(options) do\n        if option and option ~= \"\" then\n            teamCombo:AddChoice(option, option)\n        end\n    end\n    else\n        teamCombo:AddChoice(\"No teams available\", \"\")\n    end\n</code></pre></p>"},{"location":"libraries/lia.option/#set","title":"set","text":"<p>Purpose</p> <p>Sets the value of an option, triggers callbacks, saves to file, and optionally networks to clients</p> <p>When Called</p> <p>When user changes an option value through UI or when programmatically updating option values</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The option key to set</li> <li><code>value</code> (any): The new value to set for the option</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set a boolean option\nlia.option.set(\"showHUD\", true)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set option with callback execution\nlia.option.set(\"volume\", 0.5)\n-- This will trigger the callback function if one was defined\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Set multiple options with validation\nlocal optionsToSet = {\n{\"showHUD\", true},\n{\"volume\", 0.8},\n{\"espColor\", Color(255, 0, 0)}\n}\nfor _, optionData in ipairs(optionsToSet) do\n    local key, value = optionData[1], optionData[2]\n    if lia.option.stored[key] then\n        lia.option.set(key, value)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.option/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves the current value of an option, falling back to default value or provided fallback if not set</p> <p>When Called</p> <p>When modules need to read option values for configuration or when UI needs to display current values</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The option key to retrieve</li> <li><code>default</code> (any, optional): Fallback value if option doesn't exist or has no value</li> </ul> <p>Returns</p> <ul> <li>any - The current option value, default value, or provided fallback</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a boolean option\nlocal showHUD = lia.option.get(\"showHUD\")\nif showHUD then\n    -- HUD is enabled\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get option with fallback\nlocal volume = lia.option.get(\"volume\", 0.5)\nRunConsoleCommand(\"volume\", tostring(volume))\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get multiple options with validation and type checking\nlocal config = {\nshowHUD = lia.option.get(\"showHUD\", true),\nvolume = lia.option.get(\"volume\", 0.8),\nespColor = lia.option.get(\"espColor\", Color(255, 0, 0))\n}\n-- Validate and apply configuration\nif type(config.showHUD) == \"boolean\" then\n    hook.Run(\"HUDVisibilityChanged\", config.showHUD)\nend\nif type(config.volume) == \"number\" and config.volume &gt;= 0 and config.volume &lt;= 1 then\n    RunConsoleCommand(\"volume\", tostring(config.volume))\nend\n</code></pre></p>"},{"location":"libraries/lia.option/#save","title":"save","text":"<p>Purpose</p> <p>Saves all current option values to a JSON file for persistence across sessions</p> <p>When Called</p> <p>Automatically called when options are changed, or manually when saving configuration</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Save options after changes\nlia.option.set(\"showHUD\", true)\nlia.option.save() -- Automatically called, but can be called manually\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save options with error handling\nlocal function saveOptionsSafely()\n    local success, err = pcall(lia.option.save)\n    if not success then\n        print(\"Failed to save options: \" .. tostring(err))\n    end\nend\nsaveOptionsSafely()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch save with validation and backup\nlocal function batchSaveOptions()\n    -- Create backup of current options\n    local backupPath = \"lilia/options_backup_\" .. os.time() .. \".json\"\n    local currentData = file.Read(\"lilia/options.json\", \"DATA\")\n    if currentData then\n        file.Write(backupPath, currentData)\n    end\n    -- Save current options\n    lia.option.save()\n    -- Verify save was successful\n    local savedData = file.Read(\"lilia/options.json\", \"DATA\")\n    if savedData then\n        print(\"Options saved successfully\")\n        else\n            print(\"Failed to save options\")\n        end\n    end\n    batchSaveOptions()\n</code></pre></p>"},{"location":"libraries/lia.option/#load","title":"load","text":"<p>Purpose</p> <p>Loads saved option values from JSON file and initializes options with defaults if no saved data exists</p> <p>When Called</p> <p>During client initialization or when manually reloading option configuration</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load options at startup\nlia.option.load()\n-- This is typically called automatically during initialization\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load options with error handling\nlocal function loadOptionsSafely()\n    local success, err = pcall(lia.option.load)\n    if not success then\n        print(\"Failed to load options: \" .. tostring(err))\n        -- Reset to defaults\n        for key, option in pairs(lia.option.stored) do\n            option.value = option.default\n        end\n    end\nend\nloadOptionsSafely()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Load options with validation and migration\nlocal function loadOptionsWithMigration()\n    -- Check if options file exists\n    if file.Exists(\"lilia/options.json\", \"DATA\") then\n        local data = file.Read(\"lilia/options.json\", \"DATA\")\n        if data then\n            local saved = util.JSONToTable(data)\n            if saved then\n                -- Validate and migrate old option formats\n                for key, value in pairs(saved) do\n                    if lia.option.stored[key] then\n                        local option = lia.option.stored[key]\n                        -- Type validation\n                        if option.type == \"Boolean\" and type(value) ~= \"boolean\" then\n                            value = tobool(value)\n                            elseif option.type == \"Int\" and type(value) ~= \"number\" then\n                                value = tonumber(value) or option.default\n                            end\n                            option.value = value\n                        end\n                    end\n                end\n            end\n            else\n                -- No saved options, use defaults\n                lia.option.load()\n            end\n            -- Trigger initialization hook\n            hook.Run(\"InitializedOptions\")\n        end\n        loadOptionsWithMigration()\n</code></pre></p>"},{"location":"libraries/lia.playerinteract/","title":"Player Interaction Library","text":"<p>Player-to-player and entity interaction management system for the Lilia framework.</p> <p>Overview</p> <p>The player interaction library provides comprehensive functionality for managing player interactions and actions within the Lilia framework. It handles the creation, registration, and execution of various interaction types including player-to-player interactions, entity interactions, and personal actions. The library operates on both server and client sides, with the server managing interaction registration and validation, while the client handles UI display and user input. It includes range checking, timed actions, and network synchronization to ensure consistent interaction behavior across all clients. The library supports both immediate and delayed actions with progress indicators, making it suitable for complex interaction systems like money transfers, voice changes, and other gameplay mechanics.</p>"},{"location":"libraries/lia.playerinteract/#iswithinrange","title":"isWithinRange","text":"<p>Purpose</p> <p>Checks if a client is within interaction range of an entity</p> <p>When Called</p> <p>Called when determining if an interaction should be available to a player</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting the interaction</li> <li><code>entity</code> (Entity): The target entity to check distance against</li> <li><code>customRange</code> (number, optional): Custom range override (defaults to 250 units)</li> </ul> <p>Returns</p> <ul> <li>boolean - true if within range, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player is within default range of an entity\nif lia.playerinteract.isWithinRange(client, targetEntity) then\n    -- Player is within 250 units\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check with custom range for specific interaction\nlocal customRange = 100\nif lia.playerinteract.isWithinRange(client, targetEntity, customRange) then\n    -- Player is within 100 units for close-range interaction\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic range checking with validation\nlocal interactionRange = interactionData.range or 250\nif IsValid(client) and IsValid(targetEntity) and\nlia.playerinteract.isWithinRange(client, targetEntity, interactionRange) then\n-- Player is within specified range for this interaction type\nreturn true\nend\n</code></pre></p>"},{"location":"libraries/lia.playerinteract/#getinteractions","title":"getInteractions","text":"<p>Purpose</p> <p>Retrieves all available interactions for a client based on their traced entity</p> <p>When Called</p> <p>Called when opening interaction menu or checking available interactions</p> <p>Parameters</p> <ul> <li><code>client</code> (Player, optional): The player to get interactions for (defaults to LocalPlayer())</li> </ul> <p>Returns</p> <ul> <li>table - Dictionary of available interactions indexed by interaction name</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all available interactions for local player\nlocal interactions = lia.playerinteract.getInteractions()\nfor name, interaction in pairs(interactions) do\n    print(\"Available interaction:\", name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get interactions for specific player with validation\nlocal client = LocalPlayer()\nif IsValid(client) then\n    local interactions = lia.playerinteract.getInteractions(client)\n    local interactionCount = table.Count(interactions)\n    if interactionCount &gt; 0 then\n        -- Player has interactions available\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Filter interactions by category and validate conditions\nlocal interactions = lia.playerinteract.getInteractions()\nlocal filteredInteractions = {}\nfor name, interaction in pairs(interactions) do\n    if interaction.category == \"Voice\" and\n    (not interaction.shouldShow or interaction.shouldShow(LocalPlayer())) then\n    filteredInteractions[name] = interaction\nend\nend\n</code></pre></p>"},{"location":"libraries/lia.playerinteract/#getactions","title":"getActions","text":"<p>Purpose</p> <p>Retrieves all available personal actions for a client</p> <p>When Called</p> <p>Called when opening personal actions menu or checking available actions</p> <p>Parameters</p> <ul> <li><code>client</code> (Player, optional): The player to get actions for (defaults to LocalPlayer())</li> </ul> <p>Returns</p> <ul> <li>table - Dictionary of available actions indexed by action name</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all available personal actions\nlocal actions = lia.playerinteract.getActions()\nfor name, action in pairs(actions) do\n    print(\"Available action:\", name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get actions with character validation\nlocal client = LocalPlayer()\nif IsValid(client) and client:getChar() then\n    local actions = lia.playerinteract.getActions(client)\n    local actionCount = table.Count(actions)\n    if actionCount &gt; 0 then\n        -- Player has actions available\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Filter actions by category and execute specific ones\nlocal actions = lia.playerinteract.getActions()\nlocal voiceActions = {}\nfor name, action in pairs(actions) do\n    if action.category == L(\"categoryVoice\") and\n    (not action.shouldShow or action.shouldShow(LocalPlayer())) then\n    voiceActions[name] = action\nend\nend\n</code></pre></p>"},{"location":"libraries/lia.playerinteract/#getcategorizedoptions","title":"getCategorizedOptions","text":"<p>Purpose</p> <p>Prepares interaction/action options for UI display in a flat list</p> <p>When Called</p> <p>Called when preparing options for display in the interaction menu</p> <p>Parameters</p> <ul> <li><code>options</code> (table): Dictionary of options to prepare</li> </ul> <p>Returns</p> <ul> <li>table - Array of options for flat display</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get options for display\nlocal interactions = lia.playerinteract.getInteractions()\nlocal optionsList = lia.playerinteract.getCategorizedOptions(interactions)\nfor _, option in pairs(optionsList) do\n    print(\"Option:\", option.name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Process options for custom display\nlocal actions = lia.playerinteract.getActions()\nlocal optionsList = lia.playerinteract.getCategorizedOptions(actions)\nlocal count = #optionsList\nif count &gt; 0 then\n    -- Options are ready for display\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Filter and process options\nlocal interactions = lia.playerinteract.getInteractions()\nlocal optionsList = lia.playerinteract.getCategorizedOptions(interactions)\nlocal filteredOptions = {}\nfor _, option in pairs(optionsList) do\n    if option.opt.category == \"Voice\" then\n        table.insert(filteredOptions, option)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.playerinteract/#addinteraction","title":"addInteraction","text":"<p>Purpose</p> <p>Registers a new player-to-player or player-to-entity interaction</p> <p>When Called</p> <p>Called during module initialization or when registering custom interactions</p> <p>Parameters</p> <ul> <li><code>name</code> (string): Unique identifier for the interaction</li> <li><code>data</code> (table): Interaction configuration table containing:</li> <li><code>serverOnly</code> (boolean, optional): Whether interaction runs server-side only</li> <li><code>shouldShow</code> (function, optional): Function to determine if interaction should be visible</li> <li><code>onRun</code> (function): Function to execute when interaction is triggered</li> <li><code>range</code> (number, optional): Interaction range in units (defaults to 250)</li> <li><code>category</code> (string, optional): Category for UI organization</li> <li><code>target</code> (string, optional): Target type - \"player\", \"entity\", or \"any\" (defaults to \"player\")</li> <li><code>timeToComplete</code> (number, optional): Time in seconds for timed interactions</li> <li><code>actionText</code> (string, optional): Text shown to performing player during timed action</li> <li><code>targetActionText</code> (string, optional): Text shown to target player during timed action</li> <li><code>categoryColor</code> (Color, optional): Color for category display</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic player interaction\nlia.playerinteract.addInteraction(\"giveMoney\", {\nshouldShow = function(client, target)\nreturn IsValid(target) and target:IsPlayer() and client:getChar():getMoney() &gt; 0\nend,\nonRun = function(client, target)\n-- Give money logic here\nend\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add timed interaction with progress indicators\nlia.playerinteract.addInteraction(\"healPlayer\", {\ncategory = \"Medical\",\nrange = 100,\ntimeToComplete = 5,\nactionText = \"Healing player...\",\ntargetActionText = \"Being healed...\",\nshouldShow = function(client, target)\nreturn IsValid(target) and target:IsPlayer() and target:Health() &lt; target:GetMaxHealth()\nend,\nonRun = function(client, target)\ntarget:SetHealth(target:GetMaxHealth())\nclient:notify(\"Player healed successfully!\")\nend\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex interaction with validation and server-side processing\nlia.playerinteract.addInteraction(\"arrestPlayer\", {\nserverOnly = true,\ncategory = \"Law Enforcement\",\nrange = 150,\ntimeToComplete = 3,\nactionText = \"Arresting suspect...\",\ntargetActionText = \"Being arrested...\",\nshouldShow = function(client, target)\nif not IsValid(target) or not target:IsPlayer() then return false end\n    if not client:getChar() or not target:getChar() then return false end\n        return client:getChar():getFaction() == FACTION_POLICE and\n        target:getChar():getFaction() ~= FACTION_POLICE\n    end,\n    onRun = function(client, target)\n    -- Complex arrest logic with validation\n    if lia.config.get(\"DisableCheaterActions\", true) and client:getNetVar(\"cheater\", false) then\n        lia.log.add(client, \"cheaterAction\", \"Attempted arrest while flagged as cheater\")\n        client:notifyWarningLocalized(\"maybeYouShouldntHaveCheated\")\n        return\n    end\n    target:getChar():setData(\"arrested\", true)\n    target:StripWeapons()\n    client:notify(\"Suspect arrested!\")\n    target:notify(\"You have been arrested!\")\nend\n})\n</code></pre></p>"},{"location":"libraries/lia.playerinteract/#addaction","title":"addAction","text":"<p>Purpose</p> <p>Registers a new personal action that doesn't require a target entity</p> <p>When Called</p> <p>Called during module initialization or when registering custom personal actions</p> <p>Parameters</p> <ul> <li><code>name</code> (string): Unique identifier for the action</li> <li><code>data</code> (table): Action configuration table containing:</li> <li><code>serverOnly</code> (boolean, optional): Whether action runs server-side only</li> <li><code>shouldShow</code> (function, optional): Function to determine if action should be visible</li> <li><code>onRun</code> (function): Function to execute when action is triggered</li> <li><code>range</code> (number, optional): Action range in units (defaults to 250)</li> <li><code>category</code> (string, optional): Category for UI organization</li> <li><code>timeToComplete</code> (number, optional): Time in seconds for timed actions</li> <li><code>actionText</code> (string, optional): Text shown to performing player during timed action</li> <li><code>targetActionText</code> (string, optional): Text shown to target player during timed action</li> <li><code>categoryColor</code> (Color, optional): Color for category display</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic personal action\nlia.playerinteract.addAction(\"changeToWhisper\", {\ncategory = L(\"categoryVoice\"),\nshouldShow = function(client)\nreturn client:getChar() and client:Alive() and\nclient:getNetVar(\"VoiceType\") ~= L(\"whispering\")\nend,\nonRun = function(client)\nclient:setNetVar(\"VoiceType\", L(\"whispering\"))\nclient:notifyInfoLocalized(\"voiceModeSet\", L(\"whispering\"))\nend\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add timed personal action with progress indicator\nlia.playerinteract.addAction(\"meditate\", {\ncategory = \"Personal\",\ntimeToComplete = 10,\nactionText = \"Meditating...\",\nshouldShow = function(client)\nreturn client:getChar() and client:Alive() and\nnot client:getNetVar(\"meditating\", false)\nend,\nonRun = function(client)\nclient:setNetVar(\"meditating\", true)\nclient:SetHealth(math.min(client:Health() + 25, client:GetMaxHealth()))\nclient:notify(\"Meditation complete! Health restored.\")\ntimer.Simple(1, function()\nif IsValid(client) then\n    client:setNetVar(\"meditating\", false)\nend\nend)\nend\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex personal action with multiple conditions and effects\nlia.playerinteract.addAction(\"emergencyCall\", {\nserverOnly = true,\ncategory = \"Emergency\",\ntimeToComplete = 5,\nactionText = \"Calling emergency services...\",\nshouldShow = function(client)\nif not client:getChar() or not client:Alive() then return false end\n    local char = client:getChar()\n    if char:getFaction() == FACTION_POLICE or char:getFaction() == FACTION_MEDIC then\n        return false -- Emergency services don't need to call themselves\n    end\n    return not client:getNetVar(\"emergencyCooldown\", false)\nend,\nonRun = function(client)\n-- Set cooldown to prevent spam\nclient:setNetVar(\"emergencyCooldown\", true)\ntimer.Simple(300, function() -- 5 minute cooldown\nif IsValid(client) then\n    client:setNetVar(\"emergencyCooldown\", false)\nend\nend)\n-- Notify emergency services\nlocal emergencyMsg = string.format(\n\"Emergency call from %s at %s\",\nclient:getChar():getDisplayedName(),\nclient:GetPos()\n)\nfor _, ply in ipairs(player.GetAll()) do\n    if ply:getChar() and ply:getChar():getFaction() == FACTION_POLICE then\n        ply:notify(emergencyMsg)\n    end\nend\nclient:notify(\"Emergency services have been notified!\")\nend\n})\n</code></pre></p>"},{"location":"libraries/lia.playerinteract/#liasyncinteractionstoclient","title":"lia.syncInteractionsToClient","text":"<p>Purpose</p> <p>Synchronizes interaction and action data from server to clients</p> <p>When Called</p> <p>Called when interactions/actions are added or when clients connect</p> <p>Parameters</p> <ul> <li><code>client</code> (Player, optional): Specific client to sync to (if nil, syncs to all players)</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Sync all interactions to all clients\nlia.playerinteract.syncToClients()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Sync to specific client after they connect\nhook.Add(\"PlayerInitialSpawn\", \"SyncInteractions\", function(client)\ntimer.Simple(2, function() -- Wait for client to fully load\nif IsValid(client) then\n    lia.playerinteract.syncToClients(client)\nend\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Conditional sync with validation and error handling\nfunction syncInteractionsToClient(client)\n    if not IsValid(client) then return end\n        -- Check if client is ready\n        if not client:IsConnected() or not client:getChar() then\n            timer.Simple(1, function()\n            syncInteractionsToClient(client)\n        end)\n        return\n    end\n    -- Sync with custom filtering\n    local filteredData = {}\n    for name, data in pairs(lia.playerinteract.stored) do\n        -- Only sync non-admin interactions to regular players\n        if not data.adminOnly or client:IsAdmin() then\n            filteredData[name] = {\n            type = data.type,\n            serverOnly = data.serverOnly and true or false,\n            name = name,\n            range = data.range,\n            category = data.category or L(\"categoryUnsorted\"),\n            target = data.target,\n            timeToComplete = data.timeToComplete,\n            actionText = data.actionText,\n            targetActionText = data.targetActionText\n            }\n        end\n    end\n    lia.net.writeBigTable(client, \"liaPlayerInteractSync\", filteredData)\n    lia.net.writeBigTable(client, \"liaPlayerInteractCategories\", lia.playerinteract.categories)\nend\n</code></pre></p>"},{"location":"libraries/lia.playerinteract/#synctoclients","title":"syncToClients","text":"<p>Purpose</p> <p>Synchronizes interaction and action data from server to clients</p> <p>When Called</p> <p>Called when interactions/actions are added or when clients connect</p> <p>Parameters</p> <ul> <li><code>client</code> (Player, optional): Specific client to sync to (if nil, syncs to all players)</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Sync all interactions to all clients\nlia.playerinteract.syncToClients()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Sync to specific client after they connect\nhook.Add(\"PlayerInitialSpawn\", \"SyncInteractions\", function(client)\ntimer.Simple(2, function() -- Wait for client to fully load\nif IsValid(client) then\n    lia.playerinteract.syncToClients(client)\nend\nend)\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Conditional sync with validation and error handling\nfunction syncInteractionsToClient(client)\n    if not IsValid(client) then return end\n        -- Check if client is ready\n        if not client:IsConnected() or not client:getChar() then\n            timer.Simple(1, function()\n            syncInteractionsToClient(client)\n        end)\n        return\n    end\n    -- Sync with custom filtering\n    local filteredData = {}\n    for name, data in pairs(lia.playerinteract.stored) do\n        -- Only sync non-admin interactions to regular players\n        if not data.adminOnly or client:IsAdmin() then\n            filteredData[name] = {\n            type = data.type,\n            serverOnly = data.serverOnly and true or false,\n            name = name,\n            range = data.range,\n            category = data.category or L(\"categoryUnsorted\"),\n            target = data.target,\n            timeToComplete = data.timeToComplete,\n            actionText = data.actionText,\n            targetActionText = data.targetActionText\n            }\n        end\n    end\n    lia.net.writeBigTable(client, \"liaPlayerInteractSync\", filteredData)\n    lia.net.writeBigTable(client, \"liaPlayerInteractCategories\", lia.playerinteract.categories)\nend\n</code></pre></p>"},{"location":"libraries/lia.playerinteract/#openmenu","title":"openMenu","text":"<p>Purpose</p> <p>Opens the interaction/action menu UI by delegating to lia.derma.optionsMenu</p> <p>When Called</p> <p>Called when player presses interaction keybind or requests menu</p> <p>Parameters</p> <ul> <li><code>options</code> (table): Dictionary of available options to display</li> <li><code>isInteraction</code> (boolean): Whether this is an interaction menu (true) or action menu (false)</li> <li><code>titleText</code> (string): Title text to display at top of menu</li> <li><code>closeKey</code> (number): Key code that closes the menu when released</li> <li><code>netMsg</code> (string): Network message name for server-only interactions</li> <li><code>preFiltered</code> (boolean, optional): Whether options are already filtered (defaults to false)</li> </ul> <p>Returns</p> <ul> <li>Panel - The created menu frame (returns from lia.derma.optionsMenu)</li> </ul> <p>Realm</p> <p>Client Note: This function is now a thin wrapper around lia.derma.optionsMenu for backwards compatibility.</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Open basic interaction menu\nlocal interactions = lia.playerinteract.getInteractions()\nlia.playerinteract.openMenu(interactions, true, \"Interactions\", KEY_TAB, \"liaRequestInteractOptions\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Open action menu with custom title and key\nlocal actions = lia.playerinteract.getActions()\nlia.playerinteract.openMenu(actions, false, \"Personal Actions\", KEY_G, \"liaRequestInteractOptions\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Custom menu with pre-filtered options and validation\nlocal client = LocalPlayer()\nif not IsValid(client) then return end\n    local interactions = lia.playerinteract.getInteractions(client)\n    local filteredInteractions = {}\n    -- Filter interactions based on custom criteria\n    for name, interaction in pairs(interactions) do\n        if interaction.category == \"Voice\" and\n        (not interaction.shouldShow or interaction.shouldShow(client)) then\n        filteredInteractions[name] = interaction\n    end\nend\nif table.Count(filteredInteractions) &gt; 0 then\n    lia.playerinteract.openMenu(\n    filteredInteractions,\n    true,\n    \"Voice Interactions\",\n    KEY_TAB,\n    \"liaRequestInteractOptions\",\n    true -- preFiltered\n    )\n    else\n        client:notify(\"No voice interactions available!\")\n    end\n</code></pre></p>"},{"location":"libraries/lia.time/","title":"Time Library","text":"<p>Time manipulation, formatting, and calculation system for the Lilia framework.</p> <p>Overview</p> <p>The time library provides comprehensive functionality for time manipulation, formatting, and calculation within the Lilia framework. It handles time parsing, formatting, relative time calculations, and date/time display with support for both 24-hour and 12-hour (American) time formats. The library operates on both server and client sides, providing consistent time handling across the gamemode. It includes functions for calculating time differences, formatting durations, parsing date strings, and generating localized time displays. The library ensures proper time zone handling and supports configurable time format preferences.</p>"},{"location":"libraries/lia.time/#timesince","title":"timeSince","text":"<p>Purpose</p> <p>Calculate and return a human-readable string representing how long ago a given time was</p> <p>When Called</p> <p>When displaying relative timestamps, such as \"last seen\" times, message timestamps, or activity logs</p> <p>Parameters</p> <ul> <li><code>strTime</code> (string|number): Either a timestamp number or a date string in \"YYYY-MM-DD\" format</li> </ul> <p>Returns</p> <ul> <li>string - Localized string indicating time elapsed (e.g., \"5 minutes ago\", \"2 hours ago\", \"3 days ago\")</li> </ul> <p>Realm</p> <p>Shared (works on both client and server)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get time since a timestamp\nlocal lastSeen = lia.time.timeSince(1640995200) -- Returns \"2 hours ago\"\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get time since a date string with validation\nlocal playerData = {lastLogin = \"2024-01-01\"}\nif playerData.lastLogin then\n    local timeAgo = lia.time.timeSince(playerData.lastLogin)\n    print(\"Player last seen: \" .. timeAgo)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch process multiple timestamps with error handling\nlocal timestamps = {1640995200, \"2024-01-01\", 1641081600}\nfor i, timestamp in ipairs(timestamps) do\n    local result = lia.time.timeSince(timestamp)\n    if result ~= L(\"invalidDate\") and result ~= L(\"invalidInput\") then\n        print(\"Item \" .. i .. \" was created \" .. result)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.time/#tonumber","title":"toNumber","text":"<p>Purpose</p> <p>Parse a date/time string and convert it into a structured table with individual time components</p> <p>When Called</p> <p>When converting date strings to structured data for further processing or validation</p> <p>Parameters</p> <ul> <li><code>str</code> (string, optional): Date string in \"YYYY-MM-DD HH:MM:SS\" format, defaults to current time if nil</li> </ul> <p>Returns</p> <ul> <li>table - Table containing year, month, day, hour, min, sec as numbers</li> </ul> <p>Realm</p> <p>Shared (works on both client and server)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Parse current time\nlocal timeData = lia.time.toNumber() -- Returns current time components\nprint(timeData.year) -- Prints current year\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Parse specific date with validation\nlocal dateStr = \"2024-01-15 14:30:45\"\nlocal timeData = lia.time.toNumber(dateStr)\nif timeData.year and timeData.month then\n    print(\"Year: \" .. timeData.year .. \", Month: \" .. timeData.month)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch parse multiple dates and validate ranges\nlocal dates = {\"2024-01-01 00:00:00\", \"2024-12-31 23:59:59\", \"2023-06-15 12:30:00\"}\nfor i, dateStr in ipairs(dates) do\n    local timeData = lia.time.toNumber(dateStr)\n    if timeData.year &gt;= 2024 and timeData.month &lt;= 12 then\n        print(\"Valid date \" .. i .. \": \" .. timeData.day .. \"/\" .. timeData.month .. \"/\" .. timeData.year)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.time/#getdate","title":"getDate","text":"<p>Purpose</p> <p>Get a formatted, localized string representation of the current date and time</p> <p>When Called</p> <p>When displaying current date/time in UI elements, logs, or status displays</p> <p>Returns</p> <ul> <li>string - Formatted date string with localized weekday and month names</li> </ul> <p>Realm</p> <p>Shared (works on both client and server)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Display current date\nlocal currentDate = lia.time.getDate()\nprint(\"Current time: \" .. currentDate)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in UI with conditional formatting\nlocal dateStr = lia.time.getDate()\nlocal isAmerican = lia.config.get(\"AmericanTimeStamps\", false)\nlocal displayText = isAmerican and \"US Time: \" .. dateStr or \"Time: \" .. dateStr\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Log system with date formatting and multiple outputs\nlocal function logWithTimestamp(message)\n    local timestamp = lia.time.getDate()\n    local logEntry = \"[\" .. timestamp .. \"] \" .. message\n    -- Log to console\n    print(logEntry)\n    -- Log to file (if file logging exists)\n    if file.Exists(\"logs/server.log\", \"DATA\") then\n        file.Append(\"logs/server.log\", logEntry .. \"\\n\")\n    end\n    -- Send to admin chat\n    for _, admin in ipairs(player.GetAll()) do\n        if admin:IsAdmin() then\n            admin:ChatPrint(logEntry)\n        end\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.time/#formatdhm","title":"formatDHM","text":"<p>Purpose</p> <p>Format a duration in seconds into a human-readable string showing days, hours, and minutes</p> <p>When Called</p> <p>When displaying durations, cooldowns, or time remaining in UI elements</p> <p>Parameters</p> <ul> <li><code>seconds</code> (number, optional): Duration in seconds to format, defaults to 0 if nil</li> </ul> <p>Returns</p> <ul> <li>string - Localized string showing days, hours, and minutes (e.g., \"2 days, 5 hours, 30 minutes\")</li> </ul> <p>Realm</p> <p>Shared (works on both client and server)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Format a duration\nlocal duration = lia.time.formatDHM(90000) -- Returns \"1 day, 1 hour, 0 minutes\"\nprint(\"Time remaining: \" .. duration)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Format cooldown with validation\nlocal cooldownTime = player:GetNWInt(\"cooldown\", 0)\nif cooldownTime &gt; 0 then\n    local formatted = lia.time.formatDHM(cooldownTime)\n    player:ChatPrint(\"Cooldown remaining: \" .. formatted)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Multiple duration formatting with conditional display\nlocal function formatMultipleDurations(durations)\n    local results = {}\n    for name, seconds in pairs(durations) do\n        if seconds and seconds &gt; 0 then\n            local formatted = lia.time.formatDHM(seconds)\n            table.insert(results, name .. \": \" .. formatted)\n        end\n    end\n    return table.concat(results, \", \")\nend\nlocal durations = {\ncooldown = 3600,\nbanTime = 86400,\nmuteTime = 1800\n}\nprint(formatMultipleDurations(durations))\n</code></pre></p>"},{"location":"libraries/lia.time/#gethour","title":"getHour","text":"<p>Purpose</p> <p>Get the current hour in either 12-hour (AM/PM) or 24-hour format based on configuration</p> <p>When Called</p> <p>When displaying current hour in UI elements, time-based events, or hour-specific functionality</p> <p>Returns</p> <ul> <li>string|number - Current hour as string with AM/PM suffix (American format) or number (24-hour format)</li> </ul> <p>Realm</p> <p>Shared (works on both client and server)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get current hour\nlocal currentHour = lia.time.getHour()\nprint(\"Current hour: \" .. tostring(currentHour))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Time-based greeting system\nlocal hour = lia.time.getHour()\nlocal greeting = \"\"\nif lia.config.get(\"AmericanTimeStamps\", false) then\n    -- American format returns string like \"2pm\"\n    local hourNum = tonumber(hour:match(\"%d+\"))\n    if hourNum &gt;= 6 and hourNum &lt; 12 then\n        greeting = \"Good morning!\"\n        elseif hourNum &gt;= 12 and hourNum &lt; 18 then\n            greeting = \"Good afternoon!\"\n            else\n                greeting = \"Good evening!\"\n            end\n            else\n                -- 24-hour format returns number\n                if hour &gt;= 6 and hour &lt; 12 then\n                    greeting = \"Good morning!\"\n                    elseif hour &gt;= 12 and hour &lt; 18 then\n                        greeting = \"Good afternoon!\"\n                        else\n                            greeting = \"Good evening!\"\n                        end\n                    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic server events based on time with multiple time zones\nlocal function getServerEvents()\n    local hour = lia.time.getHour()\n    local events = {}\n    -- Parse hour for both formats\n    local hourNum\n    if type(hour) == \"string\" then\n        hourNum = tonumber(hour:match(\"%d+\"))\n        local isPM = hour:find(\"pm\")\n        if isPM and hourNum ~= 12 then\n            hourNum = hourNum + 12\n            elseif not isPM and hourNum == 12 then\n                hourNum = 0\n            end\n            else\n                hourNum = hour\n            end\n            -- Schedule events based on hour\n            if hourNum &gt;= 0 and hourNum &lt; 6 then\n                table.insert(events, \"Night shift bonus active\")\n                elseif hourNum &gt;= 6 and hourNum &lt; 12 then\n                    table.insert(events, \"Morning rush hour\")\n                    elseif hourNum &gt;= 12 and hourNum &lt; 18 then\n                        table.insert(events, \"Afternoon activities\")\n                        else\n                            table.insert(events, \"Evening events\")\n                        end\n                        return events\n                    end\n</code></pre></p>"},{"location":"libraries/lia.util/","title":"Utility Library","text":"<p>Common operations and helper functions for the Lilia framework.</p> <p>Overview</p> <p>The utility library provides comprehensive functionality for common operations and helper functions used throughout the Lilia framework. It contains a wide range of utilities for player management, string processing, entity handling, UI operations, and general purpose calculations. The library is divided into server-side functions for game logic and data management, and client-side functions for user interface, visual effects, and player interaction. These utilities simplify complex operations, provide consistent behavior across the framework, and offer reusable components for modules and plugins. The library handles everything from player identification and spatial queries to advanced UI animations and text processing, ensuring robust and efficient operations across both server and client environments.</p>"},{"location":"libraries/lia.util/#findplayersinbox","title":"findPlayersInBox","text":"<p>Purpose</p> <p>Find all players within a specified 3D box area</p> <p>When Called</p> <p>When you need to find players in a specific rectangular area for operations like area-of-effect abilities or zone management</p> <p>Parameters</p> <ul> <li><code>mins</code> (Vector): The minimum corner coordinates of the box</li> <li><code>maxs</code> (Vector): The maximum corner coordinates of the box</li> </ul> <p>Returns</p> <ul> <li>Table of player entities found within the box area</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find players in a small area around a position\nlocal players = lia.util.findPlayersInBox(Vector(-100, -100, -50), Vector(100, 100, 50))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Find players in a zone and notify them\nlocal zonePlayers = lia.util.findPlayersInBox(zoneMin, zoneMax)\nfor _, player in ipairs(zonePlayers) do\n    player:notify(\"You are in the danger zone!\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a dynamic zone system with multiple areas\nlocal zones = {\n{mins = Vector(0, 0, 0), maxs = Vector(100, 100, 100), name = \"Safe Zone\"},\n{mins = Vector(200, 200, 0), maxs = Vector(300, 300, 100), name = \"Combat Zone\"}\n}\nfor _, zone in ipairs(zones) do\n    local players = lia.util.findPlayersInBox(zone.mins, zone.maxs)\n    for _, player in ipairs(players) do\n        player:notify(\"Entered: \" .. zone.name)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#getbysteamid","title":"getBySteamID","text":"<p>Purpose</p> <p>Find a player by their Steam ID or Steam ID 64</p> <p>When Called</p> <p>When you need to locate a specific player using their Steam identification for operations like bans, whitelists, or data retrieval</p> <p>Parameters</p> <ul> <li><code>steamID</code> (string): The Steam ID (STEAM_0:0:123456) or Steam ID 64 to search for</li> </ul> <p>Returns</p> <ul> <li>Player entity if found with a valid character, nil otherwise</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find player by Steam ID\nlocal player = lia.util.getBySteamID(\"STEAM_0:0:12345678\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check if player is online before performing action\nlocal targetPlayer = lia.util.getBySteamID(playerSteamID)\nif IsValid(targetPlayer) then\n    targetPlayer:giveMoney(1000)\nelse\n    print(\"Player not found or offline\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Process multiple Steam IDs with validation\nlocal steamIDs = {\"STEAM_0:0:123456\", \"STEAM_0:1:789012\", \"76561198012345678\"}\nlocal foundPlayers = {}\nfor _, steamID in ipairs(steamIDs) do\n    local player = lia.util.getBySteamID(steamID)\n    if IsValid(player) then\n        foundPlayers[#foundPlayers + 1] = {\n        steamID = steamID,\n        player = player,\n        charName = player:getChar():getName()\n        }\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#findplayersinsphere","title":"findPlayersInSphere","text":"<p>Purpose</p> <p>Find all players within a specified spherical radius from a center point</p> <p>When Called</p> <p>When you need to find players in a circular area for proximity-based operations like damage, effects, or notifications</p> <p>Parameters</p> <ul> <li><code>origin</code> (Vector): The center point of the sphere</li> <li><code>radius</code> (number): The radius of the sphere in units</li> </ul> <p>Returns</p> <ul> <li>Table of player entities found within the spherical area</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find players within 500 units of a position\nlocal nearbyPlayers = lia.util.findPlayersInSphere(playerPos, 500)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Apply effect to players within radius\nlocal explosionPos = Vector(100, 200, 50)\nlocal affectedPlayers = lia.util.findPlayersInSphere(explosionPos, 300)\nfor _, player in ipairs(affectedPlayers) do\n    player:takeDamage(50)\n    player:notify(\"Hit by explosion!\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a zone system with multiple overlapping spheres\nlocal zones = {\n{center = Vector(0, 0, 0), radius = 200, type = \"safe\"},\n{center = Vector(500, 0, 0), radius = 150, type = \"danger\"},\n{center = Vector(250, 250, 0), radius = 100, type = \"neutral\"}\n}\nfor _, player in player.GetAll() do\n    local playerPos = player:GetPos()\n    local inZone = {}\n    for _, zone in ipairs(zones) do\n        if playerPos:Distance(zone.center) &lt;= zone.radius then\n            inZone[zone.type] = true\n        end\n    end\n    if inZone.danger and not inZone.safe then\n        player:takeDamage(10)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#findplayer","title":"findPlayer","text":"<p>Purpose</p> <p>Find a player by various identifier types including Steam ID, Steam ID 64, name, or special selectors</p> <p>When Called</p> <p>When you need to locate a specific player using flexible identification methods for commands, admin actions, or interactions</p> <p>Parameters</p> <ul> <li><code>client</code> (unknown): Player: The player requesting the search (for notifications and special selectors)</li> <li><code>client</code> (Player): The player requesting the search (for notifications and special selectors)</li> <li><code>identifier</code> (unknown): String: The identifier to search for (Steam ID, Steam ID 64, player name, \"^\" for self, \"@\" for looked-at player)</li> <li><code>identifier</code> (String): The identifier to search for (Steam ID, Steam ID 64, player name, \"^\" for self, \"@\" for looked-at player)</li> </ul> <p>Returns</p> <ul> <li>Player entity if found, nil otherwise with appropriate error notifications</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find player by partial name\nlocal targetPlayer = lia.util.findPlayer(client, \"John\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Find player and perform action with error handling\nlocal targetPlayer = lia.util.findPlayer(client, targetSteamID)\nif targetPlayer then\n    targetPlayer:giveMoney(100)\n    client:notify(\"Gave money to \" .. targetPlayer:Name())\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a player selection system with multiple methods\nlocal function selectPlayer(admin, identifier)\n    -- Try Steam ID first\n    local target = lia.util.findPlayer(admin, identifier)\n    if not target then\n        -- Try Steam ID 64\n        if string.match(identifier, \"^%d+$\") and #identifier &gt;= 17 then\n            target = lia.util.findPlayer(admin, identifier)\n        end\n    end\n    if not target then\n        -- Try partial name match\n        for _, ply in player.Iterator() do\n            if string.find(ply:Name():lower(), identifier:lower()) then\n                target = ply\n                break\n            end\n        end\n    end\n    return target\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#findplayeritems","title":"findPlayerItems","text":"<p>Purpose</p> <p>Find all items created by a specific player in the world</p> <p>When Called</p> <p>When you need to locate dropped items or spawned entities created by a particular player for cleanup, tracking, or management</p> <p>Parameters</p> <ul> <li><code>client</code> (unknown): Player: The player whose created items should be found</li> <li><code>client</code> (Player): The player whose created items should be found</li> </ul> <p>Returns</p> <ul> <li>Table of item entities created by the specified player</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find all items dropped by a player\nlocal playerItems = lia.util.findPlayerItems(somePlayer)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up items after player disconnects\nlocal droppedItems = lia.util.findPlayerItems(disconnectingPlayer)\nfor _, item in ipairs(droppedItems) do\n    item:Remove()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create an item management system with ownership tracking\nlocal function managePlayerItems(player, action)\n    local items = lia.util.findPlayerItems(player)\n    for _, item in ipairs(items) do\n        if action == \"remove\" then\n            item:Remove()\n        elseif action == \"transfer\" then\n            item:SetCreator(newOwner)\n        elseif action == \"info\" then\n            print(\"Item: \" .. item:getNetVar(\"id\") .. \" at \" .. tostring(item:GetPos()))\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.util/#findplayeritemsbyclass","title":"findPlayerItemsByClass","text":"<p>Purpose</p> <p>Find all items of a specific class created by a particular player</p> <p>When Called</p> <p>When you need to locate specific types of items created by a player for targeted operations like weapon cleanup or resource management</p> <p>Parameters</p> <ul> <li><code>client</code> (unknown): Player: The player whose created items should be found</li> <li><code>client</code> (Player): The player whose created items should be found</li> <li><code>class</code> (unknown): String: The item class/type to filter by (e.g., \"weapon_ar2\", \"item_healthkit\")</li> <li><code>class</code> (String): The item class/type to filter by (e.g., \"weapon_ar2\", \"item_healthkit\")</li> </ul> <p>Returns</p> <ul> <li>Table of item entities of the specified class created by the player</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find all weapons dropped by a player\nlocal droppedWeapons = lia.util.findPlayerItemsByClass(player, \"weapon_ar2\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Remove specific item types after player death\nlocal healthKits = lia.util.findPlayerItemsByClass(deadPlayer, \"item_healthkit\")\nfor _, kit in ipairs(healthKits) do\n    kit:Remove()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create an inventory management system with class-based filtering\nlocal function cleanupPlayerItems(player, itemClasses)\n    local removedCount = 0\n    for _, class in ipairs(itemClasses) do\n        local items = lia.util.findPlayerItemsByClass(player, class)\n        for _, item in ipairs(items) do\n            item:Remove()\n            removedCount = removedCount + 1\n        end\n    end\n    return removedCount\nend\n-- Usage\nlocal removed = cleanupPlayerItems(leavingPlayer, {\"weapon_*\", \"item_*\"})\n</code></pre></p>"},{"location":"libraries/lia.util/#findplayerentities","title":"findPlayerEntities","text":"<p>Purpose</p> <p>Find all entities created by or associated with a specific player, optionally filtered by class</p> <p>When Called</p> <p>When you need to locate entities spawned by a player for management, cleanup, or tracking purposes</p> <p>Parameters</p> <ul> <li><code>client</code> (unknown): Player: The player whose entities should be found</li> <li><code>client</code> (Player): The player whose entities should be found</li> <li><code>class</code> (unknown): String: Optional class name to filter entities (e.g., \"prop_physics\", \"npc_zombie\")</li> <li><code>class</code> (String): Optional class name to filter entities (e.g., \"prop_physics\", \"npc_zombie\")</li> </ul> <p>Returns</p> <ul> <li>Table of entities created by or associated with the specified player</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find all entities created by a player\nlocal playerEntities = lia.util.findPlayerEntities(somePlayer)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Find specific entity types created by player\nlocal playerProps = lia.util.findPlayerEntities(player, \"prop_physics\")\nfor _, prop in ipairs(playerProps) do\n    prop:Remove()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create an entity management system with ownership tracking\nlocal function managePlayerEntities(player, action, classFilter)\n    local entities = lia.util.findPlayerEntities(player, classFilter)\n    local results = {removed = 0, modified = 0}\n    for _, entity in ipairs(entities) do\n        if action == \"remove\" then\n            entity:Remove()\n            results.removed = results.removed + 1\n            elseif action == \"freeze\" then\n                local phys = entity:GetPhysicsObject()\n                if IsValid(phys) then\n                    phys:EnableMotion(false)\n                    results.modified = results.modified + 1\n                end\n            end\n        end\n        return results\n    end\n</code></pre></p>"},{"location":"libraries/lia.util/#stringmatches","title":"stringMatches","text":"<p>Purpose</p> <p>Check if two strings match using flexible comparison methods including case-insensitive and partial matching</p> <p>When Called</p> <p>When you need to compare strings with flexible matching for search functionality, name validation, or text processing</p> <p>Parameters</p> <ul> <li><code>a</code> (unknown): String: The first string to compare</li> <li><code>a</code> (String): The first string to compare</li> <li><code>b</code> (unknown): String: The second string to compare (the search pattern)</li> <li><code>b</code> (String): The second string to compare (the search pattern)</li> </ul> <p>Returns</p> <ul> <li>Boolean indicating if the strings match using any of the comparison methods</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if strings are equal (case-insensitive)\nlocal matches = lia.util.stringMatches(\"Hello\", \"hello\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check if player name contains search term\nlocal function playerNameMatches(player, searchTerm)\n    return lia.util.stringMatches(player:Name(), searchTerm)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a flexible search system with multiple criteria\nlocal function advancedStringSearch(text, searchTerms)\n    local results = {}\n    for _, term in ipairs(searchTerms) do\n        if lia.util.stringMatches(text, term) then\n            results[#results + 1] = {\n            text = text,\n            matchedTerm = term,\n            matchType = \"partial\"\n            }\n        end\n    end\n    return results\nend\n-- Usage\nlocal searchResults = advancedStringSearch(\"Player Name\", {\"player\", \"name\", \"test\"})\n</code></pre></p>"},{"location":"libraries/lia.util/#getadmins","title":"getAdmins","text":"<p>Purpose</p> <p>Get a list of all currently online administrators/staff members</p> <p>When Called</p> <p>When you need to identify staff members for admin-only operations, notifications, or privilege checks</p> <p>Returns</p> <ul> <li>Table of player entities that are currently staff members</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all online admins\nlocal admins = lia.util.getAdmins()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send notification to all admins\nlocal admins = lia.util.getAdmins()\nfor _, admin in ipairs(admins) do\n    admin:notify(\"Server maintenance in 5 minutes!\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create an admin monitoring system with activity tracking\nlocal function getActiveAdmins()\n    local admins = lia.util.getAdmins()\n    local activeAdmins = {}\n    for _, admin in ipairs(admins) do\n        if admin:isStaff() and admin:getChar() then\n            activeAdmins[#activeAdmins + 1] = {\n            player = admin,\n            steamID = admin:SteamID(),\n            name = admin:Name(),\n            lastSeen = CurTime()\n            }\n        end\n    end\n    return activeAdmins\nend\n-- Usage\nlocal activeStaff = getActiveAdmins()\n</code></pre></p>"},{"location":"libraries/lia.util/#findplayerbysteamid64","title":"findPlayerBySteamID64","text":"<p>Purpose</p> <p>Find a player by their Steam ID 64, converting it to Steam ID format first</p> <p>When Called</p> <p>When you need to locate a player using their Steam ID 64 for database operations or external integrations</p> <p>Parameters</p> <ul> <li><code>SteamID64</code> (unknown): String: The Steam ID 64 to search for</li> <li><code>SteamID64</code> (String): The Steam ID 64 to search for</li> </ul> <p>Returns</p> <ul> <li>Player entity if found, nil otherwise</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find player by Steam ID 64\nlocal player = lia.util.findPlayerBySteamID64(\"76561198012345678\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check if Steam ID 64 is currently online\nlocal targetPlayer = lia.util.findPlayerBySteamID64(steamID64)\nif IsValid(targetPlayer) then\n    print(targetPlayer:Name() .. \" is currently online\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Process multiple Steam ID 64s for batch operations\nlocal steamID64s = {\"76561198012345678\", \"76561198098765432\", \"76561198111111111\"}\nlocal onlinePlayers = {}\nfor _, steamID64 in ipairs(steamID64s) do\n    local player = lia.util.findPlayerBySteamID64(steamID64)\n    if IsValid(player) then\n        onlinePlayers[#onlinePlayers + 1] = {\n        steamID64 = steamID64,\n        player = player,\n        character = player:getChar():getName()\n        }\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#findplayerbysteamid","title":"findPlayerBySteamID","text":"<p>Purpose</p> <p>Find a player by their Steam ID</p> <p>When Called</p> <p>When you need to locate a player using their Steam ID for admin actions, bans, or data retrieval</p> <p>Parameters</p> <ul> <li><code>SteamID</code> (unknown): String: The Steam ID to search for (STEAM_0:0:123456 format)</li> <li><code>SteamID</code> (String): The Steam ID to search for (STEAM_0:0:123456 format)</li> </ul> <p>Returns</p> <ul> <li>Player entity if found, nil otherwise</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find player by Steam ID\nlocal player = lia.util.findPlayerBySteamID(\"STEAM_0:0:12345678\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Verify player identity before action\nlocal targetPlayer = lia.util.findPlayerBySteamID(steamID)\nif IsValid(targetPlayer) and targetPlayer:getChar() then\n    targetPlayer:kick(\"Reason for kick\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a player tracking system with Steam ID validation\nlocal function trackPlayerActivity(steamID)\n    local player = lia.util.findPlayerBySteamID(steamID)\n    if IsValid(player) then\n        return {\n        steamID = steamID,\n        name = player:Name(),\n        character = player:getChar():getName(),\n        position = player:GetPos(),\n        status = \"online\"\n        }\n        else\n            return {\n            steamID = steamID,\n            status = \"offline\"\n            }\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.util/#canfit","title":"canFit","text":"<p>Purpose</p> <p>Check if an entity can fit at a specific position without colliding with solid objects</p> <p>When Called</p> <p>When you need to validate if an entity can be placed at a location for spawning, teleportation, or collision detection</p> <p>Parameters</p> <ul> <li><code>pos</code> (unknown): Vector: The position to check for entity placement</li> <li><code>pos</code> (Vector): The position to check for entity placement</li> <li><code>mins</code> (unknown): Vector: Optional minimum bounding box coordinates (defaults to Vector(16, 16, 0))</li> <li><code>mins</code> (Vector): Optional minimum bounding box coordinates (defaults to Vector(16, 16, 0))</li> <li><code>maxs</code> (unknown): Vector: Optional maximum bounding box coordinates (defaults to mins value)</li> <li><code>maxs</code> (Vector): Optional maximum bounding box coordinates (defaults to mins value)</li> <li><code>filter</code> (unknown): Entity/Table: Optional entity or table of entities to ignore in collision detection</li> <li><code>filter</code> (Entity/Table): Optional entity or table of entities to ignore in collision detection</li> </ul> <p>Returns</p> <ul> <li>Boolean indicating if the position is clear (true) or obstructed (false)</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player can fit at position\nlocal canTeleport = lia.util.canFit(targetPosition)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Validate spawn position for entity\nlocal spawnPos = Vector(100, 200, 50)\nif lia.util.canFit(spawnPos, Vector(-16, -16, 0), Vector(16, 16, 72)) then\n    local npc = ents.Create(\"npc_zombie\")\n    npc:SetPos(spawnPos)\n    npc:Spawn()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a smart placement system with multiple validation checks\nlocal function findValidPlacement(centerPos, entitySize, attempts)\n    local validPositions = {}\n    for i = 1, attempts do\n        local randomOffset = Vector(\n        math.random(-100, 100),\n        math.random(-100, 100),\n        0\n        )\n        local testPos = centerPos + randomOffset\n        if lia.util.canFit(testPos, entitySize.mins, entitySize.maxs) then\n            validPositions[#validPositions + 1] = testPos\n        end\n    end\n    return validPositions\nend\n-- Usage\nlocal positions = findValidPlacement(playerPos, {mins = Vector(-16, -16, 0), maxs = Vector(16, 16, 72)}, 50)\n</code></pre></p>"},{"location":"libraries/lia.util/#playerinradius","title":"playerInRadius","text":"<p>Purpose</p> <p>Find all players within a specified radius from a center position</p> <p>When Called</p> <p>When you need to find players in a circular area for proximity-based operations like damage, effects, or area management</p> <p>Parameters</p> <ul> <li><code>pos</code> (unknown): Vector: The center position to check from</li> <li><code>pos</code> (Vector): The center position to check from</li> <li><code>dist</code> (unknown): Number: The radius distance to check within</li> <li><code>dist</code> (Number): The radius distance to check within</li> </ul> <p>Returns</p> <ul> <li>Table of player entities found within the specified radius</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find players within 100 units\nlocal nearbyPlayers = lia.util.playerInRadius(playerPos, 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Apply area effect to players in radius\nlocal explosionCenter = Vector(500, 300, 100)\nlocal affectedPlayers = lia.util.playerInRadius(explosionCenter, 200)\nfor _, player in ipairs(affectedPlayers) do\n    player:takeDamage(75)\n    player:notify(\"You were caught in the blast!\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a zone management system with multiple areas\nlocal zones = {\n{center = Vector(0, 0, 0), radius = 150, type = \"safe\"},\n{center = Vector(400, 0, 0), radius = 100, type = \"combat\"},\n{center = Vector(200, 200, 0), radius = 80, type = \"neutral\"}\n}\nfor _, player in player.GetAll() do\n    local playerPos = player:GetPos()\n    local zonesIn = {}\n    for _, zone in ipairs(zones) do\n        if playerPos:Distance(zone.center) &lt;= zone.radius then\n            zonesIn[zone.type] = true\n        end\n    end\n    if zonesIn.combat and not zonesIn.safe then\n        player:setNetVar(\"inCombat\", true)\n        else\n            player:setNetVar(\"inCombat\", false)\n        end\n    end\n</code></pre></p>"},{"location":"libraries/lia.util/#formatstringnamed","title":"formatStringNamed","text":"<p>Purpose</p> <p>Format a string using named placeholders with flexible argument handling</p> <p>When Called</p> <p>When you need to format strings with named parameters for localization, templating, or dynamic text generation</p> <p>Parameters</p> <ul> <li><code>format</code> (unknown): String: The format string containing {placeholder} patterns</li> <li><code>format</code> (String): The format string containing {placeholder} patterns</li> <li><code>...</code> (Mixed): Either a table with named keys or individual arguments to replace placeholders</li> </ul> <p>Returns</p> <ul> <li>String with placeholders replaced by provided values</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Format string with individual arguments\nlocal message = lia.util.formatStringNamed(\"Hello {name}!\", \"John\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Format string with named parameters\nlocal data = {name = \"Alice\", score = 150}\nlocal message = lia.util.formatStringNamed(\"Player {name} scored {score} points!\", data)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a templating system with complex data structures\nlocal template = \"Player {name} from {faction} has {health} HP and {money} credits\"\nlocal playerData = {\nname = \"Bob\",\nfaction = \"Security\",\nhealth = 85,\nmoney = 2500\n}\nlocal function formatPlayerInfo(template, data)\n    local formatted = template\n    for key, value in pairs(data) do\n        formatted = formatted:gsub(\"{\" .. key .. \"}\", tostring(value))\n    end\n    return formatted\nend\n-- Usage with both methods\nlocal message1 = lia.util.formatStringNamed(template, playerData)\nlocal message2 = formatPlayerInfo(template, playerData)\n</code></pre></p>"},{"location":"libraries/lia.util/#getmaterial","title":"getMaterial","text":"<p>Purpose</p> <p>Get a cached material object from a file path, creating it if it doesn't exist</p> <p>When Called</p> <p>When you need to load and cache materials for rendering, UI elements, or visual effects to improve performance</p> <p>Parameters</p> <ul> <li><code>materialPath</code> (unknown): String: The file path to the material (e.g., \"materials/effects/blur.vmt\")</li> <li><code>materialPath</code> (String): The file path to the material (e.g., \"materials/effects/blur.vmt\")</li> <li><code>materialParameters</code> (unknown): String: Optional parameters for material creation</li> <li><code>materialParameters</code> (String): Optional parameters for material creation</li> </ul> <p>Returns</p> <ul> <li>IMaterial object for the specified material path</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a cached material\nlocal blurMaterial = lia.util.getMaterial(\"pp/blurscreen\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use material for rendering effects\nlocal material = lia.util.getMaterial(\"effects/flashlight001\")\nsurface.SetMaterial(material)\nsurface.SetDrawColor(255, 255, 255, 128)\nsurface.DrawTexturedRect(x, y, w, h)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a material management system with preloading\nlocal materialCache = {}\nlocal function preloadMaterials(materialList)\n    for _, materialPath in ipairs(materialList) do\n        materialCache[materialPath] = lia.util.getMaterial(materialPath)\n    end\nend\nlocal function drawMaterialEffect(materialPath, x, y, w, h, alpha)\n    local material = materialCache[materialPath] or lia.util.getMaterial(materialPath)\n    if material then\n        surface.SetMaterial(material)\n        surface.SetDrawColor(255, 255, 255, alpha or 255)\n        surface.DrawTexturedRect(x, y, w, h)\n    end\nend\n-- Usage\npreloadMaterials({\"effects/water_warp01\", \"effects/bubble\", \"pp/blurscreen\"})\ndrawMaterialEffect(\"effects/water_warp01\", 100, 100, 200, 200, 150)\n</code></pre></p>"},{"location":"libraries/lia.util/#findfaction","title":"findFaction","text":"<p>Purpose</p> <p>Find a faction by name or unique ID using flexible matching</p> <p>When Called</p> <p>When you need to locate faction information for player assignment, permissions, or faction-based operations</p> <p>Parameters</p> <ul> <li><code>client</code> (unknown): Player: The player requesting the faction (for error notifications)</li> <li><code>client</code> (Player): The player requesting the faction (for error notifications)</li> <li><code>name</code> (unknown): String: The faction name or unique ID to search for</li> <li><code>name</code> (String): The faction name or unique ID to search for</li> </ul> <p>Returns</p> <ul> <li>Faction table if found, nil otherwise with error notification</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find faction by name\nlocal faction = lia.util.findFaction(player, \"Security\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction before performing action\nlocal faction = lia.util.findFaction(client, factionName)\nif faction then\n    player:setFaction(faction.index)\n    client:notify(\"Player moved to \" .. faction.name)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a faction management system with validation\nlocal function managePlayerFaction(admin, targetPlayer, factionName, action)\n    local faction = lia.util.findFaction(admin, factionName)\n    if not faction then\n        return false, \"Faction not found\"\n    end\n    if action == \"assign\" then\n        targetPlayer:setFaction(faction.index)\n        return true, \"Player assigned to \" .. faction.name\n        elseif action == \"check\" then\n            return true, \"Player is in faction: \" .. (targetPlayer:getFaction() == faction.index and faction.name or \"Different faction\")\n            elseif action == \"info\" then\n                return true, string.format(\"Faction: %s, Color: %s, Models: %d\",\n                faction.name, tostring(faction.color), #faction.models)\n            end\n            return false, \"Invalid action\"\n        end\n        -- Usage\n        local success, message = managePlayerFaction(admin, target, \"Citizen\", \"assign\")\n</code></pre></p>"},{"location":"libraries/lia.util/#liasoundduration","title":"lia.SoundDuration","text":"<p>Purpose</p> <p>Find a faction by name or unique ID using flexible matching</p> <p>When Called</p> <p>When you need to locate faction information for player assignment, permissions, or faction-based operations</p> <p>Parameters</p> <ul> <li><code>client</code> (unknown): Player: The player requesting the faction (for error notifications)</li> <li><code>client</code> (Player): The player requesting the faction (for error notifications)</li> <li><code>name</code> (unknown): String: The faction name or unique ID to search for</li> <li><code>name</code> (String): The faction name or unique ID to search for</li> </ul> <p>Returns</p> <ul> <li>Faction table if found, nil otherwise with error notification</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find faction by name\nlocal faction = lia.util.findFaction(player, \"Security\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check faction before performing action\nlocal faction = lia.util.findFaction(client, factionName)\nif faction then\n    player:setFaction(faction.index)\n    client:notify(\"Player moved to \" .. faction.name)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a faction management system with validation\nlocal function managePlayerFaction(admin, targetPlayer, factionName, action)\n    local faction = lia.util.findFaction(admin, factionName)\n    if not faction then\n        return false, \"Faction not found\"\n    end\n    if action == \"assign\" then\n        targetPlayer:setFaction(faction.index)\n        return true, \"Player assigned to \" .. faction.name\n        elseif action == \"check\" then\n            return true, \"Player is in faction: \" .. (targetPlayer:getFaction() == faction.index and faction.name or \"Different faction\")\n            elseif action == \"info\" then\n                return true, string.format(\"Faction: %s, Color: %s, Models: %d\",\n                faction.name, tostring(faction.color), #faction.models)\n            end\n            return false, \"Invalid action\"\n        end\n        -- Usage\n        local success, message = managePlayerFaction(admin, target, \"Citizen\", \"assign\")\n</code></pre></p>"},{"location":"libraries/lia.util/#generaterandomname","title":"generateRandomName","text":"<p>Purpose</p> <p>Generate a random full name by combining first and last names from provided or default lists</p> <p>When Called</p> <p>When you need to create random character names for NPCs, testing, or procedural content generation</p> <p>Parameters</p> <ul> <li><code>firstNames</code> (unknown): Table: Optional table of first names to choose from</li> <li><code>firstNames</code> (Table): Optional table of first names to choose from</li> <li><code>lastNames</code> (unknown): Table: Optional table of last names to choose from</li> <li><code>lastNames</code> (Table): Optional table of last names to choose from</li> </ul> <p>Returns</p> <ul> <li>String containing a randomly generated full name (FirstName LastName)</li> </ul> <p>Realm</p> <p>Both (Universal)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Generate a random name using defaults\nlocal randomName = lia.util.generateRandomName()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Generate name with custom name lists\nlocal fantasyFirstNames = {\"Aragorn\", \"Legolas\", \"Gimli\", \"Frodo\"}\nlocal fantasyLastNames = {\"Stormwind\", \"Ironfist\", \"Shadowalker\", \"Lightbringer\"}\nlocal fantasyName = lia.util.generateRandomName(fantasyFirstNames, fantasyLastNames)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a name generation system with cultural variations\nlocal nameCultures = {\nwestern = {\nfirst = {\"John\", \"Jane\", \"Michael\", \"Sarah\"},\nlast = {\"Smith\", \"Johnson\", \"Williams\", \"Brown\"}\n},\neastern = {\nfirst = {\"Hiroshi\", \"Yuki\", \"Kenji\", \"Sakura\"},\nlast = {\"Tanaka\", \"Suzuki\", \"Yamamoto\", \"Watanabe\"}\n}\n}\nlocal function generateCulturalName(culture)\n    local cultureData = nameCultures[culture]\n    if cultureData then\n        return lia.util.generateRandomName(cultureData.first, cultureData.last)\n    end\n    return lia.util.generateRandomName() -- fallback to defaults\nend\n-- Usage\nlocal westernName = generateCulturalName(\"western\")\nlocal easternName = generateCulturalName(\"eastern\")\n</code></pre></p>"},{"location":"libraries/lia.util/#sendtableui","title":"sendTableUI","text":"<p>Purpose</p> <p>Send a table-based user interface to a specific client for displaying data in a structured format</p> <p>When Called</p> <p>When you need to display tabular data to a player, such as inventories, player lists, or administrative information</p> <p>Parameters</p> <ul> <li><code>client</code> (unknown): Player: The player to send the table UI to</li> <li><code>client</code> (Player): The player to send the table UI to</li> <li><code>title</code> (unknown): String: The title of the table window</li> <li><code>title</code> (String): The title of the table window</li> <li><code>columns</code> (unknown): Table: Array of column definitions with name, width, and other properties</li> <li><code>columns</code> (Table): Array of column definitions with name, width, and other properties</li> <li><code>data</code> (unknown): Table: Array of row data to display in the table</li> <li><code>data</code> (Table): Array of row data to display in the table</li> <li><code>options</code> (unknown): Table: Optional configuration options for the table UI</li> <li><code>options</code> (Table): Optional configuration options for the table UI</li> <li><code>characterID</code> (unknown): Number: Optional character ID for character-specific data</li> <li><code>characterID</code> (Number): Optional character ID for character-specific data</li> </ul> <p>Returns</p> <ul> <li>Nothing (sends network message to client)</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send basic player list\nlocal columns = {\n{name = \"Name\", width = 150},\n{name = \"Steam ID\", width = 200}\n}\nlocal players = player.GetAll()\nlocal data = {}\nfor _, ply in ipairs(players) do\n    data[#data + 1] = {ply:Name(), ply:SteamID()}\nend\nlia.util.sendTableUI(client, \"Player List\", columns, data)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send inventory with action options\nlocal columns = {\n{name = \"Item\", width = 150},\n{name = \"Quantity\", width = 80},\n{name = \"Value\", width = 100}\n}\nlocal options = {\n{name = \"Drop\", net = \"liaDropItem\"},\n{name = \"Use\", net = \"liaUseItem\"}\n}\nlia.util.sendTableUI(client, \"Inventory\", columns, inventoryData, options, characterID)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a comprehensive admin panel with multiple data types\nlocal function sendAdminPanel(admin, targetPlayer)\n    local columns = {\n    {name = \"Property\", width = 150},\n    {name = \"Value\", width = 200},\n    {name = \"Actions\", width = 100}\n    }\n    local playerData = {\n    {\"Name\", targetPlayer:Name()},\n    {\"Steam ID\", targetPlayer:SteamID()},\n    {\"Health\", targetPlayer:Health()},\n    {\"Armor\", targetPlayer:Armor()},\n    {\"Money\", targetPlayer:getMoney()},\n    {\"Faction\", targetPlayer:getFaction()},\n    }\n    local options = {\n    {name = \"Kick\", net = \"liaKickPlayer\"},\n    {name = \"Ban\", net = \"liaBanPlayer\"},\n    {name = \"Teleport\", net = \"liaTeleportPlayer\"}\n    }\n    lia.util.sendTableUI(admin, \"Player Info: \" .. targetPlayer:Name(),\n    columns, playerData, options, targetPlayer:getChar() and targetPlayer:getChar():getID())\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#findemptyspace","title":"findEmptySpace","text":"<p>Purpose</p> <p>Find empty spaces around an entity for spawning or placement purposes</p> <p>When Called</p> <p>When you need to find valid locations to spawn entities, NPCs, or items around a central position</p> <p>Parameters</p> <ul> <li><code>entity</code> (unknown): Entity: The central entity to search around</li> <li><code>entity</code> (Entity): The central entity to search around</li> <li><code>filter</code> (unknown): Entity/Table: Optional entity or table of entities to ignore in collision detection</li> <li><code>filter</code> (Entity/Table): Optional entity or table of entities to ignore in collision detection</li> <li><code>spacing</code> (unknown): Number: Distance between each tested position (default: 32)</li> <li><code>spacing</code> (Number): Distance between each tested position (default: 32)</li> <li><code>size</code> (unknown): Number: Grid size to search in (default: 3, meaning -3 to +3 in both x and y)</li> <li><code>size</code> (Number): Grid size to search in (default: 3, meaning -3 to +3 in both x and y)</li> <li><code>height</code> (unknown): Number: Height of the area to check for collisions (default: 36)</li> <li><code>height</code> (Number): Height of the area to check for collisions (default: 36)</li> <li><code>tolerance</code> (unknown): Number: Additional clearance above ground (default: 5)</li> <li><code>tolerance</code> (Number): Additional clearance above ground (default: 5)</li> </ul> <p>Returns</p> <ul> <li>Table of valid Vector positions sorted by distance from the entity</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Find nearby empty spaces\nlocal emptySpaces = lia.util.findEmptySpace(someEntity)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Find spawn locations for NPCs around player\nlocal spawnPositions = lia.util.findEmptySpace(player, player, 64, 5, 72, 10)\nfor _, pos in ipairs(spawnPositions) do\n    if #spawnPositions &gt;= 3 then break end -- Limit to 3 NPCs\n        local npc = ents.Create(\"npc_zombie\")\n        npc:SetPos(pos)\n        npc:Spawn()\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a smart spawning system with validation\nlocal function spawnEntitiesInArea(centerEntity, entityType, count, spacing)\n    local validPositions = lia.util.findEmptySpace(centerEntity, nil, spacing or 48, 4, 64, 8)\n    for i = 1, math.min(count, #validPositions) do\n        local pos = validPositions[i]\n        if pos then\n            local entity = ents.Create(entityType)\n            entity:SetPos(pos)\n            -- Add some randomization to position\n            local randomOffset = Vector(\n            math.random(-16, 16),\n            math.random(-16, 16),\n            0\n            )\n            entity:SetPos(pos + randomOffset)\n            entity:Spawn()\n            -- Ensure entity is properly placed\n            if not lia.util.canFit(entity:GetPos(), entity:GetModelBounds()) then\n                entity:Remove()\n            end\n        end\n    end\n    return #validPositions\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#animateappearance","title":"animateAppearance","text":"<p>Purpose</p> <p>Animate a panel's appearance with scaling, positioning, and alpha transitions</p> <p>When Called</p> <p>When you need to create smooth entrance animations for UI panels, menus, or dialog boxes</p> <p>Parameters</p> <ul> <li><code>panel</code> (unknown): Panel: The DPanel to animate</li> <li><code>panel</code> (Panel): The DPanel to animate</li> <li><code>target_w</code> (unknown): Number: Target width for the animation</li> <li><code>target_w</code> (Number): Target width for the animation</li> <li><code>target_h</code> (unknown): Number: Target height for the animation</li> <li><code>target_h</code> (Number): Target height for the animation</li> <li><code>duration</code> (unknown): Number: Duration of size/position animation in seconds (default: 0.18)</li> <li><code>duration</code> (Number): Duration of size/position animation in seconds (default: 0.18)</li> <li><code>alpha_dur</code> (unknown): Number: Duration of alpha animation in seconds (default: same as duration)</li> <li><code>alpha_dur</code> (Number): Duration of alpha animation in seconds (default: same as duration)</li> <li><code>callback</code> (unknown): Function: Optional callback function to execute when animation completes</li> <li><code>callback</code> (Function): Optional callback function to execute when animation completes</li> <li><code>scale_factor</code> (unknown): Number: Scale factor for initial size (default: 0.8)</li> <li><code>scale_factor</code> (Number): Scale factor for initial size (default: 0.8)</li> </ul> <p>Returns</p> <ul> <li>Nothing (modifies panel directly)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic panel appearance animation\nlocal panel = vgui.Create(\"DPanel\")\npanel:SetSize(200, 100)\nlia.util.animateAppearance(panel, 200, 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Animate panel with custom duration and callback\nlocal frame = vgui.Create(\"DFrame\")\nframe:SetSize(400, 300)\nframe:Center()\nlia.util.animateAppearance(frame, 400, 300, 0.3, 0.2, function(panel)\nprint(\"Animation completed!\")\npanel:MakePopup()\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a complex UI system with staggered animations\nlocal function createAnimatedMenu(title, options)\n    local frame = vgui.Create(\"DFrame\")\n    frame:SetTitle(title)\n    frame:SetSize(300, 200)\n    frame:Center()\n    -- Animate main frame\n    lia.util.animateAppearance(frame, 300, 200, 0.25, 0.15)\n    -- Create animated buttons with delays\n    for i, option in ipairs(options) do\n        local button = vgui.Create(\"DButton\", frame)\n        button:SetText(option.text)\n        button:Dock(TOP)\n        button:DockMargin(10, 5, 10, 5)\n        -- Stagger animation timing\n        timer.Simple(i * 0.05, function()\n        if IsValid(button) then\n            button:SetAlpha(0)\n            lia.util.animateAppearance(button, button:GetWide(), button:GetTall(), 0.15, 0.1)\n        end\n    end)\nend\nreturn frame\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#clampmenuposition","title":"clampMenuPosition","text":"<p>Purpose</p> <p>Clamp a panel's position to stay within screen boundaries while avoiding UI overlap</p> <p>When Called</p> <p>When you need to ensure menus and panels stay visible and don't overlap with important UI elements like logos</p> <p>Parameters</p> <ul> <li><code>panel</code> (unknown): Panel: The DPanel whose position should be clamped</li> <li><code>panel</code> (Panel): The DPanel whose position should be clamped</li> </ul> <p>Returns</p> <ul> <li>Nothing (modifies panel position directly)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Keep panel within screen bounds\nlocal panel = vgui.Create(\"DPanel\")\npanel:SetPos(ScrW() + 100, ScrH() + 50) -- Off-screen position\nlia.util.clampMenuPosition(panel) -- Will move panel back on screen\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create a draggable panel that stays within bounds\nlocal frame = vgui.Create(\"DFrame\")\nframe:SetSize(200, 150)\nframe:SetDraggable(true)\n-- Clamp position when dragging ends\nframe.OnMouseReleased = function()\nlia.util.clampMenuPosition(frame)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a smart positioning system for multiple panels\nlocal function positionPanelsSmartly(panels)\n    local screenW, screenH = ScrW(), ScrH()\n    local margin = 10\n    -- Sort panels by priority (main panels first)\n    table.sort(panels, function(a, b) return a.priority &lt; b.priority end)\n    for i, panel in ipairs(panels) do\n        local x, y = panel:GetPos()\n        local w, h = panel:GetSize()\n        -- Try current position first\n        lia.util.clampMenuPosition(panel)\n        -- If panel would overlap with higher priority panels, reposition\n        local needsReposition = false\n        for j = 1, i - 1 do\n            local otherPanel = panels[j]\n            local otherX, otherY = otherPanel:GetPos()\n            local otherW, otherH = otherPanel:GetSize()\n            if x &lt; otherX + otherW + margin and x + w + margin &gt; otherX and\n            y &lt; otherY + otherH + margin and y + h + margin &gt; otherY then\n            needsReposition = true\n            break\n        end\n    end\n    if needsReposition then\n        -- Find best available position\n        local bestX, bestY = margin, margin\n        local minDistance = math.huge\n        for testY = margin, screenH - h - margin, 20 do\n            for testX = margin, screenW - w - margin, 20 do\n                local distance = 0\n                -- Calculate distance from other panels\n                for _, otherPanel in ipairs(panels) do\n                    if otherPanel ~= panel then\n                        local otherX, otherY = otherPanel:GetPos()\n                        local dx = testX - otherX\n                        local dy = testY - otherY\n                        distance = distance + (dx * dx + dy * dy)\n                    end\n                end\n                if distance &lt; minDistance then\n                    minDistance = distance\n                    bestX, bestY = testX, testY\n                end\n            end\n        end\n        panel:SetPos(bestX, bestY)\n    end\nend\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#drawgradient","title":"drawGradient","text":"<p>Purpose</p> <p>Draw a gradient background using predefined gradient materials</p> <p>When Called</p> <p>When you need to create gradient backgrounds for UI elements, panels, or visual effects</p> <p>Parameters</p> <ul> <li><code>_x</code> (unknown): Number: X position to draw the gradient</li> <li><code>_x</code> (Number): X position to draw the gradient</li> <li><code>_y</code> (unknown): Number: Y position to draw the gradient</li> <li><code>_y</code> (Number): Y position to draw the gradient</li> <li><code>_w</code> (unknown): Number: Width of the gradient area</li> <li><code>_w</code> (Number): Width of the gradient area</li> <li><code>_h</code> (unknown): Number: Height of the gradient area</li> <li><code>_h</code> (Number): Height of the gradient area</li> <li><code>direction</code> (unknown): Number: Gradient direction (1=up, 2=down, 3=left, 4=right)</li> <li><code>direction</code> (Number): Gradient direction (1=up, 2=down, 3=left, 4=right)</li> <li><code>color_shadow</code> (unknown): Color: Color for the gradient shadow effect</li> <li><code>color_shadow</code> (Color): Color for the gradient shadow effect</li> <li><code>radius</code> (unknown): Number: Corner radius for rounded gradients (default: 0)</li> <li><code>radius</code> (Number): Corner radius for rounded gradients (default: 0)</li> <li><code>flags</code> (unknown): Number: Material flags for rendering</li> <li><code>flags</code> (Number): Material flags for rendering</li> </ul> <p>Returns</p> <ul> <li>Nothing (draws directly to screen)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw a basic gradient background\nlia.util.drawGradient(100, 100, 200, 150, 2, Color(0, 0, 0, 150))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create a gradient panel background\nlocal panel = vgui.Create(\"DPanel\")\npanel.Paint = function(self, w, h)\nlia.util.drawGradient(0, 0, w, h, 2, Color(50, 50, 50, 200), 8)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create animated gradient backgrounds\nlocal gradients = {\n{dir = 1, color = Color(255, 100, 100, 150)},\n{dir = 2, color = Color(100, 255, 100, 150)},\n{dir = 3, color = Color(100, 100, 255, 150)},\n{dir = 4, color = Color(255, 255, 100, 150)}\n}\nlocal currentGradient = 1\nlocal function drawAnimatedGradient(x, y, w, h)\n    local gradient = gradients[currentGradient]\n    lia.util.drawGradient(x, y, w, h, gradient.dir, gradient.color, 12)\n    -- Cycle through gradients\n    if math.sin(CurTime() * 2) &gt; 0.9 then\n        currentGradient = currentGradient % #gradients + 1\n    end\nend\n-- Usage in panel\nlocal panel = vgui.Create(\"DPanel\")\npanel.Paint = function(self, w, h)\ndrawAnimatedGradient(0, 0, w, h)\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#wraptext","title":"wrapText","text":"<p>Purpose</p> <p>Wrap text to fit within a specified width, breaking it into multiple lines</p> <p>When Called</p> <p>When you need to display text that might be too long for a UI element, ensuring it wraps properly</p> <p>Parameters</p> <ul> <li><code>text</code> (unknown): String: The text to wrap</li> <li><code>text</code> (String): The text to wrap</li> <li><code>width</code> (unknown): Number: Maximum width in pixels for the text</li> <li><code>width</code> (Number): Maximum width in pixels for the text</li> <li><code>font</code> (unknown): String: Font to use for text measurement (default: \"LiliaFont.16\")</li> <li><code>font</code> (String): Font to use for text measurement (default: \"LiliaFont.16\")</li> </ul> <p>Returns</p> <ul> <li>Table of wrapped text lines, Number: Maximum width of any line</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Wrap text to fit in a label\nlocal lines, maxWidth = lia.util.wrapText(\"This is a long text that needs wrapping\", 200)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create a multi-line label with wrapped text\nlocal text = \"This is a very long description that should wrap to multiple lines when displayed in the UI.\"\nlocal lines, maxWidth = lia.util.wrapText(text, 300, \"liaSmallFont\")\nlocal label = vgui.Create(\"DLabel\")\nlabel:SetSize(maxWidth, #lines * 20)\nlabel:SetText(\"\")\nfor i, line in ipairs(lines) do\n    local lineLabel = vgui.Create(\"DLabel\", label)\n    lineLabel:SetPos(0, (i-1) * 20)\n    lineLabel:SetText(line)\n    lineLabel:SizeToContents()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a dynamic text wrapping system with font scaling\nlocal function createResponsiveTextPanel(text, maxWidth, fontBase)\n    local fontSizes = {16, 14, 12, 10}\n    local lines = {}\n    local finalFont = fontBase\n    for _, size in ipairs(fontSizes) do\n        local font = fontBase .. size\n        surface.SetFont(font)\n        local tempLines, tempWidth = lia.util.wrapText(text, maxWidth, font)\n        if tempWidth &lt;= maxWidth then\n            lines = tempLines\n            finalFont = font\n            break\n        end\n    end\n    local panel = vgui.Create(\"DPanel\")\n    panel:SetSize(maxWidth, #lines * (tonumber(finalFont:match(\"%d+\")) or 16))\n    panel.Paint = function(self, w, h)\n    surface.SetFont(finalFont)\n    for i, line in ipairs(lines) do\n        surface.SetTextPos(0, (i-1) * (h / #lines))\n        surface.DrawText(line)\n    end\nend\nreturn panel\nend\n-- Usage\nlocal textPanel = createResponsiveTextPanel(\"Very long text that needs to fit in a small area\", 250, \"liaFont.\")\n</code></pre></p>"},{"location":"libraries/lia.util/#drawblur","title":"drawBlur","text":"<p>Purpose</p> <p>Draw a blur effect behind a panel using screen-space blurring</p> <p>When Called</p> <p>When you need to create a blurred background effect for UI elements like menus or dialogs</p> <p>Parameters</p> <ul> <li><code>panel</code> (unknown): Panel: The panel to draw blur behind</li> <li><code>panel</code> (Panel): The panel to draw blur behind</li> <li><code>amount</code> (unknown): Number: Intensity of the blur effect (default: 5)</li> <li><code>amount</code> (Number): Intensity of the blur effect (default: 5)</li> <li><code>_</code> (unknown): Any: Unused parameter (legacy)</li> <li><code>_</code> (Any): Unused parameter (legacy)</li> <li><code>alpha</code> (unknown): Number: Alpha transparency of the blur effect (default: 255)</li> <li><code>alpha</code> (Number): Alpha transparency of the blur effect (default: 255)</li> </ul> <p>Returns</p> <ul> <li>Nothing (draws directly to screen)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add basic blur behind a panel\nlocal panel = vgui.Create(\"DPanel\")\nlia.util.drawBlur(panel, 5, nil, 200)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create a blurred dialog background\nlocal frame = vgui.Create(\"DFrame\")\nframe:SetTitle(\"Important Message\")\nframe:SetSize(400, 200)\nframe:Center()\nframe.Paint = function(self, w, h)\nlia.util.drawBlur(self, 8, nil, 180)\ndraw.RoundedBox(8, 0, 0, w, h, Color(0, 0, 0, 150))\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create an animated blur effect system\nlocal blurIntensity = 0\nlocal function drawDynamicBlur(panel)\n    blurIntensity = math.sin(CurTime() * 2) * 5 + 6\n    lia.util.drawBlur(panel, blurIntensity, nil, 220)\nend\nlocal function createBlurredMenu(title, options)\n    local frame = vgui.Create(\"DFrame\")\n    frame:SetTitle(title)\n    frame:SetSize(300, 400)\n    frame:Center()\n    frame.Paint = function(self, w, h)\n    drawDynamicBlur(self)\n    draw.RoundedBox(12, 0, 0, w, h, Color(20, 20, 20, 200))\nend\nfor i, option in ipairs(options) do\n    local button = vgui.Create(\"DButton\", frame)\n    button:SetText(option.text)\n    button:Dock(TOP)\n    button:DockMargin(20, 10, 20, 10)\n    button.Paint = function(self, w, h)\n    if self:IsHovered() then\n        lia.util.drawBlur(self, 3, nil, 150)\n    end\n    draw.RoundedBox(6, 0, 0, w, h, Color(60, 60, 60, 200))\nend\nbutton.DoClick = option.callback\nend\nreturn frame\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#drawblackblur","title":"drawBlackBlur","text":"<p>Purpose</p> <p>Draw a black blur effect with enhanced darkness behind a panel</p> <p>When Called</p> <p>When you need to create a darker, more opaque blurred background effect for UI elements</p> <p>Parameters</p> <ul> <li><code>panel</code> (unknown): Panel: The panel to draw blur behind</li> <li><code>panel</code> (Panel): The panel to draw blur behind</li> <li><code>amount</code> (unknown): Number: Intensity of the blur effect (default: 6)</li> <li><code>amount</code> (Number): Intensity of the blur effect (default: 6)</li> <li><code>passes</code> (unknown): Number: Number of blur passes for quality (default: 5, minimum: 1)</li> <li><code>passes</code> (Number): Number of blur passes for quality (default: 5, minimum: 1)</li> <li><code>alpha</code> (unknown): Number: Alpha transparency of the blur effect (default: 255)</li> <li><code>alpha</code> (Number): Alpha transparency of the blur effect (default: 255)</li> <li><code>darkAlpha</code> (unknown): Number: Alpha transparency of the dark overlay (default: 220)</li> <li><code>darkAlpha</code> (Number): Alpha transparency of the dark overlay (default: 220)</li> </ul> <p>Returns</p> <ul> <li>Nothing (draws directly to screen)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add dark blur behind a panel\nlocal panel = vgui.Create(\"DPanel\")\nlia.util.drawBlackBlur(panel, 6, 5, 255, 220)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create a cinematic menu with dark blur\nlocal menu = vgui.Create(\"DFrame\")\nmenu:SetTitle(\"Game Menu\")\nmenu:SetSize(500, 300)\nmenu:Center()\nmenu.Paint = function(self, w, h)\nlia.util.drawBlackBlur(self, 8, 7, 255, 240)\ndraw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 180))\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create an adaptive blur system based on context\nlocal function drawContextualBlur(panel, context)\n    local settings = {\n    menu = {amount = 6, passes = 5, alpha = 255, darkAlpha = 220},\n    dialog = {amount = 8, passes = 7, alpha = 255, darkAlpha = 240},\n    overlay = {amount = 4, passes = 3, alpha = 200, darkAlpha = 180}\n    }\n    local config = settings[context] or settings.menu\n    lia.util.drawBlackBlur(panel, config.amount, config.passes, config.alpha, config.darkAlpha)\nend\nlocal function createContextualUI(context, title)\n    local frame = vgui.Create(\"DFrame\")\n    frame:SetTitle(title)\n    frame:SetSize(400, 250)\n    frame:Center()\n    frame.Paint = function(self, w, h)\n    drawContextualBlur(self, context)\n    draw.RoundedBox(8, 0, 0, w, h, Color(10, 10, 10, 200))\nend\nreturn frame\nend\n-- Usage for different contexts\nlocal menuUI = createContextualUI(\"menu\", \"Main Menu\")\nlocal dialogUI = createContextualUI(\"dialog\", \"Important Dialog\")\nlocal overlayUI = createContextualUI(\"overlay\", \"HUD Overlay\")\n</code></pre></p>"},{"location":"libraries/lia.util/#drawblurat","title":"drawBlurAt","text":"<p>Purpose</p> <p>Draw a blur effect at specific screen coordinates</p> <p>When Called</p> <p>When you need to apply blur effects to specific screen areas for HUD elements or overlays</p> <p>Parameters</p> <ul> <li><code>x</code> (unknown): Number: X position to draw the blur</li> <li><code>x</code> (Number): X position to draw the blur</li> <li><code>y</code> (unknown): Number: Y position to draw the blur</li> <li><code>y</code> (Number): Y position to draw the blur</li> <li><code>w</code> (unknown): Number: Width of the blur area</li> <li><code>w</code> (Number): Width of the blur area</li> <li><code>h</code> (unknown): Number: Height of the blur area</li> <li><code>h</code> (Number): Height of the blur area</li> <li><code>amount</code> (unknown): Number: Intensity of the blur effect (default: 5)</li> <li><code>amount</code> (Number): Intensity of the blur effect (default: 5)</li> <li><code>passes</code> (unknown): Number: Number of blur passes (default: 0.2)</li> <li><code>passes</code> (Number): Number of blur passes (default: 0.2)</li> <li><code>alpha</code> (unknown): Number: Alpha transparency of the blur effect (default: 255)</li> <li><code>alpha</code> (Number): Alpha transparency of the blur effect (default: 255)</li> </ul> <p>Returns</p> <ul> <li>Nothing (draws directly to screen)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Blur a specific screen area\nlia.util.drawBlurAt(100, 100, 200, 150, 5, 0.2, 255)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create a blurred HUD overlay for damage effects\nlocal function drawDamageOverlay(damage)\n    local alpha = math.Clamp(damage * 2, 0, 200)\n    lia.util.drawBlurAt(0, 0, ScrW(), ScrH(), 3, 0.3, alpha)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a dynamic minimap with blur effects\nlocal function drawMinimapWithEffects(playerPos, mapSize)\n    local mapX, mapY = 50, ScrH() - mapSize - 50\n    local mapW, mapH = mapSize, mapSize\n    -- Draw blurred background for minimap\n    lia.util.drawBlurAt(mapX - 10, mapY - 10, mapW + 20, mapH + 20, 2, 0.1, 150)\n    -- Draw minimap content\n    surface.SetDrawColor(100, 100, 100, 200)\n    surface.DrawRect(mapX, mapY, mapW, mapH)\n    -- Draw player position with pulsing effect\n    local pulseAlpha = (math.sin(CurTime() * 4) + 1) * 100 + 50\n    surface.SetDrawColor(255, 255, 0, pulseAlpha)\n    surface.DrawRect(mapX + mapW/2 - 2, mapY + mapH/2 - 2, 4, 4)\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#createtableui","title":"createTableUI","text":"<p>Purpose</p> <p>Create a complete table-based UI window for displaying data with interactive features</p> <p>When Called</p> <p>When you need to display tabular data with sorting, actions, and interactive options</p> <p>Parameters</p> <ul> <li><code>title</code> (unknown): String: Title for the table window</li> <li><code>title</code> (String): Title for the table window</li> <li><code>columns</code> (unknown): Table: Array of column definitions</li> <li><code>columns</code> (Table): Array of column definitions</li> <li><code>data</code> (unknown): Table: Array of row data to display</li> <li><code>data</code> (Table): Array of row data to display</li> <li><code>options</code> (unknown): Table: Optional action buttons and configurations</li> <li><code>options</code> (Table): Optional action buttons and configurations</li> <li><code>charID</code> (unknown): Number: Character ID for character-specific data</li> <li><code>charID</code> (Number): Character ID for character-specific data</li> </ul> <p>Returns</p> <ul> <li>Frame, ListView: The created frame and list view objects</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create basic table UI\nlocal frame, listView = lia.util.createTableUI(\"Player List\", columns, playerData)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create table with action options\nlocal options = {\n{name = \"Teleport\", net = \"liaTeleportTo\"},\n{name = \"Kick\", net = \"liaKickPlayer\"}\n}\nlocal frame, listView = lia.util.createTableUI(\"Admin Panel\", columns, data, options, charID)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create comprehensive data management interface\nlocal function createDataManager(dataType)\n    local columns = {\n    {name = \"ID\", field = \"id\", width = 80},\n    {name = \"Name\", field = \"name\", width = 200},\n    {name = \"Status\", field = \"status\", width = 120}\n    }\n    local options = {\n    {name = \"Edit\", net = \"liaEdit\" .. dataType},\n    {name = \"Delete\", net = \"liaDelete\" .. dataType},\n    {name = \"View Details\", net = \"liaView\" .. dataType}\n    }\n    return lia.util.createTableUI(dataType .. \" Management\", columns, getData(dataType), options)\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#openoptionsmenu","title":"openOptionsMenu","text":"<p>Purpose</p> <p>Create and display an options menu with interactive buttons</p> <p>When Called</p> <p>When you need to present a list of options or actions to the user in a popup menu</p> <p>Parameters</p> <ul> <li><code>title</code> (unknown): String: Title for the options menu</li> <li><code>title</code> (String): Title for the options menu</li> <li><code>options</code> (unknown): Table: Array of option objects or key-value pairs with name and callback properties</li> <li><code>options</code> (Table): Array of option objects or key-value pairs with name and callback properties</li> </ul> <p>Returns</p> <ul> <li>Frame: The created options menu frame</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create basic options menu\nlocal frame = lia.util.openOptionsMenu(\"Choose Action\", {\n{name = \"Option 1\", callback = function() print(\"Option 1 selected\") end},\n{name = \"Option 2\", callback = function() print(\"Option 2 selected\") end}\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create contextual options menu\nlocal options = {\n[\"Heal Player\"] = function() healTargetPlayer(target) end,\n[\"Teleport\"] = function() teleportToTarget(target) end,\n[\"Give Item\"] = function() openGiveItemMenu(target) end\n}\nlia.util.openOptionsMenu(\"Player Actions\", options)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create dynamic options system with categories\nlocal function createCategorizedOptions(categories)\n    local allOptions = {}\n    for categoryName, categoryOptions in pairs(categories) do\n        -- Add category header (disabled button)\n        allOptions[#allOptions + 1] = {\n        name = categoryName,\n        callback = function() end, -- No action for headers\n        disabled = true\n        }\n        -- Add category options\n        for _, option in ipairs(categoryOptions) do\n            allOptions[#allOptions + 1] = option\n        end\n        -- Add spacer\n        allOptions[#allOptions + 1] = {\n        name = \"\",\n        callback = function() end,\n        separator = true\n        }\n    end\n    return lia.util.openOptionsMenu(\"Categorized Options\", allOptions)\nend\n</code></pre></p>"},{"location":"libraries/lia.util/#drawenttext","title":"drawEntText","text":"<p>Purpose</p> <p>Draw floating text above an entity with distance-based fade effects</p> <p>When Called</p> <p>When you need to display information or labels above entities in the 3D world</p> <p>Parameters</p> <ul> <li><code>ent</code> (unknown): Entity: The entity to draw text above</li> <li><code>ent</code> (Entity): The entity to draw text above</li> <li><code>text</code> (unknown): String: The text to display</li> <li><code>text</code> (String): The text to display</li> <li><code>posY</code> (unknown): Number: Vertical offset for text positioning (default: 0)</li> <li><code>posY</code> (Number): Vertical offset for text positioning (default: 0)</li> <li><code>alphaOverride</code> (unknown): Number: Optional alpha override for manual control</li> <li><code>alphaOverride</code> (Number): Optional alpha override for manual control</li> </ul> <p>Returns</p> <ul> <li>Nothing (draws directly to screen)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw text above an entity\nlia.util.drawEntText(someEntity, \"Important Item\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw contextual entity information\nlocal function drawEntityInfo(ent)\n    if ent:isItem() then\n        local itemName = ent:getNetVar(\"id\", \"Unknown Item\")\n        lia.util.drawEntText(ent, itemName, 20)\n        elseif ent:IsPlayer() then\n            lia.util.drawEntText(ent, ent:Name(), 30)\n        end\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a comprehensive entity labeling system\nlocal function drawSmartEntityLabels()\n    local entities = ents.FindInSphere(LocalPlayer():GetPos(), 500)\n    for _, ent in ipairs(entities) do\n        if not IsValid(ent) then continue end\n            local text = \"\"\n            local offset = 0\n            local alpha = nil\n            if ent:IsPlayer() then\n                text = ent:Name()\n                offset = 40\n            elseif ent:isItem() then\n                    text = ent:getNetVar(\"id\", \"Item\")\n                    offset = 25\n                    alpha = 200 -- Slightly transparent for items\n                    elseif ent:GetClass() == \"prop_physics\" then\n                        text = \"Interactive Object\"\n                        offset = 30\n                    end\n                    if text ~= \"\" then\n                        lia.util.drawEntText(ent, text, offset, alpha)\n                    end\n                end\n            end\n            -- Call in HUDPaint or Think hook\n            hook.Add(\"HUDPaint\", \"DrawEntityLabels\", drawSmartEntityLabels)\n</code></pre></p>"},{"location":"libraries/lia.util/#drawlooktext","title":"drawLookText","text":"<p>Purpose</p> <p>Draw floating text at the player's look position with distance-based fade effects</p> <p>When Called</p> <p>When you need to display contextual information at the location the player is looking at</p> <p>Parameters</p> <ul> <li><code>text</code> (unknown): String: The text to display</li> <li><code>text</code> (String): The text to display</li> <li><code>posY</code> (unknown): Number: Vertical offset for text positioning (default: 0)</li> <li><code>posY</code> (Number): Vertical offset for text positioning (default: 0)</li> <li><code>alphaOverride</code> (unknown): Number: Optional alpha override for manual control</li> <li><code>alphaOverride</code> (Number): Optional alpha override for manual control</li> <li><code>maxDist</code> (unknown): Number: Maximum distance to display text (default: 380)</li> <li><code>maxDist</code> (Number): Maximum distance to display text (default: 380)</li> </ul> <p>Returns</p> <ul> <li>Nothing (draws directly to screen)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw text where player is looking\nlia.util.drawLookText(\"Target Location\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Show distance-based information\nlocal trace = LocalPlayer():GetEyeTrace()\nif trace.Hit then\n    local distance = math.Round(trace.HitPos:Distance(LocalPlayer():GetPos()))\n    lia.util.drawLookText(\"Distance: \" .. distance .. \" units\", 20)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create an interactive world information system\nlocal function drawContextualWorldInfo()\n    local trace = util.TraceLine({\n    start = EyePos(),\nendpos = EyePos() + EyeAngles():Forward() * 200,\nfilter = LocalPlayer()\n})\nif trace.Hit and trace.HitPos:Distance(EyePos()) &lt;= 200 then\n    local hitPos = trace.HitPos\n    local hitEntity = trace.Entity\n    if IsValid(hitEntity) then\n        if hitEntity:IsPlayer() then\n            lia.util.drawLookText(\"Player: \" .. hitEntity:Name(), 30)\n        elseif hitEntity:isItem() then\n                local itemName = hitEntity:getNetVar(\"id\", \"Unknown Item\")\n                lia.util.drawLookText(\"Item: \" .. itemName, 25)\n                else\n                    lia.util.drawLookText(\"Entity: \" .. hitEntity:GetClass(), 20)\n                end\n                else\n                    -- Show world position information\n                    local posText = string.format(\"X: %d, Y: %d, Z: %d\",\n                    math.Round(hitPos.x), math.Round(hitPos.y), math.Round(hitPos.z))\n                    lia.util.drawLookText(\"Position: \" .. posText, 15)\n                end\n            end\n        end\n        -- Call in HUDPaint hook\n        hook.Add(\"HUDPaint\", \"DrawWorldInfo\", drawContextualWorldInfo)\n</code></pre></p>"},{"location":"libraries/lia.vendor/","title":"Vendor Library","text":"<p>NPC vendor management system with editing and rarity support for the Lilia framework.</p> <p>Overview</p> <p>The vendor library provides comprehensive functionality for managing NPC vendors in the Lilia framework. It handles vendor configuration, editing, presets, and rarity systems for items sold by vendors. The library operates on both server and client sides, with the server handling vendor data processing and the client managing the editing interface. It includes support for vendor presets, item rarities, stock management, pricing, faction/class restrictions, and visual customization. The library ensures that vendors can be easily configured and managed through both code and in-game editing tools.</p>"},{"location":"libraries/lia.vendor/#addrarities","title":"addRarities","text":"<p>Purpose</p> <p>Adds a new item rarity type with an associated color to the vendor system</p> <p>When Called</p> <p>During initialization or when defining custom item rarities for vendors</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name of the rarity (e.g., \"common\", \"rare\", \"legendary\"), color (Color) - The color associated with this rarity</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a basic rarity\nlia.vendor.addRarities(\"common\", Color(255, 255, 255))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add multiple rarities with custom colors\nlia.vendor.addRarities(\"rare\", Color(0, 255, 0))\nlia.vendor.addRarities(\"epic\", Color(128, 0, 255))\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add rarities with validation and error handling\nlocal rarities = {\n    { name = \"common\", color = Color(200, 200, 200) },\n    { name = \"uncommon\", color = Color(0, 255, 0) },\n    { name = \"rare\", color = Color(0, 0, 255) },\n    { name = \"epic\", color = Color(128, 0, 255) },\n    { name = \"legendary\", color = Color(255, 165, 0) }\n}\nfor _, rarity in ipairs(rarities) do\n    lia.vendor.addRarities(rarity.name, rarity.color)\nend\n</code></pre></p>"},{"location":"libraries/lia.vendor/#addpreset","title":"addPreset","text":"<p>Purpose</p> <p>Creates a vendor preset with predefined items and their configurations</p> <p>When Called</p> <p>During initialization or when defining vendor templates with specific item sets</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name of the preset, items (table) - Table containing item types as keys and their configuration as values</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a basic weapon vendor preset\nlia.vendor.addPreset(\"weapon_vendor\", {\n    [\"weapon_pistol\"] = { price = 100, stock = 5 },\n    [\"weapon_shotgun\"] = { price = 250, stock = 2 }\n})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add a medical vendor preset with various items\nlia.vendor.addPreset(\"medical_vendor\", {\n    [\"bandage\"] = { price = 25, stock = 10, mode = 1 },\n    [\"medkit\"] = { price = 100, stock = 3, mode = 1 },\n    [\"painkillers\"] = { price = 50, stock = 8, mode = 1 }\n})\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add a comprehensive vendor preset with validation\nlocal weaponPreset = {\n    [\"weapon_pistol\"] = { price = 100, stock = 5, mode = 1 },\n    [\"weapon_shotgun\"] = { price = 250, stock = 2, mode = 1 },\n    [\"weapon_rifle\"] = { price = 500, stock = 1, mode = 1 },\n    [\"ammo_pistol\"] = { price = 10, stock = 50, mode = 1 },\n    [\"ammo_shotgun\"] = { price = 15, stock = 30, mode = 1 }\n}\nlia.vendor.addPreset(\"gun_dealer\", weaponPreset)\n</code></pre></p>"},{"location":"libraries/lia.vendor/#getpreset","title":"getPreset","text":"<p>Purpose</p> <p>Retrieves a vendor preset by name for applying to vendors</p> <p>When Called</p> <p>When applying presets to vendors or checking if a preset exists</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name of the preset to retrieve</li> </ul> <p>Returns</p> <ul> <li>table or nil - The preset data table if found, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a preset and apply it to a vendor\nlocal preset = lia.vendor.getPreset(\"weapon_vendor\")\nif preset then\n    vendor:applyPreset(\"weapon_vendor\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check if preset exists and validate items\nlocal presetName = \"medical_vendor\"\nlocal preset = lia.vendor.getPreset(presetName)\nif preset then\n    print(\"Preset '\" .. presetName .. \"' found with \" .. table.Count(preset) .. \" items\")\nelse\n    print(\"Preset '\" .. presetName .. \"' not found\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Get preset and dynamically configure vendor based on preset data\nlocal presetName = \"gun_dealer\"\nlocal preset = lia.vendor.getPreset(presetName)\nif preset then\n    for itemType, itemData in pairs(preset) do\n        vendor:setItemPrice(itemType, itemData.price)\n        vendor:setStock(itemType, itemData.stock)\n        if itemData.mode then\n            vendor:setTradeMode(itemType, itemData.mode)\n        end\n    end\n    vendor:setName(\"Gun Dealer\")\nend\n</code></pre></p>"},{"location":"libraries/lia.webimage/","title":"Web Image Library","text":"<p>Web-based image downloading, caching, and management system for the Lilia framework.</p> <p>Overview</p> <p>The web image library provides comprehensive functionality for downloading, caching, and managing web-based images in the Lilia framework. It handles automatic downloading of images from URLs, local caching to improve performance, and seamless integration with Garry's Mod's material system. The library operates on both server and client sides, with intelligent caching mechanisms that prevent redundant downloads and ensure images are available offline after initial download. It includes URL validation, file format detection, and automatic directory management for organized storage. The library also provides hooks for download events and statistics tracking. Images are stored in the data/lilia/webimages/ directory and can be accessed through various path formats for maximum compatibility with existing code.</p>"},{"location":"libraries/lia.webimage/#download","title":"download","text":"<p>Purpose</p> <p>Downloads an image from a URL and caches it locally for future use</p> <p>When Called</p> <p>When you need to fetch an image from the internet and store it locally</p> <p>Parameters</p> <ul> <li><code>n</code> (string): Name/identifier for the image</li> <li><code>u</code> (string, optional): URL to download from (uses stored URL if not provided)</li> <li><code>cb</code> (function, optional): Callback function called when download completes</li> <li><code>flags</code> (string, optional): Material flags for the downloaded image</li> </ul> <p>Returns</p> <ul> <li>None (uses callback for results)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Download a single image\nlia.webimage.download(\"logo\", \"https://example.com/logo.png\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Download with callback and custom flags\nlia.webimage.download(\"avatar\", \"https://example.com/avatar.jpg\", function(material, fromCache)\nif material then\n    print(\"Image downloaded successfully\")\n    else\n        print(\"Failed to download image\")\n    end\nend, \"noclamp smooth\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch download with error handling and progress tracking\nlocal images = {\n{name = \"banner\", url = \"https://example.com/banner.png\"},\n{name = \"icon\", url = \"https://example.com/icon.jpg\"},\n{name = \"background\", url = \"https://example.com/bg.png\"}\n}\nlocal completed = 0\nfor _, img in ipairs(images) do\n    lia.webimage.download(img.name, img.url, function(material, fromCache, error)\n    completed = completed + 1\n    if material then\n        print(\"Downloaded: \" .. img.name)\n        else\n            print(\"Failed to download \" .. img.name .. \": \" .. (error or \"unknown error\"))\n        end\n        if completed == #images then\n            print(\"All downloads completed\")\n        end\n    end)\nend\n</code></pre></p>"},{"location":"libraries/lia.webimage/#register","title":"register","text":"<p>Purpose</p> <p>Registers an image URL for future use and immediately downloads it</p> <p>When Called</p> <p>When you want to store an image URL and download it for later use</p> <p>Parameters</p> <ul> <li><code>n</code> (string): Name/identifier for the image</li> <li><code>u</code> (string): URL to download from</li> <li><code>cb</code> (function, optional): Callback function called when download completes</li> <li><code>flags</code> (string, optional): Material flags for the downloaded image</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register and download a single image\nlia.webimage.register(\"logo\", \"https://example.com/logo.png\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register with callback for UI updates\nlia.webimage.register(\"avatar\", \"https://example.com/avatar.jpg\", function(material)\nif material and not material:IsError() then\n    -- Update UI with the new avatar\n    avatarPanel:SetImage(\"data/lilia/webimages/avatar\")\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register multiple images with progress tracking\nlocal imageConfigs = {\n{name = \"banner\", url = \"https://example.com/banner.png\", flags = \"noclamp\"},\n{name = \"icon\", url = \"https://example.com/icon.jpg\", flags = \"smooth\"},\n{name = \"background\", url = \"https://example.com/bg.png\"}\n}\nlocal registered = 0\nfor _, config in ipairs(imageConfigs) do\n    lia.webimage.register(config.name, config.url, function(material)\n    registered = registered + 1\n    if material then\n        print(\"Registered: \" .. config.name)\n    end\n    if registered == #imageConfigs then\n        print(\"All images registered successfully\")\n    end\nend, config.flags)\nend\n</code></pre></p>"},{"location":"libraries/lia.webimage/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves a cached material from a previously downloaded image</p> <p>When Called</p> <p>When you need to get a material that has already been downloaded and cached</p> <p>Parameters</p> <ul> <li><code>n</code> (string): Name/identifier of the image or URL</li> <li><code>flags</code> (string, optional): Material flags to apply to the material</li> </ul> <p>Returns</p> <ul> <li>Material object if found, nil otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a cached material\nlocal logo = lia.webimage.get(\"logo\")\nif logo then\n    surface.SetMaterial(logo)\n    surface.DrawTexturedRect(0, 0, 100, 100)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get material with custom flags and fallback\nlocal avatar = lia.webimage.get(\"avatar\", \"noclamp smooth\")\nif avatar and not avatar:IsError() then\n    avatarPanel:SetMaterial(avatar)\n    else\n        avatarPanel:SetImage(\"icon16/user.png\") -- fallback\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch retrieval with validation and error handling\nlocal imageNames = {\"banner\", \"icon\", \"background\", \"logo\"}\nlocal materials = {}\nfor _, name in ipairs(imageNames) do\n    local material = lia.webimage.get(name, \"noclamp\")\n    if material and not material:IsError() then\n        materials[name] = material\n        print(\"Retrieved material: \" .. name)\n        else\n            print(\"Failed to get material: \" .. name)\n            -- Trigger re-download if needed\n            lia.webimage.download(name)\n        end\n    end\n    -- Use materials for rendering\n    for name, material in pairs(materials) do\n        surface.SetMaterial(material)\n        surface.DrawTexturedRect(0, 0, 200, 200)\n    end\n</code></pre></p>"},{"location":"libraries/lia.webimage/#liamaterial","title":"lia.Material","text":"<p>Purpose</p> <p>Retrieves a cached material from a previously downloaded image</p> <p>When Called</p> <p>When you need to get a material that has already been downloaded and cached</p> <p>Parameters</p> <ul> <li><code>n</code> (string): Name/identifier of the image or URL</li> <li><code>flags</code> (string, optional): Material flags to apply to the material</li> </ul> <p>Returns</p> <ul> <li>Material object if found, nil otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a cached material\nlocal logo = lia.webimage.get(\"logo\")\nif logo then\n    surface.SetMaterial(logo)\n    surface.DrawTexturedRect(0, 0, 100, 100)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get material with custom flags and fallback\nlocal avatar = lia.webimage.get(\"avatar\", \"noclamp smooth\")\nif avatar and not avatar:IsError() then\n    avatarPanel:SetMaterial(avatar)\n    else\n        avatarPanel:SetImage(\"icon16/user.png\") -- fallback\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch retrieval with validation and error handling\nlocal imageNames = {\"banner\", \"icon\", \"background\", \"logo\"}\nlocal materials = {}\nfor _, name in ipairs(imageNames) do\n    local material = lia.webimage.get(name, \"noclamp\")\n    if material and not material:IsError() then\n        materials[name] = material\n        print(\"Retrieved material: \" .. name)\n        else\n            print(\"Failed to get material: \" .. name)\n            -- Trigger re-download if needed\n            lia.webimage.download(name)\n        end\n    end\n    -- Use materials for rendering\n    for name, material in pairs(materials) do\n        surface.SetMaterial(material)\n        surface.DrawTexturedRect(0, 0, 200, 200)\n    end\n</code></pre></p>"},{"location":"libraries/lia.webimage/#liadimagesetimage","title":"lia.dimage:SetImage","text":"<p>Purpose</p> <p>Retrieves a cached material from a previously downloaded image</p> <p>When Called</p> <p>When you need to get a material that has already been downloaded and cached</p> <p>Parameters</p> <ul> <li><code>n</code> (string): Name/identifier of the image or URL</li> <li><code>flags</code> (string, optional): Material flags to apply to the material</li> </ul> <p>Returns</p> <ul> <li>Material object if found, nil otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a cached material\nlocal logo = lia.webimage.get(\"logo\")\nif logo then\n    surface.SetMaterial(logo)\n    surface.DrawTexturedRect(0, 0, 100, 100)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get material with custom flags and fallback\nlocal avatar = lia.webimage.get(\"avatar\", \"noclamp smooth\")\nif avatar and not avatar:IsError() then\n    avatarPanel:SetMaterial(avatar)\n    else\n        avatarPanel:SetImage(\"icon16/user.png\") -- fallback\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch retrieval with validation and error handling\nlocal imageNames = {\"banner\", \"icon\", \"background\", \"logo\"}\nlocal materials = {}\nfor _, name in ipairs(imageNames) do\n    local material = lia.webimage.get(name, \"noclamp\")\n    if material and not material:IsError() then\n        materials[name] = material\n        print(\"Retrieved material: \" .. name)\n        else\n            print(\"Failed to get material: \" .. name)\n            -- Trigger re-download if needed\n            lia.webimage.download(name)\n        end\n    end\n    -- Use materials for rendering\n    for name, material in pairs(materials) do\n        surface.SetMaterial(material)\n        surface.DrawTexturedRect(0, 0, 200, 200)\n    end\n</code></pre></p>"},{"location":"libraries/lia.webimage/#getstats","title":"getStats","text":"<p>Purpose</p> <p>Retrieves statistics about downloaded and stored web images</p> <p>When Called</p> <p>When you need to monitor the library's performance or get usage statistics</p> <p>Returns</p> <ul> <li>Table containing statistics (downloaded count, stored count, last reset time)</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get basic statistics\nlocal stats = lia.webimage.getStats()\nprint(\"Downloaded images: \" .. stats.downloaded)\nprint(\"Stored images: \" .. stats.stored)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display statistics in a panel\nlocal stats = lia.webimage.getStats()\nlocal statsPanel = vgui.Create(\"DPanel\")\nstatsPanel:SetSize(200, 100)\nlocal downloadedLabel = vgui.Create(\"DLabel\", statsPanel)\ndownloadedLabel:SetText(\"Downloaded: \" .. stats.downloaded)\ndownloadedLabel:SetPos(10, 10)\nlocal storedLabel = vgui.Create(\"DLabel\", statsPanel)\nstoredLabel:SetText(\"Stored: \" .. stats.stored)\nstoredLabel:SetPos(10, 30)\nlocal resetLabel = vgui.Create(\"DLabel\", statsPanel)\nresetLabel:SetText(\"Last Reset: \" .. os.date(\"%H:%M:%S\", stats.lastReset))\nresetLabel:SetPos(10, 50)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create a comprehensive statistics dashboard\nlocal function createStatsDashboard()\n    local stats = lia.webimage.getStats()\n    local dashboard = vgui.Create(\"DFrame\")\n    dashboard:SetSize(400, 300)\n    dashboard:SetTitle(\"Web Image Statistics\")\n    dashboard:Center()\n    dashboard:MakePopup()\n    local scrollPanel = vgui.Create(\"DScrollPanel\", dashboard)\n    scrollPanel:Dock(FILL)\n    -- Download statistics\n    local downloadPanel = vgui.Create(\"DPanel\", scrollPanel)\n    downloadPanel:SetSize(380, 80)\n    downloadPanel:Dock(TOP)\n    downloadPanel:DockMargin(5, 5, 5, 5)\n    local downloadLabel = vgui.Create(\"DLabel\", downloadPanel)\n    downloadLabel:SetText(\"Downloaded Images: \" .. stats.downloaded)\n    downloadLabel:SetPos(10, 10)\n    downloadLabel:SetFont(\"DermaDefault\")\n    -- Stored statistics\n    local storedPanel = vgui.Create(\"DPanel\", scrollPanel)\n    storedPanel:SetSize(380, 80)\n    storedPanel:Dock(TOP)\n    storedPanel:DockMargin(5, 5, 5, 5)\n    local storedLabel = vgui.Create(\"DLabel\", storedPanel)\n    storedLabel:SetText(\"Stored Images: \" .. stats.stored)\n    storedLabel:SetPos(10, 10)\n    storedLabel:SetFont(\"DermaDefault\")\n    -- Reset time\n    local resetPanel = vgui.Create(\"DPanel\", scrollPanel)\n    resetPanel:SetSize(380, 80)\n    resetPanel:Dock(TOP)\n    resetPanel:DockMargin(5, 5, 5, 5)\n    local resetLabel = vgui.Create(\"DLabel\", resetPanel)\n    resetLabel:SetText(\"Last Reset: \" .. os.date(\"%Y-%m-%d %H:%M:%S\", stats.lastReset))\n    resetLabel:SetPos(10, 10)\n    resetLabel:SetFont(\"DermaDefault\")\n    -- Refresh button\n    local refreshBtn = vgui.Create(\"DButton\", dashboard)\n    refreshBtn:SetText(\"Refresh Stats\")\n    refreshBtn:SetSize(100, 30)\n    refreshBtn:SetPos(150, 250)\n    refreshBtn.DoClick = function()\n    dashboard:Close()\n    createStatsDashboard() -- Refresh\nend\nend\ncreateStatsDashboard()\n</code></pre></p>"},{"location":"libraries/lia.websound/","title":"WebSound Library","text":"<p>Web-based audio content downloading, caching, and playback system for the Lilia framework.</p> <p>Overview</p> <p>The websound library provides comprehensive functionality for managing web-based audio content in the Lilia framework. It handles downloading, caching, validation, and playback of sound files from HTTP/HTTPS URLs, with automatic local storage and retrieval. The library operates on both server and client sides, providing seamless integration with Garry's Mod's sound system through enhanced versions of sound.PlayFile, sound.PlayURL, and surface.PlaySound functions. It includes robust URL validation, file format verification, caching mechanisms, and statistics tracking. The library ensures optimal performance by avoiding redundant downloads and providing fallback mechanisms for failed downloads while maintaining compatibility with existing sound APIs.</p>"},{"location":"libraries/lia.websound/#download","title":"download","text":"<p>Purpose</p> <p>Downloads a sound file from a URL and caches it locally for future use</p> <p>When Called</p> <p>When a sound needs to be downloaded from a web URL, either directly or through other websound functions</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name/path for the sound file (will be normalized)</li> <li><code>url</code> (string, optional): The HTTP/HTTPS URL to download from (uses stored URL if not provided)</li> <li><code>cb</code> (function, optional): Callback function called with (path, fromCache, error) parameters</li> </ul> <p>Returns</p> <ul> <li>None (uses callback for results)</li> </ul> <p>Realm</p> <p>Client and Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Download a sound file\nlia.websound.download(\"notification.wav\", \"https://example.com/sound.wav\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Download with callback handling\nlia.websound.download(\"alert.mp3\", \"https://example.com/alert.mp3\", function(path, fromCache, error)\nif path then\n    -- Sound downloaded successfully\n    if fromCache then\n        -- Loaded from cache\n    end\n    else\n        -- Download failed\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch download with validation and error handling\nlocal sounds = {\n{name = \"ui/click.wav\", url = \"https://cdn.example.com/ui/click.wav\"},\n{name = \"ui/hover.wav\", url = \"https://cdn.example.com/ui/hover.wav\"},\n{name = \"ui/error.wav\", url = \"https://cdn.example.com/ui/error.wav\"}\n}\nlocal downloadCount = 0\nlocal totalSounds = #sounds\nfor _, soundData in ipairs(sounds) do\n    lia.websound.download(soundData.name, soundData.url, function(path, fromCache, error)\n    downloadCount = downloadCount + 1\n    if path then\n        -- Downloaded sound\n    else\n        -- Failed to download sound\n    end\n        if downloadCount == totalSounds then\n            -- All sounds processed\n        end\n    end)\nend\n</code></pre></p>"},{"location":"libraries/lia.websound/#register","title":"register","text":"<p>Purpose</p> <p>Registers a sound file URL for future use and immediately downloads it</p> <p>When Called</p> <p>When registering a new sound file that should be available for playback</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name/path for the sound file (will be normalized)</li> <li><code>url</code> (string): The HTTP/HTTPS URL to download from</li> <li><code>cb</code> (function, optional): Callback function called with (path, fromCache, error) parameters</li> </ul> <p>Returns</p> <ul> <li>None (uses callback for results)</li> </ul> <p>Realm</p> <p>Client and Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Register a sound file\nlia.websound.register(\"button_click.wav\", \"https://example.com/click.wav\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Register with callback and error handling\nlia.websound.register(\"notification.mp3\", \"https://cdn.example.com/notify.mp3\", function(path, fromCache, error)\nif path then\n    -- Sound registered and downloaded\n    -- Sound is now available for playback\n    else\n        -- Failed to register sound\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Register multiple sounds with validation and progress tracking\nlocal soundRegistry = {\nui = {\n{name = \"ui/click.wav\", url = \"https://cdn.example.com/ui/click.wav\"},\n{name = \"ui/hover.wav\", url = \"https://cdn.example.com/ui/hover.wav\"},\n{name = \"ui/error.wav\", url = \"https://cdn.example.com/ui/error.wav\"}\n},\nambient = {\n{name = \"ambient/rain.mp3\", url = \"https://cdn.example.com/ambient/rain.mp3\"},\n{name = \"ambient/wind.mp3\", url = \"https://cdn.example.com/ambient/wind.mp3\"}\n}\n}\nlocal registeredCount = 0\nlocal totalSounds = 0\nfor category, sounds in pairs(soundRegistry) do\n    totalSounds = totalSounds + #sounds\nend\nfor category, sounds in pairs(soundRegistry) do\n    for _, soundData in ipairs(sounds) do\n        lia.websound.register(soundData.name, soundData.url, function(path, fromCache, error)\n        registeredCount = registeredCount + 1\n        if path then\n            -- Registered sound\n            else\n                -- Failed to register sound\n            end\n            if registeredCount == totalSounds then\n                -- All sounds registered successfully\n            end\n        end)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.websound/#get","title":"get","text":"<p>Purpose</p> <p>Retrieves the local file path of a cached sound file</p> <p>When Called</p> <p>When checking if a sound file is available locally or getting its path for playback</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name/path of the sound file to retrieve (will be normalized)</li> </ul> <p>Returns</p> <ul> <li>string or nil - The local file path if found, nil if not cached</li> </ul> <p>Realm</p> <p>Client and Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if a sound is cached\nlocal soundPath = lia.websound.get(\"button_click.wav\")\nif soundPath then\n    -- Sound is available\n    else\n        -- Sound not cached yet\n    end\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get sound path with fallback handling\nlocal function playSoundIfAvailable(soundName)\n    local soundPath = lia.websound.get(soundName)\n    if soundPath then\n        sound.PlayFile(soundPath)\n        return true\n        else\n            -- Sound not available locally\n            return false\n        end\n    end\n    -- Usage\n    if not playSoundIfAvailable(\"notification.wav\") then\n        -- Fallback to default sound or download\n        lia.websound.register(\"notification.wav\", \"https://example.com/notify.wav\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch check multiple sounds with availability tracking\nlocal requiredSounds = {\n\"ui/click.wav\",\n\"ui/hover.wav\",\n\"ui/error.wav\",\n\"ambient/rain.mp3\",\n\"ambient/wind.mp3\"\n}\nlocal availableSounds = {}\nlocal missingSounds = {}\nfor _, soundName in ipairs(requiredSounds) do\n    local soundPath = lia.websound.get(soundName)\n    if soundPath then\n        availableSounds[soundName] = soundPath\n        -- Sound available\n        else\n            table.insert(missingSounds, soundName)\n            -- Sound not cached\n        end\n    end\n    if #missingSounds &gt; 0 then\n        -- Missing sounds, downloading...\n        for _, soundName in ipairs(missingSounds) do\n            lia.websound.register(soundName, \"https://cdn.example.com/\" .. soundName)\n        end\n        else\n            -- All required sounds are available!\n        end\n</code></pre></p>"},{"location":"libraries/lia.websound/#liasoundplayfile","title":"lia.sound.PlayFile","text":"<p>Purpose</p> <p>Retrieves the local file path of a cached sound file</p> <p>When Called</p> <p>When checking if a sound file is available locally or getting its path for playback</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name/path of the sound file to retrieve (will be normalized)</li> </ul> <p>Returns</p> <ul> <li>string or nil - The local file path if found, nil if not cached</li> </ul> <p>Realm</p> <p>Client and Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if a sound is cached\nlocal soundPath = lia.websound.get(\"button_click.wav\")\nif soundPath then\n    -- Sound is available\n    else\n        -- Sound not cached yet\n    end\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get sound path with fallback handling\nlocal function playSoundIfAvailable(soundName)\n    local soundPath = lia.websound.get(soundName)\n    if soundPath then\n        sound.PlayFile(soundPath)\n        return true\n        else\n            -- Sound not available locally\n            return false\n        end\n    end\n    -- Usage\n    if not playSoundIfAvailable(\"notification.wav\") then\n        -- Fallback to default sound or download\n        lia.websound.register(\"notification.wav\", \"https://example.com/notify.wav\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch check multiple sounds with availability tracking\nlocal requiredSounds = {\n\"ui/click.wav\",\n\"ui/hover.wav\",\n\"ui/error.wav\",\n\"ambient/rain.mp3\",\n\"ambient/wind.mp3\"\n}\nlocal availableSounds = {}\nlocal missingSounds = {}\nfor _, soundName in ipairs(requiredSounds) do\n    local soundPath = lia.websound.get(soundName)\n    if soundPath then\n        availableSounds[soundName] = soundPath\n        -- Sound available\n        else\n            table.insert(missingSounds, soundName)\n            -- Sound not cached\n        end\n    end\n    if #missingSounds &gt; 0 then\n        -- Missing sounds, downloading...\n        for _, soundName in ipairs(missingSounds) do\n            lia.websound.register(soundName, \"https://cdn.example.com/\" .. soundName)\n        end\n        else\n            -- All required sounds are available!\n        end\n</code></pre></p>"},{"location":"libraries/lia.websound/#liasoundplayurl","title":"lia.sound.PlayURL","text":"<p>Purpose</p> <p>Retrieves the local file path of a cached sound file</p> <p>When Called</p> <p>When checking if a sound file is available locally or getting its path for playback</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name/path of the sound file to retrieve (will be normalized)</li> </ul> <p>Returns</p> <ul> <li>string or nil - The local file path if found, nil if not cached</li> </ul> <p>Realm</p> <p>Client and Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if a sound is cached\nlocal soundPath = lia.websound.get(\"button_click.wav\")\nif soundPath then\n    -- Sound is available\n    else\n        -- Sound not cached yet\n    end\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get sound path with fallback handling\nlocal function playSoundIfAvailable(soundName)\n    local soundPath = lia.websound.get(soundName)\n    if soundPath then\n        sound.PlayFile(soundPath)\n        return true\n        else\n            -- Sound not available locally\n            return false\n        end\n    end\n    -- Usage\n    if not playSoundIfAvailable(\"notification.wav\") then\n        -- Fallback to default sound or download\n        lia.websound.register(\"notification.wav\", \"https://example.com/notify.wav\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch check multiple sounds with availability tracking\nlocal requiredSounds = {\n\"ui/click.wav\",\n\"ui/hover.wav\",\n\"ui/error.wav\",\n\"ambient/rain.mp3\",\n\"ambient/wind.mp3\"\n}\nlocal availableSounds = {}\nlocal missingSounds = {}\nfor _, soundName in ipairs(requiredSounds) do\n    local soundPath = lia.websound.get(soundName)\n    if soundPath then\n        availableSounds[soundName] = soundPath\n        -- Sound available\n        else\n            table.insert(missingSounds, soundName)\n            -- Sound not cached\n        end\n    end\n    if #missingSounds &gt; 0 then\n        -- Missing sounds, downloading...\n        for _, soundName in ipairs(missingSounds) do\n            lia.websound.register(soundName, \"https://cdn.example.com/\" .. soundName)\n        end\n        else\n            -- All required sounds are available!\n        end\n</code></pre></p>"},{"location":"libraries/lia.websound/#liasurfaceplaysound","title":"lia.surface.PlaySound","text":"<p>Purpose</p> <p>Retrieves the local file path of a cached sound file</p> <p>When Called</p> <p>When checking if a sound file is available locally or getting its path for playback</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name/path of the sound file to retrieve (will be normalized)</li> </ul> <p>Returns</p> <ul> <li>string or nil - The local file path if found, nil if not cached</li> </ul> <p>Realm</p> <p>Client and Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if a sound is cached\nlocal soundPath = lia.websound.get(\"button_click.wav\")\nif soundPath then\n    -- Sound is available\n    else\n        -- Sound not cached yet\n    end\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get sound path with fallback handling\nlocal function playSoundIfAvailable(soundName)\n    local soundPath = lia.websound.get(soundName)\n    if soundPath then\n        sound.PlayFile(soundPath)\n        return true\n        else\n            -- Sound not available locally\n            return false\n        end\n    end\n    -- Usage\n    if not playSoundIfAvailable(\"notification.wav\") then\n        -- Fallback to default sound or download\n        lia.websound.register(\"notification.wav\", \"https://example.com/notify.wav\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Batch check multiple sounds with availability tracking\nlocal requiredSounds = {\n\"ui/click.wav\",\n\"ui/hover.wav\",\n\"ui/error.wav\",\n\"ambient/rain.mp3\",\n\"ambient/wind.mp3\"\n}\nlocal availableSounds = {}\nlocal missingSounds = {}\nfor _, soundName in ipairs(requiredSounds) do\n    local soundPath = lia.websound.get(soundName)\n    if soundPath then\n        availableSounds[soundName] = soundPath\n        -- Sound available\n        else\n            table.insert(missingSounds, soundName)\n            -- Sound not cached\n        end\n    end\n    if #missingSounds &gt; 0 then\n        -- Missing sounds, downloading...\n        for _, soundName in ipairs(missingSounds) do\n            lia.websound.register(soundName, \"https://cdn.example.com/\" .. soundName)\n        end\n        else\n            -- All required sounds are available!\n        end\n</code></pre></p>"},{"location":"libraries/lia.websound/#getstats","title":"getStats","text":"<p>Purpose</p> <p>Retrieves statistics about downloaded and stored sound files</p> <p>When Called</p> <p>When monitoring websound library performance or displaying usage statistics</p> <p>Returns</p> <ul> <li>table - Contains downloaded count, stored count, and last reset timestamp</li> </ul> <p>Realm</p> <p>Client and Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get basic statistics\nlocal stats = lia.websound.getStats()\n-- Downloaded sounds: stats.downloaded\n-- Stored sounds: stats.stored\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display formatted statistics with timestamp\nlocal function displayWebSoundStats()\n    local stats = lia.websound.getStats()\n    local resetTime = os.date(\"%Y-%m-%d %H:%M:%S\", stats.lastReset)\n    -- WebSound Statistics\n    -- Downloaded sounds: stats.downloaded\n    -- Stored sounds: stats.stored\n    -- Last reset: resetTime\nend\ndisplayWebSoundStats()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Monitor statistics with logging and performance tracking\nlocal function monitorWebSoundPerformance()\n    local stats = lia.websound.getStats()\n    local currentTime = os.time()\n    local timeSinceReset = currentTime - stats.lastReset\n    -- Log statistics to file\n    local logData = {\n    timestamp = os.date(\"%Y-%m-%d %H:%M:%S\", currentTime),\n    downloaded = stats.downloaded,\n    stored = stats.stored,\n    timeSinceReset = timeSinceReset,\n    downloadRate = timeSinceReset &gt; 0 and (stats.downloaded / timeSinceReset) or 0\n    }\n    -- Save to file\n    file.Write(\"websound_stats.json\", util.TableToJSON(logData, true))\n    -- Display performance metrics\n    -- WebSound Performance Report\n    -- Downloads: stats.downloaded sounds\n    -- Storage: stats.stored registered sounds\n    -- Uptime: timeSinceReset seconds\n    -- Download rate: logData.downloadRate sounds/second\n    -- Performance warnings\n    if stats.downloaded &gt; 100 then\n        -- WARNING: High download count detected!\n    end\n    if timeSinceReset &gt; 3600 and stats.downloaded == 0 then\n        -- INFO: No downloads in the last hour\n    end\nend\n-- Run monitoring every 5 minutes\ntimer.Create(\"WebSoundMonitor\", 300, 0, monitorWebSoundPerformance)\n</code></pre></p>"},{"location":"libraries/lia.websound/#playbuttonsound","title":"playButtonSound","text":"<p>Purpose</p> <p>Plays a button click sound with automatic fallback to default button_click.wav</p> <p>When Called</p> <p>When a button is clicked and needs to play a sound</p> <p>Parameters</p> <ul> <li><code>customSound</code> (string, optional): Custom sound to play instead of default</li> <li><code>callback</code> (function, optional): Callback function called with (success) parameter</li> </ul> <p>Returns</p> <ul> <li>None (uses callback for results)</li> </ul> <p>Realm</p> <p>Client only</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Play default button sound\nlia.websound.playButtonSound()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Play custom sound with fallback\nlia.websound.playButtonSound(\"custom_click.wav\", function(success)\nif success then\n    -- Button sound played successfully\n    else\n        -- Failed to play button sound\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Conditional button sounds with error handling\nlocal function handleButtonClick(buttonType, customSound)\n    local soundToPlay = customSound or \"button_click.wav\"\n    lia.websound.playButtonSound(soundToPlay, function(success)\n    if success then\n        -- Played sound for button\n        else\n            -- Failed to play sound, using default\n            -- Fallback to default\n            lia.websound.playButtonSound()\n        end\n    end)\nend\n-- Usage\nhandleButtonClick(\"primary\", \"primary_click.wav\")\nhandleButtonClick(\"secondary\") -- Will use default\n</code></pre></p>"},{"location":"libraries/lia.workshop/","title":"Workshop Library","text":"<p>Steam Workshop addon downloading, mounting, and management system for the Lilia framework.</p> <p>Overview</p> <p>The workshop library provides comprehensive functionality for managing Steam Workshop addons in the Lilia framework. It handles automatic downloading, mounting, and management of workshop content required by the gamemode and its modules. The library operates on both server and client sides, with the server gathering workshop IDs from modules and mounted addons, while the client handles downloading and mounting of required content. It includes user interface elements for download progress tracking and addon information display. The library ensures that all required workshop content is available before gameplay begins.</p>"},{"location":"libraries/lia.workshop/#addworkshop","title":"addWorkshop","text":"<p>Purpose</p> <p>Adds a workshop addon ID to the server's required workshop content list</p> <p>When Called</p> <p>Called when modules or addons need specific workshop content</p> <p>Parameters</p> <ul> <li><code>id</code> (string/number): The Steam Workshop ID of the addon to add</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add a single workshop addon\nlia.workshop.addWorkshop(\"1234567890\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add workshop addon from module configuration\nlocal workshopId = module.WorkshopContent\nif workshopId then\n    lia.workshop.addWorkshop(workshopId)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Add multiple workshop addons with validation\nlocal workshopIds = {\"1234567890\", \"0987654321\", \"1122334455\"}\nfor _, id in ipairs(workshopIds) do\n    if id and id ~= \"\" then\n        lia.workshop.addWorkshop(id)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.workshop/#gather","title":"gather","text":"<p>Purpose</p> <p>Gathers all workshop IDs from mounted addons and module configurations</p> <p>When Called</p> <p>Called during module initialization to collect all required workshop content</p> <p>Returns</p> <ul> <li>table - Table containing all workshop IDs that need to be downloaded</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Gather workshop IDs\nlocal workshopIds = lia.workshop.gather()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Gather and validate workshop IDs\nlocal workshopIds = lia.workshop.gather()\nlocal count = table.Count(workshopIds)\nprint(\"Found \" .. count .. \" workshop addons\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Gather workshop IDs and send to specific players\nlocal workshopIds = lia.workshop.gather()\nfor _, ply in pairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        net.Start(\"liaWorkshopDownloaderStart\")\n        net.WriteTable(workshopIds)\n        net.Send(ply)\n    end\nend\n</code></pre></p>"},{"location":"libraries/lia.workshop/#send","title":"send","text":"<p>Purpose</p> <p>Sends the cached workshop IDs to a specific player to initiate download</p> <p>When Called</p> <p>Called when a player requests workshop content or during initial spawn</p> <p>Parameters</p> <ul> <li><code>ply</code> (Player): The player to send workshop IDs to</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send workshop IDs to a player\nlia.workshop.send(player.GetByID(1))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send workshop IDs to admin players only\nfor _, ply in pairs(player.GetAll()) do\n    if ply:IsAdmin() then\n        lia.workshop.send(ply)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Send workshop IDs with validation and logging\nlocal function sendToPlayer(ply)\n    if IsValid(ply) and ply:IsConnected() then\n        lia.workshop.send(ply)\n        print(\"Sent workshop IDs to \" .. ply:Name())\n    end\nend\nhook.Add(\"PlayerInitialSpawn\", \"CustomWorkshopSend\", function(ply)\ntimer.Simple(5, function()\nsendToPlayer(ply)\nend)\nend)\n</code></pre></p>"},{"location":"libraries/lia.workshop/#hascontenttodownload","title":"hasContentToDownload","text":"<p>Purpose</p> <p>Checks if there are any workshop addons that need to be downloaded</p> <p>When Called</p> <p>Called to determine if the client needs to download workshop content</p> <p>Returns</p> <ul> <li>boolean - True if content needs to be downloaded, false otherwise</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if downloads are needed\nif lia.workshop.hasContentToDownload() then\n    print(\"Workshop content needs to be downloaded\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check and show notification\nif lia.workshop.hasContentToDownload() then\n    notification.AddLegacy(\"Workshop content available for download\", NOTIFY_GENERIC, 5)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Check downloads and create custom UI\nlocal function checkDownloads()\n    if lia.workshop.hasContentToDownload() then\n        local frame = vgui.Create(\"DFrame\")\n        frame:SetTitle(\"Workshop Downloads Available\")\n        frame:SetSize(400, 200)\n        frame:Center()\n        frame:MakePopup()\n        local btn = vgui.Create(\"DButton\", frame)\n        btn:SetText(\"Download Now\")\n        btn:Dock(BOTTOM)\n        btn.DoClick = function()\n        lia.workshop.mountContent()\n        frame:Close()\n    end\nend\nend\nhook.Add(\"OnEntityCreated\", \"CheckWorkshopDownloads\", function(ent)\nif ent == LocalPlayer() then\n    timer.Simple(1, checkDownloads)\nend\nend)\n</code></pre></p>"},{"location":"libraries/lia.workshop/#mountcontent","title":"mountContent","text":"<p>Purpose</p> <p>Initiates the mounting process for required workshop content with user confirmation</p> <p>When Called</p> <p>Called when the client needs to download and mount workshop addons</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Mount workshop content\nlia.workshop.mountContent()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Mount content with custom callback\nlia.workshop.mountContent()\nhook.Add(\"Think\", \"CheckMountComplete\", function()\nif not lia.workshop.hasContentToDownload() then\n    print(\"All workshop content mounted successfully\")\n    hook.Remove(\"Think\", \"CheckMountComplete\")\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Mount content with progress tracking and custom UI\nlocal function mountWithProgress()\n    local needed = {}\n    local ids = lia.workshop.serverIds or {}\n    for id in pairs(ids) do\n        if id ~= \"3527535922\" and not mounted(id) and not mountLocal(id) then\n            needed[#needed + 1] = id\n        end\n    end\n    if #needed &gt; 0 then\n        local frame = vgui.Create(\"DFrame\")\n        frame:SetTitle(\"Workshop Content Download\")\n        frame:SetSize(500, 300)\n        frame:Center()\n        frame:MakePopup()\n        local progress = vgui.Create(\"DProgress\", frame)\n        progress:Dock(TOP)\n        progress:SetHeight(30)\n        local function updateProgress(current, total)\n            progress:SetFraction(current / total)\n            progress:SetText(current .. \"/\" .. total)\n        end\n        lia.workshop.mountContent()\n    end\nend\nhook.Add(\"PlayerInitialSpawn\", \"MountWorkshopContent\", function(ply)\nif ply == LocalPlayer() then\n    timer.Simple(3, mountWithProgress)\nend\nend)\n</code></pre></p>"},{"location":"meta/character/","title":"Character Meta","text":"<p>Character management system for the Lilia framework.</p> <p>Overview</p> <p>The character meta table provides comprehensive functionality for managing character data, attributes, and operations in the Lilia framework. It handles character creation, data persistence, attribute management, recognition systems, and character-specific operations. The meta table operates on both server and client sides, with the server managing character storage and validation while the client provides character data access and display. It includes integration with the database system for character persistence, inventory management for character items, and faction/class systems for character roles. The meta table ensures proper character data synchronization, attribute calculations with boosts, recognition between characters, and comprehensive character lifecycle management from creation to deletion.</p>"},{"location":"meta/character/#tostring","title":"tostring","text":"<p>Purpose</p> <p>Converts the character object to a string representation</p> <p>When Called</p> <p>When displaying character information or debugging</p> <p>Returns</p> <ul> <li>string - Formatted character string with ID</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get character string representation\nlocal charString = character:tostring()\nprint(charString) -- Output: \"character[123]\"\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in debug messages\nlocal char = player:getChar()\nif char then\n    print(\"Character: \" .. char:tostring())\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in logging system\nlocal char = player:getChar()\nlia.log.add(player, \"action\", \"Character \" .. char:tostring() .. \" performed action\")\n</code></pre></p>"},{"location":"meta/character/#eq","title":"eq","text":"<p>Purpose</p> <p>Compares two character objects for equality based on their IDs</p> <p>When Called</p> <p>When checking if two character references point to the same character</p> <p>Parameters</p> <ul> <li><code>other</code> (character): The other character object to compare with</li> </ul> <p>Returns</p> <ul> <li>boolean - True if both characters have the same ID, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Compare two character objects\nlocal char1 = player1:getChar()\nlocal char2 = player2:getChar()\nif char1:eq(char2) then\n    print(\"Same character\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in conditional logic\nlocal targetChar = target:getChar()\nlocal myChar = player:getChar()\nif myChar:eq(targetChar) then\n    -- Handle self-targeting\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in character management system\nfor _, char in pairs(characterList) do\n    if char:eq(selectedCharacter) then\n        -- Process matching character\n        break\n    end\nend\n</code></pre></p>"},{"location":"meta/character/#getid","title":"getID","text":"<p>Purpose</p> <p>Retrieves the unique ID of the character</p> <p>When Called</p> <p>When you need to identify a specific character instance</p> <p>Returns</p> <ul> <li>number - The character's unique ID</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get character ID\nlocal char = player:getChar()\nlocal charID = char:getID()\nprint(\"Character ID: \" .. charID)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use ID for database operations\nlocal char = player:getChar()\nlocal charID = char:getID()\nlia.db.query(\"SELECT * FROM chardata WHERE charID = \" .. charID)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use ID in networking\nnet.Start(\"liaCharInfo\")\nnet.WriteUInt(char:getID(), 32)\nnet.Send(player)\n</code></pre></p>"},{"location":"meta/character/#getplayer","title":"getPlayer","text":"<p>Purpose</p> <p>Retrieves the player entity associated with this character</p> <p>When Called</p> <p>When you need to access the player who owns this character</p> <p>Returns</p> <ul> <li>Player - The player entity, or nil if not found</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get the player from character\nlocal char = player:getChar()\nlocal owner = char:getPlayer()\nif IsValid(owner) then\n    print(\"Player: \" .. owner:Name())\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use player for operations\nlocal char = character:getPlayer()\nif IsValid(char) then\n    char:SetPos(Vector(0, 0, 0))\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in networking and validation\nlocal char = character:getPlayer()\nif IsValid(char) then\n    net.Start(\"liaCharSync\")\n    net.WriteEntity(char)\n    net.Broadcast()\nend\n</code></pre></p>"},{"location":"meta/character/#getdisplayedname","title":"getDisplayedName","text":"<p>Purpose</p> <p>Gets the display name for a character based on recognition system</p> <p>When Called</p> <p>When displaying character names to other players</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client who is viewing the character</li> </ul> <p>Returns</p> <ul> <li>string - The name to display (real name, fake name, or \"unknown\")</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get display name for a player\nlocal char = target:getChar()\nlocal displayName = char:getDisplayedName(player)\nprint(\"You see: \" .. displayName)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in chat system\nlocal char = speaker:getChar()\nlocal displayName = char:getDisplayedName(listener)\nchat.AddText(Color(255, 255, 255), displayName .. \": \" .. message)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in UI display system\nlocal char = character:getDisplayedName(client)\nlocal nameColor = char == \"unknown\" and Color(128, 128, 128) or Color(255, 255, 255)\ndraw.SimpleText(char, \"DermaDefault\", x, y, nameColor)\n</code></pre></p>"},{"location":"meta/character/#hasmoney","title":"hasMoney","text":"<p>Purpose</p> <p>Checks if the character has enough money for a transaction</p> <p>When Called</p> <p>Before processing purchases, payments, or money transfers</p> <p>Parameters</p> <ul> <li><code>amount</code> (number): The amount of money to check for</li> </ul> <p>Returns</p> <ul> <li>boolean - True if character has sufficient funds, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player can afford an item\nlocal char = player:getChar()\nif char:hasMoney(100) then\n    print(\"Can afford item\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in shop system\nlocal char = buyer:getChar()\nlocal itemPrice = 500\nif char:hasMoney(itemPrice) then\n    char:takeMoney(itemPrice)\n    char:giveItem(\"item_id\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex transaction system\nlocal char = player:getChar()\nlocal totalCost = calculateTotalCost(items)\nif char:hasMoney(totalCost) then\n    processTransaction(char, items, totalCost)\n    else\n        showInsufficientFundsError(char, totalCost)\n    end\n</code></pre></p>"},{"location":"meta/character/#hasflags","title":"hasFlags","text":"<p>Purpose</p> <p>Checks if the character has any of the specified flags</p> <p>When Called</p> <p>When checking permissions or access rights for a character</p> <p>Parameters</p> <ul> <li><code>flagStr</code> (string): String containing flags to check for</li> </ul> <p>Returns</p> <ul> <li>boolean - True if character has any of the specified flags, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check for admin flag\nlocal char = player:getChar()\nif char:hasFlags(\"a\") then\n    print(\"Player is admin\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check multiple flags\nlocal char = player:getChar()\nif char:hasFlags(\"ad\") then\n    -- Player has admin or donator flag\n    grantSpecialAccess(char)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in permission system\nlocal char = player:getChar()\nlocal requiredFlags = \"adm\"\nif char:hasFlags(requiredFlags) then\n    showAdminPanel(player)\n    else\n        showAccessDenied(player)\n    end\n</code></pre></p>"},{"location":"meta/character/#getitemweapon","title":"getItemWeapon","text":"<p>Purpose</p> <p>Checks if the character has a weapon item equipped</p> <p>When Called</p> <p>When validating weapon usage or checking equipped items</p> <p>Parameters</p> <ul> <li><code>requireEquip</code> (boolean): Whether to check if item is equipped (default: true)</li> </ul> <p>Returns</p> <ul> <li>boolean - True if character has the weapon item, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player has weapon\nlocal char = player:getChar()\nif char:getItemWeapon() then\n    print(\"Player has weapon\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check weapon with equip requirement\nlocal char = player:getChar()\nif char:getItemWeapon(true) then\n    -- Player has equipped weapon\n    allowWeaponUse(char)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in weapon validation system\nlocal char = player:getChar()\nlocal hasWeapon = char:getItemWeapon(requireEquip)\nif hasWeapon then\n    processWeaponAction(char, action)\n    else\n        showWeaponRequiredError(char)\n    end\n</code></pre></p>"},{"location":"meta/character/#getattrib","title":"getAttrib","text":"<p>Purpose</p> <p>Gets the value of a character attribute including boosts</p> <p>When Called</p> <p>When checking character stats or calculating bonuses</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The attribute key to retrieve</li> <li><code>default</code> (number): Default value if attribute doesn't exist (default: 0)</li> </ul> <p>Returns</p> <ul> <li>number - The attribute value with boosts applied</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get character strength\nlocal char = player:getChar()\nlocal strength = char:getAttrib(\"str\")\nprint(\"Strength: \" .. strength)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in skill checks\nlocal char = player:getChar()\nlocal intelligence = char:getAttrib(\"int\", 10)\nif intelligence &gt; 15 then\n    grantSpecialAbility(char)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex calculations\nlocal char = player:getChar()\nlocal baseStr = char:getAttrib(\"str\")\nlocal baseInt = char:getAttrib(\"int\")\nlocal totalBonus = baseStr + baseInt\ncalculateCombatEffectiveness(char, totalBonus)\n</code></pre></p>"},{"location":"meta/character/#getboost","title":"getBoost","text":"<p>Purpose</p> <p>Gets the boost table for a specific attribute</p> <p>When Called</p> <p>When checking or modifying attribute boosts</p> <p>Parameters</p> <ul> <li><code>attribID</code> (string): The attribute ID to get boosts for</li> </ul> <p>Returns</p> <ul> <li>table - Table containing boost values for the attribute</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>        Medium Complexity:\n\n        High Complexity:\n\n]]\n</code></pre></p>"},{"location":"meta/character/#doesrecognize","title":"doesRecognize","text":"<p>Purpose</p> <p>Checks if the character recognizes another character by ID</p> <p>When Called</p> <p>When determining if one character knows another character's identity</p> <p>Parameters</p> <ul> <li><code>id</code> (number|character): Character ID or character object to check recognition for</li> </ul> <p>Returns</p> <ul> <li>boolean - True if character recognizes the other, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player recognizes target\nlocal char = player:getChar()\nlocal targetChar = target:getChar()\nif char:doesRecognize(targetChar) then\n    print(\"Player recognizes target\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in recognition system\nlocal char = player:getChar()\nlocal targetID = target:getChar():getID()\nif char:doesRecognize(targetID) then\n    showRealName(char, target)\n    else\n        showUnknownName(char, target)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex recognition logic\nlocal char = player:getChar()\nfor _, otherChar in pairs(characterList) do\n    if char:doesRecognize(otherChar) then\n        addToKnownList(char, otherChar)\n    end\nend\n</code></pre></p>"},{"location":"meta/character/#doesfakerecognize","title":"doesFakeRecognize","text":"<p>Purpose</p> <p>Checks if the character has fake recognition of another character</p> <p>When Called</p> <p>When determining if character knows a fake name for another character</p> <p>Parameters</p> <ul> <li><code>id</code> (number|character): Character ID or character object to check fake recognition for</li> </ul> <p>Returns</p> <ul> <li>boolean - True if character has fake recognition, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check fake recognition\nlocal char = player:getChar()\nlocal targetChar = target:getChar()\nif char:doesFakeRecognize(targetChar) then\n    print(\"Player knows fake name\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in disguise system\nlocal char = player:getChar()\nlocal targetID = target:getChar():getID()\nif char:doesFakeRecognize(targetID) then\n    showFakeName(char, target)\n    else\n        showUnknownName(char, target)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex identity system\nlocal char = player:getChar()\nfor _, otherChar in pairs(characterList) do\n    if char:doesFakeRecognize(otherChar) then\n        addToFakeKnownList(char, otherChar)\n    end\nend\n</code></pre></p>"},{"location":"meta/character/#setdata","title":"setData","text":"<p>Purpose</p> <p>Sets character data and optionally syncs it to database and clients</p> <p>When Called</p> <p>When storing character-specific data that needs persistence</p> <p>Parameters</p> <ul> <li><code>k</code> (string|table): Key to set or table of key-value pairs</li> <li><code>v</code> (any): Value to set (ignored if k is table)</li> <li><code>noReplication</code> (boolean): Skip client replication (default: false)</li> <li><code>receiver</code> (Player): Specific client to send to (default: character owner)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set single data value\nlocal char = player:getChar()\nchar:setData(\"lastLogin\", os.time())\n</code></pre></p> <p>Medium Complexity: <pre><code>\n</code></pre></p> <p>Char Complexity: <pre><code>High Complexity:\n</code></pre></p> <p>Char Complexity: <pre><code>]]\n</code></pre></p>"},{"location":"meta/character/#getdata","title":"getData","text":"<p>Purpose</p> <p>Retrieves character data by key or returns all data</p> <p>When Called</p> <p>When accessing stored character-specific data</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The data key to retrieve (optional)</li> <li><code>default</code> (any): Default value if key doesn't exist (optional)</li> </ul> <p>Returns</p> <ul> <li>any - The data value, all data table, or default value</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get specific data\nlocal char = player:getChar()\nlocal level = char:getData(\"level\", 1)\nprint(\"Level: \" .. level)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get all character data\nlocal char = player:getChar()\nlocal allData = char:getData()\nfor key, value in pairs(allData) do\n    print(key .. \": \" .. tostring(value))\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in data processing system\nlocal char = player:getChar()\nlocal inventory = char:getData(\"inventory\", {})\nlocal position = char:getData(\"position\", Vector(0, 0, 0))\nprocessCharacterState(char, inventory, position)\n</code></pre></p>"},{"location":"meta/character/#isbanned","title":"isBanned","text":"<p>Purpose</p> <p>Checks if the character is currently banned</p> <p>When Called</p> <p>When validating character access or checking ban status</p> <p>Returns</p> <ul> <li>boolean - True if character is banned, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if character is banned\nlocal char = player:getChar()\nif char:isBanned() then\n    print(\"Character is banned\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in login validation\nlocal char = player:getChar()\nif char:isBanned() then\n    player:Kick(\"Your character is banned\")\n    return\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in ban management system\nlocal char = player:getChar()\nif char:isBanned() then\n    local banTime = char:getBanned()\n    local banReason = char:getData(\"banReason\", \"No reason provided\")\n    showBanMessage(player, banTime, banReason)\nend\n</code></pre></p>"},{"location":"meta/character/#recognize","title":"recognize","text":"<p>Purpose</p> <p>Makes the character recognize another character (with optional fake name)</p> <p>When Called</p> <p>When establishing recognition between characters</p> <p>Parameters</p> <ul> <li><code>character</code> (number|character): Character ID or character object to recognize</li> <li><code>name</code> (string): Optional fake name to assign (default: nil)</li> </ul> <p>Returns</p> <ul> <li>boolean - True if recognition was successful</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Recognize another character\nlocal char = player:getChar()\nlocal targetChar = target:getChar()\nchar:recognize(targetChar)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Recognize with fake name\nlocal char = player:getChar()\nlocal targetID = target:getChar():getID()\nchar:recognize(targetID, \"John Doe\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in recognition system\nlocal char = player:getChar()\nfor _, otherChar in pairs(characterList) do\n    if shouldRecognize(char, otherChar) then\n        char:recognize(otherChar, getFakeName(char, otherChar))\n    end\nend\n</code></pre></p>"},{"location":"meta/character/#joinclass","title":"joinClass","text":"<p>Purpose</p> <p>Makes the character join a specific class (faction job)</p> <p>When Called</p> <p>When changing character class or job within their faction</p> <p>Parameters</p> <ul> <li><code>class</code> (string): The class name to join</li> <li><code>isForced</code> (boolean): Whether to force the class change (default: false)</li> </ul> <p>Returns</p> <ul> <li>boolean - True if class change was successful, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Join a class\nlocal char = player:getChar()\nchar:joinClass(\"citizen\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Force class change\nlocal char = player:getChar()\nif char:joinClass(\"police\", true) then\n    print(\"Successfully joined police force\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in class management system\nlocal char = player:getChar()\nlocal newClass = determineClass(char, player)\nif char:joinClass(newClass) then\n    updateCharacterUI(player)\n    notifyClassChange(player, newClass)\n    else\n        showClassChangeError(player, newClass)\n    end\n</code></pre></p>"},{"location":"meta/character/#kickclass","title":"kickClass","text":"<p>Purpose</p> <p>Removes the character from their current class and assigns default class</p> <p>When Called</p> <p>When removing character from their current job or class</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Kick from class\nlocal char = player:getChar()\nchar:kickClass()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in demotion system\nlocal char = player:getChar()\nif char:getClass() == \"police\" then\n    char:kickClass()\n    notifyDemotion(player)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in class management system\nlocal char = player:getChar()\nlocal oldClass = char:getClass()\nchar:kickClass()\nlogClassChange(player, oldClass, \"none\")\nupdateCharacterPermissions(player)\n</code></pre></p>"},{"location":"meta/character/#updateattrib","title":"updateAttrib","text":"<p>Purpose</p> <p>Updates a character attribute by adding to the current value</p> <p>When Called</p> <p>When modifying character stats through gameplay or admin actions</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The attribute key to update</li> <li><code>value</code> (number): The amount to add to the current attribute value</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Increase strength\nlocal char = player:getChar()\nchar:updateAttrib(\"str\", 1)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in level up system\nlocal char = player:getChar()\nchar:updateAttrib(\"int\", 2)\nchar:updateAttrib(\"str\", 1)\nnotifyStatIncrease(player, \"int\", 2)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex attribute system\nlocal char = player:getChar()\nlocal statGains = calculateStatGains(char, experience)\nfor stat, gain in pairs(statGains) do\n    char:updateAttrib(stat, gain)\n    logStatChange(player, stat, gain)\nend\n</code></pre></p>"},{"location":"meta/character/#setattrib","title":"setAttrib","text":"<p>Purpose</p> <p>Sets a character attribute to a specific value</p> <p>When Called</p> <p>When setting character stats to exact values</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The attribute key to set</li> <li><code>value</code> (number): The exact value to set the attribute to</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set strength to specific value\nlocal char = player:getChar()\nchar:setAttrib(\"str\", 10)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in character creation\nlocal char = player:getChar()\nchar:setAttrib(\"str\", 5)\nchar:setAttrib(\"int\", 8)\nchar:setAttrib(\"dex\", 6)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in admin system\nlocal char = player:getChar()\nlocal newStats = calculateNewStats(char, adminCommand)\nfor stat, value in pairs(newStats) do\n    char:setAttrib(stat, value)\n    logAdminAction(admin, \"set \" .. stat .. \" to \" .. value)\nend\n</code></pre></p>"},{"location":"meta/character/#addboost","title":"addBoost","text":"<p>Purpose</p> <p>Adds a temporary boost to a character attribute</p> <p>When Called</p> <p>When applying temporary stat bonuses from items, spells, or effects</p> <p>Parameters</p> <ul> <li><code>boostID</code> (string): Unique identifier for this boost</li> <li><code>attribID</code> (string): The attribute to boost</li> <li><code>boostAmount</code> (number): The amount to boost the attribute by</li> </ul> <p>Returns</p> <ul> <li>boolean - True if boost was added successfully</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add strength boost\nlocal char = player:getChar()\nchar:addBoost(\"potion_str\", \"str\", 5)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in item system\nlocal char = player:getChar()\nlocal item = char:getItem(\"strength_potion\")\nif item then\n    char:addBoost(\"item_\" .. item:getID(), \"str\", item:getData(\"boostAmount\", 3))\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex boost system\nlocal char = player:getChar()\nlocal boosts = calculateBoosts(char, equipment)\nfor boostID, boostData in pairs(boosts) do\n    char:addBoost(boostID, boostData.attrib, boostData.amount)\nend\n</code></pre></p>"},{"location":"meta/character/#removeboost","title":"removeBoost","text":"<p>Purpose</p> <p>Removes a temporary boost from a character attribute</p> <p>When Called</p> <p>When removing temporary stat bonuses from items, spells, or effects</p> <p>Parameters</p> <ul> <li><code>boostID</code> (string): Unique identifier for the boost to remove</li> <li><code>attribID</code> (string): The attribute the boost was applied to</li> </ul> <p>Returns</p> <ul> <li>boolean - True if boost was removed successfully</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove strength boost\nlocal char = player:getChar()\nchar:removeBoost(\"potion_str\", \"str\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in item removal\nlocal char = player:getChar()\nlocal item = char:getItem(\"strength_potion\")\nif item then\n    char:removeBoost(\"item_\" .. item:getID(), \"str\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in boost cleanup system\nlocal char = player:getChar()\nlocal expiredBoosts = getExpiredBoosts(char)\nfor boostID, attribID in pairs(expiredBoosts) do\n    char:removeBoost(boostID, attribID)\nend\n</code></pre></p>"},{"location":"meta/character/#setflags","title":"setFlags","text":"<p>Purpose</p> <p>Sets the character flags to a specific string</p> <p>When Called</p> <p>When changing character permissions or access rights</p> <p>Parameters</p> <ul> <li><code>flags</code> (string): The flags string to set</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set admin flags\nlocal char = player:getChar()\nchar:setFlags(\"a\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in permission system\nlocal char = player:getChar()\nchar:setFlags(\"ad\")\nnotifyPermissionChange(player, \"admin and donator\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex permission management\nlocal char = player:getChar()\nlocal newFlags = calculateFlags(char, role, level)\nchar:setFlags(newFlags)\nupdateCharacterPermissions(player)\nlogPermissionChange(admin, player, newFlags)\n</code></pre></p>"},{"location":"meta/character/#giveflags","title":"giveFlags","text":"<p>Purpose</p> <p>Adds flags to the character without removing existing ones</p> <p>When Called</p> <p>When granting additional permissions to a character</p> <p>Parameters</p> <ul> <li><code>flags</code> (string): The flags to add to the character</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Give donator flag\nlocal char = player:getChar()\nchar:giveFlags(\"d\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in reward system\nlocal char = player:getChar()\nchar:giveFlags(\"v\")\nnotifyReward(player, \"VIP status granted\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex permission system\nlocal char = player:getChar()\nlocal earnedFlags = calculateEarnedFlags(char, achievements)\nchar:giveFlags(earnedFlags)\nupdateCharacterUI(player)\nlogFlagGrant(admin, player, earnedFlags)\n</code></pre></p>"},{"location":"meta/character/#takeflags","title":"takeFlags","text":"<p>Purpose</p> <p>Removes flags from the character</p> <p>When Called</p> <p>When revoking permissions or access rights from a character</p> <p>Parameters</p> <ul> <li><code>flags</code> (string): The flags to remove from the character</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove admin flag\nlocal char = player:getChar()\nchar:takeFlags(\"a\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in demotion system\nlocal char = player:getChar()\nchar:takeFlags(\"a\")\nnotifyDemotion(player, \"Admin status revoked\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex permission system\nlocal char = player:getChar()\nlocal revokedFlags = calculateRevokedFlags(char, violations)\nchar:takeFlags(revokedFlags)\nupdateCharacterUI(player)\nlogFlagRevoke(admin, player, revokedFlags)\n</code></pre></p>"},{"location":"meta/character/#save","title":"save","text":"<p>Purpose</p> <p>Saves the character data to the database</p> <p>When Called</p> <p>When persisting character changes to the database</p> <p>Parameters</p> <ul> <li><code>callback</code> (function): Optional callback function to execute after save</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Save character\nlocal char = player:getChar()\nchar:save()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save with callback\nlocal char = player:getChar()\nchar:save(function()\nprint(\"Character saved successfully\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in save system\nlocal char = player:getChar()\nchar:save(function()\nupdateCharacterCache(char)\nnotifySaveComplete(player)\nlogCharacterSave(char)\nend)\n</code></pre></p>"},{"location":"meta/character/#sync","title":"sync","text":"<p>Purpose</p> <p>Synchronizes character data with clients</p> <p>When Called</p> <p>When updating character information on client side</p> <p>Parameters</p> <ul> <li><code>receiver</code> (Player): Specific client to sync to (default: all players)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Sync to all players\nlocal char = player:getChar()\nchar:sync()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Sync to specific player\nlocal char = player:getChar()\nchar:sync(targetPlayer)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in sync system\nlocal char = player:getChar()\nchar:sync(receiver)\nupdateCharacterUI(receiver)\nlogCharacterSync(char, receiver)\n</code></pre></p>"},{"location":"meta/character/#setup","title":"setup","text":"<p>Purpose</p> <p>Sets up the character for the player (model, team, inventory, etc.)</p> <p>When Called</p> <p>When loading a character for a player</p> <p>Parameters</p> <ul> <li><code>noNetworking</code> (boolean): Skip networking setup (default: false)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Setup character\nlocal char = player:getChar()\nchar:setup()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Setup without networking\nlocal char = player:getChar()\nchar:setup(true)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in character loading system\nlocal char = player:getChar()\nchar:setup(noNetworking)\nupdateCharacterUI(player)\nlogCharacterLoad(char)\n</code></pre></p>"},{"location":"meta/character/#kick","title":"kick","text":"<p>Purpose</p> <p>Kicks the character from the server</p> <p>When Called</p> <p>When removing a character from the game</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Kick character\nlocal char = player:getChar()\nchar:kick()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in admin system\nlocal char = target:getChar()\nchar:kick()\nnotifyKick(admin, target)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex kick system\nlocal char = player:getChar()\nchar:kick()\nlogCharacterKick(char, reason)\nupdateCharacterList()\n</code></pre></p>"},{"location":"meta/character/#ban","title":"ban","text":"<p>Purpose</p> <p>Bans the character for a specified time or permanently</p> <p>When Called</p> <p>When applying a ban to a character</p> <p>Parameters</p> <ul> <li><code>time</code> (number): Ban duration in seconds (nil for permanent ban)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Ban character permanently\nlocal char = player:getChar()\nchar:ban()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Ban for specific time\nlocal char = player:getChar()\nchar:ban(3600) -- 1 hour ban\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in ban system\nlocal char = player:getChar()\nchar:ban(banTime)\nlogCharacterBan(char, banTime, reason)\nnotifyBan(admin, player, banTime)\n</code></pre></p>"},{"location":"meta/character/#delete","title":"delete","text":"<p>Purpose</p> <p>Deletes the character from the database</p> <p>When Called</p> <p>When permanently removing a character</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Delete character\nlocal char = player:getChar()\nchar:delete()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in admin system\nlocal char = target:getChar()\nchar:delete()\nnotifyDeletion(admin, target)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex deletion system\nlocal char = player:getChar()\nchar:delete()\nlogCharacterDeletion(char, reason)\nupdateCharacterList()\n</code></pre></p>"},{"location":"meta/character/#destroy","title":"destroy","text":"<p>Purpose</p> <p>Destroys the character object and removes it from memory</p> <p>When Called</p> <p>When cleaning up character data from memory</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Destroy character\nlocal char = player:getChar()\nchar:destroy()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in cleanup system\nlocal char = player:getChar()\nchar:destroy()\nupdateCharacterList()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex cleanup system\nlocal char = player:getChar()\nchar:destroy()\nlogCharacterDestroy(char)\nupdateCharacterCache()\n</code></pre></p>"},{"location":"meta/character/#givemoney","title":"giveMoney","text":"<p>Purpose</p> <p>Gives money to the character</p> <p>When Called</p> <p>When adding money to a character's account</p> <p>Parameters</p> <ul> <li><code>amount</code> (number): The amount of money to give</li> </ul> <p>Returns</p> <ul> <li>boolean - True if money was given successfully</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Give money\nlocal char = player:getChar()\nchar:giveMoney(100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in reward system\nlocal char = player:getChar()\nchar:giveMoney(rewardAmount)\nnotifyReward(player, \"You received $\" .. rewardAmount)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex economy system\nlocal char = player:getChar()\nchar:giveMoney(amount)\nlogMoneyTransaction(char, amount, \"reward\")\nupdateEconomyStats()\n</code></pre></p>"},{"location":"meta/character/#takemoney","title":"takeMoney","text":"<p>Purpose</p> <p>Takes money from the character</p> <p>When Called</p> <p>When removing money from a character's account</p> <p>Parameters</p> <ul> <li><code>amount</code> (number): The amount of money to take</li> </ul> <p>Returns</p> <ul> <li>boolean - True if money was taken successfully</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Take money\nlocal char = player:getChar()\nchar:takeMoney(50)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in payment system\nlocal char = player:getChar()\nchar:takeMoney(itemPrice)\nnotifyPayment(player, \"You paid $\" .. itemPrice)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex economy system\nlocal char = player:getChar()\nchar:takeMoney(amount)\nlogMoneyTransaction(char, -amount, \"purchase\")\nupdateEconomyStats()\n</code></pre></p>"},{"location":"meta/entity/","title":"Entity Meta","text":"<p>Entity management system for the Lilia framework.</p> <p>Overview</p> <p>The entity meta table provides comprehensive functionality for extending Garry's Mod entities with Lilia-specific features and operations. It handles entity identification, sound management, door access control, vehicle ownership, network variable synchronization, and entity-specific operations. The meta table operates on both server and client sides, with the server managing entity data and validation while the client provides entity interaction and display. It includes integration with the door system for access control, vehicle system for ownership management, network system for data synchronization, and sound system for audio playback. The meta table ensures proper entity identification, access control validation, network data synchronization, and comprehensive entity interaction management for doors, vehicles, and other game objects.</p>"},{"location":"meta/entity/#emitsound","title":"EmitSound","text":"<p>Purpose</p> <p>Emits a sound from the entity, with support for web sounds and URL-based audio</p> <p>When Called</p> <p>When an entity needs to play a sound effect or audio</p> <p>Parameters</p> <ul> <li><code>soundName</code> (string): The sound file path, URL, or websound identifier</li> <li><code>soundLevel</code> (number, optional): Sound level/distance (default: 100)</li> <li><code>pitchPercent</code> (number, optional): Pitch adjustment percentage</li> <li><code>volume</code> (number, optional): Volume level (default: 100)</li> <li><code>channel</code> (number, optional): Sound channel</li> <li><code>flags</code> (number, optional): Sound flags</li> <li><code>dsp</code> (number, optional): DSP effect</li> </ul> <p>Returns</p> <ul> <li>boolean - True if sound was played successfully</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Play a basic sound\nentity:EmitSound(\"buttons/button15.wav\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Play sound with custom volume and distance\nentity:EmitSound(\"ambient/atmosphere/city_hum_loop.wav\", 200, 100, 0.5)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Play web sound with full parameters\nentity:EmitSound(\"https://example.com/sound.mp3\", 300, 100, 0.8, CHAN_AUTO, 0, 0)\n</code></pre></p>"},{"location":"meta/entity/#isprop","title":"isProp","text":"<p>Purpose</p> <p>Checks if the entity is a physics prop</p> <p>When Called</p> <p>When you need to determine if an entity is a prop_physics object</p> <p>Returns</p> <ul> <li>boolean - True if the entity is a prop_physics, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if entity is a prop\nif entity:isProp() then\n    print(\"This is a physics prop\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in conditional logic\nif entity:isProp() and entity:GetPhysicsObject():IsValid() then\n    entity:GetPhysicsObject():Wake()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Combine with other checks for complex logic\nif entity:isProp() and entity:GetModel():find(\"wood\") then\n    -- Handle wooden prop specifically\n    entity:SetMaterial(\"models/wood\")\nend\n</code></pre></p>"},{"location":"meta/entity/#isitem","title":"isItem","text":"<p>Purpose</p> <p>Checks if the entity is a Lilia item entity</p> <p>When Called</p> <p>When you need to determine if an entity is a lia_item object</p> <p>Returns</p> <ul> <li>boolean - True if the entity is a lia_item, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if entity is an item\nif entity:isItem() then\n    print(\"This is a Lilia item\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in item handling logic\nif entity:isItem() and entity:GetItemData() then\n    local itemData = entity:GetItemData()\n    print(\"Item name:\", itemData.name)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Combine with inventory system\nif entity:isItem() and IsValid(ply) then\n    local itemData = entity:GetItemData()\n    if itemData and ply:getChar():getInv():canFit(itemData) then\n        ply:getChar():getInv():add(itemData)\n        entity:Remove()\n    end\nend\n</code></pre></p>"},{"location":"meta/entity/#ismoney","title":"isMoney","text":"<p>Purpose</p> <p>Checks if the entity is a Lilia money entity</p> <p>When Called</p> <p>When you need to determine if an entity is a lia_money object</p> <p>Returns</p> <ul> <li>boolean - True if the entity is a lia_money, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if entity is money\nif entity:isMoney() then\n    print(\"This is money\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in money handling logic\nif entity:isMoney() and IsValid(ply) then\n    local amount = entity:GetAmount() or 0\n    ply:getChar():giveMoney(amount)\n    entity:Remove()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Combine with economy system\nif entity:isMoney() and IsValid(ply) then\n    local amount = entity:GetAmount() or 0\n    local char = ply:getChar()\n    if char:getMoney() + amount &lt;= char:getMaxMoney() then\n        char:giveMoney(amount)\n        entity:Remove()\n        ply:notify(\"You picked up $\" .. amount)\n    end\nend\n</code></pre></p>"},{"location":"meta/entity/#issimfphyscar","title":"isSimfphysCar","text":"<p>Purpose</p> <p>Checks if the entity is a Simfphys vehicle or LVS vehicle</p> <p>When Called</p> <p>When you need to determine if an entity is a vehicle from Simfphys or LVS</p> <p>Returns</p> <ul> <li>boolean - True if the entity is a supported vehicle, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if entity is a vehicle\nif entity:isSimfphysCar() then\n    print(\"This is a vehicle\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in vehicle handling logic\nif entity:isSimfphysCar() and IsValid(ply) then\n    if entity:GetDriver() == ply then\n        ply:notify(\"You are driving this vehicle\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Combine with vehicle systems\nif entity:isSimfphysCar() and IsValid(ply) then\n    local char = ply:getChar()\n    if char:hasFlags(\"v\") then\n        entity:SetDriver(ply)\n        entity:SetNetVar(\"owner\", char:getID())\n    end\nend\n</code></pre></p>"},{"location":"meta/entity/#checkdooraccess","title":"checkDoorAccess","text":"<p>Purpose</p> <p>Checks if a client has access to a door with the specified access level</p> <p>When Called</p> <p>When you need to verify if a player can access a door</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to check access for</li> <li><code>access</code> (number, optional): The required access level (default: DOOR_GUEST)</li> </ul> <p>Returns</p> <ul> <li>boolean - True if the client has access, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check basic door access\nif door:checkDoorAccess(ply) then\n    door:Fire(\"Open\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check specific access level\nif door:checkDoorAccess(ply, DOOR_OWNER) then\n    ply:notify(\"You own this door\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in door interaction system\nif door:checkDoorAccess(ply, DOOR_GUEST) then\n    if door:isDoorLocked() then\n        ply:notify(\"The door is locked\")\n        else\n            door:Fire(\"Open\")\n            ply:notify(\"Door opened\")\n        end\n        else\n            ply:notify(\"You don't have access to this door\")\n        end\n</code></pre></p>"},{"location":"meta/entity/#keysown","title":"keysOwn","text":"<p>Purpose</p> <p>Sets a client as the owner of a vehicle and updates ownership data</p> <p>When Called</p> <p>When a player becomes the owner of a vehicle</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to set as the owner</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set vehicle owner\nvehicle:keysOwn(ply)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set owner with validation\nif IsValid(ply) and ply:getChar() then\n    vehicle:keysOwn(ply)\n    ply:notify(\"You now own this vehicle\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in vehicle purchase system\nif ply:getChar():getMoney() &gt;= vehiclePrice then\n    ply:getChar():takeMoney(vehiclePrice)\n    vehicle:keysOwn(ply)\n    ply:notify(\"Vehicle purchased for $\" .. vehiclePrice)\n    else\n        ply:notify(\"Insufficient funds\")\n    end\n</code></pre></p>"},{"location":"meta/entity/#keyslock","title":"keysLock","text":"<p>Purpose</p> <p>Locks a vehicle if it is a valid vehicle entity</p> <p>When Called</p> <p>When a player wants to lock their vehicle</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Lock vehicle\nvehicle:keysLock()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Lock with validation\nif IsValid(vehicle) and vehicle:IsVehicle() then\n    vehicle:keysLock()\n    ply:notify(\"Vehicle locked\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in vehicle interaction system\nif vehicle:keysOwn(ply) and not vehicle:isLocked() then\n    vehicle:keysLock()\n    ply:notify(\"Vehicle locked\")\n    elseif not vehicle:keysOwn(ply) then\n        ply:notify(\"You don't own this vehicle\")\n        else\n            ply:notify(\"Vehicle is already locked\")\n        end\n</code></pre></p>"},{"location":"meta/entity/#keysunlock","title":"keysUnLock","text":"<p>Purpose</p> <p>Unlocks a vehicle if it is a valid vehicle entity</p> <p>When Called</p> <p>When a player wants to unlock their vehicle</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Unlock vehicle\nvehicle:keysUnLock()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Unlock with validation\nif IsValid(vehicle) and vehicle:IsVehicle() then\n    vehicle:keysUnLock()\n    ply:notify(\"Vehicle unlocked\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in vehicle interaction system\nif vehicle:keysOwn(ply) and vehicle:isLocked() then\n    vehicle:keysUnLock()\n    ply:notify(\"Vehicle unlocked\")\n    elseif not vehicle:keysOwn(ply) then\n        ply:notify(\"You don't own this vehicle\")\n        else\n            ply:notify(\"Vehicle is already unlocked\")\n        end\n</code></pre></p>"},{"location":"meta/entity/#getdoorowner","title":"getDoorOwner","text":"<p>Purpose</p> <p>Gets the owner of a door entity</p> <p>When Called</p> <p>When you need to retrieve the owner of a door</p> <p>Returns</p> <ul> <li>Player or nil - The door owner if it's a vehicle with CPPI, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get door owner\nlocal owner = door:getDoorOwner()\nif IsValid(owner) then\n    print(\"Door owner:\", owner:Name())\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check ownership for access control\nlocal owner = door:getDoorOwner()\nif IsValid(owner) and owner == ply then\n    ply:notify(\"You own this door\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in door management system\nlocal owner = door:getDoorOwner()\nif IsValid(owner) then\n    local char = owner:getChar()\n    if char then\n        door:setNetVar(\"ownerName\", char:getName())\n        door:setNetVar(\"ownerID\", char:getID())\n    end\nend\n</code></pre></p>"},{"location":"meta/entity/#islocked","title":"isLocked","text":"<p>Purpose</p> <p>Checks if the entity is locked using network variables</p> <p>When Called</p> <p>When you need to check if an entity is in a locked state</p> <p>Returns</p> <ul> <li>boolean - True if the entity is locked, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if entity is locked\nif entity:isLocked() then\n    print(\"Entity is locked\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in interaction logic\nif entity:isLocked() then\n    ply:notify(\"This is locked\")\n    else\n        entity:Use(ply)\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in security system\nif entity:isLocked() and not ply:hasFlags(\"A\") then\n    ply:notify(\"Access denied - locked\")\n    elseif entity:isLocked() and ply:hasFlags(\"A\") then\n        entity:setLocked(false)\n        ply:notify(\"Unlocked with admin access\")\n    end\n</code></pre></p>"},{"location":"meta/entity/#isdoorlocked","title":"isDoorLocked","text":"<p>Purpose</p> <p>Checks if a door entity is locked using internal variables or custom properties</p> <p>When Called</p> <p>When you need to check if a door is in a locked state</p> <p>Returns</p> <ul> <li>boolean - True if the door is locked, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if door is locked\nif door:isDoorLocked() then\n    print(\"Door is locked\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in door interaction\nif door:isDoorLocked() then\n    ply:notify(\"The door is locked\")\n    else\n        door:Fire(\"Open\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in door access system\nif door:isDoorLocked() and not door:checkDoorAccess(ply, DOOR_OWNER) then\n    ply:notify(\"Door is locked and you don't have access\")\n    elseif door:isDoorLocked() and door:checkDoorAccess(ply, DOOR_OWNER) then\n        door:setLocked(false)\n        ply:notify(\"Door unlocked with your key\")\n    end\n</code></pre></p>"},{"location":"meta/entity/#getentitemdroppos","title":"getEntItemDropPos","text":"<p>Purpose</p> <p>Calculates the position and angle for dropping items from an entity</p> <p>When Called</p> <p>When an entity needs to drop an item at a specific location</p> <p>Parameters</p> <ul> <li><code>offset</code> (number, optional): Distance to trace forward from entity (default: 64)</li> </ul> <p>Returns</p> <ul> <li>Vector, Angle - The drop position and angle</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get drop position\nlocal pos, ang = entity:getEntItemDropPos()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use with custom offset\nlocal pos, ang = entity:getEntItemDropPos(100)\nlocal item = ents.Create(\"lia_item\")\nitem:SetPos(pos)\nitem:SetAngles(ang)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in item dropping system\nlocal pos, ang = entity:getEntItemDropPos(offset)\nlocal tr = util.TraceLine({\nstart = pos,\nendpos = pos + Vector(0, 0, -50),\nmask = MASK_SOLID_BRUSHONLY\n})\nif tr.Hit then\n    pos = tr.HitPos + tr.HitNormal * 5\nend\nlocal item = ents.Create(\"lia_item\")\nitem:SetPos(pos)\nitem:SetAngles(ang)\nitem:Spawn()\n</code></pre></p>"},{"location":"meta/entity/#isfemale","title":"isFemale","text":"<p>Purpose</p> <p>Checks if the entity's model represents a female character</p> <p>When Called</p> <p>When you need to determine the gender of a character entity</p> <p>Returns</p> <ul> <li>boolean - True if the entity is female, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if entity is female\nif entity:isFemale() then\n    print(\"This is a female character\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in character customization\nif entity:isFemale() then\n    entity:SetBodygroup(1, 1) -- Set female bodygroup\n    else\n        entity:SetBodygroup(1, 0) -- Set male bodygroup\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in roleplay system\nif entity:isFemale() then\n    local char = entity:getChar()\n    if char then\n        char:setData(\"gender\", \"female\")\n        char:setData(\"pronouns\", {\"she\", \"her\", \"hers\"})\n    end\nend\n</code></pre></p>"},{"location":"meta/entity/#isnearentity","title":"isNearEntity","text":"<p>Purpose</p> <p>Checks if the entity is near another entity within a specified radius</p> <p>When Called</p> <p>When you need to check proximity between entities</p> <p>Parameters</p> <ul> <li><code>radius</code> (number, optional): Search radius in units (default: 96)</li> <li><code>otherEntity</code> (Entity, optional): Specific entity to check for proximity</li> </ul> <p>Returns</p> <ul> <li>boolean - True if near another entity, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if entity is near any other entity\nif entity:isNearEntity() then\n    print(\"Entity is near something\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check proximity to specific entity\nif entity:isNearEntity(150, targetEntity) then\n    print(\"Entity is near target\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in interaction system\nif entity:isNearEntity(100, ply) then\n    if entity:isItem() then\n        ply:notify(\"Press E to pick up \" .. entity:GetItemData().name)\n        elseif entity:isMoney() then\n            ply:notify(\"Press E to collect $\" .. entity:GetAmount())\n        end\n    end\n</code></pre></p>"},{"location":"meta/entity/#getdoorpartner","title":"getDoorPartner","text":"<p>Purpose</p> <p>Gets the partner door entity for double doors</p> <p>When Called</p> <p>When you need to find the paired door in a double door setup</p> <p>Returns</p> <ul> <li>Entity or nil - The partner door if found, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get door partner\nlocal partner = door:getDoorPartner()\nif IsValid(partner) then\n    print(\"Found door partner\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in door synchronization\nlocal partner = door:getDoorPartner()\nif IsValid(partner) then\n    partner:Fire(\"Open\")\n    door:Fire(\"Open\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in door management system\nlocal partner = door:getDoorPartner()\nif IsValid(partner) then\n    if door:isDoorLocked() then\n        partner:setLocked(true)\n        else\n            partner:setLocked(false)\n        end\n        door:setNetVar(\"partnerID\", partner:EntIndex())\n    end\n</code></pre></p>"},{"location":"meta/entity/#sendnetvar","title":"sendNetVar","text":"<p>Purpose</p> <p>Sends a network variable to clients via network message</p> <p>When Called</p> <p>When you need to synchronize entity data with clients</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The network variable key to send</li> <li><code>receiver</code> (Player, optional): Specific player to send to, or nil for all players</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send network variable to all clients\nentity:sendNetVar(\"health\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send to specific player\nentity:sendNetVar(\"owner\", ply)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in data synchronization system\nif entity:getNetVar(\"dirty\") then\n    entity:sendNetVar(\"data\", nil)\n    entity:setNetVar(\"dirty\", false)\nend\n</code></pre></p>"},{"location":"meta/entity/#clearnetvars","title":"clearNetVars","text":"<p>Purpose</p> <p>Clears all network variables for the entity and notifies clients</p> <p>When Called</p> <p>When you need to remove all network data from an entity</p> <p>Parameters</p> <ul> <li><code>receiver</code> (Player, optional): Specific player to notify, or nil for all players</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Clear all network variables\nentity:clearNetVars()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clear for specific player\nentity:clearNetVars(ply)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in entity cleanup system\nif entity:IsValid() then\n    entity:clearNetVars()\n    entity:Remove()\nend\n</code></pre></p>"},{"location":"meta/entity/#removedooraccessdata","title":"removeDoorAccessData","text":"<p>Purpose</p> <p>Removes all door access data and notifies clients to close door menus</p> <p>When Called</p> <p>When you need to clear all door access permissions and close related UIs</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (can only be called on server)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove door access data\ndoor:removeDoorAccessData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in door cleanup\nif door:IsValid() then\n    door:removeDoorAccessData()\n    door:Remove()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in door management system\nif ply:hasFlags(\"A\") then\n    door:removeDoorAccessData()\n    ply:notify(\"Door access data cleared\")\nend\n</code></pre></p>"},{"location":"meta/entity/#setlocked","title":"setLocked","text":"<p>Purpose</p> <p>Sets the locked state of an entity using network variables</p> <p>When Called</p> <p>When you need to lock or unlock an entity</p> <p>Parameters</p> <ul> <li><code>state</code> (boolean): True to lock, false to unlock</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Lock entity\nentity:setLocked(true)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Toggle lock state\nentity:setLocked(not entity:isLocked())\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in security system\nif ply:hasFlags(\"A\") then\n    entity:setLocked(not entity:isLocked())\n    ply:notify(\"Entity \" .. (entity:isLocked() and \"locked\" or \"unlocked\"))\nend\n</code></pre></p>"},{"location":"meta/entity/#setkeysnonownable","title":"setKeysNonOwnable","text":"<p>Purpose</p> <p>Sets whether a vehicle can be owned or sold</p> <p>When Called</p> <p>When you need to make a vehicle non-ownable or ownable</p> <p>Parameters</p> <ul> <li><code>state</code> (boolean): True to make non-ownable, false to make ownable</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Make vehicle non-ownable\nvehicle:setKeysNonOwnable(true)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Toggle ownable state\nvehicle:setKeysNonOwnable(not vehicle:getNetVar(\"noSell\", false))\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in vehicle management system\nif ply:hasFlags(\"A\") then\n    vehicle:setKeysNonOwnable(true)\n    ply:notify(\"Vehicle made non-ownable\")\nend\n</code></pre></p>"},{"location":"meta/entity/#isdoor","title":"isDoor","text":"<p>Purpose</p> <p>Checks if the entity is a door by examining its class name</p> <p>When Called</p> <p>When you need to determine if an entity is a door</p> <p>Returns</p> <ul> <li>boolean - True if the entity is a door, false otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if entity is a door\nif entity:isDoor() then\n    print(\"This is a door\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in door interaction\nif entity:isDoor() and entity:checkDoorAccess(ply) then\n    entity:Fire(\"Open\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in door management system\nif entity:isDoor() then\n    local partner = entity:getDoorPartner()\n    if IsValid(partner) then\n        partner:setLocked(entity:isDoorLocked())\n    end\nend\n</code></pre></p>"},{"location":"meta/entity/#setnetvar","title":"setNetVar","text":"<p>Purpose</p> <p>Sets a network variable for the entity and synchronizes it with clients</p> <p>When Called</p> <p>When you need to store and sync data on an entity</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The network variable key</li> <li><code>value</code> (any): The value to store</li> <li><code>receiver</code> (Player, optional): Specific player to send to, or nil for all players</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set a network variable\nentity:setNetVar(\"health\", 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set with specific receiver\nentity:setNetVar(\"owner\", ply, ply)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in data management system\nif entity:getNetVar(\"dirty\") then\n    entity:setNetVar(\"lastUpdate\", CurTime())\n    entity:setNetVar(\"dirty\", false)\nend\n</code></pre></p>"},{"location":"meta/entity/#getnetvar","title":"getNetVar","text":"<p>Purpose</p> <p>Gets a network variable from the entity (server-side)</p> <p>When Called</p> <p>When you need to retrieve synchronized data from an entity on the server</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The network variable key to retrieve</li> <li><code>default</code> (any, optional): Default value if the key doesn't exist</li> </ul> <p>Returns</p> <ul> <li>any - The network variable value or default</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a network variable\nlocal health = entity:getNetVar(\"health\", 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in server-side logic\nlocal owner = entity:getNetVar(\"owner\")\nif owner and IsValid(owner) then\n    print(\"Entity owner:\", owner:Name())\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in server-side data management\nlocal data = entity:getNetVar(\"data\", {})\nif data.lastUpdate and CurTime() - data.lastUpdate &gt; 300 then\n    entity:setNetVar(\"data\", {lastUpdate = CurTime()})\nend\n</code></pre></p>"},{"location":"meta/entity/#isdoor_1","title":"isDoor","text":"<p>Purpose</p> <p>Checks if the entity is a door by examining its class name (client-side)</p> <p>When Called</p> <p>When you need to determine if an entity is a door on the client</p> <p>Returns</p> <ul> <li>boolean - True if the entity is a door, false otherwise</li> </ul> <p>Realm</p> <p>Client (can only be called on client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if entity is a door\nif entity:isDoor() then\n    print(\"This is a door\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in client-side door interaction\nif entity:isDoor() and entity:isNearEntity(100, LocalPlayer()) then\n    draw.DrawText(\"Press E to open door\", \"DermaDefault\", ScrW()/2, ScrH()/2)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in client-side door management\nif entity:isDoor() then\n    local locked = entity:getNetVar(\"locked\", false)\n    local color = locked and Color(255, 0, 0) or Color(0, 255, 0)\n    draw.DrawText(locked and \"Locked\" or \"Unlocked\", \"DermaDefault\", ScrW()/2, ScrH()/2, color)\nend\n</code></pre></p>"},{"location":"meta/entity/#getnetvar_1","title":"getNetVar","text":"<p>Purpose</p> <p>Gets a network variable from the entity (client-side)</p> <p>When Called</p> <p>When you need to retrieve synchronized data from an entity on the client</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The network variable key to retrieve</li> <li><code>default</code> (any, optional): Default value if the key doesn't exist</li> </ul> <p>Returns</p> <ul> <li>any - The network variable value or default</li> </ul> <p>Realm</p> <p>Client (can only be called on client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get a network variable\nlocal health = entity:getNetVar(\"health\", 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in client-side logic\nlocal owner = entity:getNetVar(\"owner\")\nif owner and owner == LocalPlayer() then\n    print(\"You own this entity\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in client-side rendering\nlocal locked = entity:getNetVar(\"locked\", false)\nlocal color = locked and Color(255, 0, 0) or Color(0, 255, 0)\ndraw.DrawText(locked and \"Locked\" or \"Unlocked\", \"DermaDefault\", x, y, color)\n</code></pre></p>"},{"location":"meta/entity/#playfollowingsound","title":"playFollowingSound","text":"<p>Purpose</p> <p>Plays a sound that follows the entity with 3D positioning and distance attenuation</p> <p>When Called</p> <p>When you need to play a sound that moves with an entity</p> <p>Parameters</p> <ul> <li><code>soundPath</code> (string): Path to the sound file or URL</li> <li><code>volume</code> (number, optional): Volume level (0-1, default: 1)</li> <li><code>shouldFollow</code> (boolean, optional): Whether sound should follow entity (default: true)</li> <li><code>maxDistance</code> (number, optional): Maximum audible distance (default: 1200)</li> <li><code>startDelay</code> (number, optional): Delay before playing (default: 0)</li> <li><code>minDistance</code> (number, optional): Minimum distance for full volume (default: 0)</li> <li><code>pitch</code> (number, optional): Pitch multiplier (default: 1)</li> <li><code>_</code> (any, optional): Unused parameter</li> <li><code>dsp</code> (number, optional): DSP effect ID (default: 0)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client (can only be called on client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Play following sound\nentity:playFollowingSound(\"ambient/atmosphere/city_hum_loop.wav\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Play with custom volume and distance\nentity:playFollowingSound(\"buttons/button15.wav\", 0.5, true, 500)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Play web sound with full parameters\nentity:playFollowingSound(\"https://example.com/sound.mp3\", 0.8, true, 1000, 0.5, 100, 1.2, nil, 1)\n</code></pre></p>"},{"location":"meta/inventory/","title":"Inventory Meta","text":"<p>Inventory management system for the Lilia framework.</p> <p>Overview</p> <p>The inventory meta table provides comprehensive functionality for managing inventory data, item storage, and inventory operations in the Lilia framework. It handles inventory creation, item management, data persistence, capacity management, and inventory-specific operations. The meta table operates on both server and client sides, with the server managing inventory storage and validation while the client provides inventory data access and display. It includes integration with the item system for item storage, database system for inventory persistence, character system for character inventories, and network system for inventory synchronization. The meta table ensures proper inventory data synchronization, item capacity management, item validation, and comprehensive inventory lifecycle management from creation to deletion.</p>"},{"location":"meta/inventory/#getdata","title":"getData","text":"<p>Purpose</p> <p>Retrieves data from the inventory's data table with optional default fallback</p> <p>When Called</p> <p>Whenever inventory data needs to be accessed with a safe default value</p> <p>Parameters</p> <ul> <li><code>key</code> (unknown): The data key to retrieve</li> <li><code>key</code> (unknown): The data key to retrieve</li> <li><code>default</code> (unknown): Optional default value if key doesn't exist</li> <li><code>default</code> (unknown): Optional default value if key doesn't exist</li> </ul> <p>Returns</p> <ul> <li>The data value or default value if key doesn't exist</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local money = inventory:getData(\"money\", 0)\n</code></pre></p> <p>Medium Complexity: <pre><code>local characterName = inventory:getData(\"charName\", \"Unknown\")\nif characterName ~= \"Unknown\" then\n    print(\"Character: \" .. characterName)\nend\n</code></pre></p> <p>High Complexity: <pre><code>local settings = {\nautoSave = inventory:getData(\"autoSave\", true),\nmaxSlots = inventory:getData(\"maxSlots\", 50),\npermissions = inventory:getData(\"permissions\", {})\n}\nfor setting, value in pairs(settings) do\n    print(setting .. \": \" .. tostring(value))\nend\n</code></pre></p>"},{"location":"meta/inventory/#logaccess","title":"logAccess","text":"<p>Purpose</p> <p>Extends a class with the Inventory metatable functionality</p> <p>When Called</p> <p>During inventory type registration to create specialized inventory types</p> <p>Parameters</p> <ul> <li><code>className</code> (unknown): The name of the class to extend</li> <li><code>className</code> (unknown): The name of the class to extend</li> </ul> <p>Returns</p> <ul> <li>The extended class with Inventory functionality</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local PlayerInventory = Inventory:extend(\"PlayerInventory\")\n</code></pre></p> <p>Medium Complexity: <pre><code>local CustomInventory = Inventory:extend(\"Backpack\")\nCustomInventory.maxSlots = 20\n</code></pre></p> <p>High Complexity: <pre><code>local SecureInventory = Inventory:extend(\"BankVault\")\nSecureInventory.accessLevel = \"admin\"\nSecureInventory.auditLog = {}\nfunction SecureInventory:logAccess(player)\n    table.insert(self.auditLog, {player = player, time = os.time()})\nend\n</code></pre></p>"},{"location":"meta/inventory/#extend","title":"extend","text":"<p>Purpose</p> <p>Extends a class with the Inventory metatable functionality</p> <p>When Called</p> <p>During inventory type registration to create specialized inventory types</p> <p>Parameters</p> <ul> <li><code>className</code> (unknown): The name of the class to extend</li> <li><code>className</code> (unknown): The name of the class to extend</li> </ul> <p>Returns</p> <ul> <li>The extended class with Inventory functionality</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local PlayerInventory = Inventory:extend(\"PlayerInventory\")\n</code></pre></p> <p>Medium Complexity: <pre><code>local CustomInventory = Inventory:extend(\"Backpack\")\nCustomInventory.maxSlots = 20\n</code></pre></p> <p>High Complexity: <pre><code>local SecureInventory = Inventory:extend(\"BankVault\")\nSecureInventory.accessLevel = \"admin\"\nSecureInventory.auditLog = {}\nfunction SecureInventory:logAccess(player)\n    table.insert(self.auditLog, {player = player, time = os.time()})\nend\n</code></pre></p>"},{"location":"meta/inventory/#configure","title":"configure","text":"<p>Purpose</p> <p>Configures the inventory type with default settings and rules</p> <p>When Called</p> <p>During inventory type registration, allows customization of inventory behavior</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:configure()\n    self.maxWeight = 100\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:configure()\n    self.config.data[\"money\"] = {default = 0}\n    self.config.data[\"level\"] = {default = 1}\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:configure()\n    self.config.data[\"permissions\"] = {default = {}}\n    self.config.data[\"settings\"] = {default = {}}\n    self:addDataProxy(\"permissions\", function(old, new)\n    print(\"Permissions changed from\", old, \"to\", new)\nend)\nend\n</code></pre></p>"},{"location":"meta/inventory/#configure_1","title":"configure","text":"<p>Purpose</p> <p>Configures the inventory type with default settings and rules</p> <p>When Called</p> <p>During inventory type registration, allows customization of inventory behavior</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:configure()\n    self.maxWeight = 100\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:configure()\n    self.config.data[\"money\"] = {default = 0}\n    self.config.data[\"level\"] = {default = 1}\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:configure()\n    self.config.data[\"permissions\"] = {default = {}}\n    self.config.data[\"settings\"] = {default = {}}\n    self:addDataProxy(\"permissions\", function(old, new)\n    print(\"Permissions changed from\", old, \"to\", new)\nend)\nend\n</code></pre></p>"},{"location":"meta/inventory/#configure_2","title":"configure","text":"<p>Purpose</p> <p>Configures the inventory type with default settings and rules</p> <p>When Called</p> <p>During inventory type registration, allows customization of inventory behavior</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:configure()\n    self.maxWeight = 100\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:configure()\n    self.config.data[\"money\"] = {default = 0}\n    self.config.data[\"level\"] = {default = 1}\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:configure()\n    self.config.data[\"permissions\"] = {default = {}}\n    self.config.data[\"settings\"] = {default = {}}\n    self:addDataProxy(\"permissions\", function(old, new)\n    print(\"Permissions changed from\", old, \"to\", new)\nend)\nend\n</code></pre></p>"},{"location":"meta/inventory/#configure_3","title":"configure","text":"<p>Purpose</p> <p>Configures the inventory type with default settings and rules</p> <p>When Called</p> <p>During inventory type registration, allows customization of inventory behavior</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:configure()\n    self.maxWeight = 100\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:configure()\n    self.config.data[\"money\"] = {default = 0}\n    self.config.data[\"level\"] = {default = 1}\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:configure()\n    self.config.data[\"permissions\"] = {default = {}}\n    self.config.data[\"settings\"] = {default = {}}\n    self:addDataProxy(\"permissions\", function(old, new)\n    print(\"Permissions changed from\", old, \"to\", new)\nend)\nend\n</code></pre></p>"},{"location":"meta/inventory/#adddataproxy","title":"addDataProxy","text":"<p>Purpose</p> <p>Adds a data proxy function that gets called when specific data changes</p> <p>When Called</p> <p>During inventory configuration to set up data change callbacks</p> <p>Parameters</p> <ul> <li><code>key</code> (unknown): The data key to monitor for changes</li> <li><code>key</code> (unknown): The data key to monitor for changes</li> <li><code>onChange</code> (unknown): Function to call when the data changes (oldValue, newValue)</li> <li><code>onChange</code> (unknown): Function to call when the data changes (oldValue, newValue)</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:addDataProxy(\"money\", function(old, new)\nprint(\"Money changed from\", old, \"to\", new)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>inventory:addDataProxy(\"level\", function(old, new)\nif new &gt; old then\n    lia.chat.send(nil, \"Level up!\", player)\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>local function complexProxy(old, new)\n    if new.xp and old.xp and new.xp &gt; old.xp then\n        local gained = new.xp - old.xp\n        hook.Run(\"OnPlayerXPGain\", player, gained, new.level)\n    end\nend\ninventory:addDataProxy(\"stats\", complexProxy)\n</code></pre></p>"},{"location":"meta/inventory/#getitemsbyuniqueid","title":"getItemsByUniqueID","text":"<p>Purpose</p> <p>Retrieves all items with a specific uniqueID from the inventory</p> <p>When Called</p> <p>When you need to find all instances of a particular item type</p> <p>Parameters</p> <ul> <li><code>uniqueID</code> (unknown): The uniqueID of the item type to find</li> <li><code>uniqueID</code> (unknown): The uniqueID of the item type to find</li> <li><code>onlyMain</code> (unknown): Optional boolean to only return items in main inventory slots</li> <li><code>onlyMain</code> (unknown): Optional boolean to only return items in main inventory slots</li> </ul> <p>Returns</p> <ul> <li>Table of items matching the uniqueID</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local weapons = inventory:getItemsByUniqueID(\"weapon_pistol\")\n</code></pre></p> <p>Medium Complexity: <pre><code>local foodItems = inventory:getItemsByUniqueID(\"food_apple\")\nfor _, food in ipairs(foodItems) do\n    print(\"Found apple:\", food:getID())\nend\n</code></pre></p> <p>High Complexity: <pre><code>local allItems = inventory:getItemsByUniqueID(\"consumable\")\nlocal totalValue = 0\nfor _, item in ipairs(allItems) do\n    if item.data and item.data.value then\n        totalValue = totalValue + item.data.value\n    end\nend\nprint(\"Total consumable value:\", totalValue)\n</code></pre></p>"},{"location":"meta/inventory/#register","title":"register","text":"<p>Purpose</p> <p>Registers this inventory type with the Lilia inventory system</p> <p>When Called</p> <p>During inventory type definition to make it available for use</p> <p>Parameters</p> <ul> <li><code>typeID</code> (unknown): String identifier for this inventory type</li> <li><code>typeID</code> (unknown): String identifier for this inventory type</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>MyInventory:register(\"player\")\n</code></pre></p> <p>Medium Complexity: <pre><code>PlayerInventory:register(\"player_backpack\")\nBankInventory:register(\"secure_storage\")\n</code></pre></p> <p>High Complexity: <pre><code>local types = {\"player\", \"vehicle\", \"house\", \"guild\"}\nfor _, typeName in ipairs(types) do\n    local inventoryClass = Inventory:extend(typeName .. \"_inventory\")\n    inventoryClass:register(typeName)\nend\n</code></pre></p>"},{"location":"meta/inventory/#new","title":"new","text":"<p>Purpose</p> <p>Creates a new instance of this inventory type</p> <p>When Called</p> <p>When you need to create a new inventory of this type</p> <p>Returns</p> <ul> <li>New inventory instance</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local newInventory = MyInventory:new()\n</code></pre></p> <p>Medium Complexity: <pre><code>local playerInv = PlayerInventory:new()\nlocal bankInv = BankInventory:new()\n</code></pre></p> <p>High Complexity: <pre><code>local inventories = {}\nfor i = 1, 10 do\n    inventories[i] = StorageInventory:new()\nend\n</code></pre></p>"},{"location":"meta/inventory/#tostring","title":"tostring","text":"<p>Purpose</p> <p>Returns a string representation of the inventory</p> <p>When Called</p> <p>For debugging, logging, or display purposes</p> <p>Returns</p> <ul> <li>String representation of the inventory</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>print(inventory:tostring())\n</code></pre></p> <p>Medium Complexity: <pre><code>lia.chat.send(player, \"Inventory: \" .. inventory:tostring())\n</code></pre></p> <p>High Complexity: <pre><code>local inventories = {inv1, inv2, inv3}\nfor i, inv in ipairs(inventories) do\n    print(\"Inventory \" .. i .. \": \" .. inv:tostring())\nend\n</code></pre></p>"},{"location":"meta/inventory/#gettype","title":"getType","text":"<p>Purpose</p> <p>Gets the inventory type configuration</p> <p>When Called</p> <p>When you need to access type-specific settings or behavior</p> <p>Returns</p> <ul> <li>The inventory type configuration table</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local config = inventory:getType()\n</code></pre></p> <p>Medium Complexity: <pre><code>local invType = inventory:getType()\nif invType.maxSlots then print(\"Max slots:\", invType.maxSlots) end\n</code></pre></p> <p>High Complexity: <pre><code>local function analyzeInventoryType(inv)\n    local config = inv:getType()\n    print(\"Type:\", config.typeID)\n    print(\"Data fields:\", table.Count(config.data))\n    print(\"Persistent:\", config.persistent or false)\nend\n</code></pre></p>"},{"location":"meta/inventory/#ondatachanged","title":"onDataChanged","text":"<p>Purpose</p> <p>Called when inventory data changes, triggers proxy functions</p> <p>When Called</p> <p>Automatically when setData is called and data changes</p> <p>Parameters</p> <ul> <li><code>key</code> (unknown): The data key that changed</li> <li><code>key</code> (unknown): The data key that changed</li> <li><code>oldValue</code> (unknown): The previous value</li> <li><code>oldValue</code> (unknown): The previous value</li> <li><code>newValue</code> (unknown): The new value</li> <li><code>newValue</code> (unknown): The new value</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- This is usually called automatically, not manually\ninventory:onDataChanged(\"money\", 100, 150)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Override in subclass for custom behavior\nfunction MyInventory:onDataChanged(key, old, new)\n    if key == \"level\" and new &gt; old then\n        print(\"Level increased!\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onDataChanged(key, old, new)\n    if key == \"permissions\" then\n        hook.Run(\"OnPermissionsChanged\", self, old, new)\n        elseif key == \"settings\" then\n            for setting, value in pairs(new) do\n                if old[setting] ~= value then\n                    print(\"Setting \" .. setting .. \" changed\")\n                end\n            end\n        end\n    end\n</code></pre></p>"},{"location":"meta/inventory/#ondatachanged_1","title":"onDataChanged","text":"<p>Purpose</p> <p>Called when inventory data changes, triggers proxy functions</p> <p>When Called</p> <p>Automatically when setData is called and data changes</p> <p>Parameters</p> <ul> <li><code>key</code> (unknown): The data key that changed</li> <li><code>key</code> (unknown): The data key that changed</li> <li><code>oldValue</code> (unknown): The previous value</li> <li><code>oldValue</code> (unknown): The previous value</li> <li><code>newValue</code> (unknown): The new value</li> <li><code>newValue</code> (unknown): The new value</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- This is usually called automatically, not manually\ninventory:onDataChanged(\"money\", 100, 150)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Override in subclass for custom behavior\nfunction MyInventory:onDataChanged(key, old, new)\n    if key == \"level\" and new &gt; old then\n        print(\"Level increased!\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onDataChanged(key, old, new)\n    if key == \"permissions\" then\n        hook.Run(\"OnPermissionsChanged\", self, old, new)\n        elseif key == \"settings\" then\n            for setting, value in pairs(new) do\n                if old[setting] ~= value then\n                    print(\"Setting \" .. setting .. \" changed\")\n                end\n            end\n        end\n    end\n</code></pre></p>"},{"location":"meta/inventory/#ondatachanged_2","title":"onDataChanged","text":"<p>Purpose</p> <p>Called when inventory data changes, triggers proxy functions</p> <p>When Called</p> <p>Automatically when setData is called and data changes</p> <p>Parameters</p> <ul> <li><code>key</code> (unknown): The data key that changed</li> <li><code>key</code> (unknown): The data key that changed</li> <li><code>oldValue</code> (unknown): The previous value</li> <li><code>oldValue</code> (unknown): The previous value</li> <li><code>newValue</code> (unknown): The new value</li> <li><code>newValue</code> (unknown): The new value</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- This is usually called automatically, not manually\ninventory:onDataChanged(\"money\", 100, 150)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Override in subclass for custom behavior\nfunction MyInventory:onDataChanged(key, old, new)\n    if key == \"level\" and new &gt; old then\n        print(\"Level increased!\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onDataChanged(key, old, new)\n    if key == \"permissions\" then\n        hook.Run(\"OnPermissionsChanged\", self, old, new)\n        elseif key == \"settings\" then\n            for setting, value in pairs(new) do\n                if old[setting] ~= value then\n                    print(\"Setting \" .. setting .. \" changed\")\n                end\n            end\n        end\n    end\n</code></pre></p>"},{"location":"meta/inventory/#getitems","title":"getItems","text":"<p>Purpose</p> <p>Gets all items in the inventory</p> <p>When Called</p> <p>When you need to iterate through all inventory items</p> <p>Returns</p> <ul> <li>Table of all items in the inventory</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local items = inventory:getItems()\n</code></pre></p> <p>Medium Complexity: <pre><code>for _, item in pairs(inventory:getItems()) do\n    print(\"Item:\", item:getName())\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function analyzeInventoryContents(inv)\n    local items = inv:getItems()\n    local totalValue = 0\n    local categories = {}\n    for _, item in pairs(items) do\n        totalValue = totalValue + (item:getValue() or 0)\n        local category = item.category or \"misc\"\n        categories[category] = (categories[category] or 0) + 1\n    end\n    return totalValue, categories\nend\n</code></pre></p>"},{"location":"meta/inventory/#getitemsoftype","title":"getItemsOfType","text":"<p>Purpose</p> <p>Gets all items of a specific type from the inventory</p> <p>When Called</p> <p>When you need items of a particular type for processing</p> <p>Parameters</p> <ul> <li><code>itemType</code> (unknown): The uniqueID of the item type to find</li> <li><code>itemType</code> (unknown): The uniqueID of the item type to find</li> </ul> <p>Returns</p> <ul> <li>Table of items matching the specified type</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local weapons = inventory:getItemsOfType(\"weapon_pistol\")\n</code></pre></p> <p>Medium Complexity: <pre><code>local food = inventory:getItemsOfType(\"food_apple\")\nprint(\"Found\", #food, \"apples\")\n</code></pre></p> <p>High Complexity: <pre><code>local function getItemsByRarity(inv, rarity)\n    local items = {}\n    for _, item in pairs(inv:getItems()) do\n        if item.data and item.data.rarity == rarity then\n            table.insert(items, item)\n        end\n    end\n    return items\nend\nlocal rareItems = getItemsByRarity(inventory, \"legendary\")\n</code></pre></p>"},{"location":"meta/inventory/#getfirstitemoftype","title":"getFirstItemOfType","text":"<p>Purpose</p> <p>Gets the first item of a specific type from the inventory</p> <p>When Called</p> <p>When you need any single item of a type (efficiency over getting all)</p> <p>Parameters</p> <ul> <li><code>itemType</code> (unknown): The uniqueID of the item type to find</li> <li><code>itemType</code> (unknown): The uniqueID of the item type to find</li> </ul> <p>Returns</p> <ul> <li>The first item found of the specified type, or nil if none found</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local weapon = inventory:getFirstItemOfType(\"weapon_pistol\")\n</code></pre></p> <p>Medium Complexity: <pre><code>local apple = inventory:getFirstItemOfType(\"food_apple\")\nif apple then apple:use(player) end\n</code></pre></p> <p>High Complexity: <pre><code>local function findBestTool(inv, toolType)\n    local tools = inv:getItemsOfType(toolType)\n    local bestTool = nil\n    local bestLevel = 0\n    for _, tool in ipairs(tools) do\n        if tool.data and tool.data.level &gt; bestLevel then\n            bestTool = tool\n            bestLevel = tool.data.level\n        end\n    end\n    return bestTool\nend\nlocal bestPickaxe = findBestTool(inventory, \"tool_pickaxe\")\n</code></pre></p>"},{"location":"meta/inventory/#hasitem","title":"hasItem","text":"<p>Purpose</p> <p>Checks if the inventory contains at least one item of a specific type</p> <p>When Called</p> <p>For quick boolean checks before performing actions</p> <p>Parameters</p> <ul> <li><code>itemType</code> (unknown): The uniqueID of the item type to check for</li> <li><code>itemType</code> (unknown): The uniqueID of the item type to check for</li> </ul> <p>Returns</p> <ul> <li>Boolean indicating if the item type exists in inventory</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>if inventory:hasItem(\"food_apple\") then print(\"Has apple!\") end\n</code></pre></p> <p>Medium Complexity: <pre><code>if inventory:hasItem(\"weapon_pistol\") then\n    player:giveWeapon(\"weapon_pistol\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function canCraftRecipe(inv, recipe)\n    for _, ingredient in ipairs(recipe.ingredients) do\n        if not inv:hasItem(ingredient.id) then\n            return false, \"Missing: \" .. ingredient.name\n        end\n    end\n    return true\nend\nlocal canCraft, reason = canCraftRecipe(inventory, woodRecipe)\n</code></pre></p>"},{"location":"meta/inventory/#getitemcount","title":"getItemCount","text":"<p>Purpose</p> <p>Counts total quantity of items of a specific type in the inventory</p> <p>When Called</p> <p>When you need to know how many of a particular item type exist</p> <p>Parameters</p> <ul> <li><code>itemType</code> (unknown): Optional uniqueID of item type to count, nil for all items</li> <li><code>itemType</code> (unknown): Optional uniqueID of item type to count, nil for all items</li> </ul> <p>Returns</p> <ul> <li>Number representing total quantity of specified item type</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local appleCount = inventory:getItemCount(\"food_apple\")\n</code></pre></p> <p>Medium Complexity: <pre><code>local totalFood = inventory:getItemCount(\"food\")\nlocal totalWeapons = inventory:getItemCount(\"weapon\")\n</code></pre></p> <p>High Complexity: <pre><code>local function calculateInventoryWeight(inv)\n    local totalWeight = 0\n    for _, item in pairs(inv:getItems()) do\n        local itemWeight = item:getWeight and item:getWeight() or 1\n        totalWeight = totalWeight + (itemWeight * item:getQuantity())\n    end\n    return totalWeight\nend\nlocal weight = calculateInventoryWeight(inventory)\n</code></pre></p>"},{"location":"meta/inventory/#getid","title":"getID","text":"<p>Purpose</p> <p>Gets the unique ID of this inventory instance</p> <p>When Called</p> <p>When you need to reference this specific inventory instance</p> <p>Returns</p> <ul> <li>The inventory's unique ID number</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local id = inventory:getID()\n</code></pre></p> <p>Medium Complexity: <pre><code>print(\"Inventory ID:\", inventory:getID())\n</code></pre></p> <p>High Complexity: <pre><code>local function transferItems(fromInv, toInv, itemType)\n    local items = fromInv:getItemsOfType(itemType)\n    for _, item in ipairs(items) do\n        fromInv:removeItem(item:getID())\n        toInv:addItem(item)\n    end\n    print(\"Transferred\", #items, \"items between inventories\",\n    fromInv:getID(), \"and\", toInv:getID())\nend\n</code></pre></p>"},{"location":"meta/inventory/#additem","title":"addItem","text":"<p>Purpose</p> <p>Adds an item to the inventory with optional replication control</p> <p>When Called</p> <p>When items need to be added to an inventory instance</p> <p>Parameters</p> <ul> <li><code>item</code> (unknown): The item instance to add</li> <li><code>item</code> (unknown): The item instance to add</li> <li><code>noReplicate</code> (unknown): Optional boolean to skip network synchronization</li> <li><code>noReplicate</code> (unknown): Optional boolean to skip network synchronization</li> </ul> <p>Returns</p> <ul> <li>The inventory instance for method chaining</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:addItem(myItem)\n</code></pre></p> <p>Medium Complexity: <pre><code>local weapon = lia.item.new(\"weapon_pistol\", 1)\nplayer:getInventory():addItem(weapon)\n</code></pre></p> <p>High Complexity: <pre><code>local function addItemsToInventory(inv, itemList)\n    for _, itemData in ipairs(itemList) do\n        local item = lia.item.new(itemData.uniqueID, itemData.id)\n        if item then\n            inv:addItem(item, false) -- Force replication\n        end\n    end\nend\naddItemsToInventory(playerInventory, lootTable)\n</code></pre></p>"},{"location":"meta/inventory/#add","title":"add","text":"<p>Purpose</p> <p>Alias for addItem method for convenience</p> <p>When Called</p> <p>Alternative method name for adding items</p> <p>Parameters</p> <ul> <li><code>item</code> (unknown): The item instance to add</li> <li><code>item</code> (unknown): The item instance to add</li> </ul> <p>Returns</p> <ul> <li>The inventory instance for method chaining</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:add(myItem)\n</code></pre></p> <p>Medium Complexity: <pre><code>playerInventory:add(lia.item.new(\"food_apple\", 1))\n</code></pre></p> <p>High Complexity: <pre><code>local items = {weapon = \"weapon_pistol\", armor = \"armor_helmet\"}\nfor slot, uniqueID in pairs(items) do\n    local item = lia.item.new(uniqueID, slot .. \"_id\")\n    inventory:add(item)\nend\n</code></pre></p>"},{"location":"meta/inventory/#syncitemadded","title":"syncItemAdded","text":"<p>Purpose</p> <p>Synchronizes newly added items to appropriate clients</p> <p>When Called</p> <p>Automatically called when items are added to inventory</p> <p>Parameters</p> <ul> <li><code>item</code> (unknown): The item that was added</li> <li><code>item</code> (unknown): The item that was added</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Usually called automatically by addItem\ninventory:syncItemAdded(item)\n</code></pre></p> <p>Medium Complexity: <pre><code>local item = lia.item.new(\"weapon_sniper\", 1)\ninventory:addItem(item)\n-- syncItemAdded is called automatically\n</code></pre></p> <p>High Complexity: <pre><code>local function batchAddItems(inv, items)\n    for _, item in ipairs(items) do\n        inv:addItem(item, true) -- Don't replicate individually\n    end\n    -- Manually sync all at once\n    for _, item in pairs(inv:getItems()) do\n        inv:syncItemAdded(item)\n    end\nend\n</code></pre></p>"},{"location":"meta/inventory/#initializestorage","title":"initializeStorage","text":"<p>Purpose</p> <p>Initializes inventory storage in the database</p> <p>When Called</p> <p>When creating new persistent inventories</p> <p>Parameters</p> <ul> <li><code>initialData</code> (unknown): Initial data to store with the inventory</li> <li><code>initialData</code> (unknown): Initial data to store with the inventory</li> </ul> <p>Returns</p> <ul> <li>Deferred object that resolves when storage is initialized</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local deferred = inventory:initializeStorage({char = characterID})\ndeferred:next(function(id) print(\"Created inventory:\", id) end)\n</code></pre></p> <p>Medium Complexity: <pre><code>local initialData = {\nchar = player:getCharacter():getID(),\npermissions = {\"read\", \"write\"}\n}\ninventory:initializeStorage(initialData)\n</code></pre></p> <p>High Complexity: <pre><code>local function createGuildInventory(guildData)\n    local inventory = lia.inventory.new(\"guild_storage\")\n    local initialData = {\n    char = guildData.leaderID,\n    guildID = guildData.id,\n    accessLevel = \"member\",\n    maxSlots = guildData.tier * 50\n    }\n    return inventory:initializeStorage(initialData)\nend\nlocal deferred = createGuildInventory(guildInfo)\n</code></pre></p>"},{"location":"meta/inventory/#restorefromstorage","title":"restoreFromStorage","text":"<p>Purpose</p> <p>Placeholder for restoring inventory from storage</p> <p>When Called</p> <p>When loading existing inventories from database</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Override in subclass for custom restoration logic\nfunction MyInventory:restoreFromStorage()\n    -- Custom restoration code here\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function SecureInventory:restoreFromStorage()\n    -- Load encryption keys, permissions, etc.\n    self.encryptionKey = self:getData(\"encryptionKey\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:restoreFromStorage()\n    -- Restore complex state from multiple data sources\n    self:loadAccessRules()\n    self:restoreItemStates()\n    self:validateIntegrity()\nend\n</code></pre></p>"},{"location":"meta/inventory/#restorefromstorage_1","title":"restoreFromStorage","text":"<p>Purpose</p> <p>Placeholder for restoring inventory from storage</p> <p>When Called</p> <p>When loading existing inventories from database</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Override in subclass for custom restoration logic\nfunction MyInventory:restoreFromStorage()\n    -- Custom restoration code here\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function SecureInventory:restoreFromStorage()\n    -- Load encryption keys, permissions, etc.\n    self.encryptionKey = self:getData(\"encryptionKey\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:restoreFromStorage()\n    -- Restore complex state from multiple data sources\n    self:loadAccessRules()\n    self:restoreItemStates()\n    self:validateIntegrity()\nend\n</code></pre></p>"},{"location":"meta/inventory/#restorefromstorage_2","title":"restoreFromStorage","text":"<p>Purpose</p> <p>Placeholder for restoring inventory from storage</p> <p>When Called</p> <p>When loading existing inventories from database</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Override in subclass for custom restoration logic\nfunction MyInventory:restoreFromStorage()\n    -- Custom restoration code here\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function SecureInventory:restoreFromStorage()\n    -- Load encryption keys, permissions, etc.\n    self.encryptionKey = self:getData(\"encryptionKey\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:restoreFromStorage()\n    -- Restore complex state from multiple data sources\n    self:loadAccessRules()\n    self:restoreItemStates()\n    self:validateIntegrity()\nend\n</code></pre></p>"},{"location":"meta/inventory/#restorefromstorage_3","title":"restoreFromStorage","text":"<p>Purpose</p> <p>Placeholder for restoring inventory from storage</p> <p>When Called</p> <p>When loading existing inventories from database</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Override in subclass for custom restoration logic\nfunction MyInventory:restoreFromStorage()\n    -- Custom restoration code here\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function SecureInventory:restoreFromStorage()\n    -- Load encryption keys, permissions, etc.\n    self.encryptionKey = self:getData(\"encryptionKey\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:restoreFromStorage()\n    -- Restore complex state from multiple data sources\n    self:loadAccessRules()\n    self:restoreItemStates()\n    self:validateIntegrity()\nend\n</code></pre></p>"},{"location":"meta/inventory/#removeitem","title":"removeItem","text":"<p>Purpose</p> <p>Removes an item from the inventory with optional preservation</p> <p>When Called</p> <p>When items need to be removed from inventory</p> <p>Parameters</p> <ul> <li><code>itemID</code> (unknown): The ID of the item to remove</li> <li><code>itemID</code> (unknown): The ID of the item to remove</li> <li><code>preserveItem</code> (unknown): Optional boolean to preserve item data in database</li> <li><code>preserveItem</code> (unknown): Optional boolean to preserve item data in database</li> </ul> <p>Returns</p> <ul> <li>Deferred object that resolves when removal is complete</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:removeItem(12345)\n</code></pre></p> <p>Medium Complexity: <pre><code>local itemID = playerInventory:getFirstItemOfType(\"food_apple\"):getID()\ninventory:removeItem(itemID)\n</code></pre></p> <p>High Complexity: <pre><code>local function removeItemsByType(inv, itemType, preserve)\n    local items = inv:getItemsOfType(itemType)\n    local deferreds = {}\n    for _, item in ipairs(items) do\n        deferreds[#deferreds + 1] = inv:removeItem(item:getID(), preserve)\n    end\n    return deferreds\nend\nlocal deferreds = removeItemsByType(inventory, \"expired_food\", true)\n</code></pre></p>"},{"location":"meta/inventory/#remove","title":"remove","text":"<p>Purpose</p> <p>Alias for removeItem method for convenience</p> <p>When Called</p> <p>Alternative method name for removing items</p> <p>Parameters</p> <ul> <li><code>itemID</code> (unknown): The ID of the item to remove</li> <li><code>itemID</code> (unknown): The ID of the item to remove</li> </ul> <p>Returns</p> <ul> <li>Deferred object that resolves when removal is complete</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:remove(12345)\n</code></pre></p> <p>Medium Complexity: <pre><code>local item = inventory:getFirstItemOfType(\"weapon_knife\")\nif item then inventory:remove(item:getID()) end\n</code></pre></p> <p>High Complexity: <pre><code>local function clearInventoryOfType(inv, itemType)\n    local items = inv:getItemsOfType(itemType)\n    for _, item in ipairs(items) do\n        inv:remove(item:getID())\n    end\nend\nclearInventoryOfType(playerInventory, \"contraband\")\n</code></pre></p>"},{"location":"meta/inventory/#setdata","title":"setData","text":"<p>Purpose</p> <p>Sets data for the inventory and persists to database</p> <p>When Called</p> <p>When inventory data needs to be updated</p> <p>Parameters</p> <ul> <li><code>key</code> (unknown): The data key to set</li> <li><code>key</code> (unknown): The data key to set</li> <li><code>value</code> (unknown): The value to set for the key</li> <li><code>value</code> (unknown): The value to set for the key</li> </ul> <p>Returns</p> <ul> <li>The inventory instance for method chaining</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:setData(\"money\", 1000)\n</code></pre></p> <p>Medium Complexity: <pre><code>inventory:setData(\"permissions\", {\"read\", \"write\", \"admin\"})\n</code></pre></p> <p>High Complexity: <pre><code>local function updateInventoryStats(inv, stats)\n    for statName, statValue in pairs(stats) do\n        inv:setData(statName, statValue)\n    end\n    -- Trigger custom update logic\n    inv:onStatsUpdated(stats)\nend\nupdateInventoryStats(guildInventory, {level = 5, members = 25})\n</code></pre></p>"},{"location":"meta/inventory/#canaccess","title":"canAccess","text":"<p>Purpose</p> <p>Checks if an action is allowed on this inventory</p> <p>When Called</p> <p>Before performing actions that require access control</p> <p>Parameters</p> <ul> <li><code>action</code> (unknown): The action to check (e.g., \"repl\", \"add\", \"remove\")</li> <li><code>action</code> (unknown): The action to check (e.g., \"repl\", \"add\", \"remove\")</li> <li><code>context</code> (unknown): Optional context table with additional information</li> <li><code>context</code> (unknown): Optional context table with additional information</li> </ul> <p>Returns</p> <ul> <li>Boolean indicating if action is allowed, and optional reason string</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local canAccess, reason = inventory:canAccess(\"repl\")\nif not canAccess then print(\"Access denied:\", reason) end\n</code></pre></p> <p>Medium Complexity: <pre><code>local canAdd, reason = inventory:canAccess(\"add\", {client = player})\nif canAdd then inventory:addItem(item) end\n</code></pre></p> <p>High Complexity: <pre><code>local function checkInventoryPermissions(inv, player, action)\n    local context = {\n    client = player,\n    itemType = \"weapon\",\n    quantity = 1,\n    time = os.time()\n    }\n    local allowed, reason = inv:canAccess(action, context)\n    if not allowed then\n        lia.log.add(player, \"inventory_denied\", action, reason)\n    end\n    return allowed, reason\nend\nlocal canTake, reason = checkInventoryPermissions(bankInv, robber, \"remove\")\n</code></pre></p>"},{"location":"meta/inventory/#addaccessrule","title":"addAccessRule","text":"<p>Purpose</p> <p>Adds an access control rule to the inventory</p> <p>When Called</p> <p>During inventory configuration to set up access control</p> <p>Parameters</p> <ul> <li><code>rule</code> (unknown): Function that takes (inventory, action, context) and returns bool, string</li> <li><code>rule</code> (unknown): Function that takes (inventory, action, context) and returns bool, string</li> <li><code>priority</code> (unknown): Optional priority number for rule evaluation order</li> <li><code>priority</code> (unknown): Optional priority number for rule evaluation order</li> </ul> <p>Returns</p> <ul> <li>The inventory instance for method chaining</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:addAccessRule(function(inv, action, context)\nif action == \"repl\" then return true end\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>inventory:addAccessRule(function(inv, action, context)\nif context.client == inv:getOwner() then\n    return true, \"Owner access\"\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>local function complexAccessRule(inv, action, context)\n    local client = context.client\n    if not client then return false, \"No client provided\" end\n        -- Check if client is admin\n        if client:isAdmin() then return true, \"Admin access\" end\n            -- Check time-based restrictions\n            local currentHour = os.date(\"%H\", os.time())\n            if action == \"remove\" and currentHour &lt; 6 then\n                return false, \"Withdrawals not allowed before 6 AM\"\n            end\n            -- Check item-specific rules\n            if context.itemType == \"weapon\" then\n                if not client:hasFlag(\"can_carry_weapons\") then\n                    return false, \"No weapon permit\"\n                end\n            end\n            return true\n        end\n        inventory:addAccessRule(complexAccessRule)\n</code></pre></p>"},{"location":"meta/inventory/#removeaccessrule","title":"removeAccessRule","text":"<p>Purpose</p> <p>Removes an access control rule from the inventory</p> <p>When Called</p> <p>When access rules need to be removed or updated</p> <p>Parameters</p> <ul> <li><code>rule</code> (unknown): The rule function to remove</li> <li><code>rule</code> (unknown): The rule function to remove</li> </ul> <p>Returns</p> <ul> <li>The inventory instance for method chaining</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:removeAccessRule(myRule)\n</code></pre></p> <p>Medium Complexity: <pre><code>local rules = inventory.config.accessRules\nfor i, rule in ipairs(rules) do\n    if rule == tempAccessRule then\n        inventory:removeAccessRule(rule)\n        break\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function cleanupAccessRules(inv)\n    local rules = inv.config.accessRules\n    local currentTime = os.time()\n    for i = #rules, 1, -1 do\n        local rule = rules[i]\n        -- Remove expired temporary rules\n        if rule.expiry and rule.expiry &lt; currentTime then\n            inv:removeAccessRule(rule)\n        end\n    end\nend\ncleanupAccessRules(guildInventory)\n</code></pre></p>"},{"location":"meta/inventory/#getrecipients","title":"getRecipients","text":"<p>Purpose</p> <p>Gets list of clients that should receive inventory updates</p> <p>When Called</p> <p>When synchronizing inventory changes to clients</p> <p>Returns</p> <ul> <li>Table of client entities that can access this inventory</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local recipients = inventory:getRecipients()\n</code></pre></p> <p>Medium Complexity: <pre><code>local players = inventory:getRecipients()\nfor _, client in ipairs(players) do\n    client:ChatPrint(\"Inventory updated\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function sendCustomNotification(inv, message)\n    local recipients = inv:getRecipients()\n    net.Start(\"CustomInventoryNotification\")\n    net.WriteString(message)\n    net.Send(recipients)\nend\nsendCustomNotification(bankInventory, \"Security alert triggered!\")\n</code></pre></p>"},{"location":"meta/inventory/#oninstanced","title":"onInstanced","text":"<p>Purpose</p> <p>Called when inventory instance is created</p> <p>When Called</p> <p>Automatically when inventory instances are created</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Override in subclass for custom initialization\nfunction MyInventory:onInstanced()\n    print(\"New inventory created\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onInstanced()\n    self:addAccessRule(function(inv, action, context)\n    return context.client == inv:getOwner()\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>function SecureInventory:onInstanced()\n    -- Initialize security features\n    self.securityLevel = self:getData(\"securityLevel\", 1)\n    self.accessLog = {}\n    self.failedAttempts = 0\n    -- Set up monitoring\n    self:addAccessRule(function(inv, action, context)\n    if action == \"remove\" and inv.securityLevel &gt; 3 then\n        table.insert(inv.accessLog, {\n        client = context.client,\n        action = action,\n        time = os.time()\n        })\n    end\n    return true\nend)\nend\n</code></pre></p>"},{"location":"meta/inventory/#oninstanced_1","title":"onInstanced","text":"<p>Purpose</p> <p>Called when inventory instance is created</p> <p>When Called</p> <p>Automatically when inventory instances are created</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Override in subclass for custom initialization\nfunction MyInventory:onInstanced()\n    print(\"New inventory created\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onInstanced()\n    self:addAccessRule(function(inv, action, context)\n    return context.client == inv:getOwner()\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>function SecureInventory:onInstanced()\n    -- Initialize security features\n    self.securityLevel = self:getData(\"securityLevel\", 1)\n    self.accessLog = {}\n    self.failedAttempts = 0\n    -- Set up monitoring\n    self:addAccessRule(function(inv, action, context)\n    if action == \"remove\" and inv.securityLevel &gt; 3 then\n        table.insert(inv.accessLog, {\n        client = context.client,\n        action = action,\n        time = os.time()\n        })\n    end\n    return true\nend)\nend\n</code></pre></p>"},{"location":"meta/inventory/#oninstanced_2","title":"onInstanced","text":"<p>Purpose</p> <p>Called when inventory instance is created</p> <p>When Called</p> <p>Automatically when inventory instances are created</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Override in subclass for custom initialization\nfunction MyInventory:onInstanced()\n    print(\"New inventory created\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onInstanced()\n    self:addAccessRule(function(inv, action, context)\n    return context.client == inv:getOwner()\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>function SecureInventory:onInstanced()\n    -- Initialize security features\n    self.securityLevel = self:getData(\"securityLevel\", 1)\n    self.accessLog = {}\n    self.failedAttempts = 0\n    -- Set up monitoring\n    self:addAccessRule(function(inv, action, context)\n    if action == \"remove\" and inv.securityLevel &gt; 3 then\n        table.insert(inv.accessLog, {\n        client = context.client,\n        action = action,\n        time = os.time()\n        })\n    end\n    return true\nend)\nend\n</code></pre></p>"},{"location":"meta/inventory/#oninstanced_3","title":"onInstanced","text":"<p>Purpose</p> <p>Called when inventory instance is created</p> <p>When Called</p> <p>Automatically when inventory instances are created</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Override in subclass for custom initialization\nfunction MyInventory:onInstanced()\n    print(\"New inventory created\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onInstanced()\n    self:addAccessRule(function(inv, action, context)\n    return context.client == inv:getOwner()\nend)\nend\n</code></pre></p> <p>High Complexity: <pre><code>function SecureInventory:onInstanced()\n    -- Initialize security features\n    self.securityLevel = self:getData(\"securityLevel\", 1)\n    self.accessLog = {}\n    self.failedAttempts = 0\n    -- Set up monitoring\n    self:addAccessRule(function(inv, action, context)\n    if action == \"remove\" and inv.securityLevel &gt; 3 then\n        table.insert(inv.accessLog, {\n        client = context.client,\n        action = action,\n        time = os.time()\n        })\n    end\n    return true\nend)\nend\n</code></pre></p>"},{"location":"meta/inventory/#onloaded","title":"onLoaded","text":"<p>Purpose</p> <p>Called when inventory is loaded from storage</p> <p>When Called</p> <p>Automatically when persistent inventories are loaded</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:onLoaded()\n    print(\"Inventory loaded from storage\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onLoaded()\n    -- Restore character-specific settings\n    local char = self:getCharacter()\n    if char then\n        self:setData(\"lastSeen\", os.time())\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onLoaded()\n    -- Validate inventory integrity\n    self:validateItemStates()\n    self:restoreAccessRules()\n    self:checkForExpiredItems()\n    -- Initialize advanced features\n    if self:getData(\"autoSort\") then\n        self:sortItems()\n    end\nend\n</code></pre></p>"},{"location":"meta/inventory/#onloaded_1","title":"onLoaded","text":"<p>Purpose</p> <p>Called when inventory is loaded from storage</p> <p>When Called</p> <p>Automatically when persistent inventories are loaded</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:onLoaded()\n    print(\"Inventory loaded from storage\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onLoaded()\n    -- Restore character-specific settings\n    local char = self:getCharacter()\n    if char then\n        self:setData(\"lastSeen\", os.time())\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onLoaded()\n    -- Validate inventory integrity\n    self:validateItemStates()\n    self:restoreAccessRules()\n    self:checkForExpiredItems()\n    -- Initialize advanced features\n    if self:getData(\"autoSort\") then\n        self:sortItems()\n    end\nend\n</code></pre></p>"},{"location":"meta/inventory/#onloaded_2","title":"onLoaded","text":"<p>Purpose</p> <p>Called when inventory is loaded from storage</p> <p>When Called</p> <p>Automatically when persistent inventories are loaded</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:onLoaded()\n    print(\"Inventory loaded from storage\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onLoaded()\n    -- Restore character-specific settings\n    local char = self:getCharacter()\n    if char then\n        self:setData(\"lastSeen\", os.time())\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onLoaded()\n    -- Validate inventory integrity\n    self:validateItemStates()\n    self:restoreAccessRules()\n    self:checkForExpiredItems()\n    -- Initialize advanced features\n    if self:getData(\"autoSort\") then\n        self:sortItems()\n    end\nend\n</code></pre></p>"},{"location":"meta/inventory/#onloaded_3","title":"onLoaded","text":"<p>Purpose</p> <p>Called when inventory is loaded from storage</p> <p>When Called</p> <p>Automatically when persistent inventories are loaded</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:onLoaded()\n    print(\"Inventory loaded from storage\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onLoaded()\n    -- Restore character-specific settings\n    local char = self:getCharacter()\n    if char then\n        self:setData(\"lastSeen\", os.time())\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onLoaded()\n    -- Validate inventory integrity\n    self:validateItemStates()\n    self:restoreAccessRules()\n    self:checkForExpiredItems()\n    -- Initialize advanced features\n    if self:getData(\"autoSort\") then\n        self:sortItems()\n    end\nend\n</code></pre></p>"},{"location":"meta/inventory/#loaditems","title":"loadItems","text":"<p>Purpose</p> <p>Loads items from database storage</p> <p>When Called</p> <p>When inventory needs to be populated from persistent storage</p> <p>Returns</p> <ul> <li>Deferred object that resolves with loaded items</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:loadItems():next(function(items)\nprint(\"Loaded\", #items, \"items\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>playerInventory:loadItems():next(function(items)\nfor _, item in pairs(items) do\n    if item.uniqueID == \"weapon\" then\n        player:giveWeapon(item.data.weaponClass)\n    end\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>local function loadInventoryWithValidation(inv)\n    return inv:loadItems():next(function(items)\n    -- Validate loaded items\n    local validItems = {}\n    local invalidCount = 0\n    for _, item in pairs(items) do\n        if inv:validateItem(item) then\n            table.insert(validItems, item)\n            else\n                invalidCount = invalidCount + 1\n                lia.log.add(nil, \"invalid_item\", item:getID(), inv:getID())\n            end\n        end\n        if invalidCount &gt; 0 then\n            lia.log.add(nil, \"inventory_validation\", inv:getID(), invalidCount .. \" invalid items\")\n        end\n        return validItems\n    end)\nend\nloadInventoryWithValidation(playerInventory)\n</code></pre></p>"},{"location":"meta/inventory/#onitemsloaded","title":"onItemsLoaded","text":"<p>Purpose</p> <p>Called after items are loaded from storage</p> <p>When Called</p> <p>Automatically after loadItems completes successfully</p> <p>Parameters</p> <ul> <li><code>items</code> (unknown): Table of loaded items</li> <li><code>items</code> (unknown): Table of loaded items</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:onItemsLoaded(items)\n    print(\"Loaded\", #items, \"items\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onItemsLoaded(items)\n    for _, item in pairs(items) do\n        if item.uniqueID == \"quest_item\" then\n            hook.Run(\"OnQuestItemLoaded\", self:getOwner(), item)\n        end\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onItemsLoaded(items)\n    -- Categorize items\n    self.itemCategories = {}\n    for _, item in pairs(items) do\n        local category = item.category or \"misc\"\n        if not self.itemCategories[category] then\n            self.itemCategories[category] = {}\n        end\n        table.insert(self.itemCategories[category], item)\n    end\n    -- Initialize item relationships\n    for _, item in pairs(items) do\n        item:onInventoryLoaded(self)\n    end\n    -- Validate inventory constraints\n    self:validateInventoryConstraints()\nend\n</code></pre></p>"},{"location":"meta/inventory/#onitemsloaded_1","title":"onItemsLoaded","text":"<p>Purpose</p> <p>Called after items are loaded from storage</p> <p>When Called</p> <p>Automatically after loadItems completes successfully</p> <p>Parameters</p> <ul> <li><code>items</code> (unknown): Table of loaded items</li> <li><code>items</code> (unknown): Table of loaded items</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:onItemsLoaded(items)\n    print(\"Loaded\", #items, \"items\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onItemsLoaded(items)\n    for _, item in pairs(items) do\n        if item.uniqueID == \"quest_item\" then\n            hook.Run(\"OnQuestItemLoaded\", self:getOwner(), item)\n        end\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onItemsLoaded(items)\n    -- Categorize items\n    self.itemCategories = {}\n    for _, item in pairs(items) do\n        local category = item.category or \"misc\"\n        if not self.itemCategories[category] then\n            self.itemCategories[category] = {}\n        end\n        table.insert(self.itemCategories[category], item)\n    end\n    -- Initialize item relationships\n    for _, item in pairs(items) do\n        item:onInventoryLoaded(self)\n    end\n    -- Validate inventory constraints\n    self:validateInventoryConstraints()\nend\n</code></pre></p>"},{"location":"meta/inventory/#onitemsloaded_2","title":"onItemsLoaded","text":"<p>Purpose</p> <p>Called after items are loaded from storage</p> <p>When Called</p> <p>Automatically after loadItems completes successfully</p> <p>Parameters</p> <ul> <li><code>items</code> (unknown): Table of loaded items</li> <li><code>items</code> (unknown): Table of loaded items</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:onItemsLoaded(items)\n    print(\"Loaded\", #items, \"items\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onItemsLoaded(items)\n    for _, item in pairs(items) do\n        if item.uniqueID == \"quest_item\" then\n            hook.Run(\"OnQuestItemLoaded\", self:getOwner(), item)\n        end\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onItemsLoaded(items)\n    -- Categorize items\n    self.itemCategories = {}\n    for _, item in pairs(items) do\n        local category = item.category or \"misc\"\n        if not self.itemCategories[category] then\n            self.itemCategories[category] = {}\n        end\n        table.insert(self.itemCategories[category], item)\n    end\n    -- Initialize item relationships\n    for _, item in pairs(items) do\n        item:onInventoryLoaded(self)\n    end\n    -- Validate inventory constraints\n    self:validateInventoryConstraints()\nend\n</code></pre></p>"},{"location":"meta/inventory/#onitemsloaded_3","title":"onItemsLoaded","text":"<p>Purpose</p> <p>Called after items are loaded from storage</p> <p>When Called</p> <p>Automatically after loadItems completes successfully</p> <p>Parameters</p> <ul> <li><code>items</code> (unknown): Table of loaded items</li> <li><code>items</code> (unknown): Table of loaded items</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function MyInventory:onItemsLoaded(items)\n    print(\"Loaded\", #items, \"items\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function PlayerInventory:onItemsLoaded(items)\n    for _, item in pairs(items) do\n        if item.uniqueID == \"quest_item\" then\n            hook.Run(\"OnQuestItemLoaded\", self:getOwner(), item)\n        end\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function AdvancedInventory:onItemsLoaded(items)\n    -- Categorize items\n    self.itemCategories = {}\n    for _, item in pairs(items) do\n        local category = item.category or \"misc\"\n        if not self.itemCategories[category] then\n            self.itemCategories[category] = {}\n        end\n        table.insert(self.itemCategories[category], item)\n    end\n    -- Initialize item relationships\n    for _, item in pairs(items) do\n        item:onInventoryLoaded(self)\n    end\n    -- Validate inventory constraints\n    self:validateInventoryConstraints()\nend\n</code></pre></p>"},{"location":"meta/inventory/#instance","title":"instance","text":"<p>Purpose</p> <p>Creates a new instance of this inventory type with initial data</p> <p>When Called</p> <p>When creating configured inventory instances</p> <p>Parameters</p> <ul> <li><code>initialData</code> (unknown): Initial data for the inventory instance</li> <li><code>initialData</code> (unknown): Initial data for the inventory instance</li> </ul> <p>Returns</p> <ul> <li>New inventory instance</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local inventory = MyInventory:instance({char = playerID})\n</code></pre></p> <p>Medium Complexity: <pre><code>local bank = BankInventory:instance({\nchar = characterID,\naccessLevel = \"premium\"\n})\n</code></pre></p> <p>High Complexity: <pre><code>local function createComplexInventory(typeClass, config)\n    local inventory = typeClass:instance({\n    char = config.ownerID,\n    permissions = config.permissions,\n    settings = config.settings,\n    maxSlots = config.maxSlots or 50\n    })\n    -- Configure based on type\n    if config.secure then\n        inventory:addAccessRule(function(inv, action, context)\n        if action == \"remove\" and not context.client:isAdmin() then\n            return false, \"Secure inventory - admin access required\"\n        end\n        return true\n    end)\nend\nreturn inventory\nend\nlocal secureBank = createComplexInventory(BankInventory, {\nownerID = playerID,\nsecure = true,\nmaxSlots = 100\n})\n</code></pre></p>"},{"location":"meta/inventory/#syncdata","title":"syncData","text":"<p>Purpose</p> <p>Synchronizes inventory data changes to clients</p> <p>When Called</p> <p>When inventory data changes and needs to be replicated</p> <p>Parameters</p> <ul> <li><code>key</code> (unknown): The data key that changed</li> <li><code>key</code> (unknown): The data key that changed</li> <li><code>recipients</code> (unknown): Optional specific clients to send to, defaults to all recipients</li> <li><code>recipients</code> (unknown): Optional specific clients to send to, defaults to all recipients</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:syncData(\"money\")\n</code></pre></p> <p>Medium Complexity: <pre><code>inventory:setData(\"level\", 5)\n-- syncData is called automatically\n</code></pre></p> <p>High Complexity: <pre><code>local function updateInventoryData(inv, updates)\n    local recipients = inv:getRecipients()\n    for key, value in pairs(updates) do\n        inv:setData(key, value)\n        -- Additional custom sync logic\n        if key == \"permissions\" then\n            inv:syncData(key, recipients) -- Force immediate sync\n        end\n    end\nend\nupdateInventoryData(guildInventory, {level = 5, memberCount = 25})\n</code></pre></p>"},{"location":"meta/inventory/#sync","title":"sync","text":"<p>Purpose</p> <p>Synchronizes entire inventory state to clients</p> <p>When Called</p> <p>When clients need full inventory state (initial load, resync)</p> <p>Parameters</p> <ul> <li><code>recipients</code> (unknown): Optional specific clients to send to, defaults to all recipients</li> <li><code>recipients</code> (unknown): Optional specific clients to send to, defaults to all recipients</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:sync()\n</code></pre></p> <p>Medium Complexity: <pre><code>local recipients = inventory:getRecipients()\ninventory:sync(recipients)\n</code></pre></p> <p>High Complexity: <pre><code>local function fullInventorySync(inv, targetClients)\n    -- Send full inventory state\n    inv:sync(targetClients)\n    -- Send additional metadata if needed\n    for _, client in ipairs(targetClients) do\n        net.Start(\"InventoryMetadata\")\n        net.WriteType(inv:getID())\n        net.WriteTable(inv:getData())\n        net.Send(client)\n    end\nend\nfullInventorySync(playerInventory, {admin1, admin2})\n</code></pre></p>"},{"location":"meta/inventory/#delete","title":"delete","text":"<p>Purpose</p> <p>Deletes the inventory from the system</p> <p>When Called</p> <p>When inventory should be permanently removed</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:delete()\n</code></pre></p> <p>Medium Complexity: <pre><code>if inventory:getItemCount() == 0 then\n    inventory:delete()\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function safelyDeleteInventory(inv)\n    -- Archive inventory data first\n    inv:archiveData()\n    -- Remove all items\n    for _, item in pairs(inv:getItems()) do\n        inv:removeItem(item:getID())\n    end\n    -- Clear access rules\n    inv.config.accessRules = {}\n    -- Finally delete\n    inv:delete()\nend\nsafelyDeleteInventory(oldInventory)\n</code></pre></p>"},{"location":"meta/inventory/#destroy","title":"destroy","text":"<p>Purpose</p> <p>Destroys the inventory and all its items</p> <p>When Called</p> <p>When inventory and all contents should be completely removed</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:destroy()\n</code></pre></p> <p>Medium Complexity: <pre><code>if shouldDestroy then\n    inventory:destroy()\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function cleanupPlayerInventory(player)\n    local inventory = player:getInventory()\n    if inventory then\n        -- Log destruction reason\n        lia.log.add(player, \"inventory_destroyed\", reason)\n        -- Transfer important items to bank first\n        local bankItems = {\"important_document\", \"rare_item\"}\n        for _, itemType in ipairs(bankItems) do\n            local items = inventory:getItemsOfType(itemType)\n            for _, item in ipairs(items) do\n                inventory:removeItem(item:getID())\n                bankInventory:addItem(item)\n            end\n        end\n        -- Destroy remaining inventory\n        inventory:destroy()\n    end\nend\ncleanupPlayerInventory(leavingPlayer)\n</code></pre></p>"},{"location":"meta/inventory/#show","title":"show","text":"<p>Purpose</p> <p>Shows the inventory panel to the player</p> <p>When Called</p> <p>When player opens inventory interface</p> <p>Parameters</p> <ul> <li><code>parent</code> (unknown): Optional parent panel for the inventory UI</li> <li><code>parent</code> (unknown): Optional parent panel for the inventory UI</li> </ul> <p>Returns</p> <ul> <li>The created inventory panel</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>inventory:show()\n</code></pre></p> <p>Medium Complexity: <pre><code>local panel = inventory:show(myCustomParent)\n</code></pre></p> <p>High Complexity: <pre><code>local function createCustomInventoryUI(inv)\n    local frame = vgui.Create(\"DFrame\")\n    frame:SetSize(800, 600)\n    frame:Center()\n    frame:SetTitle(\"Custom Inventory\")\n    local inventoryPanel = inv:show(frame)\n    inventoryPanel:Dock(FILL)\n    -- Add custom buttons\n    local sortButton = vgui.Create(\"DButton\", frame)\n    sortButton:Dock(BOTTOM)\n    sortButton:SetText(\"Sort Items\")\n    sortButton.DoClick = function()\n    net.Start(\"InventorySort\")\n    net.WriteType(inv:getID())\n    net.SendToServer()\nend\nreturn frame\nend\nlocal ui = createCustomInventoryUI(playerInventory)\nui:MakePopup()\n</code></pre></p>"},{"location":"meta/item/","title":"Item Meta","text":"<p>Item management system for the Lilia framework.</p> <p>Overview</p> <p>The item meta table provides comprehensive functionality for managing item data, properties, and operations in the Lilia framework. It handles item creation, data persistence, inventory management, stacking, rotation, and item-specific operations. The meta table operates on both server and client sides, with the server managing item storage and validation while the client provides item data access and display. It includes integration with the inventory system for item storage, database system for item persistence, and rendering system for item display. The meta table ensures proper item data synchronization, quantity management, rotation handling, and comprehensive item lifecycle management from creation to destruction.</p>"},{"location":"meta/item/#isrotated","title":"isRotated","text":"<p>Purpose</p> <p>Checks if the item is currently rotated in the inventory grid</p> <p>When Called</p> <p>When determining item dimensions or display orientation</p> <p>Returns</p> <ul> <li>Boolean indicating if the item is rotated</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>if item:isRotated() then\n    print(\"Item is rotated\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>local width = item:isRotated() and item:getHeight() or item:getWidth()\nlocal height = item:isRotated() and item:getWidth() or item:getHeight()\n</code></pre></p> <p>High Complexity: <pre><code>local function getItemDisplaySize(item)\n    if item:isRotated() then\n        return item:getHeight(), item:getWidth()\n    else\n        return item:getWidth(), item:getHeight()\n    end\nend\nlocal displayW, displayH = getItemDisplaySize(myItem)\n</code></pre></p>"},{"location":"meta/item/#getwidth","title":"getWidth","text":"<p>Purpose</p> <p>Gets the current width of the item considering rotation</p> <p>When Called</p> <p>When determining item grid space requirements or display size</p> <p>Returns</p> <ul> <li>Number representing the item's width in grid units</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local width = item:getWidth()\n</code></pre></p> <p>Medium Complexity: <pre><code>if item:getWidth() &gt; maxWidth then\n    print(\"Item too wide for slot\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function canPlaceItem(inventory, item, x, y)\n    local width = item:getWidth()\n    local height = item:getHeight()\n    return inventory:canPlaceAt(x, y, width, height)\nend\nif canPlaceItem(myInventory, myItem, 1, 1) then\n    inventory:placeItem(myItem, 1, 1)\nend\n</code></pre></p>"},{"location":"meta/item/#getheight","title":"getHeight","text":"<p>Purpose</p> <p>Gets the current height of the item considering rotation</p> <p>When Called</p> <p>When determining item grid space requirements or display size</p> <p>Returns</p> <ul> <li>Number representing the item's height in grid units</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local height = item:getHeight()\n</code></pre></p> <p>Medium Complexity: <pre><code>local totalSpace = item:getWidth() * item:getHeight()\n</code></pre></p> <p>High Complexity: <pre><code>local function calculateInventorySpace(items)\n    local totalWidth = 0\n    local totalHeight = 0\n    for _, item in ipairs(items) do\n        totalWidth = math.max(totalWidth, item:getWidth())\n        totalHeight = totalHeight + item:getHeight()\n    end\n    return totalWidth, totalHeight\nend\nlocal neededW, neededH = calculateInventorySpace(selectedItems)\n</code></pre></p>"},{"location":"meta/item/#getquantity","title":"getQuantity","text":"<p>Purpose</p> <p>Gets the current quantity of the item</p> <p>When Called</p> <p>When checking how many of this item exist, for display or validation</p> <p>Returns</p> <ul> <li>Number representing the item's current quantity</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local count = item:getQuantity()\n</code></pre></p> <p>Medium Complexity: <pre><code>if item:getQuantity() &gt;= requiredAmount then\n    useItem(item)\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function calculateTotalValue(items)\n    local total = 0\n    for _, item in ipairs(items) do\n        local quantity = item:getQuantity()\n        local value = item:getPrice() or 0\n        total = total + (quantity * value)\n    end\n    return total\nend\nlocal inventoryValue = calculateTotalValue(playerInventory:getItems())\n</code></pre></p>"},{"location":"meta/item/#tostring","title":"tostring","text":"<p>Purpose</p> <p>Creates a string representation of the item for debugging/logging</p> <p>When Called</p> <p>For logging, debugging, or console output</p> <p>Returns</p> <ul> <li>String representation of the item</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>print(item:tostring())\n</code></pre></p> <p>Medium Complexity: <pre><code>lia.information(\"Processing \" .. item:tostring())\n</code></pre></p> <p>High Complexity: <pre><code>local function logItemTransaction(item, action, player)\n    local logEntry = string.format(\"[%s] %s performed %s on %s\",\n    os.date(\"%H:%M:%S\"),\n    player:GetName(),\n    action,\n    item:tostring()\n    )\n    file.Append(\"item_transactions.txt\", logEntry .. \"\\n\")\nend\nlogItemTransaction(myItem, \"used\", player)\n</code></pre></p>"},{"location":"meta/item/#getid","title":"getID","text":"<p>Purpose</p> <p>Gets the unique instance ID of this item</p> <p>When Called</p> <p>When you need to reference this specific item instance</p> <p>Returns</p> <ul> <li>Number representing the item's unique ID</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local itemID = item:getID()\n</code></pre></p> <p>Medium Complexity: <pre><code>if item:getID() == targetID then\n    selectItem(item)\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function findItemByID(inventory, targetID)\n    for _, item in pairs(inventory:getItems()) do\n        if item:getID() == targetID then\n            return item\n        end\n    end\n    return nil\nend\nlocal foundItem = findItemByID(playerInventory, 12345)\n</code></pre></p>"},{"location":"meta/item/#getmodel","title":"getModel","text":"<p>Purpose</p> <p>Gets the model path for the item</p> <p>When Called</p> <p>When displaying the item or creating item entities</p> <p>Returns</p> <ul> <li>String representing the item's model path</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local model = item:getModel()\n</code></pre></p> <p>Medium Complexity: <pre><code>if item:getModel() then\n    entity:SetModel(item:getModel())\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function createItemEntity(item, position)\n    local ent = ents.Create(\"prop_physics\")\n    ent:SetModel(item:getModel() or \"models/error.mdl\")\n    ent:SetPos(position)\n    ent:Spawn()\n    if item:getSkin() then\n        ent:SetSkin(item:getSkin())\n    end\n    return ent\nend\nlocal itemEntity = createItemEntity(myItem, Vector(0, 0, 0))\n</code></pre></p>"},{"location":"meta/item/#getskin","title":"getSkin","text":"<p>Purpose</p> <p>Gets the skin index for the item's model</p> <p>When Called</p> <p>When setting up item display or entity appearance</p> <p>Returns</p> <ul> <li>Number representing the skin index, or nil if none set</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local skin = item:getSkin()\n</code></pre></p> <p>Medium Complexity: <pre><code>if item:getSkin() then\n    entity:SetSkin(item:getSkin())\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function applyItemAppearance(entity, item)\n    entity:SetModel(item:getModel())\n    entity:SetSkin(item:getSkin() or 0)\n    for k, v in pairs(item:getBodygroups()) do\n        entity:SetBodygroup(k, v)\n    end\n    entity:SetColor(item:getData(\"color\", Color(255, 255, 255)))\nend\napplyItemAppearance(myEntity, myItem)\n</code></pre></p>"},{"location":"meta/item/#getbodygroups","title":"getBodygroups","text":"<p>Purpose</p> <p>Gets the bodygroup settings for the item's model</p> <p>When Called</p> <p>When setting up item display or entity appearance</p> <p>Returns</p> <ul> <li>Table of bodygroup settings, empty table if none set</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local bodygroups = item:getBodygroups()\n</code></pre></p> <p>Medium Complexity: <pre><code>for id, value in pairs(item:getBodygroups()) do\n    entity:SetBodygroup(id, value)\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function applyBodygroups(entity, bodygroups)\n    for bodygroupID, bodygroupValue in pairs(bodygroups) do\n        if isstring(bodygroupID) then\n            -- Handle named bodygroups\n            local id = entity:FindBodygroupByName(bodygroupID)\n            if id ~= -1 then\n                entity:SetBodygroup(id, bodygroupValue)\n            end\n            else\n                entity:SetBodygroup(bodygroupID, bodygroupValue)\n            end\n        end\n    end\n    applyBodygroups(myEntity, item:getBodygroups())\n</code></pre></p>"},{"location":"meta/item/#getprice","title":"getPrice","text":"<p>Purpose</p> <p>Gets the current price of the item, potentially calculated dynamically</p> <p>When Called</p> <p>When selling, trading, or displaying item value</p> <p>Returns</p> <ul> <li>Number representing the item's price</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local price = item:getPrice()\n</code></pre></p> <p>Medium Complexity: <pre><code>if player:getMoney() &gt;= item:getPrice() then\n    player:buyItem(item)\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function calculateTotalCost(items)\n    local total = 0\n    for _, item in ipairs(items) do\n        local price = item:getPrice()\n        local quantity = item:getQuantity()\n        total = total + (price * quantity)\n    end\n    -- Apply bulk discount\n    if #items &gt; 5 then\n        total = total * 0.9\n    end\n    return total\nend\nlocal cost = calculateTotalCost(selectedItems)\n</code></pre></p>"},{"location":"meta/item/#call","title":"call","text":"<p>Purpose</p> <p>Calls an item method with specified player and entity context</p> <p>When Called</p> <p>When executing item functions that need player/entity context</p> <p>Parameters</p> <ul> <li><code>method</code> (unknown): String name of the method to call</li> <li><code>method</code> (unknown): String name of the method to call</li> <li><code>client</code> (unknown): Player entity to set as context</li> <li><code>client</code> (unknown): Player entity to set as context</li> <li><code>entity</code> (unknown): Entity to set as context</li> <li><code>entity</code> (unknown): Entity to set as context</li> <li><code>...</code> (unknown): Additional arguments to pass to the method</li> </ul> <p>Returns</p> <ul> <li>The return values from the called method</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:call(\"use\", player)\n</code></pre></p> <p>Medium Complexity: <pre><code>local success = item:call(\"canUse\", player, entity)\nif success then\n    item:call(\"onUse\", player, entity)\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function executeItemAction(item, action, player, entity, ...)\n    local canRun, reason = item:call(\"can\" .. action, player, entity, ...)\n    if canRun then\n        local result = {item:call(\"on\" .. action, player, entity, ...)}\n        hook.Run(\"OnItem\" .. action, item, player, entity, unpack(result))\n        return true, unpack(result)\n        else\n            player:notifyError(reason or \"Cannot perform action\")\n            return false\n        end\n    end\n    local success, data = executeItemAction(myItem, \"Use\", player, nil, target)\n</code></pre></p>"},{"location":"meta/item/#getowner","title":"getOwner","text":"<p>Purpose</p> <p>Gets the player who owns this item</p> <p>When Called</p> <p>When you need to determine item ownership or permissions</p> <p>Returns</p> <ul> <li>Player entity who owns the item, or nil if not found</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local owner = item:getOwner()\n</code></pre></p> <p>Medium Complexity: <pre><code>if item:getOwner() == player then\n    allowModification = true\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function canPlayerAccessItem(player, item)\n    local owner = item:getOwner()\n    if not owner then return false end\n        -- Check if player is the owner\n        if owner == player then return true end\n            -- Check if player has admin permissions\n            if player:isAdmin() then return true end\n                -- Check if item is in shared inventory\n                local inventory = lia.inventory.instances[item.invID]\n                if inventory and inventory:getData(\"shared\") then\n                    return inventory:canAccess(\"view\", {client = player})\n                end\n                return false\n            end\n            if canPlayerAccessItem(client, myItem) then\n                -- Allow access\n            end\n</code></pre></p>"},{"location":"meta/item/#getdata","title":"getData","text":"<p>Purpose</p> <p>Retrieves data from the item's data table with fallback to entity data</p> <p>When Called</p> <p>When accessing item-specific data or configuration</p> <p>Parameters</p> <ul> <li><code>key</code> (unknown): The data key to retrieve</li> <li><code>key</code> (unknown): The data key to retrieve</li> <li><code>default</code> (unknown): Optional default value if key doesn't exist</li> <li><code>default</code> (unknown): Optional default value if key doesn't exist</li> </ul> <p>Returns</p> <ul> <li>The data value or default value if key doesn't exist</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local durability = item:getData(\"durability\", 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>local color = item:getData(\"color\", Color(255, 255, 255))\nentity:SetColor(color)\n</code></pre></p> <p>High Complexity: <pre><code>local function applyItemModifiers(entity, item)\n    -- Apply durability-based modifications\n    local durability = item:getData(\"durability\", 100)\n    local maxDurability = item:getData(\"maxDurability\", 100)\n    local durabilityPercent = durability / maxDurability\n    -- Reduce effectiveness based on durability\n    if item.damage then\n        entity:SetHealth(entity:GetMaxHealth() * durabilityPercent)\n    end\n    -- Apply custom modifiers\n    local modifiers = item:getData(\"modifiers\", {})\n    for modifierType, modifierValue in pairs(modifiers) do\n        applyModifier(entity, modifierType, modifierValue * durabilityPercent)\n    end\nend\napplyItemModifiers(myEntity, myItem)\n</code></pre></p>"},{"location":"meta/item/#getalldata","title":"getAllData","text":"<p>Purpose</p> <p>Gets all data associated with the item from both item and entity</p> <p>When Called</p> <p>When you need a complete view of all item data</p> <p>Returns</p> <ul> <li>Table containing all item data</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local allData = item:getAllData()\n</code></pre></p> <p>Medium Complexity: <pre><code>local data = item:getAllData()\nfor key, value in pairs(data) do\n    print(key .. \": \" .. tostring(value))\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function serializeItemForSave(item)\n    local data = item:getAllData()\n    -- Remove runtime-only data\n    data.entity = nil\n    data.player = nil\n    -- Add metadata\n    data.savedAt = os.time()\n    data.version = \"1.0\"\n    return util.TableToJSON(data)\nend\nlocal serializedData = serializeItemForSave(myItem)\nfile.Write(\"item_backup.txt\", serializedData)\n</code></pre></p>"},{"location":"meta/item/#hook","title":"hook","text":"<p>Purpose</p> <p>Registers a hook function to be called before item actions</p> <p>When Called</p> <p>During item configuration to add custom behavior</p> <p>Parameters</p> <ul> <li><code>name</code> (unknown): String name of the hook (e.g., \"use\", \"drop\")</li> <li><code>name</code> (unknown): String name of the hook (e.g., \"use\", \"drop\")</li> <li><code>func</code> (unknown): Function to call when the hook is triggered</li> <li><code>func</code> (unknown): Function to call when the hook is triggered</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:hook(\"use\", function(item)\nprint(\"Item used!\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>item:hook(\"drop\", function(item)\nif item:getData(\"soulbound\") then\n    return false -- Prevent dropping\nend\nend)\n</code></pre></p> <p>High Complexity: <pre><code>item:hook(\"use\", function(item)\n-- Check cooldown\nlocal lastUsed = item:getData(\"lastUsed\", 0)\nlocal cooldown = item:getData(\"cooldown\", 60)\nif CurTime() - lastUsed &lt; cooldown then\n    item.player:notifyError(\"Item is on cooldown\")\n    return false\nend\n-- Update last used time\nitem:setData(\"lastUsed\", CurTime())\n-- Apply custom effects\napplyItemEffect(item.player, item.uniqueID)\nend)\n</code></pre></p>"},{"location":"meta/item/#posthook","title":"postHook","text":"<p>Purpose</p> <p>Registers a post-hook function to be called after item actions</p> <p>When Called</p> <p>During item configuration to add cleanup or follow-up behavior</p> <p>Parameters</p> <ul> <li><code>name</code> (unknown): String name of the hook (e.g., \"use\", \"drop\")</li> <li><code>name</code> (unknown): String name of the hook (e.g., \"use\", \"drop\")</li> <li><code>func</code> (unknown): Function to call after the hook is triggered</li> <li><code>func</code> (unknown): Function to call after the hook is triggered</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:postHook(\"use\", function(item)\nprint(\"Item use completed\")\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>item:postHook(\"drop\", function(item)\nlia.log.add(item.player, \"item_dropped\", item:getName())\nend)\n</code></pre></p> <p>High Complexity: <pre><code>item:postHook(\"use\", function(item, result)\n-- Log usage statistics\nlocal stats = lia.data.get(\"item_usage_stats\", {})\nstats[item.uniqueID] = (stats[item.uniqueID] or 0) + 1\nlia.data.set(\"item_usage_stats\", stats)\n-- Apply post-use effects\nif result == true and item:getData(\"consumable\") then\n    item:addQuantity(-1)\nend\n-- Trigger achievements\nif stats[item.uniqueID] &gt;= 100 then\n    item.player:unlockAchievement(\"frequent_user\")\nend\nend)\n</code></pre></p>"},{"location":"meta/item/#onregistered","title":"onRegistered","text":"<p>Purpose</p> <p>Called when the item is registered with the system</p> <p>When Called</p> <p>Automatically during item registration</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRegistered()\n    print(\"Item registered: \" .. self.uniqueID)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRegistered()\n    if self.model then\n        util.PrecacheModel(self.model)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRegistered()\n    -- Precache model\n    if self.model then\n        util.PrecacheModel(self.model)\n    end\n    -- Register with item categories\n    if self.category then\n        local categories = lia.data.get(\"item_categories\", {})\n        categories[self.category] = categories[self.category] or {}\n        table.insert(categories[self.category], self.uniqueID)\n        lia.data.set(\"item_categories\", categories)\n    end\n    -- Set up default data\n    self.defaultData = self.defaultData or {}\n    for key, value in pairs(self.defaultData) do\n        if self:getData(key) == nil then\n            self:setData(key, value)\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/item/#onregistered_1","title":"onRegistered","text":"<p>Purpose</p> <p>Called when the item is registered with the system</p> <p>When Called</p> <p>Automatically during item registration</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRegistered()\n    print(\"Item registered: \" .. self.uniqueID)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRegistered()\n    if self.model then\n        util.PrecacheModel(self.model)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRegistered()\n    -- Precache model\n    if self.model then\n        util.PrecacheModel(self.model)\n    end\n    -- Register with item categories\n    if self.category then\n        local categories = lia.data.get(\"item_categories\", {})\n        categories[self.category] = categories[self.category] or {}\n        table.insert(categories[self.category], self.uniqueID)\n        lia.data.set(\"item_categories\", categories)\n    end\n    -- Set up default data\n    self.defaultData = self.defaultData or {}\n    for key, value in pairs(self.defaultData) do\n        if self:getData(key) == nil then\n            self:setData(key, value)\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/item/#onregistered_2","title":"onRegistered","text":"<p>Purpose</p> <p>Called when the item is registered with the system</p> <p>When Called</p> <p>Automatically during item registration</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRegistered()\n    print(\"Item registered: \" .. self.uniqueID)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRegistered()\n    if self.model then\n        util.PrecacheModel(self.model)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRegistered()\n    -- Precache model\n    if self.model then\n        util.PrecacheModel(self.model)\n    end\n    -- Register with item categories\n    if self.category then\n        local categories = lia.data.get(\"item_categories\", {})\n        categories[self.category] = categories[self.category] or {}\n        table.insert(categories[self.category], self.uniqueID)\n        lia.data.set(\"item_categories\", categories)\n    end\n    -- Set up default data\n    self.defaultData = self.defaultData or {}\n    for key, value in pairs(self.defaultData) do\n        if self:getData(key) == nil then\n            self:setData(key, value)\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/item/#onregistered_3","title":"onRegistered","text":"<p>Purpose</p> <p>Called when the item is registered with the system</p> <p>When Called</p> <p>Automatically during item registration</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRegistered()\n    print(\"Item registered: \" .. self.uniqueID)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRegistered()\n    if self.model then\n        util.PrecacheModel(self.model)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRegistered()\n    -- Precache model\n    if self.model then\n        util.PrecacheModel(self.model)\n    end\n    -- Register with item categories\n    if self.category then\n        local categories = lia.data.get(\"item_categories\", {})\n        categories[self.category] = categories[self.category] or {}\n        table.insert(categories[self.category], self.uniqueID)\n        lia.data.set(\"item_categories\", categories)\n    end\n    -- Set up default data\n    self.defaultData = self.defaultData or {}\n    for key, value in pairs(self.defaultData) do\n        if self:getData(key) == nil then\n            self:setData(key, value)\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/item/#print","title":"print","text":"<p>Purpose</p> <p>Prints basic item information to the server console</p> <p>When Called</p> <p>For debugging or logging item state</p> <p>Parameters</p> <ul> <li><code>detail</code> (unknown): Optional boolean to show detailed information</li> <li><code>detail</code> (unknown): Optional boolean to show detailed information</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:print()\n</code></pre></p> <p>Medium Complexity: <pre><code>item:print(true) -- Show detailed info\n</code></pre></p> <p>High Complexity: <pre><code>local function debugInventory(inventory)\n    for _, item in pairs(inventory:getItems()) do\n        item:print(true)\n        print(\"---\")\n    end\nend\ndebugInventory(player:getInventory())\n</code></pre></p>"},{"location":"meta/item/#printdata","title":"printData","text":"<p>Purpose</p> <p>Prints all item data to the server console</p> <p>When Called</p> <p>For detailed debugging of item data</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:printData()\n</code></pre></p> <p>Medium Complexity: <pre><code>if item:getData(\"debug\") then\n    item:printData()\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function auditItemData(item)\n    item:printData()\n    -- Check for invalid data\n    local data = item:getAllData()\n    for key, value in pairs(data) do\n        if istable(value) and table.Count(value) &gt; 100 then\n            lia.log.add(nil, \"large_data_warning\", item:getID(), key, table.Count(value))\n        end\n    end\nend\nauditItemData(suspiciousItem)\n</code></pre></p>"},{"location":"meta/item/#getname","title":"getName","text":"<p>Purpose</p> <p>Gets the display name of the item</p> <p>When Called</p> <p>When displaying item names in UI or chat</p> <p>Returns</p> <ul> <li>String representing the item's name</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local name = item:getName()\n</code></pre></p> <p>Medium Complexity: <pre><code>chat.AddText(Color(255, 255, 255), \"You received: \", item:getName())\n</code></pre></p> <p>High Complexity: <pre><code>local function formatItemName(item)\n    local name = item:getName()\n    local quality = item:getData(\"quality\")\n    if quality then\n        local colors = {\n        common = Color(255, 255, 255),\n        rare = Color(0, 255, 255),\n        epic = Color(255, 0, 255),\n        legendary = Color(255, 165, 0)\n        }\n        return colors[quality], name\n    end\n    return Color(255, 255, 255), name\nend\nlocal color, displayName = formatItemName(myItem)\n</code></pre></p>"},{"location":"meta/item/#getdesc","title":"getDesc","text":"<p>Purpose</p> <p>Gets the description of the item</p> <p>When Called</p> <p>When displaying item details or tooltips</p> <p>Returns</p> <ul> <li>String representing the item's description</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local desc = item:getDesc()\n</code></pre></p> <p>Medium Complexity: <pre><code>print(\"Item description: \" .. item:getDesc())\n</code></pre></p> <p>High Complexity: <pre><code>local function getFormattedDescription(item)\n    local desc = item:getDesc()\n    -- Add dynamic information\n    if item:getData(\"durability\") then\n        local durability = item:getData(\"durability\", 100)\n        local maxDurability = item:getData(\"maxDurability\", 100)\n        desc = desc .. string.format(\"\\nDurability: %d/%d\", durability, maxDurability)\n    end\n    if item:getData(\"level\") then\n        desc = desc .. string.format(\"\\nRequired Level: %d\", item:getData(\"level\"))\n    end\n    return desc\nend\nlocal fullDesc = getFormattedDescription(myItem)\n</code></pre></p>"},{"location":"meta/item/#removefrominventory","title":"removeFromInventory","text":"<p>Purpose</p> <p>Removes the item from its current inventory without deleting it</p> <p>When Called</p> <p>When transferring items between inventories or temporarily removing them</p> <p>Parameters</p> <ul> <li><code>preserveItem</code> (unknown): Optional boolean to preserve item data in database</li> <li><code>preserveItem</code> (unknown): Optional boolean to preserve item data in database</li> </ul> <p>Returns</p> <ul> <li>Deferred object that resolves when removal is complete</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:removeFromInventory()\n</code></pre></p> <p>Medium Complexity: <pre><code>item:removeFromInventory(true):next(function()\nprint(\"Item removed but preserved\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>local function transferItem(item, fromInv, toInv)\n    return item:removeFromInventory(true):next(function()\n    return toInv:add(item)\nend):next(function()\nlia.log.add(nil, \"item_transferred\",\nitem:getID(), fromInv:getID(), toInv:getID())\nend)\nend\ntransferItem(myItem, playerInv, bankInv)\n</code></pre></p>"},{"location":"meta/item/#delete","title":"delete","text":"<p>Purpose</p> <p>Permanently deletes the item from the database and system</p> <p>When Called</p> <p>When completely removing an item from the game world</p> <p>Returns</p> <ul> <li>Deferred object that resolves when deletion is complete</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:delete()\n</code></pre></p> <p>Medium Complexity: <pre><code>item:delete():next(function()\nprint(\"Item permanently deleted\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>local function safelyDeleteExpiredItems()\n    local expiredItems = lia.db.select(\"*\", \"items\", \"expiry_date &lt; \" .. os.time())\n    expiredItems:next(function(results)\n    for _, row in ipairs(results.results or {}) do\n        local item = lia.item.instances[tonumber(row.itemID)]\n        if item then\n            -- Log deletion reason\n            lia.log.add(nil, \"expired_item_deleted\", row.itemID, row.uniqueID)\n            -- Delete the item\n            item:delete()\n        end\n    end\nend)\nend\nsafelyDeleteExpiredItems()\n</code></pre></p>"},{"location":"meta/item/#remove","title":"remove","text":"<p>Purpose</p> <p>Completely removes the item from the world, inventory, and database</p> <p>When Called</p> <p>When an item is used up, destroyed, or needs to be completely eliminated</p> <p>Returns</p> <ul> <li>Deferred object that resolves when removal is complete</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:remove()\n</code></pre></p> <p>Medium Complexity: <pre><code>item:remove():next(function()\nplayer:notify(\"Item consumed\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>local function consumeItemWithEffects(item, player)\n    -- Apply item effects before removal\n    if item.onConsume then\n        item:call(\"onConsume\", player)\n    end\n    -- Remove the item\n    return item:remove():next(function()\n    -- Post-consumption effects\n    if item:getData(\"reusable\") then\n        -- Create a new instance if reusable\n        local newItem = lia.item.new(item.uniqueID, 1)\n        player:getInventory():add(newItem)\n    end\n    -- Trigger achievements\n    local consumedCount = player:getData(\"items_consumed\", 0) + 1\n    player:setData(\"items_consumed\", consumedCount)\n    if consumedCount &gt;= 100 then\n        player:unlockAchievement(\"consumptive\")\n    end\nend)\nend\nconsumeItemWithEffects(myItem, player)\n</code></pre></p>"},{"location":"meta/item/#destroy","title":"destroy","text":"<p>Purpose</p> <p>Destroys the item instance and notifies all clients to remove it</p> <p>When Called</p> <p>When an item needs to be removed from the game world immediately</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:destroy()\n</code></pre></p> <p>Medium Complexity: <pre><code>if item:getData(\"temporary\") then\n    item:destroy()\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function destroyItemsInRadius(position, radius)\n    local items = ents.FindInSphere(position, radius)\n    local destroyedCount = 0\n    for _, ent in ipairs(items) do\n        if ent:GetClass() == \"lia_item\" and ent.liaItemID then\n            local item = lia.item.instances[ent.liaItemID]\n            if item then\n                -- Log destruction\n                lia.log.add(nil, \"area_destruction\", item:getID(), item:getName())\n                item:destroy()\n                destroyedCount = destroyedCount + 1\n            end\n        end\n    end\n    lia.chat.send(nil, \"Destroyed \" .. destroyedCount .. \" items in area\")\n    return destroyedCount\nend\ndestroyItemsInRadius(explosionPos, 500)\n</code></pre></p>"},{"location":"meta/item/#ondisposed","title":"onDisposed","text":"<p>Purpose</p> <p>Called when the item is disposed/destroyed</p> <p>When Called</p> <p>Automatically when destroy() is called</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onDisposed()\n    -- Cleanup code here\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onDisposed()\n    -- Clean up associated entities\n    if self.associatedEntity then\n        SafeRemoveEntity(self.associatedEntity)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onDisposed()\n    -- Comprehensive cleanup\n    if self.temporaryEntities then\n        for _, ent in ipairs(self.temporaryEntities) do\n            SafeRemoveEntity(ent)\n        end\n        self.temporaryEntities = nil\n    end\n    -- Remove from global item lists\n    if self.category then\n        local categoryItems = lia.data.get(\"category_items_\" .. self.category, {})\n        categoryItems[self:getID()] = nil\n        lia.data.set(\"category_items_\" .. self.category, categoryItems)\n    end\n    -- Log disposal\n    lia.log.add(nil, \"item_disposed\", self:getID(), self.uniqueID)\n    -- Trigger disposal hooks\n    hook.Run(\"OnItemDisposed\", self)\nend\n</code></pre></p>"},{"location":"meta/item/#ondisposed_1","title":"onDisposed","text":"<p>Purpose</p> <p>Called when the item is disposed/destroyed</p> <p>When Called</p> <p>Automatically when destroy() is called</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onDisposed()\n    -- Cleanup code here\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onDisposed()\n    -- Clean up associated entities\n    if self.associatedEntity then\n        SafeRemoveEntity(self.associatedEntity)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onDisposed()\n    -- Comprehensive cleanup\n    if self.temporaryEntities then\n        for _, ent in ipairs(self.temporaryEntities) do\n            SafeRemoveEntity(ent)\n        end\n        self.temporaryEntities = nil\n    end\n    -- Remove from global item lists\n    if self.category then\n        local categoryItems = lia.data.get(\"category_items_\" .. self.category, {})\n        categoryItems[self:getID()] = nil\n        lia.data.set(\"category_items_\" .. self.category, categoryItems)\n    end\n    -- Log disposal\n    lia.log.add(nil, \"item_disposed\", self:getID(), self.uniqueID)\n    -- Trigger disposal hooks\n    hook.Run(\"OnItemDisposed\", self)\nend\n</code></pre></p>"},{"location":"meta/item/#ondisposed_2","title":"onDisposed","text":"<p>Purpose</p> <p>Called when the item is disposed/destroyed</p> <p>When Called</p> <p>Automatically when destroy() is called</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onDisposed()\n    -- Cleanup code here\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onDisposed()\n    -- Clean up associated entities\n    if self.associatedEntity then\n        SafeRemoveEntity(self.associatedEntity)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onDisposed()\n    -- Comprehensive cleanup\n    if self.temporaryEntities then\n        for _, ent in ipairs(self.temporaryEntities) do\n            SafeRemoveEntity(ent)\n        end\n        self.temporaryEntities = nil\n    end\n    -- Remove from global item lists\n    if self.category then\n        local categoryItems = lia.data.get(\"category_items_\" .. self.category, {})\n        categoryItems[self:getID()] = nil\n        lia.data.set(\"category_items_\" .. self.category, categoryItems)\n    end\n    -- Log disposal\n    lia.log.add(nil, \"item_disposed\", self:getID(), self.uniqueID)\n    -- Trigger disposal hooks\n    hook.Run(\"OnItemDisposed\", self)\nend\n</code></pre></p>"},{"location":"meta/item/#ondisposed_3","title":"onDisposed","text":"<p>Purpose</p> <p>Called when the item is disposed/destroyed</p> <p>When Called</p> <p>Automatically when destroy() is called</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onDisposed()\n    -- Cleanup code here\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onDisposed()\n    -- Clean up associated entities\n    if self.associatedEntity then\n        SafeRemoveEntity(self.associatedEntity)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onDisposed()\n    -- Comprehensive cleanup\n    if self.temporaryEntities then\n        for _, ent in ipairs(self.temporaryEntities) do\n            SafeRemoveEntity(ent)\n        end\n        self.temporaryEntities = nil\n    end\n    -- Remove from global item lists\n    if self.category then\n        local categoryItems = lia.data.get(\"category_items_\" .. self.category, {})\n        categoryItems[self:getID()] = nil\n        lia.data.set(\"category_items_\" .. self.category, categoryItems)\n    end\n    -- Log disposal\n    lia.log.add(nil, \"item_disposed\", self:getID(), self.uniqueID)\n    -- Trigger disposal hooks\n    hook.Run(\"OnItemDisposed\", self)\nend\n</code></pre></p>"},{"location":"meta/item/#getentity","title":"getEntity","text":"<p>Purpose</p> <p>Gets the world entity associated with this item instance</p> <p>When Called</p> <p>When you need to manipulate the physical item entity in the world</p> <p>Returns</p> <ul> <li>Entity object if found, nil otherwise</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local entity = item:getEntity()\n</code></pre></p> <p>Medium Complexity: <pre><code>local entity = item:getEntity()\nif entity then\n    entity:SetPos(newPosition)\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function teleportItemToPlayer(item, player)\n    local entity = item:getEntity()\n    if entity then\n        -- Remove from inventory first\n        item:removeFromInventory(true):next(function()\n        -- Teleport entity to player\n        entity:SetPos(player:GetPos() + Vector(0, 0, 50))\n        entity:SetVelocity(Vector(0, 0, 0))\n        -- Log the action\n        lia.log.add(player, \"item_teleported\", item:getID(), item:getName())\n    end)\n    else\n        player:notifyError(\"Item has no physical entity\")\n    end\nend\nteleportItemToPlayer(myItem, player)\n</code></pre></p>"},{"location":"meta/item/#spawn","title":"spawn","text":"<p>Purpose</p> <p>Creates a physical entity for the item in the world</p> <p>When Called</p> <p>When dropping items or spawning them in the world</p> <p>Parameters</p> <ul> <li><code>position</code> (unknown): Position to spawn the item (Vector, table, or Player entity)</li> <li><code>position</code> (unknown): Position to spawn the item (Vector, table, or Player entity)</li> <li><code>angles</code> (unknown): Optional angles for the spawned item</li> <li><code>angles</code> (unknown): Optional angles for the spawned item</li> </ul> <p>Returns</p> <ul> <li>The created entity</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:spawn(Vector(0, 0, 0))\n</code></pre></p> <p>Medium Complexity: <pre><code>item:spawn(player:GetPos() + Vector(0, 0, 50), Angle(0, 0, 0))\n</code></pre></p> <p>High Complexity: <pre><code>local function dropItemWithPhysics(item, player, force)\n    -- Remove from inventory\n    item:removeFromInventory(true):next(function()\n    -- Spawn with physics\n    local entity = item:spawn(player:GetPos() + Vector(0, 50, 0))\n    if entity and IsValid(entity:GetPhysicsObject()) then\n        -- Apply throw force\n        local phys = entity:GetPhysicsObject()\n        phys:ApplyForceCenter(player:GetAimVector() * force)\n        -- Add some spin\n        phys:AddAngleVelocity(VectorRand() * 100)\n        -- Log the drop\n        lia.log.add(player, \"item_dropped\", item:getID(), item:getName())\n    end\nend)\nend\ndropItemWithPhysics(myItem, player, 1000)\n</code></pre></p>"},{"location":"meta/item/#transfer","title":"transfer","text":"<p>Purpose</p> <p>Transfers the item from its current inventory to a new inventory</p> <p>When Called</p> <p>When moving items between inventories (trading, storing, etc.)</p> <p>Parameters</p> <ul> <li><code>newInventory</code> (unknown): The inventory to transfer the item to</li> <li><code>newInventory</code> (unknown): The inventory to transfer the item to</li> <li><code>bBypass</code> (unknown): Optional boolean to bypass access control checks</li> <li><code>bBypass</code> (unknown): Optional boolean to bypass access control checks</li> </ul> <p>Returns</p> <ul> <li>Boolean indicating if transfer was successful</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:transfer(otherInventory)\n</code></pre></p> <p>Medium Complexity: <pre><code>if item:transfer(bankInventory) then\n    player:notify(\"Item stored in bank\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function tradeItems(player1, player2, itemID, payment)\n    local item = player1:getInventory():getItems()[itemID]\n    if not item then return false, \"Item not found\" end\n        -- Check if player2 has enough money\n        if player2:getMoney() &lt; payment then\n            return false, \"Insufficient funds\"\n        end\n        -- Transfer item\n        if item:transfer(player2:getInventory()) then\n            -- Handle payment\n            player2:addMoney(-payment)\n            player1:addMoney(payment)\n            -- Log the trade\n            lia.log.add(nil, \"item_trade\",\n            item:getID(), player1:GetName(), player2:GetName(), payment)\n            return true\n            else\n                return false, \"Transfer failed\"\n            end\n        end\n        local success, reason = tradeItems(seller, buyer, itemID, 500)\n</code></pre></p>"},{"location":"meta/item/#oninstanced","title":"onInstanced","text":"<p>Purpose</p> <p>Called when the item instance is first created</p> <p>When Called</p> <p>Automatically when item instances are created</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onInstanced()\n    print(\"New item instance created\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onInstanced()\n    -- Set default data for new instances\n    if not self:getData(\"created\") then\n        self:setData(\"created\", os.time())\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onInstanced()\n    -- Initialize complex item state\n    self:setData(\"durability\", self:getData(\"maxDurability\", 100))\n    self:setData(\"serialNumber\", \"SN-\" .. self:getID())\n    -- Register with item tracking system\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[self:getID()] = {\n    uniqueID = self.uniqueID,\n    created = os.time(),\n    owner = self:getOwner() and self:getOwner():GetName() or \"unknown\"\n    }\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Apply category-specific initialization\n    if self.category == \"weapons\" then\n        self:setData(\"ammo\", self:getData(\"maxAmmo\", 30))\n        elseif self.category == \"armor\" then\n            self:setData(\"protection\", self:getData(\"maxProtection\", 50))\n        end\n    end\n</code></pre></p>"},{"location":"meta/item/#oninstanced_1","title":"onInstanced","text":"<p>Purpose</p> <p>Called when the item instance is first created</p> <p>When Called</p> <p>Automatically when item instances are created</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onInstanced()\n    print(\"New item instance created\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onInstanced()\n    -- Set default data for new instances\n    if not self:getData(\"created\") then\n        self:setData(\"created\", os.time())\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onInstanced()\n    -- Initialize complex item state\n    self:setData(\"durability\", self:getData(\"maxDurability\", 100))\n    self:setData(\"serialNumber\", \"SN-\" .. self:getID())\n    -- Register with item tracking system\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[self:getID()] = {\n    uniqueID = self.uniqueID,\n    created = os.time(),\n    owner = self:getOwner() and self:getOwner():GetName() or \"unknown\"\n    }\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Apply category-specific initialization\n    if self.category == \"weapons\" then\n        self:setData(\"ammo\", self:getData(\"maxAmmo\", 30))\n        elseif self.category == \"armor\" then\n            self:setData(\"protection\", self:getData(\"maxProtection\", 50))\n        end\n    end\n</code></pre></p>"},{"location":"meta/item/#oninstanced_2","title":"onInstanced","text":"<p>Purpose</p> <p>Called when the item instance is first created</p> <p>When Called</p> <p>Automatically when item instances are created</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onInstanced()\n    print(\"New item instance created\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onInstanced()\n    -- Set default data for new instances\n    if not self:getData(\"created\") then\n        self:setData(\"created\", os.time())\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onInstanced()\n    -- Initialize complex item state\n    self:setData(\"durability\", self:getData(\"maxDurability\", 100))\n    self:setData(\"serialNumber\", \"SN-\" .. self:getID())\n    -- Register with item tracking system\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[self:getID()] = {\n    uniqueID = self.uniqueID,\n    created = os.time(),\n    owner = self:getOwner() and self:getOwner():GetName() or \"unknown\"\n    }\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Apply category-specific initialization\n    if self.category == \"weapons\" then\n        self:setData(\"ammo\", self:getData(\"maxAmmo\", 30))\n        elseif self.category == \"armor\" then\n            self:setData(\"protection\", self:getData(\"maxProtection\", 50))\n        end\n    end\n</code></pre></p>"},{"location":"meta/item/#oninstanced_3","title":"onInstanced","text":"<p>Purpose</p> <p>Called when the item instance is first created</p> <p>When Called</p> <p>Automatically when item instances are created</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onInstanced()\n    print(\"New item instance created\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onInstanced()\n    -- Set default data for new instances\n    if not self:getData(\"created\") then\n        self:setData(\"created\", os.time())\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onInstanced()\n    -- Initialize complex item state\n    self:setData(\"durability\", self:getData(\"maxDurability\", 100))\n    self:setData(\"serialNumber\", \"SN-\" .. self:getID())\n    -- Register with item tracking system\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[self:getID()] = {\n    uniqueID = self.uniqueID,\n    created = os.time(),\n    owner = self:getOwner() and self:getOwner():GetName() or \"unknown\"\n    }\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Apply category-specific initialization\n    if self.category == \"weapons\" then\n        self:setData(\"ammo\", self:getData(\"maxAmmo\", 30))\n        elseif self.category == \"armor\" then\n            self:setData(\"protection\", self:getData(\"maxProtection\", 50))\n        end\n    end\n</code></pre></p>"},{"location":"meta/item/#onsync","title":"onSync","text":"<p>Purpose</p> <p>Called when the item is synchronized to clients</p> <p>When Called</p> <p>Automatically when item data is sent to clients</p> <p>Parameters</p> <ul> <li><code>recipient</code> (unknown): Optional specific client to sync to</li> <li><code>recipient</code> (unknown): Optional specific client to sync to</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Custom sync logic\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Send additional data to specific client\n    if recipient then\n        net.Start(\"CustomItemData\")\n        net.WriteType(self:getID())\n        net.WriteTable(self:getAllData())\n        net.Send(recipient)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Advanced sync with filtering\n    local dataToSend = {}\n    -- Only send sensitive data to item owner\n    if recipient == self:getOwner() then\n        dataToSend = self:getAllData()\n        else\n            -- Filter out sensitive data for other players\n            for key, value in pairs(self:getAllData()) do\n                if not self.sensitiveDataKeys[key] then\n                    dataToSend[key] = value\n                end\n            end\n        end\n        -- Send filtered data\n        net.Start(\"FilteredItemData\")\n        net.WriteType(self:getID())\n        net.WriteTable(dataToSend)\n        net.Send(recipient)\n    end\n</code></pre></p>"},{"location":"meta/item/#onsync_1","title":"onSync","text":"<p>Purpose</p> <p>Called when the item is synchronized to clients</p> <p>When Called</p> <p>Automatically when item data is sent to clients</p> <p>Parameters</p> <ul> <li><code>recipient</code> (unknown): Optional specific client to sync to</li> <li><code>recipient</code> (unknown): Optional specific client to sync to</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Custom sync logic\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Send additional data to specific client\n    if recipient then\n        net.Start(\"CustomItemData\")\n        net.WriteType(self:getID())\n        net.WriteTable(self:getAllData())\n        net.Send(recipient)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Advanced sync with filtering\n    local dataToSend = {}\n    -- Only send sensitive data to item owner\n    if recipient == self:getOwner() then\n        dataToSend = self:getAllData()\n        else\n            -- Filter out sensitive data for other players\n            for key, value in pairs(self:getAllData()) do\n                if not self.sensitiveDataKeys[key] then\n                    dataToSend[key] = value\n                end\n            end\n        end\n        -- Send filtered data\n        net.Start(\"FilteredItemData\")\n        net.WriteType(self:getID())\n        net.WriteTable(dataToSend)\n        net.Send(recipient)\n    end\n</code></pre></p>"},{"location":"meta/item/#onsync_2","title":"onSync","text":"<p>Purpose</p> <p>Called when the item is synchronized to clients</p> <p>When Called</p> <p>Automatically when item data is sent to clients</p> <p>Parameters</p> <ul> <li><code>recipient</code> (unknown): Optional specific client to sync to</li> <li><code>recipient</code> (unknown): Optional specific client to sync to</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Custom sync logic\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Send additional data to specific client\n    if recipient then\n        net.Start(\"CustomItemData\")\n        net.WriteType(self:getID())\n        net.WriteTable(self:getAllData())\n        net.Send(recipient)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Advanced sync with filtering\n    local dataToSend = {}\n    -- Only send sensitive data to item owner\n    if recipient == self:getOwner() then\n        dataToSend = self:getAllData()\n        else\n            -- Filter out sensitive data for other players\n            for key, value in pairs(self:getAllData()) do\n                if not self.sensitiveDataKeys[key] then\n                    dataToSend[key] = value\n                end\n            end\n        end\n        -- Send filtered data\n        net.Start(\"FilteredItemData\")\n        net.WriteType(self:getID())\n        net.WriteTable(dataToSend)\n        net.Send(recipient)\n    end\n</code></pre></p>"},{"location":"meta/item/#onsync_3","title":"onSync","text":"<p>Purpose</p> <p>Called when the item is synchronized to clients</p> <p>When Called</p> <p>Automatically when item data is sent to clients</p> <p>Parameters</p> <ul> <li><code>recipient</code> (unknown): Optional specific client to sync to</li> <li><code>recipient</code> (unknown): Optional specific client to sync to</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Custom sync logic\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Send additional data to specific client\n    if recipient then\n        net.Start(\"CustomItemData\")\n        net.WriteType(self:getID())\n        net.WriteTable(self:getAllData())\n        net.Send(recipient)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onSync(recipient)\n    -- Advanced sync with filtering\n    local dataToSend = {}\n    -- Only send sensitive data to item owner\n    if recipient == self:getOwner() then\n        dataToSend = self:getAllData()\n        else\n            -- Filter out sensitive data for other players\n            for key, value in pairs(self:getAllData()) do\n                if not self.sensitiveDataKeys[key] then\n                    dataToSend[key] = value\n                end\n            end\n        end\n        -- Send filtered data\n        net.Start(\"FilteredItemData\")\n        net.WriteType(self:getID())\n        net.WriteTable(dataToSend)\n        net.Send(recipient)\n    end\n</code></pre></p>"},{"location":"meta/item/#onremoved","title":"onRemoved","text":"<p>Purpose</p> <p>Called when the item is permanently removed from the system</p> <p>When Called</p> <p>Automatically when delete() completes</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRemoved()\n    print(\"Item permanently removed\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRemoved()\n    -- Clean up references\n    lia.data.delete(\"item_\" .. self:getID())\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRemoved()\n    -- Comprehensive cleanup\n    local itemID = self:getID()\n    -- Remove from tracking systems\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[itemID] = nil\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Remove from category lists\n    if self.category then\n        local categoryItems = lia.data.get(\"category_items_\" .. self.category, {})\n        categoryItems[itemID] = nil\n        lia.data.set(\"category_items_\" .. self.category, categoryItems)\n    end\n    -- Log permanent removal\n    lia.log.add(nil, \"item_permanently_removed\", itemID, self.uniqueID)\n    -- Notify administrators of rare item removal\n    if self:getData(\"rarity\") == \"legendary\" then\n        lia.chat.send(lia.util.getAdmins(), \"Legendary item permanently removed: \" .. self:getName())\n    end\nend\n</code></pre></p>"},{"location":"meta/item/#onremoved_1","title":"onRemoved","text":"<p>Purpose</p> <p>Called when the item is permanently removed from the system</p> <p>When Called</p> <p>Automatically when delete() completes</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRemoved()\n    print(\"Item permanently removed\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRemoved()\n    -- Clean up references\n    lia.data.delete(\"item_\" .. self:getID())\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRemoved()\n    -- Comprehensive cleanup\n    local itemID = self:getID()\n    -- Remove from tracking systems\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[itemID] = nil\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Remove from category lists\n    if self.category then\n        local categoryItems = lia.data.get(\"category_items_\" .. self.category, {})\n        categoryItems[itemID] = nil\n        lia.data.set(\"category_items_\" .. self.category, categoryItems)\n    end\n    -- Log permanent removal\n    lia.log.add(nil, \"item_permanently_removed\", itemID, self.uniqueID)\n    -- Notify administrators of rare item removal\n    if self:getData(\"rarity\") == \"legendary\" then\n        lia.chat.send(lia.util.getAdmins(), \"Legendary item permanently removed: \" .. self:getName())\n    end\nend\n</code></pre></p>"},{"location":"meta/item/#onremoved_2","title":"onRemoved","text":"<p>Purpose</p> <p>Called when the item is permanently removed from the system</p> <p>When Called</p> <p>Automatically when delete() completes</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRemoved()\n    print(\"Item permanently removed\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRemoved()\n    -- Clean up references\n    lia.data.delete(\"item_\" .. self:getID())\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRemoved()\n    -- Comprehensive cleanup\n    local itemID = self:getID()\n    -- Remove from tracking systems\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[itemID] = nil\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Remove from category lists\n    if self.category then\n        local categoryItems = lia.data.get(\"category_items_\" .. self.category, {})\n        categoryItems[itemID] = nil\n        lia.data.set(\"category_items_\" .. self.category, categoryItems)\n    end\n    -- Log permanent removal\n    lia.log.add(nil, \"item_permanently_removed\", itemID, self.uniqueID)\n    -- Notify administrators of rare item removal\n    if self:getData(\"rarity\") == \"legendary\" then\n        lia.chat.send(lia.util.getAdmins(), \"Legendary item permanently removed: \" .. self:getName())\n    end\nend\n</code></pre></p>"},{"location":"meta/item/#onremoved_3","title":"onRemoved","text":"<p>Purpose</p> <p>Called when the item is permanently removed from the system</p> <p>When Called</p> <p>Automatically when delete() completes</p> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRemoved()\n    print(\"Item permanently removed\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRemoved()\n    -- Clean up references\n    lia.data.delete(\"item_\" .. self:getID())\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRemoved()\n    -- Comprehensive cleanup\n    local itemID = self:getID()\n    -- Remove from tracking systems\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[itemID] = nil\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Remove from category lists\n    if self.category then\n        local categoryItems = lia.data.get(\"category_items_\" .. self.category, {})\n        categoryItems[itemID] = nil\n        lia.data.set(\"category_items_\" .. self.category, categoryItems)\n    end\n    -- Log permanent removal\n    lia.log.add(nil, \"item_permanently_removed\", itemID, self.uniqueID)\n    -- Notify administrators of rare item removal\n    if self:getData(\"rarity\") == \"legendary\" then\n        lia.chat.send(lia.util.getAdmins(), \"Legendary item permanently removed: \" .. self:getName())\n    end\nend\n</code></pre></p>"},{"location":"meta/item/#onrestored","title":"onRestored","text":"<p>Purpose</p> <p>Called when the item is loaded from the database</p> <p>When Called</p> <p>Automatically when item data is restored from storage</p> <p>Parameters</p> <ul> <li><code>inventory</code> (unknown): The inventory this item belongs to</li> <li><code>inventory</code> (unknown): The inventory this item belongs to</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRestored(inventory)\n    print(\"Item restored from database\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRestored(inventory)\n    -- Validate restored data\n    if self:getData(\"durability\") and self:getData(\"durability\") &lt; 0 then\n        self:setData(\"durability\", 0)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRestored(inventory)\n    -- Comprehensive restoration logic\n    local itemID = self:getID()\n    -- Restore complex relationships\n    self:restoreOwnershipLinks()\n    self:restoreEnchantments()\n    self:validateDataIntegrity()\n    -- Update tracking systems\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[itemID].restored = os.time()\n    trackingData[itemID].inventory = inventory:getID()\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Apply restoration effects\n    if self:getData(\"temporary\") then\n        local expiryTime = self:getData(\"expiryTime\")\n        if expiryTime and expiryTime &lt; os.time() then\n            -- Item has expired, schedule removal\n            timer.Simple(0, function()\n            if IsValid(self) then\n                self:remove()\n                lia.log.add(nil, \"expired_item_removed_on_restore\", itemID)\n            end\n        end)\n    end\nend\n-- Trigger restoration hooks\nhook.Run(\"OnItemRestored\", self, inventory)\nend\n</code></pre></p>"},{"location":"meta/item/#onrestored_1","title":"onRestored","text":"<p>Purpose</p> <p>Called when the item is loaded from the database</p> <p>When Called</p> <p>Automatically when item data is restored from storage</p> <p>Parameters</p> <ul> <li><code>inventory</code> (unknown): The inventory this item belongs to</li> <li><code>inventory</code> (unknown): The inventory this item belongs to</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRestored(inventory)\n    print(\"Item restored from database\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRestored(inventory)\n    -- Validate restored data\n    if self:getData(\"durability\") and self:getData(\"durability\") &lt; 0 then\n        self:setData(\"durability\", 0)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRestored(inventory)\n    -- Comprehensive restoration logic\n    local itemID = self:getID()\n    -- Restore complex relationships\n    self:restoreOwnershipLinks()\n    self:restoreEnchantments()\n    self:validateDataIntegrity()\n    -- Update tracking systems\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[itemID].restored = os.time()\n    trackingData[itemID].inventory = inventory:getID()\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Apply restoration effects\n    if self:getData(\"temporary\") then\n        local expiryTime = self:getData(\"expiryTime\")\n        if expiryTime and expiryTime &lt; os.time() then\n            -- Item has expired, schedule removal\n            timer.Simple(0, function()\n            if IsValid(self) then\n                self:remove()\n                lia.log.add(nil, \"expired_item_removed_on_restore\", itemID)\n            end\n        end)\n    end\nend\n-- Trigger restoration hooks\nhook.Run(\"OnItemRestored\", self, inventory)\nend\n</code></pre></p>"},{"location":"meta/item/#onrestored_2","title":"onRestored","text":"<p>Purpose</p> <p>Called when the item is loaded from the database</p> <p>When Called</p> <p>Automatically when item data is restored from storage</p> <p>Parameters</p> <ul> <li><code>inventory</code> (unknown): The inventory this item belongs to</li> <li><code>inventory</code> (unknown): The inventory this item belongs to</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRestored(inventory)\n    print(\"Item restored from database\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRestored(inventory)\n    -- Validate restored data\n    if self:getData(\"durability\") and self:getData(\"durability\") &lt; 0 then\n        self:setData(\"durability\", 0)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRestored(inventory)\n    -- Comprehensive restoration logic\n    local itemID = self:getID()\n    -- Restore complex relationships\n    self:restoreOwnershipLinks()\n    self:restoreEnchantments()\n    self:validateDataIntegrity()\n    -- Update tracking systems\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[itemID].restored = os.time()\n    trackingData[itemID].inventory = inventory:getID()\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Apply restoration effects\n    if self:getData(\"temporary\") then\n        local expiryTime = self:getData(\"expiryTime\")\n        if expiryTime and expiryTime &lt; os.time() then\n            -- Item has expired, schedule removal\n            timer.Simple(0, function()\n            if IsValid(self) then\n                self:remove()\n                lia.log.add(nil, \"expired_item_removed_on_restore\", itemID)\n            end\n        end)\n    end\nend\n-- Trigger restoration hooks\nhook.Run(\"OnItemRestored\", self, inventory)\nend\n</code></pre></p>"},{"location":"meta/item/#onrestored_3","title":"onRestored","text":"<p>Purpose</p> <p>Called when the item is loaded from the database</p> <p>When Called</p> <p>Automatically when item data is restored from storage</p> <p>Parameters</p> <ul> <li><code>inventory</code> (unknown): The inventory this item belongs to</li> <li><code>inventory</code> (unknown): The inventory this item belongs to</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>function ITEM:onRestored(inventory)\n    print(\"Item restored from database\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>function ITEM:onRestored(inventory)\n    -- Validate restored data\n    if self:getData(\"durability\") and self:getData(\"durability\") &lt; 0 then\n        self:setData(\"durability\", 0)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>function ITEM:onRestored(inventory)\n    -- Comprehensive restoration logic\n    local itemID = self:getID()\n    -- Restore complex relationships\n    self:restoreOwnershipLinks()\n    self:restoreEnchantments()\n    self:validateDataIntegrity()\n    -- Update tracking systems\n    local trackingData = lia.data.get(\"item_tracking\", {})\n    trackingData[itemID].restored = os.time()\n    trackingData[itemID].inventory = inventory:getID()\n    lia.data.set(\"item_tracking\", trackingData)\n    -- Apply restoration effects\n    if self:getData(\"temporary\") then\n        local expiryTime = self:getData(\"expiryTime\")\n        if expiryTime and expiryTime &lt; os.time() then\n            -- Item has expired, schedule removal\n            timer.Simple(0, function()\n            if IsValid(self) then\n                self:remove()\n                lia.log.add(nil, \"expired_item_removed_on_restore\", itemID)\n            end\n        end)\n    end\nend\n-- Trigger restoration hooks\nhook.Run(\"OnItemRestored\", self, inventory)\nend\n</code></pre></p>"},{"location":"meta/item/#sync","title":"sync","text":"<p>Purpose</p> <p>Synchronizes item instance data to clients</p> <p>When Called</p> <p>When item data needs to be sent to clients</p> <p>Parameters</p> <ul> <li><code>recipient</code> (unknown): Optional specific client to sync to, broadcasts if nil</li> <li><code>recipient</code> (unknown): Optional specific client to sync to, broadcasts if nil</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:sync()\n</code></pre></p> <p>Medium Complexity: <pre><code>item:sync(specificPlayer)\n</code></pre></p> <p>High Complexity: <pre><code>local function syncItemToGroup(item, players)\n    -- Send different data based on player permissions\n    for _, player in ipairs(players) do\n        if player:canAccessItem(item) then\n            item:sync(player)\n            else\n                -- Send limited data\n                net.Start(\"liaItemLimited\")\n                net.WriteUInt(item:getID(), 32)\n                net.WriteString(item:getName())\n                net.Send(player)\n            end\n        end\n    end\n    syncItemToGroup(myItem, nearbyPlayers)\n</code></pre></p>"},{"location":"meta/item/#setdata","title":"setData","text":"<p>Purpose</p> <p>Sets item data and synchronizes changes to clients and database</p> <p>When Called</p> <p>When item data needs to be updated and persisted</p> <p>Parameters</p> <ul> <li><code>key</code> (unknown): The data key to set</li> <li><code>key</code> (unknown): The data key to set</li> <li><code>value</code> (unknown): The value to set</li> <li><code>value</code> (unknown): The value to set</li> <li><code>receivers</code> (unknown): Optional specific clients to notify</li> <li><code>receivers</code> (unknown): Optional specific clients to notify</li> <li><code>noSave</code> (unknown): Optional boolean to skip database saving</li> <li><code>noSave</code> (unknown): Optional boolean to skip database saving</li> <li><code>noCheckEntity</code> (unknown): Optional boolean to skip entity data sync</li> <li><code>noCheckEntity</code> (unknown): Optional boolean to skip entity data sync</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:setData(\"durability\", 50)\n</code></pre></p> <p>Medium Complexity: <pre><code>item:setData(\"owner\", player:GetName())\nitem:setData(\"acquired\", os.time())\n</code></pre></p> <p>High Complexity: <pre><code>local function applyDamageToItem(item, damage)\n    local currentDurability = item:getData(\"durability\", 100)\n    local newDurability = math.max(0, currentDurability - damage)\n    -- Set durability and sync to all players\n    item:setData(\"durability\", newDurability)\n    -- If item is broken, apply broken effects\n    if newDurability == 0 then\n        item:setData(\"broken\", true)\n        item:setData(\"repairCost\", item:getData(\"baseRepairCost\", 100) * 2)\n        -- Notify owner\n        local owner = item:getOwner()\n        if owner then\n            owner:notify(\"Your \" .. item:getName() .. \" has broken!\")\n        end\n    end\n    -- Log damage\n    lia.log.add(nil, \"item_damaged\", item:getID(), damage, newDurability)\nend\napplyDamageToItem(myItem, 25)\n</code></pre></p>"},{"location":"meta/item/#addquantity","title":"addQuantity","text":"<p>Purpose</p> <p>Adds to the item's quantity and synchronizes the change</p> <p>When Called</p> <p>When increasing item stack size</p> <p>Parameters</p> <ul> <li><code>quantity</code> (unknown): Amount to add to the quantity</li> <li><code>quantity</code> (unknown): Amount to add to the quantity</li> <li><code>receivers</code> (unknown): Optional specific clients to notify</li> <li><code>receivers</code> (unknown): Optional specific clients to notify</li> <li><code>noCheckEntity</code> (unknown): Optional boolean to skip entity sync</li> <li><code>noCheckEntity</code> (unknown): Optional boolean to skip entity sync</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:addQuantity(5)\n</code></pre></p> <p>Medium Complexity: <pre><code>item:addQuantity(1, player) -- Notify specific player\n</code></pre></p> <p>High Complexity: <pre><code>local function combineStacks(item1, item2)\n    if item1.uniqueID == item2.uniqueID then\n        local combinedQuantity = item1:getQuantity() + item2:getQuantity()\n        local maxStack = item1.maxQuantity or 1\n        if combinedQuantity &lt;= maxStack then\n            -- Combine into one stack\n            item1:setQuantity(combinedQuantity)\n            item2:remove()\n            return true, \"Items combined successfully\"\n            else\n                -- Fill first stack and adjust second\n                local overflow = combinedQuantity - maxStack\n                item1:setQuantity(maxStack)\n                item2:setQuantity(overflow)\n                return true, \"Items partially combined\"\n            end\n        end\n        return false, \"Items cannot be combined\"\n    end\n    local success, message = combineStacks(stack1, stack2)\n</code></pre></p>"},{"location":"meta/item/#setquantity","title":"setQuantity","text":"<p>Purpose</p> <p>Sets the item's quantity and synchronizes the change</p> <p>When Called</p> <p>When changing item stack size or count</p> <p>Parameters</p> <ul> <li><code>quantity</code> (unknown): New quantity value</li> <li><code>quantity</code> (unknown): New quantity value</li> <li><code>receivers</code> (unknown): Optional specific clients to notify</li> <li><code>receivers</code> (unknown): Optional specific clients to notify</li> <li><code>noCheckEntity</code> (unknown): Optional boolean to skip entity sync</li> <li><code>noCheckEntity</code> (unknown): Optional boolean to skip entity sync</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:setQuantity(10)\n</code></pre></p> <p>Medium Complexity: <pre><code>item:setQuantity(0) -- Remove all items from stack\n</code></pre></p> <p>High Complexity: <pre><code>local function splitStack(item, splitAmount)\n    local currentQuantity = item:getQuantity()\n    if splitAmount &gt;= currentQuantity then\n        return false, \"Cannot split more than available\"\n    end\n    -- Create new item instance\n    local newItem = lia.item.new(item.uniqueID, 1)\n    newItem:setQuantity(splitAmount)\n    newItem:setData(\"splitFrom\", item:getID())\n    -- Reduce original stack\n    item:setQuantity(currentQuantity - splitAmount)\n    -- Add new stack to same inventory\n    local inventory = lia.inventory.instances[item.invID]\n    if inventory then\n        inventory:add(newItem)\n        return true, newItem\n    end\n    return false, \"Failed to add split item to inventory\"\nend\nlocal success, newStack = splitStack(myItem, 5)\n</code></pre></p>"},{"location":"meta/item/#interact","title":"interact","text":"<p>Purpose</p> <p>Handles player interaction with items (use, drop, etc.)</p> <p>When Called</p> <p>When a player attempts to interact with an item</p> <p>Parameters</p> <ul> <li><code>action</code> (unknown): The interaction action (e.g., \"use\", \"drop\")</li> <li><code>action</code> (unknown): The interaction action (e.g., \"use\", \"drop\")</li> <li><code>client</code> (unknown): The player performing the action</li> <li><code>client</code> (unknown): The player performing the action</li> <li><code>entity</code> (unknown): Optional entity involved in the interaction</li> <li><code>entity</code> (unknown): Optional entity involved in the interaction</li> <li><code>data</code> (unknown): Optional additional data for the interaction</li> <li><code>data</code> (unknown): Optional additional data for the interaction</li> </ul> <p>Returns</p> <ul> <li>Boolean indicating if the interaction was successful</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>item:interact(\"use\", player)\n</code></pre></p> <p>Medium Complexity: <pre><code>item:interact(\"drop\", player, nil, {position = dropPos})\n</code></pre></p> <p>High Complexity: <pre><code>local function handleComplexInteraction(item, action, player, entity, data)\n    -- Pre-interaction validation\n    if action == \"use\" and item:getData(\"cooldown\") then\n        local lastUsed = item:getData(\"lastUsed\", 0)\n        if CurTime() - lastUsed &lt; item:getData(\"cooldown\") then\n            player:notifyError(\"Item is on cooldown\")\n            return false\n        end\n    end\n    -- Perform interaction\n    local success = item:interact(action, player, entity, data)\n    if success then\n        -- Post-interaction effects\n        if action == \"use\" then\n            item:setData(\"lastUsed\", CurTime())\n            item:setData(\"uses\", item:getData(\"uses\", 0) + 1)\n            -- Check for breakage\n            if item:getData(\"uses\") &gt;= item:getData(\"maxUses\", 100) then\n                player:notify(\"Your \" .. item:getName() .. \" has broken!\")\n                item:setData(\"broken\", true)\n            end\n        end\n        -- Log the interaction\n        lia.log.add(player, \"item_interaction\", action, item:getID(), item:getName())\n    end\n    return success\nend\nlocal success = handleComplexInteraction(myItem, \"use\", player)\n</code></pre></p>"},{"location":"meta/item/#getcategory","title":"getCategory","text":"<p>Purpose</p> <p>Gets the localized category name for the item</p> <p>When Called</p> <p>When displaying or organizing items by category</p> <p>Returns</p> <ul> <li>String representing the localized category name</li> </ul> <p>Realm</p> <p>Both</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>local category = item:getCategory()\n</code></pre></p> <p>Medium Complexity: <pre><code>if item:getCategory() == \"weapons\" then\n    -- Handle weapon-specific logic\nend\n</code></pre></p> <p>High Complexity: <pre><code>local function organizeItemsByCategory(items)\n    local categories = {}\n    for _, item in ipairs(items) do\n        local category = item:getCategory()\n        categories[category] = categories[category] or {}\n        table.insert(categories[category], item)\n    end\n    -- Sort categories alphabetically\n    local sortedCategories = {}\n    for categoryName, categoryItems in pairs(categories) do\n        table.insert(sortedCategories, {\n        name = categoryName,\n        items = categoryItems,\n        count = #categoryItems\n        })\n    end\n    table.sort(sortedCategories, function(a, b) return a.name &lt; b.name end)\n    return sortedCategories\nend\nlocal organizedItems = organizeItemsByCategory(playerInventory:getItems())\n</code></pre></p>"},{"location":"meta/panel/","title":"Panel Meta","text":"<p>Panel management system for the Lilia framework.</p> <p>Overview</p> <p>The panel meta table provides comprehensive functionality for managing VGUI panels, UI interactions, and panel operations in the Lilia framework. It handles panel event listening, inventory synchronization, UI updates, and panel-specific operations. The meta table operates primarily on the client side, with the server providing data that panels can listen to and display. It includes integration with the inventory system for inventory change notifications, character system for character data display, network system for data synchronization, and UI system for panel management. The meta table ensures proper panel event handling, inventory synchronization, UI updates, and comprehensive panel lifecycle management from creation to destruction.</p>"},{"location":"meta/panel/#lialistenforinventorychanges","title":"liaListenForInventoryChanges","text":"<p>Purpose</p> <p>Sets up event listeners for inventory changes on a panel</p> <p>When Called</p> <p>When a UI panel needs to respond to inventory modifications, typically during panel initialization</p> <p>Parameters</p> <ul> <li><code>inventory</code> (unknown): The inventory object to listen for changes on</li> <li><code>inventory</code> (unknown): The inventory object to listen for changes on</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set up inventory listening for a basic panel\npanel:liaListenForInventoryChanges(playerInventory)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set up inventory listening with conditional setup\nif playerInventory then\n    characterPanel:liaListenForInventoryChanges(playerInventory)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Set up inventory listening for multiple panels with error handling\nlocal panels = {inventoryPanel, characterPanel, equipmentPanel}\nfor _, pnl in ipairs(panels) do\n    if IsValid(pnl) and playerInventory then\n        pnl:liaListenForInventoryChanges(playerInventory)\n    end\nend\n</code></pre></p>"},{"location":"meta/panel/#liadeleteinventoryhooks","title":"liaDeleteInventoryHooks","text":"<p>Purpose</p> <p>Removes inventory change event listeners from a panel</p> <p>When Called</p> <p>When a panel no longer needs to listen to inventory changes, during cleanup, or when switching inventories</p> <p>Parameters</p> <ul> <li><code>id</code> (optional): The specific inventory ID to remove hooks for, or nil to remove all hooks</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove hooks for a specific inventory\npanel:liaDeleteInventoryHooks(inventoryID)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clean up hooks when closing a panel\nif IsValid(panel) then\n    panel:liaDeleteInventoryHooks()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Clean up multiple panels with different inventory IDs\nlocal panels = {inventoryPanel, equipmentPanel, storagePanel}\nlocal inventoryIDs = {playerInvID, equipmentInvID, storageInvID}\nfor i, pnl in ipairs(panels) do\n    if IsValid(pnl) then\n        pnl:liaDeleteInventoryHooks(inventoryIDs[i])\n    end\nend\n</code></pre></p>"},{"location":"meta/panel/#setscaledpos","title":"setScaledPos","text":"<p>Purpose</p> <p>Sets the position of a panel with automatic screen scaling</p> <p>When Called</p> <p>When positioning UI elements that need to adapt to different screen resolutions</p> <p>Parameters</p> <ul> <li><code>x</code> (unknown): The horizontal position value to be scaled</li> <li><code>x</code> (unknown): The horizontal position value to be scaled</li> <li><code>y</code> (unknown): The vertical position value to be scaled</li> <li><code>y</code> (unknown): The vertical position value to be scaled</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Position a button at scaled coordinates\nbutton:setScaledPos(100, 50)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Position panel based on screen dimensions\nlocal x = ScrW() * 0.5 - 200\nlocal y = ScrH() * 0.3\npanel:setScaledPos(x, y)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Position multiple panels with responsive layout\nlocal panels = {mainPanel, sidePanel, footerPanel}\nlocal positions = {\n{ScrW() * 0.1, ScrH() * 0.1},\n{ScrW() * 0.7, ScrH() * 0.1},\n{ScrW() * 0.1, ScrH() * 0.8}\n}\nfor i, pnl in ipairs(panels) do\n    if IsValid(pnl) then\n        pnl:setScaledPos(positions[i][1], positions[i][2])\n    end\nend\n</code></pre></p>"},{"location":"meta/panel/#setscaledsize","title":"setScaledSize","text":"<p>Purpose</p> <p>Sets the size of a panel with automatic screen scaling</p> <p>When Called</p> <p>When sizing UI elements that need to adapt to different screen resolutions</p> <p>Parameters</p> <ul> <li><code>w</code> (unknown): The width value to be scaled</li> <li><code>w</code> (unknown): The width value to be scaled</li> <li><code>h</code> (unknown): The height value to be scaled</li> <li><code>h</code> (unknown): The height value to be scaled</li> </ul> <p>Returns</p> <ul> <li>Nothing</li> </ul> <p>Realm</p> <p>Client</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set panel size with scaled dimensions\npanel:setScaledSize(400, 300)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set size based on screen proportions\nlocal w = ScrW() * 0.8\nlocal h = ScrH() * 0.6\npanel:setScaledSize(w, h)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Set sizes for multiple panels with responsive layout\nlocal panels = {mainPanel, sidePanel, footerPanel}\nlocal sizes = {\n{ScrW() * 0.7, ScrH() * 0.6},\n{ScrW() * 0.25, ScrH() * 0.6},\n{ScrW() * 0.95, ScrH() * 0.1}\n}\nfor i, pnl in ipairs(panels) do\n    if IsValid(pnl) then\n        pnl:setScaledSize(sizes[i][1], sizes[i][2])\n    end\nend\n</code></pre></p>"},{"location":"meta/player/","title":"Player Meta","text":"<p>Player management system for the Lilia framework.</p> <p>Overview</p> <p>The player meta table provides comprehensive functionality for managing player data, interactions, and operations in the Lilia framework. It handles player character access, notification systems, permission checking, data management, interaction systems, and player-specific operations. The meta table operates on both server and client sides, with the server managing player data and validation while the client provides player interaction and display. It includes integration with the character system for character access, notification system for player messages, permission system for access control, data system for player persistence, and interaction system for player actions. The meta table ensures proper player data synchronization, permission validation, notification delivery, and comprehensive player management from connection to disconnection.</p>"},{"location":"meta/player/#getchar","title":"getChar","text":"<p>Purpose</p> <p>Retrieves the player's current character object</p> <p>When Called</p> <p>When accessing the player's character data or performing character-related operations</p> <p>Returns</p> <ul> <li>table|nil - The character object if player has a character, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player's character\nlocal char = player:getChar()\nif char then\n    print(\"Player has character:\", char:getName())\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check character and access properties\nlocal char = player:getChar()\nif char and char.getData then\n    local money = char:getData(\"money\", 0)\n    char:setData(\"money\", money + 100)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Full character validation and operations\nlocal char = player:getChar()\nif char and char.getInventory and char.getData then\n    local inventory = char:getInventory()\n    local faction = char:getData(\"faction\", \"citizen\")\n    if inventory and faction ~= \"citizen\" then\n        inventory:add(\"weapon_pistol\", 1)\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#tostring","title":"tostring","text":"<p>Purpose</p> <p>Retrieves the player's current character object</p> <p>When Called</p> <p>When accessing the player's character data or performing character-related operations</p> <p>Returns</p> <ul> <li>table|nil - The character object if player has a character, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player's character\nlocal char = player:getChar()\nif char then\n    print(\"Player has character:\", char:getName())\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check character and access properties\nlocal char = player:getChar()\nif char and char.getData then\n    local money = char:getData(\"money\", 0)\n    char:setData(\"money\", money + 100)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Full character validation and operations\nlocal char = player:getChar()\nif char and char.getInventory and char.getData then\n    local inventory = char:getInventory()\n    local faction = char:getData(\"faction\", \"citizen\")\n    if inventory and faction ~= \"citizen\" then\n        inventory:add(\"weapon_pistol\", 1)\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#name","title":"Name","text":"<p>Purpose</p> <p>Converts the player to a string representation using character name or Steam name</p> <p>When Called</p> <p>When converting player to string for display, logging, or comparison purposes</p> <p>Returns</p> <ul> <li>string - The player's character name if available, otherwise their Steam name</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Convert player to string for display\nlocal playerName = player:tostring()\nprint(\"Player name:\", playerName)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use in logging with fallback\nlocal playerName = player:tostring()\nlia.log.add(\"Player \" .. playerName .. \" performed action\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Use in complex display logic with validation\nlocal playerName = player:tostring()\nif playerName and playerName ~= \"\" then\n    local displayText = string.format(\"[%s] %s\", player:SteamID(), playerName)\n    chat.AddText(Color(255, 255, 255), displayText)\nend\n</code></pre></p>"},{"location":"meta/player/#dogesture","title":"doGesture","text":"<p>Purpose</p> <p>Makes the player perform a gesture animation and synchronizes it across clients</p> <p>When Called</p> <p>When triggering player animations for roleplay, emotes, or visual effects</p> <p>Parameters</p> <ul> <li><code>a</code> (number): Gesture slot (0-15)</li> <li><code>b</code> (number): Gesture weight (0-255)</li> <li><code>c</code> (boolean): Whether to restart the gesture</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Make player wave\nplayer:doGesture(ACT_GMOD_GESTURE_WAVE, 1, true)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional gesture based on player state\nif player:IsOnGround() then\n    player:doGesture(ACT_GMOD_GESTURE_BOW, 2, true)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex gesture system with validation\nlocal gesture = ACT_GMOD_GESTURE_AGREE\nlocal weight = math.Clamp(emotionLevel, 1, 5)\nlocal restart = not player:IsPlayingGesture(gesture)\nif player:Alive() and not player:InVehicle() then\n    player:doGesture(gesture, weight, restart)\nend\n</code></pre></p>"},{"location":"meta/player/#hasprivilege","title":"hasPrivilege","text":"<p>Purpose</p> <p>Checks if the player has a specific administrative privilege</p> <p>When Called</p> <p>When validating player permissions for commands, features, or access control</p> <p>Parameters</p> <ul> <li><code>privilegeName</code> (string): The name of the privilege to check</li> </ul> <p>Returns</p> <ul> <li>boolean - True if player has the privilege, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player is admin\nif player:hasPrivilege(\"admin\") then\n    print(\"Player is an admin\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional access based on privilege\nif player:hasPrivilege(\"moderator\") then\n    player:SetHealth(100)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex permission system with multiple checks\nlocal requiredPrivs = {\"admin\", \"superadmin\"}\nlocal hasAccess = false\nfor _, priv in ipairs(requiredPrivs) do\n    if player:hasPrivilege(priv) then\n        hasAccess = true\n        break\n    end\nend\nif hasAccess then\n    -- Grant special access\nend\n</code></pre></p>"},{"location":"meta/player/#removeragdoll","title":"removeRagdoll","text":"<p>Purpose</p> <p>Removes the player's ragdoll entity and clears associated blur effect</p> <p>When Called</p> <p>When cleaning up player ragdoll after respawn, revival, or state changes</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Remove player's ragdoll\nplayer:removeRagdoll()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Remove ragdoll with validation\nif player:getNetVar(\"ragdoll\") then\n    player:removeRagdoll()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ragdoll cleanup with state management\nlocal ragdoll = player:getNetVar(\"ragdoll\")\nif IsValid(ragdoll) and ragdoll:GetCreationTime() &lt; CurTime() - 5 then\n    player:removeRagdoll()\n    player:setNetVar(\"deathTime\", nil)\nend\n</code></pre></p>"},{"location":"meta/player/#isstuck","title":"isStuck","text":"<p>Purpose</p> <p>Checks if the player is stuck inside a solid object or wall</p> <p>When Called</p> <p>When detecting collision issues, implementing anti-stuck systems, or validating player position</p> <p>Returns</p> <ul> <li>boolean - True if player is stuck, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player is stuck\nif player:isStuck() then\n    print(\"Player is stuck!\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Handle stuck player with teleport\nif player:isStuck() then\n    player:SetPos(Vector(0, 0, 0))\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex stuck detection with logging and recovery\nif player:isStuck() then\n    local oldPos = player:GetPos()\n    player:SetPos(player:GetPos() + Vector(0, 0, 50))\n    if player:isStuck() then\n        player:SetPos(Vector(0, 0, 0))\n        lia.log.add(\"Player \" .. player:Name() .. \" was stuck and teleported\")\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#isnearplayer","title":"isNearPlayer","text":"<p>Purpose</p> <p>Checks if the player is within a specified radius of another entity</p> <p>When Called</p> <p>When implementing proximity-based features, interaction systems, or distance validation</p> <p>Parameters</p> <ul> <li><code>radius</code> (number): The maximum distance to check</li> <li><code>entity</code> (Entity): The entity to check distance against</li> </ul> <p>Returns</p> <ul> <li>boolean - True if player is within radius, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player is near another player\nif player:isNearPlayer(100, otherPlayer) then\n    print(\"Players are close!\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Proximity-based interaction\nlocal npc = ents.FindByClass(\"npc_citizen\")[1]\nif player:isNearPlayer(50, npc) then\n    player:notify(\"Press E to talk to NPC\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex proximity system with multiple entities\nlocal nearbyEntities = {}\nfor _, ent in ipairs(ents.FindInSphere(player:GetPos(), 200)) do\n    if player:isNearPlayer(100, ent) and ent:IsPlayer() then\n        table.insert(nearbyEntities, ent)\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#entitiesnearplayer","title":"entitiesNearPlayer","text":"<p>Purpose</p> <p>Gets all entities within a specified radius of the player</p> <p>When Called</p> <p>When implementing area-of-effect systems, proximity detection, or entity scanning</p> <p>Parameters</p> <ul> <li><code>radius</code> (number): The radius to search within</li> <li><code>playerOnly</code> (boolean, optional): If true, only returns player entities</li> </ul> <p>Returns</p> <ul> <li>table - Array of entities within the radius</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all nearby entities\nlocal nearby = player:entitiesNearPlayer(100)\nprint(\"Found \" .. #nearby .. \" entities nearby\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get only nearby players\nlocal nearbyPlayers = player:entitiesNearPlayer(150, true)\nfor _, ply in ipairs(nearbyPlayers) do\n    ply:notify(\"You are near \" .. player:Name())\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex entity filtering and processing\nlocal nearby = player:entitiesNearPlayer(200, false)\nlocal weapons = {}\nfor _, ent in ipairs(nearby) do\n    if ent:IsWeapon() and ent:GetOwner() == player then\n        table.insert(weapons, ent)\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#getitemweapon","title":"getItemWeapon","text":"<p>Purpose</p> <p>Gets the weapon entity and corresponding item data for the player's active weapon</p> <p>When Called</p> <p>When accessing weapon properties, validating equipped items, or implementing weapon systems</p> <p>Returns</p> <ul> <li>weapon (Entity|nil), item (table|nil) - The weapon entity and item data if found</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player's active weapon item\nlocal weapon, item = player:getItemWeapon()\nif weapon then\n    print(\"Player has weapon:\", weapon:GetClass())\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check weapon and modify properties\nlocal weapon, item = player:getItemWeapon()\nif weapon and item then\n    local durability = item:getData(\"durability\", 100)\n    if durability &lt; 50 then\n        player:notify(\"Weapon is damaged!\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex weapon system with inventory management\nlocal weapon, item = player:getItemWeapon()\nif weapon and item then\n    local ammo = item:getData(\"ammo\", 0)\n    local maxAmmo = item:getData(\"maxAmmo\", 30)\n    if ammo &lt; maxAmmo * 0.1 then\n        item:setData(\"ammo\", maxAmmo)\n        player:notify(\"Weapon reloaded!\")\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#isrunning","title":"isRunning","text":"<p>Purpose</p> <p>Checks if the player is currently running (moving faster than walk speed)</p> <p>When Called</p> <p>When implementing movement-based features, stamina systems, or speed validation</p> <p>Returns</p> <ul> <li>boolean - True if player is running, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player is running\nif player:isRunning() then\n    print(\"Player is running!\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Running-based stamina system\nif player:isRunning() then\n    local stamina = player:getData(\"stamina\", 100)\n    player:setData(\"stamina\", math.max(0, stamina - 1))\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex movement system with effects\nif player:isRunning() then\n    local speed = player:GetVelocity():Length2D()\n    local maxSpeed = player:GetRunSpeed()\n    local speedRatio = speed / maxSpeed\n    if speedRatio &gt; 0.8 then\n        player:setNetVar(\"exhausted\", true)\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#isfamilysharedaccount","title":"isFamilySharedAccount","text":"<p>Purpose</p> <p>Checks if the player is using a family shared Steam account</p> <p>When Called</p> <p>When implementing account validation, anti-cheat systems, or account restrictions</p> <p>Returns</p> <ul> <li>boolean - True if player is using family shared account, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if account is family shared\nif player:isFamilySharedAccount() then\n    print(\"Player is using family shared account\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Restrict features for family shared accounts\nif player:isFamilySharedAccount() then\n    player:notify(\"Some features are restricted for family shared accounts\")\n    return false\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex account validation with logging\nif player:isFamilySharedAccount() then\n    local ownerID = util.SteamIDFrom64(player:OwnerSteamID64())\n    lia.log.add(\"Family shared account detected: \" .. player:SteamID() .. \" (Owner: \" .. ownerID .. \")\")\n    player:setData(\"isFamilyShared\", true)\nend\n</code></pre></p>"},{"location":"meta/player/#getitemdroppos","title":"getItemDropPos","text":"<p>Purpose</p> <p>Calculates the position where items should be dropped in front of the player</p> <p>When Called</p> <p>When implementing item dropping, inventory management, or item placement systems</p> <p>Returns</p> <ul> <li>Vector - The calculated drop position</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get drop position for item\nlocal dropPos = player:getItemDropPos()\nlocal item = ents.Create(\"lia_item\")\nitem:SetPos(dropPos)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Drop item with validation\nlocal dropPos = player:getItemDropPos()\nif dropPos and dropPos:Distance(player:GetPos()) &lt; 100 then\n    local item = lia.item.create(\"weapon_pistol\", 1)\n    item:spawn(dropPos)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex item dropping with physics and effects\nlocal dropPos = player:getItemDropPos()\nlocal item = lia.item.create(\"weapon_pistol\", 1)\nitem:spawn(dropPos)\nlocal phys = item:GetPhysicsObject()\nif IsValid(phys) then\n    phys:SetVelocity(player:GetAimVector() * 100)\nend\n</code></pre></p>"},{"location":"meta/player/#getitems","title":"getItems","text":"<p>Purpose</p> <p>Gets all items from the player's character inventory</p> <p>When Called</p> <p>When accessing player inventory, implementing item systems, or inventory management</p> <p>Returns</p> <ul> <li>table|nil - Array of items in the player's inventory, nil if no character</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player's items\nlocal items = player:getItems()\nif items then\n    print(\"Player has \" .. #items .. \" items\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Search for specific items\nlocal items = player:getItems()\nif items then\n    for _, item in ipairs(items) do\n        if item.uniqueID == \"weapon_pistol\" then\n            print(\"Player has a pistol!\")\n        end\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex inventory analysis and management\nlocal items = player:getItems()\nif items then\n    local weaponCount = 0\n    local totalValue = 0\n    for _, item in ipairs(items) do\n        if item.isWeapon then\n            weaponCount = weaponCount + 1\n        end\n        totalValue = totalValue + (item:getData(\"value\", 0))\n    end\n    player:notify(\"Weapons: \" .. weaponCount .. \", Total Value: $\" .. totalValue)\nend\n</code></pre></p>"},{"location":"meta/player/#gettracedentity","title":"getTracedEntity","text":"<p>Purpose</p> <p>Gets the entity that the player is looking at within a specified distance</p> <p>When Called</p> <p>When implementing interaction systems, targeting, or line-of-sight detection</p> <p>Parameters</p> <ul> <li><code>distance</code> (number, optional): Maximum trace distance (default: 96)</li> </ul> <p>Returns</p> <ul> <li>Entity|nil - The traced entity if found, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get what player is looking at\nlocal ent = player:getTracedEntity()\nif IsValid(ent) then\n    print(\"Player is looking at:\", ent:GetClass())\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Interaction with traced entity\nlocal ent = player:getTracedEntity(150)\nif IsValid(ent) and ent:IsPlayer() then\n    player:notify(\"Looking at player: \" .. ent:Name())\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex interaction system with validation\nlocal ent = player:getTracedEntity(200)\nif IsValid(ent) then\n    local distance = player:GetPos():Distance(ent:GetPos())\n    if distance &lt; 100 and ent:GetClass() == \"lia_item\" then\n        local item = ent:getItem()\n        if item then\n            player:notify(\"Item: \" .. item:getName() .. \" (Value: $\" .. item:getData(\"value\", 0) .. \")\")\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#gettrace","title":"getTrace","text":"<p>Purpose</p> <p>Performs a hull trace from the player's position to detect collisions and surfaces</p> <p>When Called</p> <p>When implementing collision detection, surface analysis, or spatial queries</p> <p>Parameters</p> <ul> <li><code>distance</code> (number, optional): Maximum trace distance (default: 200)</li> </ul> <p>Returns</p> <ul> <li>table - Trace result containing hit information, position, and entity data</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check what's in front of player\nlocal trace = player:getTrace()\nif trace.Hit then\n    print(\"Hit something at:\", trace.HitPos)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Surface detection and interaction\nlocal trace = player:getTrace(150)\nif trace.Hit and trace.HitWorld then\n    player:notify(\"Looking at world surface\")\n    elseif trace.Hit and IsValid(trace.Entity) then\n        player:notify(\"Looking at: \" .. trace.Entity:GetClass())\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex spatial analysis with physics\nlocal trace = player:getTrace(300)\nif trace.Hit then\n    local hitPos = trace.HitPos\n    local hitNormal = trace.HitNormal\n    local distance = trace.Fraction * 300\n    if IsValid(trace.Entity) then\n        local phys = trace.Entity:GetPhysicsObject()\n        if IsValid(phys) then\n            phys:ApplyForceCenter(hitNormal * 1000)\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#geteyeent","title":"getEyeEnt","text":"<p>Purpose</p> <p>Gets the entity that the player is looking at within a specified distance using eye trace</p> <p>When Called</p> <p>When implementing precise targeting, interaction systems, or line-of-sight detection</p> <p>Parameters</p> <ul> <li><code>distance</code> (number, optional): Maximum distance to check (default: 150)</li> </ul> <p>Returns</p> <ul> <li>Entity|nil - The entity if within distance, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get entity player is looking at\nlocal ent = player:getEyeEnt()\nif IsValid(ent) then\n    print(\"Looking at:\", ent:GetClass())\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Distance-based interaction\nlocal ent = player:getEyeEnt(100)\nif IsValid(ent) and ent:IsPlayer() then\n    player:notify(\"Looking at player: \" .. ent:Name())\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex targeting system with validation\nlocal ent = player:getEyeEnt(200)\nif IsValid(ent) then\n    local distance = ent:GetPos():Distance(player:GetPos())\n    if distance &lt;= 150 and ent:GetClass() == \"lia_item\" then\n        local item = ent:getItem()\n        if item and item:getData(\"interactable\", true) then\n            player:notify(\"Press E to interact with \" .. item:getName())\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#notify","title":"notify","text":"<p>Purpose</p> <p>Sends a notification message to the player</p> <p>When Called</p> <p>When displaying messages, alerts, or status updates to the player</p> <p>Parameters</p> <ul> <li><code>message</code> (string): The message to display</li> <li><code>notifType</code> (string, optional): The type of notification (default: \"default\")</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send basic notification\nplayer:notify(\"Hello, player!\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send typed notification\nplayer:notify(\"You found a weapon!\", \"success\")\nplayer:notify(\"Health is low!\", \"warning\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex notification system with conditions\nlocal health = player:Health()\nif health &lt; 25 then\n    player:notify(\"Critical health! Seek medical attention!\", \"error\")\n    elseif health &lt; 50 then\n        player:notify(\"Health is low\", \"warning\")\n        else\n            player:notify(\"Health is good\", \"success\")\n        end\n</code></pre></p>"},{"location":"meta/player/#notifylocalized","title":"notifyLocalized","text":"<p>Purpose</p> <p>Sends a localized notification message to the player with string formatting</p> <p>When Called</p> <p>When displaying translated messages, alerts, or status updates to the player</p> <p>Parameters</p> <ul> <li><code>message</code> (string): The localization key for the message</li> <li><code>notifType</code> (string, optional): The type of notification (default: \"default\")</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send localized notification\nplayer:notifyLocalized(\"welcome_message\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send localized notification with formatting\nplayer:notifySuccessLocalized(\"item_found\")\nplayer:notifyWarningLocalized(\"health_low\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex localized notification system\nlocal itemName = item:getName()\nlocal itemValue = item:getData(\"value\", 0)\nlocal currency = lia.currency.get(\"money\")\nplayer:notifySuccessLocalized(\"item_sold\")\n</code></pre></p>"},{"location":"meta/player/#notifyerror","title":"notifyError","text":"<p>Purpose</p> <p>Sends an error notification message to the player</p> <p>When Called</p> <p>When displaying error messages, failures, or critical alerts to the player</p> <p>Parameters</p> <ul> <li><code>message</code> (string): The error message to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send error notification\nplayer:notifyError(\"Something went wrong!\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send error with context\nif not player:hasPrivilege(\"admin\") then\n    player:notifyError(\"You don't have permission to do that!\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex error handling with logging\nlocal success, err = pcall(function()\n-- Some risky operation\nplayer:SetHealth(100)\nend)\nif not success then\n    player:notifyError(\"Failed to heal player: \" .. tostring(err))\n    lia.log.add(\"Heal error for \" .. player:Name() .. \": \" .. tostring(err))\nend\n</code></pre></p>"},{"location":"meta/player/#notifywarning","title":"notifyWarning","text":"<p>Purpose</p> <p>Sends a warning notification message to the player</p> <p>When Called</p> <p>When displaying warning messages, cautions, or important alerts to the player</p> <p>Parameters</p> <ul> <li><code>message</code> (string): The warning message to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send warning notification\nplayer:notifyWarning(\"Be careful!\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send warning with condition\nif player:Health() &lt; 25 then\n    player:notifyWarning(\"Health is critically low!\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex warning system with multiple conditions\nlocal health = player:Health()\nlocal armor = player:Armor()\nif health &lt; 50 and armor &lt; 25 then\n    player:notifyWarning(\"You are vulnerable! Health: \" .. health .. \", Armor: \" .. armor)\n    elseif health &lt; 25 then\n        player:notifyWarning(\"Critical health! Seek medical attention immediately!\")\n    end\n</code></pre></p>"},{"location":"meta/player/#notifyinfo","title":"notifyInfo","text":"<p>Purpose</p> <p>Sends an informational notification message to the player</p> <p>When Called</p> <p>When displaying informational messages, tips, or general updates to the player</p> <p>Parameters</p> <ul> <li><code>message</code> (string): The informational message to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send info notification\nplayer:notifyInfo(\"Welcome to the server!\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send info with context\nplayer:notifyInfo(\"You have \" .. player:GetAmmoCount(\"Pistol\") .. \" pistol rounds\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex info system with data\nlocal char = player:getChar()\nif char then\n    local money = char:getData(\"money\", 0)\n    local level = char:getData(\"level\", 1)\n    player:notifyInfo(\"Level \" .. level .. \" | Money: $\" .. money)\nend\n</code></pre></p>"},{"location":"meta/player/#notifysuccess","title":"notifySuccess","text":"<p>Purpose</p> <p>Sends a success notification message to the player</p> <p>When Called</p> <p>When displaying success messages, achievements, or positive feedback to the player</p> <p>Parameters</p> <ul> <li><code>message</code> (string): The success message to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send success notification\nplayer:notifySuccess(\"Task completed!\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send success with context\nplayer:notifySuccess(\"You earned $\" .. amount .. \"!\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex success system with rewards\nlocal char = player:getChar()\nif char then\n    local exp = char:getData(\"experience\", 0)\n    local newExp = exp + 100\n    char:setData(\"experience\", newExp)\n    player:notifySuccess(\"Gained 100 XP! Total: \" .. newExp)\nend\n</code></pre></p>"},{"location":"meta/player/#notifymoney","title":"notifyMoney","text":"<p>Purpose</p> <p>Sends a money-related notification message to the player</p> <p>When Called</p> <p>When displaying financial transactions, currency changes, or economic updates to the player</p> <p>Parameters</p> <ul> <li><code>message</code> (string): The money-related message to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send money notification\nplayer:notifyMoney(\"You received $100!\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send money notification with context\nlocal amount = 500\nplayer:notifyMoney(\"Payment received: $\" .. amount)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex money system with character data\nlocal char = player:getChar()\nif char then\n    local oldMoney = char:getData(\"money\", 0)\n    local newMoney = oldMoney + amount\n    char:setData(\"money\", newMoney)\n    player:notifyMoney(\"Balance updated: $\" .. oldMoney .. \" \u2192 $\" .. newMoney)\nend\n</code></pre></p>"},{"location":"meta/player/#notifyadmin","title":"notifyAdmin","text":"<p>Purpose</p> <p>Sends an admin notification message to the player</p> <p>When Called</p> <p>When displaying administrative messages, system alerts, or admin-specific information to the player</p> <p>Parameters</p> <ul> <li><code>message</code> (string): The admin message to display</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send admin notification\nplayer:notifyAdmin(\"Admin command executed!\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send admin notification with context\nplayer:notifyAdmin(\"Player \" .. target:Name() .. \" has been banned\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex admin system with logging\nlocal adminName = player:Name()\nlocal targetName = target:Name()\nlocal reason = \"Cheating\"\nplayer:notifyAdmin(\"Banned \" .. targetName .. \" for: \" .. reason)\nlia.log.add(\"Admin \" .. adminName .. \" banned \" .. targetName .. \" for: \" .. reason)\n</code></pre></p>"},{"location":"meta/player/#notifyerrorlocalized","title":"notifyErrorLocalized","text":"<p>Purpose</p> <p>Sends a localized error notification message to the player with string formatting</p> <p>When Called</p> <p>When displaying translated error messages, failures, or critical alerts to the player</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The localization key for the error message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send localized error notification\nplayer:notifyErrorLocalized(\"error_generic\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send localized error with formatting\nplayer:notifyErrorLocalized(\"error_permission_denied\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex localized error system with context\nlocal char = player:getChar()\nif not char then\n    player:notifyErrorLocalized(\"error_no_character\")\n    else\n        local money = char:getData(\"money\", 0)\n        local required = 1000\n        if money &lt; required then\n            player:notifyErrorLocalized(\"error_insufficient_funds\")\n        end\n    end\n</code></pre></p>"},{"location":"meta/player/#notifywarninglocalized","title":"notifyWarningLocalized","text":"<p>Purpose</p> <p>Sends a localized warning notification message to the player with string formatting</p> <p>When Called</p> <p>When displaying translated warning messages, cautions, or important alerts to the player</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The localization key for the warning message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send localized warning notification\nplayer:notifyWarningLocalized(\"warning_generic\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send localized warning with formatting\nplayer:notifyWarningLocalized(\"warning_health_low\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex localized warning system with conditions\nlocal char = player:getChar()\nif char then\n    local health = player:Health()\n    local armor = player:Armor()\n    if health &lt; 25 then\n        player:notifyWarningLocalized(\"warning_critical_health\")\n        elseif health &lt; 50 and armor &lt; 25 then\n            player:notifyWarningLocalized(\"warning_vulnerable\")\n        end\n    end\n</code></pre></p>"},{"location":"meta/player/#notifyinfolocalized","title":"notifyInfoLocalized","text":"<p>Purpose</p> <p>Sends a localized informational notification message to the player with string formatting</p> <p>When Called</p> <p>When displaying translated informational messages, tips, or general updates to the player</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The localization key for the informational message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send localized info notification\nplayer:notifyInfoLocalized(\"info_welcome\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send localized info with formatting\nplayer:notifyInfoLocalized(\"info_ammo_count\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex localized info system with character data\nlocal char = player:getChar()\nif char then\n    local money = char:getData(\"money\", 0)\n    local level = char:getData(\"level\", 1)\n    player:notifyInfoLocalized(\"info_character_stats\")\nend\n</code></pre></p>"},{"location":"meta/player/#notifysuccesslocalized","title":"notifySuccessLocalized","text":"<p>Purpose</p> <p>Sends a localized success notification message to the player with string formatting</p> <p>When Called</p> <p>When displaying translated success messages, achievements, or positive feedback to the player</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The localization key for the success message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send localized success notification\nplayer:notifySuccessLocalized(\"success_task_completed\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send localized success with formatting\nplayer:notifySuccessLocalized(\"success_money_earned\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex localized success system with rewards\nlocal char = player:getChar()\nif char then\n    local exp = char:getData(\"experience\", 0)\n    local newExp = exp + 100\n    char:setData(\"experience\", newExp)\n    player:notifySuccessLocalized(\"success_experience_gained\")\nend\n</code></pre></p>"},{"location":"meta/player/#notifymoneylocalized","title":"notifyMoneyLocalized","text":"<p>Purpose</p> <p>Sends a localized money-related notification message to the player with string formatting</p> <p>When Called</p> <p>When displaying translated financial transactions, currency changes, or economic updates to the player</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The localization key for the money-related message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send localized money notification\nplayer:notifyMoneyLocalized(\"money_received\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send localized money notification with formatting\nplayer:notifyMoneyLocalized(\"money_payment_received\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex localized money system with character data\nlocal char = player:getChar()\nif char then\n    local oldMoney = char:getData(\"money\", 0)\n    local newMoney = oldMoney + amount\n    char:setData(\"money\", newMoney)\n    player:notifyMoneyLocalized(\"money_balance_updated\")\nend\n</code></pre></p>"},{"location":"meta/player/#notifyadminlocalized","title":"notifyAdminLocalized","text":"<p>Purpose</p> <p>Sends a localized admin notification message to the player with string formatting</p> <p>When Called</p> <p>When displaying translated administrative messages, system alerts, or admin-specific information to the player</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The localization key for the admin message</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Send localized admin notification\nplayer:notifyAdminLocalized(\"admin_command_executed\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Send localized admin notification with formatting\nplayer:notifyAdminLocalized(\"admin_player_banned\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex localized admin system with logging\nlocal adminName = player:Name()\nlocal targetName = target:Name()\nlocal reason = \"Cheating\"\nplayer:notifyAdminLocalized(\"admin_ban_executed\")\nlia.log.add(\"Admin \" .. adminName .. \" banned \" .. targetName .. \" for: \" .. reason)\n</code></pre></p>"},{"location":"meta/player/#caneditvendor","title":"canEditVendor","text":"<p>Purpose</p> <p>Checks if the player can edit a specific vendor entity</p> <p>When Called</p> <p>When validating vendor editing permissions, implementing vendor management systems, or access control</p> <p>Parameters</p> <ul> <li><code>vendor</code> (Entity): The vendor entity to check edit permissions for</li> </ul> <p>Returns</p> <ul> <li>boolean - True if player can edit the vendor, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player can edit vendor\nif player:canEditVendor(vendor) then\n    print(\"Player can edit this vendor\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional vendor editing with feedback\nif player:canEditVendor(vendor) then\n    player:notify(\"You can edit this vendor\")\n    else\n        player:notifyError(\"You don't have permission to edit this vendor\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex vendor system with logging and validation\nif player:canEditVendor(vendor) then\n    local vendorData = vendor:getData(\"vendorData\", {})\n    if vendorData.owner == player:SteamID() or player:hasPrivilege(\"admin\") then\n        -- Allow editing\n        player:notifySuccess(\"Vendor edit access granted\")\n        else\n            player:notifyError(\"You don't own this vendor\")\n        end\n    end\n</code></pre></p>"},{"location":"meta/player/#isstaff","title":"isStaff","text":"<p>Purpose</p> <p>Checks if the player is a staff member based on their user group</p> <p>When Called</p> <p>When validating staff permissions, implementing staff-only features, or access control systems</p> <p>Returns</p> <ul> <li>boolean - True if player is staff, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player is staff\nif player:isStaff() then\n    print(\"Player is staff\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Staff-only feature access\nif player:isStaff() then\n    player:notify(\"Welcome, staff member!\")\n    else\n        player:notifyError(\"This feature is for staff only\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex staff system with different levels\nif player:isStaff() then\n    local userGroup = player:GetUserGroup()\n    if userGroup == \"superadmin\" then\n        player:notify(\"Full admin access granted\")\n        elseif userGroup == \"admin\" then\n            player:notify(\"Admin access granted\")\n            else\n                player:notify(\"Staff access granted\")\n            end\n        end\n</code></pre></p>"},{"location":"meta/player/#isvip","title":"isVIP","text":"<p>Purpose</p> <p>Checks if the player is a VIP member based on their user group</p> <p>When Called</p> <p>When validating VIP permissions, implementing VIP-only features, or access control systems</p> <p>Returns</p> <ul> <li>boolean - True if player is VIP, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player is VIP\nif player:isVIP() then\n    print(\"Player is VIP\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: VIP-only feature access\nif player:isVIP() then\n    player:notify(\"Welcome, VIP member!\")\n    else\n        player:notifyError(\"This feature is for VIP members only\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex VIP system with benefits\nif player:isVIP() then\n    local char = player:getChar()\n    if char then\n        local money = char:getData(\"money\", 0)\n        local vipBonus = money * 0.1\n        char:setData(\"money\", money + vipBonus)\n        player:notifySuccess(\"VIP bonus: +$\" .. vipBonus)\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#isstaffonduty","title":"isStaffOnDuty","text":"<p>Purpose</p> <p>Checks if the player is currently on duty as staff (in staff faction)</p> <p>When Called</p> <p>When validating active staff status, implementing duty-based features, or staff management systems</p> <p>Returns</p> <ul> <li>boolean - True if player is on duty as staff, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player is on duty\nif player:isStaffOnDuty() then\n    print(\"Player is on duty as staff\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Duty-based feature access\nif player:isStaffOnDuty() then\n    player:notify(\"Staff tools available\")\n    else\n        player:notifyError(\"You must be on duty to use this\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex duty system with logging and management\nif player:isStaffOnDuty() then\n    local dutyTime = player:getData(\"dutyStartTime\", 0)\n    local currentTime = os.time()\n    local dutyDuration = currentTime - dutyTime\n    player:notifyInfo(\"On duty for \" .. math.floor(dutyDuration / 60) .. \" minutes\")\n    else\n        player:notify(\"You are not currently on duty\")\n    end\n</code></pre></p>"},{"location":"meta/player/#haswhitelist","title":"hasWhitelist","text":"<p>Purpose</p> <p>Checks if the player has whitelist access to a specific faction</p> <p>When Called</p> <p>When validating faction access, implementing whitelist systems, or character creation restrictions</p> <p>Parameters</p> <ul> <li><code>faction</code> (string): The faction unique ID to check whitelist for</li> </ul> <p>Returns</p> <ul> <li>boolean - True if player has whitelist access, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player has whitelist\nif player:hasWhitelist(\"police\") then\n    print(\"Player can join police faction\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Faction selection with whitelist check\nif player:hasWhitelist(\"police\") then\n    player:notify(\"You can join the police faction\")\n    else\n        player:notifyError(\"You don't have whitelist for police faction\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex whitelist system with multiple checks\nlocal faction = \"police\"\nif player:hasWhitelist(faction) then\n    local factionData = lia.faction.indices[faction]\n    if factionData and not factionData.isDefault then\n        player:notifySuccess(\"Whitelist access granted for \" .. factionData.name)\n    end\n    else\n        player:notifyError(\"Whitelist required for \" .. faction)\n    end\n</code></pre></p>"},{"location":"meta/player/#getclassdata","title":"getClassData","text":"<p>Purpose</p> <p>Gets the class data for the player's current character class</p> <p>When Called</p> <p>When accessing character class information, implementing class-based features, or character management</p> <p>Returns</p> <ul> <li>table|nil - The class data table if character has a class, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player's class data\nlocal classData = player:getClassData()\nif classData then\n    print(\"Player class:\", classData.name)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use class data for features\nlocal classData = player:getClassData()\nif classData then\n    player:notify(\"Class: \" .. classData.name .. \" - \" .. classData.description)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex class system with abilities and restrictions\nlocal classData = player:getClassData()\nif classData then\n    local abilities = classData.abilities or {}\n    local restrictions = classData.restrictions or {}\n    player:notifyInfo(\"Class: \" .. classData.name)\n    if #abilities &gt; 0 then\n        player:notifyInfo(\"Abilities: \" .. table.concat(abilities, \", \"))\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#getdarkrpvar","title":"getDarkRPVar","text":"<p>Purpose</p> <p>Gets DarkRP-compatible variable values for the player (currently only supports money)</p> <p>When Called</p> <p>When implementing DarkRP compatibility, accessing player money, or legacy system integration</p> <p>Parameters</p> <ul> <li><code>var</code> (string): The variable name to get (currently only \"money\" is supported)</li> </ul> <p>Returns</p> <ul> <li>number|nil - The money amount if var is \"money\", nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player money via DarkRP compatibility\nlocal money = player:getDarkRPVar(\"money\")\nif money then\n    print(\"Player has $\" .. money)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use DarkRP var for compatibility\nlocal money = player:getDarkRPVar(\"money\")\nif money and money &gt; 1000 then\n    player:notify(\"You have enough money for this purchase\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex DarkRP compatibility system\nlocal var = \"money\"\nlocal value = player:getDarkRPVar(var)\nif value then\n    local char = player:getChar()\n    if char then\n        local actualMoney = char:getMoney()\n        if value == actualMoney then\n            player:notifyInfo(\"DarkRP compatibility: $\" .. value)\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#getmoney","title":"getMoney","text":"<p>Purpose</p> <p>Gets the player's current money amount from their character</p> <p>When Called</p> <p>When accessing player money, implementing economic systems, or financial transactions</p> <p>Returns</p> <ul> <li>number - The player's money amount (0 if no character)</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player money\nlocal money = player:getMoney()\nprint(\"Player has $\" .. money)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check if player can afford something\nlocal cost = 1000\nlocal money = player:getMoney()\nif money &gt;= cost then\n    player:notify(\"You can afford this purchase!\")\n    else\n        player:notifyError(\"You need $\" .. (cost - money) .. \" more\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex economic system with multiple currencies\nlocal money = player:getMoney()\nlocal char = player:getChar()\nif char then\n    local bankMoney = char:getData(\"bankMoney\", 0)\n    local totalWealth = money + bankMoney\n    player:notifyInfo(\"Cash: $\" .. money .. \" | Bank: $\" .. bankMoney .. \" | Total: $\" .. totalWealth)\nend\n</code></pre></p>"},{"location":"meta/player/#canafford","title":"canAfford","text":"<p>Purpose</p> <p>Checks if the player can afford a specific amount of money</p> <p>When Called</p> <p>When validating purchases, implementing economic systems, or checking financial capacity</p> <p>Parameters</p> <ul> <li><code>amount</code> (number): The amount of money to check if player can afford</li> </ul> <p>Returns</p> <ul> <li>boolean - True if player can afford the amount, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player can afford something\nif player:canAfford(1000) then\n    print(\"Player can afford $1000\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Purchase validation with feedback\nlocal cost = 500\nif player:canAfford(cost) then\n    player:notify(\"You can afford this purchase!\")\n    else\n        player:notifyError(\"You need $\" .. (cost - player:getMoney()) .. \" more\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex economic system with multiple checks\nlocal cost = 1000\nif player:canAfford(cost) then\n    local char = player:getChar()\n    if char then\n        local currentMoney = char:getMoney()\n        local remaining = currentMoney - cost\n        player:notifySuccess(\"Purchase successful! Remaining: $\" .. remaining)\n    end\n    else\n        player:notifyError(\"Insufficient funds for this purchase\")\n    end\n</code></pre></p>"},{"location":"meta/player/#hasskilllevel","title":"hasSkillLevel","text":"<p>Purpose</p> <p>Checks if the player has a specific skill level or higher</p> <p>When Called</p> <p>When validating skill requirements, implementing skill-based features, or character progression systems</p> <p>Parameters</p> <ul> <li><code>skill</code> (string): The skill name to check</li> <li><code>level</code> (number): The minimum skill level required</li> </ul> <p>Returns</p> <ul> <li>boolean - True if player has the required skill level, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player has skill level\nif player:hasSkillLevel(\"strength\", 5) then\n    print(\"Player has strength level 5 or higher\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Skill-based feature access\nif player:hasSkillLevel(\"engineering\", 10) then\n    player:notify(\"You can use advanced engineering tools\")\n    else\n        player:notifyError(\"You need engineering level 10 for this\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex skill system with multiple requirements\nlocal requiredSkills = {\n{skill = \"strength\", level = 5},\n{skill = \"intelligence\", level = 8}\n}\nlocal canUse = true\nfor _, req in ipairs(requiredSkills) do\n    if not player:hasSkillLevel(req.skill, req.level) then\n        canUse = false\n        player:notifyError(\"Need \" .. req.skill .. \" level \" .. req.level)\n    end\nend\nif canUse then\n    player:notifySuccess(\"All skill requirements met!\")\nend\n</code></pre></p>"},{"location":"meta/player/#meetsrequiredskills","title":"meetsRequiredSkills","text":"<p>Purpose</p> <p>Checks if the player meets all required skill levels for a task or feature</p> <p>When Called</p> <p>When validating complex skill requirements, implementing multi-skill features, or character progression systems</p> <p>Parameters</p> <ul> <li><code>requiredSkillLevels</code> (table): Table of skill names and required levels {skill = level, ...}</li> </ul> <p>Returns</p> <ul> <li>boolean - True if player meets all requirements, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check multiple skill requirements\nlocal requirements = {strength = 5, intelligence = 3}\nif player:meetsRequiredSkills(requirements) then\n    print(\"Player meets all skill requirements\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Complex feature with multiple skill checks\nlocal requirements = {engineering = 10, strength = 8, intelligence = 6}\nif player:meetsRequiredSkills(requirements) then\n    player:notify(\"You can use the advanced workshop!\")\n    else\n        player:notifyError(\"You don't meet the skill requirements\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Dynamic skill system with detailed feedback\nlocal requirements = {engineering = 10, strength = 8, intelligence = 6}\nif player:meetsRequiredSkills(requirements) then\n    player:notifySuccess(\"All skill requirements met!\")\n    else\n        local missing = {}\n        for skill, level in pairs(requirements) do\n            if not player:hasSkillLevel(skill, level) then\n                table.insert(missing, skill .. \"(\" .. level .. \")\")\n            end\n        end\n        player:notifyError(\"Missing skills: \" .. table.concat(missing, \", \"))\n    end\n</code></pre></p>"},{"location":"meta/player/#forcesequence","title":"forceSequence","text":"<p>Purpose</p> <p>Forces the player to play a specific animation sequence with optional callback</p> <p>When Called</p> <p>When implementing cutscenes, animations, or scripted sequences for the player</p> <p>Parameters</p> <ul> <li><code>sequenceName</code> (string): The name of the animation sequence to play</li> <li><code>callback</code> (function, optional): Function to call when sequence completes</li> <li><code>time</code> (number, optional): Duration of the sequence (default: sequence duration)</li> <li><code>noFreeze</code> (boolean, optional): Whether to freeze the player during sequence</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Play animation sequence\nplayer:forceSequence(\"sit\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Play sequence with callback\nplayer:forceSequence(\"wave\", function()\nplayer:notify(\"Animation completed!\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex sequence system with timing and effects\nlocal sequenceName = \"salute\"\nlocal duration = 3.0\nlocal callback = function()\nplayer:notifySuccess(\"Salute completed!\")\nplayer:setData(\"lastSalute\", os.time())\nend\nplayer:forceSequence(sequenceName, callback, duration, false)\n</code></pre></p>"},{"location":"meta/player/#leavesequence","title":"leaveSequence","text":"<p>Purpose</p> <p>Makes the player leave their current animation sequence and restore normal movement</p> <p>When Called</p> <p>When ending cutscenes, animations, or scripted sequences for the player</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: End animation sequence\nplayer:leaveSequence()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: End sequence with notification\nplayer:leaveSequence()\nplayer:notify(\"Animation sequence ended\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex sequence management with cleanup\nplayer:leaveSequence()\nplayer:notifySuccess(\"Sequence completed!\")\nplayer:setData(\"lastSequence\", os.time())\n-- Clean up any sequence-related data\nplayer:setData(\"sequenceActive\", false)\n</code></pre></p>"},{"location":"meta/player/#getflags","title":"getFlags","text":"<p>Purpose</p> <p>Gets the player's character flags string</p> <p>When Called</p> <p>When accessing character flags, implementing flag-based features, or character management</p> <p>Returns</p> <ul> <li>string - The character flags string (empty if no character)</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player flags\nlocal flags = player:getFlags()\nprint(\"Player flags:\", flags)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check for specific flags\nlocal flags = player:getFlags()\nif string.find(flags, \"a\") then\n    player:notify(\"You have admin flags\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex flag system with multiple checks\nlocal flags = player:getFlags()\nlocal flagList = {}\nfor i = 1, #flags do\n    local flag = string.sub(flags, i, i)\n    table.insert(flagList, flag)\nend\nplayer:notifyInfo(\"Your flags: \" .. table.concat(flagList, \", \"))\n</code></pre></p>"},{"location":"meta/player/#giveflags","title":"giveFlags","text":"<p>Purpose</p> <p>Gives flags to the player's character</p> <p>When Called</p> <p>When granting character flags, implementing flag-based permissions, or character management</p> <p>Parameters</p> <ul> <li><code>flags</code> (string): The flags to give to the character</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Give flags to player\nplayer:giveFlags(\"a\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Give flags with validation\nif player:hasPrivilege(\"admin\") then\n    player:giveFlags(\"a\")\n    player:notify(\"Admin flags granted!\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex flag system with logging\nlocal flags = \"a\"\nlocal char = player:getChar()\nif char then\n    local oldFlags = char:getFlags()\n    char:giveFlags(flags)\n    local newFlags = char:getFlags()\n    player:notifySuccess(\"Flags updated: \" .. oldFlags .. \" \u2192 \" .. newFlags)\n    lia.log.add(\"Player \" .. player:Name() .. \" received flags: \" .. flags)\nend\n</code></pre></p>"},{"location":"meta/player/#takeflags","title":"takeFlags","text":"<p>Purpose</p> <p>Takes flags from the player's character</p> <p>When Called</p> <p>When removing character flags, implementing flag-based permissions, or character management</p> <p>Parameters</p> <ul> <li><code>flags</code> (string): The flags to take from the character</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Take flags from player\nplayer:takeFlags(\"a\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Take flags with validation\nif player:hasPrivilege(\"admin\") then\n    player:takeFlags(\"a\")\n    player:notify(\"Admin flags removed!\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex flag system with logging\nlocal flags = \"a\"\nlocal char = player:getChar()\nif char then\n    local oldFlags = char:getFlags()\n    char:takeFlags(flags)\n    local newFlags = char:getFlags()\n    player:notifyWarning(\"Flags updated: \" .. oldFlags .. \" \u2192 \" .. newFlags)\n    lia.log.add(\"Player \" .. player:Name() .. \" lost flags: \" .. flags)\nend\n</code></pre></p>"},{"location":"meta/player/#networkanimation","title":"networkAnimation","text":"<p>Purpose</p> <p>Networks bone animation data to all clients for the player</p> <p>When Called</p> <p>When implementing custom animations, bone manipulation, or visual effects for the player</p> <p>Parameters</p> <ul> <li><code>active</code> (boolean): Whether the animation is active</li> <li><code>boneData</code> (table): Table of bone names and angles {boneName = angle, ...}</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Network basic animation\nlocal boneData = {ValveBiped.Bip01_Head1 = Angle(0, 0, 0)}\nplayer:networkAnimation(true, boneData)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Network animation with multiple bones\nlocal boneData = {\nValveBiped.Bip01_Head1 = Angle(0, 0, 0),\nValveBiped.Bip01_Spine2 = Angle(0, 0, 0)\n}\nplayer:networkAnimation(true, boneData)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex animation system with timing\nlocal boneData = {\nValveBiped.Bip01_Head1 = Angle(0, 0, 0),\nValveBiped.Bip01_Spine2 = Angle(0, 0, 0),\nValveBiped.Bip01_L_Hand = Angle(0, 0, 0)\n}\nplayer:networkAnimation(true, boneData)\ntimer.Simple(5, function()\nif IsValid(player) then\n    player:networkAnimation(false, boneData)\nend\nend)\n</code></pre></p>"},{"location":"meta/player/#getallliliadata","title":"getAllLiliaData","text":"<p>Purpose</p> <p>Gets all Lilia data for the player (server-side) or local data (client-side)</p> <p>When Called</p> <p>When accessing player data storage, implementing data management, or debugging systems</p> <p>Returns</p> <ul> <li>table - The player's Lilia data table</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get all player data\nlocal data = player:getAllLiliaData()\nprint(\"Player data keys:\", table.GetKeys(data))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Access specific data with validation\nlocal data = player:getAllLiliaData()\nif data.settings then\n    player:notify(\"Settings loaded: \" .. tostring(data.settings))\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data management with logging\nlocal data = player:getAllLiliaData()\nlocal dataSize = 0\nfor k, v in pairs(data) do\n    dataSize = dataSize + 1\nend\nplayer:notifyInfo(\"Data entries: \" .. dataSize)\nlia.log.add(\"Player \" .. player:Name() .. \" data accessed\")\n</code></pre></p>"},{"location":"meta/player/#setwaypoint","title":"setWaypoint","text":"<p>Purpose</p> <p>Sets a waypoint for the player to navigate to</p> <p>When Called</p> <p>When implementing navigation systems, quest objectives, or location guidance for the player</p> <p>Parameters</p> <ul> <li><code>name</code> (string): The name of the waypoint</li> <li><code>vector</code> (Vector): The position of the waypoint</li> <li><code>logo</code> (string, optional): The material path for the waypoint icon</li> <li><code>onReach</code> (function, optional): Function to call when waypoint is reached</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set basic waypoint\nplayer:setWaypoint(\"Objective\", Vector(100, 200, 50))\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set waypoint with icon\nplayer:setWaypoint(\"Treasure\", Vector(500, 300, 100), \"icon16/star.png\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex waypoint system with callback\nlocal waypointName = \"Mission Objective\"\nlocal waypointPos = Vector(1000, 2000, 100)\nlocal waypointIcon = \"icon16/flag.png\"\nlocal onReach = function()\nplayer:notifySuccess(\"Objective reached!\")\nplayer:setData(\"missionComplete\", true)\nend\nplayer:setWaypoint(waypointName, waypointPos, waypointIcon, onReach)\n</code></pre></p>"},{"location":"meta/player/#getliliadata","title":"getLiliaData","text":"<p>Purpose</p> <p>Gets a specific Lilia data value for the player with optional default</p> <p>When Called</p> <p>When accessing player data storage, implementing data management, or retrieving stored values</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The data key to retrieve</li> <li><code>default</code> (any, optional): The default value to return if key doesn't exist</li> </ul> <p>Returns</p> <ul> <li>any - The data value or default if not found</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player data with default\nlocal settings = player:getLiliaData(\"settings\", {})\nprint(\"Player settings:\", settings)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Get data with validation\nlocal level = player:getLiliaData(\"level\", 1)\nif level &gt; 10 then\n    player:notify(\"You are level \" .. level)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data management with fallbacks\nlocal config = player:getLiliaData(\"config\", {})\nlocal defaultConfig = {theme = \"dark\", language = \"en\", notifications = true}\nfor k, v in pairs(defaultConfig) do\n    if config[k] == nil then\n        config[k] = v\n    end\nend\nplayer:notifyInfo(\"Config loaded with \" .. table.Count(config) .. \" settings\")\n</code></pre></p>"},{"location":"meta/player/#hasflags","title":"hasFlags","text":"<p>Purpose</p> <p>Checks if the player has any of the specified flags</p> <p>When Called</p> <p>When validating flag-based permissions, implementing access control, or character management</p> <p>Parameters</p> <ul> <li><code>flags</code> (string): The flags to check for (any one flag will return true)</li> </ul> <p>Returns</p> <ul> <li>boolean - True if player has any of the specified flags, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player has flags\nif player:hasFlags(\"a\") then\n    print(\"Player has admin flags\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check multiple flags\nif player:hasFlags(\"abc\") then\n    player:notify(\"You have admin, builder, or custom flags\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex flag system with detailed feedback\nlocal requiredFlags = \"abc\"\nif player:hasFlags(requiredFlags) then\n    local playerFlags = player:getFlags()\n    local hasFlags = {}\n    for i = 1, #requiredFlags do\n        local flag = requiredFlags:sub(i, i)\n        if playerFlags:find(flag, 1, true) then\n            table.insert(hasFlags, flag)\n        end\n    end\n    player:notifySuccess(\"You have flags: \" .. table.concat(hasFlags, \", \"))\nend\n</code></pre></p>"},{"location":"meta/player/#playtimegreaterthan","title":"playTimeGreaterThan","text":"<p>Purpose</p> <p>Checks if the player's play time is greater than a specified amount</p> <p>When Called</p> <p>When implementing time-based features, veteran rewards, or play time validation</p> <p>Parameters</p> <ul> <li><code>time</code> (number): The minimum play time required in seconds</li> </ul> <p>Returns</p> <ul> <li>boolean - True if player's play time is greater than the specified time, false otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player has enough play time\nif player:playTimeGreaterThan(3600) then\n    print(\"Player has played for more than 1 hour\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Time-based feature access\nif player:playTimeGreaterThan(7200) then\n    player:notify(\"You can access veteran features!\")\n    else\n        player:notifyError(\"You need 2 hours of play time for this feature\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex time-based system with rewards\nlocal requiredTime = 86400 -- 24 hours\nif player:playTimeGreaterThan(requiredTime) then\n    local playTime = player:getPlayTime()\n    local hours = math.floor(playTime / 3600)\n    player:notifySuccess(\"Veteran status achieved! Play time: \" .. hours .. \" hours\")\n    player:giveFlags(\"v\")\nend\n</code></pre></p>"},{"location":"meta/player/#requestoptions","title":"requestOptions","text":"<p>Purpose</p> <p>Requests the player to select from a list of options via a UI dialog</p> <p>When Called</p> <p>When implementing interactive menus, choice systems, or user input dialogs for the player</p> <p>Parameters</p> <ul> <li><code>title</code> (string): The title of the options dialog</li> <li><code>subTitle</code> (string): The subtitle or description of the options</li> <li><code>options</code> (table): Array of option strings to choose from</li> <li><code>limit</code> (number, optional): Maximum number of options that can be selected (default: 1)</li> <li><code>callback</code> (function, optional): Function to call when player makes a selection</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request single option\nplayer:requestOptions(\"Choose Action\", \"What do you want to do?\", {\"Option 1\", \"Option 2\"})\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with callback\nlocal options = {\"Yes\", \"No\", \"Maybe\"}\nlocal callback = function(selected)\nplayer:notify(\"You selected: \" .. table.concat(selected, \", \"))\nend\nplayer:requestOptions(\"Confirmation\", \"Do you want to continue?\", options, 1, callback)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex options system with validation\nlocal title = \"Character Creation\"\nlocal subTitle = \"Choose your character's background\"\nlocal options = {\"Warrior\", \"Mage\", \"Rogue\", \"Healer\"}\nlocal limit = 1\nlocal callback = function(selected)\nif #selected &gt; 0 then\n    local char = player:getChar()\n    if char then\n        char:setData(\"class\", selected[1])\n        player:notifySuccess(\"Character class set to: \" .. selected[1])\n    end\nend\nend\nplayer:requestOptions(title, subTitle, options, limit, callback)\n</code></pre></p>"},{"location":"meta/player/#requeststring","title":"requestString","text":"<p>Purpose</p> <p>Requests the player to input a string via a UI dialog</p> <p>When Called</p> <p>When implementing text input systems, name entry, or string-based user input for the player</p> <p>Parameters</p> <ul> <li><code>title</code> (string): The title of the string input dialog</li> <li><code>subTitle</code> (string): The subtitle or description of the input</li> <li><code>callback</code> (function): Function to call when player submits the string</li> <li><code>default</code> (string, optional): Default value to pre-fill in the input field</li> </ul> <p>Returns</p> <ul> <li>deferred|nil - A deferred object if no callback provided, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request string input\nplayer:requestString(\"Enter Name\", \"What is your name?\", function(name)\nprint(\"Player entered:\", name)\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with default value\nplayer:requestString(\"Enter Message\", \"Type your message:\", function(message)\nplayer:notify(\"You said: \" .. message)\nend, \"Hello World\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex string input with validation\nlocal title = \"Character Name\"\nlocal subTitle = \"Enter your character's name (3-20 characters)\"\nlocal callback = function(name)\nif name and #name &gt;= 3 and #name &lt;= 20 then\n    local char = player:getChar()\n    if char then\n        char:setData(\"name\", name)\n        player:notifySuccess(\"Character name set to: \" .. name)\n    end\n    else\n        player:notifyError(\"Name must be 3-20 characters long\")\n    end\nend\nplayer:requestString(title, subTitle, callback, \"New Character\")\n</code></pre></p>"},{"location":"meta/player/#requestarguments","title":"requestArguments","text":"<p>Purpose</p> <p>Requests the player to input multiple arguments via a UI dialog</p> <p>When Called</p> <p>When implementing complex input systems, command interfaces, or multi-parameter user input for the player</p> <p>Parameters</p> <ul> <li><code>title</code> (string): The title of the arguments input dialog</li> <li><code>argTypes</code> (table): Array of argument type specifications</li> <li><code>callback</code> (function): Function to call when player submits the arguments</li> </ul> <p>Returns</p> <ul> <li>deferred|nil - A deferred object if no callback provided, nil otherwise</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request basic arguments\nlocal argTypes = {{type = \"string\", name = \"Name\"}, {type = \"number\", name = \"Age\"}}\nplayer:requestArguments(\"Enter Info\", argTypes, function(args)\nprint(\"Name:\", args[1], \"Age:\", args[2])\nend)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with validation\nlocal argTypes = {\n{type = \"string\", name = \"Item Name\", required = true},\n{type = \"number\", name = \"Quantity\", min = 1, max = 100}\n}\nplayer:requestArguments(\"Create Item\", argTypes, function(args)\nplayer:notify(\"Created \" .. args[2] .. \"x \" .. args[1])\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex argument system with multiple types\nlocal argTypes = {\n{type = \"string\", name = \"Character Name\", required = true},\n{type = \"number\", name = \"Level\", min = 1, max = 100},\n{type = \"boolean\", name = \"Is VIP\", default = false},\n{type = \"string\", name = \"Faction\", options = {\"police\", \"citizen\", \"criminal\"}}\n}\nlocal callback = function(args)\nlocal char = player:getChar()\nif char then\n    char:setData(\"name\", args[1])\n    char:setData(\"level\", args[2])\n    char:setData(\"isVIP\", args[3])\n    char:setData(\"faction\", args[4])\n    player:notifySuccess(\"Character updated!\")\nend\nend\nplayer:requestArguments(\"Character Setup\", argTypes, callback)\n</code></pre></p>"},{"location":"meta/player/#binaryquestion","title":"binaryQuestion","text":"<p>Purpose</p> <p>Presents a binary question to the player with two options</p> <p>When Called</p> <p>When implementing yes/no dialogs, confirmation prompts, or binary choice systems for the player</p> <p>Parameters</p> <ul> <li><code>question</code> (string): The question to ask the player</li> <li><code>option1</code> (string): The first option (usually \"Yes\" or \"Accept\")</li> <li><code>option2</code> (string): The second option (usually \"No\" or \"Cancel\")</li> <li><code>manualDismiss</code> (boolean, optional): Whether the player can manually dismiss the dialog</li> <li><code>callback</code> (function, optional): Function to call when player makes a choice</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Ask yes/no question\nplayer:binaryQuestion(\"Do you want to continue?\", \"Yes\", \"No\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Ask with callback\nplayer:binaryQuestion(\"Delete this item?\", \"Delete\", \"Cancel\", true, function(choice)\nif choice == 1 then\n    player:notify(\"Item deleted!\")\n    else\n        player:notify(\"Deletion cancelled\")\n    end\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex confirmation system with validation\nlocal question = \"Are you sure you want to reset your character? This cannot be undone!\"\nlocal option1 = \"Yes, Reset\"\nlocal option2 = \"No, Keep Character\"\nlocal callback = function(choice)\nif choice == 1 then\n    local char = player:getChar()\n    if char then\n        char:delete()\n        player:notifySuccess(\"Character reset successfully!\")\n    end\n    else\n        player:notifyInfo(\"Character reset cancelled\")\n    end\nend\nplayer:binaryQuestion(question, option1, option2, true, callback)\n</code></pre></p>"},{"location":"meta/player/#requestbuttons","title":"requestButtons","text":"<p>Purpose</p> <p>Presents a custom button dialog to the player with multiple action buttons</p> <p>When Called</p> <p>When implementing custom action menus, button interfaces, or interactive dialogs for the player</p> <p>Parameters</p> <ul> <li><code>title</code> (string): The title of the button dialog</li> <li><code>buttons</code> (table): Array of button data {text = \"Button Text\", callback = function() end} or {text, callback}</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request basic buttons\nlocal buttons = {\n{text = \"Option 1\", callback = function() print(\"Option 1 selected\") end},\n{text = \"Option 2\", callback = function() print(\"Option 2 selected\") end}\n}\nplayer:requestButtons(\"Choose Action\", buttons)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with different actions\nlocal buttons = {\n{text = \"Heal\", callback = function() player:SetHealth(100) end},\n{text = \"Give Money\", callback = function() player:notify(\"Money given!\") end},\n{text = \"Cancel\", callback = function() player:notify(\"Cancelled\") end}\n}\nplayer:requestButtons(\"Player Actions\", buttons)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex button system with validation\nlocal title = \"Character Management\"\nlocal buttons = {\n{text = \"Reset Character\", callback = function()\nplayer:binaryQuestion(\"Reset character?\", \"Yes\", \"No\", true, function(choice)\nif choice == 1 then\n    local char = player:getChar()\n    if char then char:delete() end\n    end\nend)\nend},\n{text = \"Change Name\", callback = function()\nplayer:requestString(\"New Name\", \"Enter new character name:\", function(name)\nlocal char = player:getChar()\nif char then char:setData(\"name\", name) end\nend)\nend},\n{text = \"Cancel\", callback = function() player:notify(\"Cancelled\") end}\n}\nplayer:requestButtons(title, buttons)\n</code></pre></p>"},{"location":"meta/player/#requestdropdown","title":"requestDropdown","text":"<p>Purpose</p> <p>Presents a dropdown selection dialog to the player</p> <p>When Called</p> <p>When implementing selection menus, choice systems, or dropdown interfaces for the player</p> <p>Parameters</p> <ul> <li><code>title</code> (string): The title of the dropdown dialog</li> <li><code>subTitle</code> (string): The subtitle or description of the selection</li> <li><code>options</code> (table): Array of option strings to choose from</li> <li><code>callback</code> (function, optional): Function to call when player makes a selection</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Request dropdown selection\nlocal options = {\"Option 1\", \"Option 2\", \"Option 3\"}\nplayer:requestDropdown(\"Choose Option\", \"Select an option:\", options)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Request with callback\nlocal options = {\"Red\", \"Green\", \"Blue\", \"Yellow\"}\nlocal callback = function(selected)\nplayer:notify(\"You selected: \" .. selected)\nend\nplayer:requestDropdown(\"Choose Color\", \"Select your favorite color:\", options, callback)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex dropdown system with validation\nlocal title = \"Character Class\"\nlocal subTitle = \"Choose your character's class\"\nlocal options = {\"Warrior\", \"Mage\", \"Rogue\", \"Healer\", \"Paladin\"}\nlocal callback = function(selected)\nlocal char = player:getChar()\nif char then\n    char:setData(\"class\", selected)\n    player:notifySuccess(\"Character class set to: \" .. selected)\n    -- Apply class-specific bonuses\n    if selected == \"Warrior\" then\n        char:setData(\"strength\", 15)\n        elseif selected == \"Mage\" then\n            char:setData(\"intelligence\", 15)\n        end\n    end\nend\nplayer:requestDropdown(title, subTitle, options, callback)\n</code></pre></p>"},{"location":"meta/player/#getparts","title":"getParts","text":"<p>Purpose</p> <p>Retrieves the player's current PAC (Player Accessory Control) parts</p> <p>When Called</p> <p>When accessing player's PAC parts data</p> <p>Returns</p> <ul> <li>table - Table of active PAC part IDs</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Low: Basic part checking\nlocal parts = player:getParts()\nif parts[\"hat_001\"] then\n    player:notify(\"You have a hat equipped\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Part validation and management\nlocal parts = player:getParts()\nlocal partCount = 0\nfor partID, _ in pairs(parts) do\n    partCount = partCount + 1\nend\nif partCount &gt; 5 then\n    player:notifyWarning(\"You have too many accessories equipped\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex part system with validation and effects\nlocal parts = player:getParts()\nlocal validParts = {}\nlocal invalidParts = {}\nfor partID, _ in pairs(parts) do\n    if lia.pac.isValidPart(partID) then\n        table.insert(validParts, partID)\n        else\n            table.insert(invalidParts, partID)\n            player:removePart(partID)\n        end\n    end\n    if #invalidParts &gt; 0 then\n        player:notifyError(\"Removed \" .. #invalidParts .. \" invalid parts\")\n    end\n</code></pre></p>"},{"location":"meta/player/#syncparts","title":"syncParts","text":"<p>Purpose</p> <p>Synchronizes the player's PAC parts with all clients</p> <p>When Called</p> <p>When player's PAC parts need to be synchronized</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Basic part synchronization\nplayer:syncParts()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Sync parts after validation\nlocal parts = player:getParts()\nlocal validParts = {}\nfor partID, _ in pairs(parts) do\n    if lia.pac.isValidPart(partID) then\n        validParts[partID] = true\n    end\nend\nplayer:setNetVar(\"parts\", validParts)\nplayer:syncParts()\n</code></pre></p> <p>High Complexity: <pre><code>-- Complex synchronization with logging and validation\nlocal parts = player:getParts()\nlocal syncCount = 0\nlocal removedParts = {}\nfor partID, _ in pairs(parts) do\n    if not lia.pac.isValidPart(partID) then\n        table.insert(removedParts, partID)\n        parts[partID] = nil\n        else\n            syncCount = syncCount + 1\n        end\n    end\n    player:setNetVar(\"parts\", parts)\n    player:syncParts()\n    if #removedParts &gt; 0 then\n        lia.log.add(\"Player \" .. player:Name() .. \" had \" .. #removedParts .. \" invalid parts removed\")\n    end\n</code></pre></p>"},{"location":"meta/player/#addpart","title":"addPart","text":"<p>Purpose</p> <p>Adds a PAC part to the player and synchronizes it with all clients</p> <p>When Called</p> <p>When a player equips a new PAC accessory</p> <p>Parameters</p> <ul> <li><code>partID</code> (string): The unique identifier of the PAC part to add</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Basic part addition\nplayer:addPart(\"hat_001\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Part addition with validation and limits\nlocal parts = player:getParts()\nlocal partCount = 0\nfor _, _ in pairs(parts) do\n    partCount = partCount + 1\nend\nif partCount &lt; 10 and lia.pac.isValidPart(partID) then\n    player:addPart(partID)\n    player:notifySuccess(\"Part equipped: \" .. partID)\n    else\n        player:notifyError(\"Cannot equip more parts or invalid part ID\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- Complex part system with permissions and effects\nlocal partID = \"premium_hat_001\"\nlocal char = player:getChar()\nif char and char:hasFlags(\"P\") then\n    if lia.pac.isValidPart(partID) then\n        local parts = player:getParts()\n        if not parts[partID] then\n            player:addPart(partID)\n            player:notifySuccess(\"Premium part equipped!\")\n            lia.log.add(\"Player \" .. player:Name() .. \" equipped premium part: \" .. partID)\n            -- Apply special effects\n            player:setData(\"premiumPartEquipped\", true)\n            player:notifyInfo(\"Premium effects activated!\")\n            else\n                player:notifyWarning(\"Part already equipped\")\n            end\n            else\n                player:notifyError(\"Invalid part ID\")\n            end\n            else\n                player:notifyError(\"Insufficient permissions for this part\")\n            end\n</code></pre></p>"},{"location":"meta/player/#removepart","title":"removePart","text":"<p>Purpose</p> <p>Removes a PAC part from the player and synchronizes the change with all clients</p> <p>When Called</p> <p>When a player unequips a PAC accessory</p> <p>Parameters</p> <ul> <li><code>partID</code> (string): The unique identifier of the PAC part to remove</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Basic part removal\nplayer:removePart(\"hat_001\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Part removal with validation and cleanup\nlocal parts = player:getParts()\nif parts[partID] then\n    player:removePart(partID)\n    player:notifySuccess(\"Part removed: \" .. partID)\n    -- Clean up related data\n    player:setData(\"part_\" .. partID .. \"_equipped\", false)\n    else\n        player:notifyWarning(\"Part not equipped\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- Complex part removal with effects and logging\nlocal partID = \"premium_hat_001\"\nlocal parts = player:getParts()\nif parts[partID] then\n    player:removePart(partID)\n    -- Remove special effects\n    if partID:find(\"premium_\") then\n        player:setData(\"premiumPartEquipped\", false)\n        player:notifyInfo(\"Premium effects deactivated\")\n    end\n    -- Log the removal\n    lia.log.add(\"Player \" .. player:Name() .. \" removed part: \" .. partID)\n    -- Check if any premium parts remain\n    local hasPremiumParts = false\n    for id, _ in pairs(parts) do\n        if id:find(\"premium_\") then\n            hasPremiumParts = true\n            break\n        end\n    end\n    if not hasPremiumParts then\n        player:notifyWarning(\"No premium parts remaining\")\n    end\n    else\n        player:notifyError(\"Part not found\")\n    end\n</code></pre></p>"},{"location":"meta/player/#resetparts","title":"resetParts","text":"<p>Purpose</p> <p>Removes all PAC parts from the player and synchronizes the reset with all clients</p> <p>When Called</p> <p>When a player wants to remove all accessories or during cleanup</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Basic parts reset\nplayer:resetParts()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Reset parts with validation and notification\nlocal parts = player:getParts()\nlocal partCount = 0\nfor _, _ in pairs(parts) do\n    partCount = partCount + 1\nend\nif partCount &gt; 0 then\n    player:resetParts()\n    player:notifySuccess(\"All parts removed (\" .. partCount .. \" parts)\")\n    else\n        player:notifyInfo(\"No parts to remove\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- Complex parts reset with logging and cleanup\nlocal parts = player:getParts()\nlocal removedParts = {}\nlocal premiumParts = 0\n-- Count and categorize parts before removal\nfor partID, _ in pairs(parts) do\n    table.insert(removedParts, partID)\n    if partID:find(\"premium_\") then\n        premiumParts = premiumParts + 1\n    end\nend\nif #removedParts &gt; 0 then\n    player:resetParts()\n    -- Clean up related data\n    player:setData(\"premiumPartEquipped\", false)\n    player:setData(\"lastPartReset\", os.time())\n    -- Log the reset\n    lia.log.add(\"Player \" .. player:Name() .. \" reset \" .. #removedParts .. \" parts (Premium: \" .. premiumParts .. \")\")\n    -- Notify with details\n    if premiumParts &gt; 0 then\n        player:notifyWarning(\"Reset \" .. #removedParts .. \" parts including \" .. premiumParts .. \" premium items\")\n        else\n            player:notifySuccess(\"Reset \" .. #removedParts .. \" parts\")\n        end\n        -- Trigger cleanup hooks\n        hook.Run(\"OnPlayerResetParts\", player, removedParts)\n        else\n            player:notifyInfo(\"No parts to reset\")\n        end\n</code></pre></p>"},{"location":"meta/player/#restorestamina","title":"restoreStamina","text":"<p>Purpose</p> <p>Restores stamina to the player's character</p> <p>When Called</p> <p>When implementing stamina recovery, rest systems, or character healing for the player</p> <p>Parameters</p> <ul> <li><code>amount</code> (number): The amount of stamina to restore</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Restore stamina\nplayer:restoreStamina(25)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Restore stamina with notification\nlocal amount = 50\nplayer:restoreStamina(amount)\nplayer:notify(\"Stamina restored by \" .. amount)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex stamina system with effects\nlocal char = player:getChar()\nif char then\n    local currentStamina = player:getNetVar(\"stamina\", 100)\n    local maxStamina = hook.Run(\"GetCharMaxStamina\", char) or 100\n    local restoreAmount = math.min(amount, maxStamina - currentStamina)\n    player:restoreStamina(restoreAmount)\n    if restoreAmount &gt; 0 then\n        player:notifySuccess(\"Stamina restored: \" .. restoreAmount .. \"/\" .. maxStamina)\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#consumestamina","title":"consumeStamina","text":"<p>Purpose</p> <p>Consumes stamina from the player's character</p> <p>When Called</p> <p>When implementing stamina usage, movement costs, or action requirements for the player</p> <p>Parameters</p> <ul> <li><code>amount</code> (number): The amount of stamina to consume</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Consume stamina\nplayer:consumeStamina(10)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Consume stamina with validation\nlocal cost = 15\nlocal currentStamina = player:getNetVar(\"stamina\", 100)\nif currentStamina &gt;= cost then\n    player:consumeStamina(cost)\n    player:notify(\"Stamina used: \" .. cost)\n    else\n        player:notifyError(\"Not enough stamina!\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex stamina system with effects\nlocal char = player:getChar()\nif char then\n    local currentStamina = player:getNetVar(\"stamina\", 100)\n    local maxStamina = hook.Run(\"GetCharMaxStamina\", char) or 100\n    local staminaRatio = currentStamina / maxStamina\n    if staminaRatio &lt; 0.25 then\n        player:setNetVar(\"brth\", true)\n        hook.Run(\"PlayerStaminaDepleted\", player)\n    end\n    player:consumeStamina(amount)\nend\n</code></pre></p>"},{"location":"meta/player/#addmoney","title":"addMoney","text":"<p>Purpose</p> <p>Adds money to the player's character</p> <p>When Called</p> <p>When implementing economic systems, rewards, or financial transactions for the player</p> <p>Parameters</p> <ul> <li><code>amount</code> (number): The amount of money to add</li> </ul> <p>Returns</p> <ul> <li>boolean - True if money was added successfully, false otherwise</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Add money to player\nplayer:addMoney(100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Add money with notification\nlocal amount = 500\nif player:addMoney(amount) then\n    player:notify(\"You received $\" .. amount)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex economic system with logging\nlocal amount = 1000\nlocal char = player:getChar()\nif char then\n    local oldMoney = char:getMoney()\n    if player:addMoney(amount) then\n        local newMoney = char:getMoney()\n        player:notifySuccess(\"Money added: $\" .. amount .. \" (Total: $\" .. newMoney .. \")\")\n        lia.log.add(\"Player \" .. player:Name() .. \" received $\" .. amount)\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#takemoney","title":"takeMoney","text":"<p>Purpose</p> <p>Takes money from the player's character</p> <p>When Called</p> <p>When implementing economic systems, penalties, or financial transactions for the player</p> <p>Parameters</p> <ul> <li><code>amount</code> (number): The amount of money to take</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Take money from player\nplayer:takeMoney(50)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Take money with validation\nlocal cost = 100\nif player:canAfford(cost) then\n    player:takeMoney(cost)\n    player:notify(\"You paid $\" .. cost)\n    else\n        player:notifyError(\"You can't afford this!\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex economic system with logging\nlocal amount = 200\nlocal char = player:getChar()\nif char then\n    local oldMoney = char:getMoney()\n    if oldMoney &gt;= amount then\n        player:takeMoney(amount)\n        local newMoney = char:getMoney()\n        player:notifyWarning(\"Money taken: $\" .. amount .. \" (Remaining: $\" .. newMoney .. \")\")\n        lia.log.add(\"Player \" .. player:Name() .. \" lost $\" .. amount)\n        else\n            player:notifyError(\"Insufficient funds!\")\n        end\n    end\n</code></pre></p>"},{"location":"meta/player/#loadliliadata","title":"loadLiliaData","text":"<p>Purpose</p> <p>Loads Lilia data for the player from the database</p> <p>When Called</p> <p>When initializing player data, loading saved information, or database operations for the player</p> <p>Parameters</p> <ul> <li><code>callback</code> (function, optional): Function to call when data is loaded</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Load player data\nplayer:loadLiliaData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Load data with callback\nplayer:loadLiliaData(function(data)\nplayer:notify(\"Data loaded with \" .. table.Count(data) .. \" entries\")\nend)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data loading with validation\nplayer:loadLiliaData(function(data)\nif data then\n    local settings = data.settings or {}\n    local level = data.level or 1\n    local experience = data.experience or 0\n    player:notifyInfo(\"Welcome back! Level: \" .. level .. \", XP: \" .. experience)\n    -- Apply saved settings\n    if settings.theme then\n        player:setData(\"theme\", settings.theme)\n    end\nend\nend)\n</code></pre></p>"},{"location":"meta/player/#saveliliadata","title":"saveLiliaData","text":"<p>Purpose</p> <p>Saves Lilia data for the player to the database</p> <p>When Called</p> <p>When saving player data, updating database information, or data persistence for the player</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Save player data\nplayer:saveLiliaData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Save data with validation\nif player:IsValid() and not player:IsBot() then\n    player:saveLiliaData()\n    player:notify(\"Data saved successfully\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data saving with logging\nif player:IsValid() and not player:IsBot() then\n    local dataSize = table.Count(player.liaData or {})\n    player:saveLiliaData()\n    lia.log.add(\"Player \" .. player:Name() .. \" data saved (\" .. dataSize .. \" entries)\")\n    player:notifyInfo(\"Data saved with \" .. dataSize .. \" entries\")\nend\n</code></pre></p>"},{"location":"meta/player/#setliliadata","title":"setLiliaData","text":"<p>Purpose</p> <p>Sets a Lilia data value for the player with optional networking and saving control</p> <p>When Called</p> <p>When storing player data, implementing data management, or updating player information</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The data key to set</li> <li><code>value</code> (any): The value to store</li> <li><code>noNetworking</code> (boolean, optional): Whether to skip networking the change</li> <li><code>noSave</code> (boolean, optional): Whether to skip saving to database</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set player data\nplayer:setLiliaData(\"level\", 5)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set data with networking\nplayer:setLiliaData(\"settings\", {theme = \"dark\"}, false, true)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex data management with validation\nlocal key = \"achievements\"\nlocal value = player:getLiliaData(\"achievements\", {})\ntable.insert(value, \"first_login\")\nplayer:setLiliaData(key, value, false, false)\nplayer:notifySuccess(\"Achievement unlocked: First Login!\")\n</code></pre></p>"},{"location":"meta/player/#banplayer","title":"banPlayer","text":"<p>Purpose</p> <p>Bans the player from the server with a reason and duration</p> <p>When Called</p> <p>When implementing administrative actions, moderation systems, or player punishment for the player</p> <p>Parameters</p> <ul> <li><code>reason</code> (string, optional): The reason for the ban (default: generic reason)</li> <li><code>duration</code> (number, optional): The duration of the ban in seconds (0 for permanent)</li> <li><code>banner</code> (Player, optional): The player who issued the ban</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Ban player\nplayer:banPlayer(\"Cheating\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Ban with duration\nlocal duration = 86400 -- 24 hours\nplayer:banPlayer(\"Griefing\", duration, admin)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ban system with logging\nlocal reason = \"Multiple violations\"\nlocal duration = 604800 -- 7 days\nlocal banner = admin\nplayer:banPlayer(reason, duration, banner)\nlia.log.add(\"Player \" .. player:Name() .. \" banned by \" .. banner:Name() .. \" for: \" .. reason)\n</code></pre></p>"},{"location":"meta/player/#setaction","title":"setAction","text":"<p>Purpose</p> <p>Sets an action for the player with optional duration and callback</p> <p>When Called</p> <p>When implementing player actions, progress bars, or timed activities for the player</p> <p>Parameters</p> <ul> <li><code>text</code> (string): The action text to display</li> <li><code>time</code> (number, optional): The duration of the action in seconds</li> <li><code>callback</code> (function, optional): Function to call when action completes</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set action\nplayer:setAction(\"Loading...\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set action with duration\nplayer:setAction(\"Crafting item...\", 5)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex action system with callback\nlocal actionText = \"Repairing weapon...\"\nlocal duration = 10\nlocal callback = function(ply)\nply:notifySuccess(\"Weapon repaired!\")\nlocal weapon = ply:GetActiveWeapon()\nif IsValid(weapon) then\n    weapon:SetHealth(100)\nend\nend\nplayer:setAction(actionText, duration, callback)\n</code></pre></p>"},{"location":"meta/player/#dostaredaction","title":"doStaredAction","text":"<p>Purpose</p> <p>Makes the player perform an action by staring at an entity for a specified duration</p> <p>When Called</p> <p>When implementing interaction systems, examination mechanics, or focused actions for the player</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The entity to stare at</li> <li><code>callback</code> (function): Function to call when action completes</li> <li><code>time</code> (number): The duration to stare at the entity</li> <li><code>onCancel</code> (function, optional): Function to call if action is cancelled</li> <li><code>distance</code> (number, optional): Maximum distance to check (default: 96)</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Stare at entity\nplayer:doStaredAction(ent, function() print(\"Action completed\") end, 3)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Stare with cancellation\nlocal onCancel = function() player:notify(\"Action cancelled\") end\nplayer:doStaredAction(ent, function() player:notify(\"Action completed\") end, 5, onCancel)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex interaction system with validation\nlocal entity = player:getTracedEntity()\nif IsValid(entity) then\n    local callback = function()\n    player:notifySuccess(\"Examination complete!\")\n    local data = entity:getData(\"examinationData\", {})\n    player:notifyInfo(\"Entity data: \" .. table.Count(data) .. \" entries\")\nend\nlocal onCancel = function()\nplayer:notifyWarning(\"Examination interrupted\")\nend\nplayer:doStaredAction(entity, callback, 10, onCancel, 150)\nend\n</code></pre></p>"},{"location":"meta/player/#stopaction","title":"stopAction","text":"<p>Purpose</p> <p>Stops the player's current action and clears action timers</p> <p>When Called</p> <p>When interrupting player actions, implementing action cancellation, or cleaning up player state</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Stop player action\nplayer:stopAction()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Stop action with notification\nplayer:stopAction()\nplayer:notify(\"Action stopped\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex action management with cleanup\nif player:getNetVar(\"actionActive\", false) then\n    player:stopAction()\n    player:setNetVar(\"actionActive\", false)\n    player:notifyWarning(\"Action interrupted\")\n    -- Clean up any action-related data\n    player:setData(\"actionProgress\", 0)\nend\n</code></pre></p>"},{"location":"meta/player/#getplaytime","title":"getPlayTime","text":"<p>Purpose</p> <p>Gets the player's total play time in seconds</p> <p>When Called</p> <p>When calculating play time, implementing time-based features, or displaying player statistics</p> <p>Returns</p> <ul> <li>number - The player's total play time in seconds</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player play time\nlocal playTime = player:getPlayTime()\nprint(\"Play time:\", playTime)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display play time in hours\nlocal playTime = player:getPlayTime()\nlocal hours = math.floor(playTime / 3600)\nplayer:notify(\"You have played for \" .. hours .. \" hours\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex play time system with rewards\nlocal playTime = player:getPlayTime()\nlocal hours = math.floor(playTime / 3600)\nlocal days = math.floor(hours / 24)\nif days &gt;= 7 then\n    player:notifySuccess(\"Veteran player! \" .. days .. \" days played\")\n    player:giveFlags(\"v\")\n    elseif hours &gt;= 24 then\n        player:notifyInfo(\"Experienced player! \" .. hours .. \" hours played\")\n    end\n</code></pre></p>"},{"location":"meta/player/#getsessiontime","title":"getSessionTime","text":"<p>Purpose</p> <p>Gets the player's current session time in seconds</p> <p>When Called</p> <p>When calculating session duration, implementing session-based features, or displaying current session statistics</p> <p>Returns</p> <ul> <li>number - The player's current session time in seconds</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get session time\nlocal sessionTime = player:getSessionTime()\nprint(\"Session time:\", sessionTime)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display session time in minutes\nlocal sessionTime = player:getSessionTime()\nlocal minutes = math.floor(sessionTime / 60)\nplayer:notify(\"You have been online for \" .. minutes .. \" minutes\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex session system with rewards\nlocal sessionTime = player:getSessionTime()\nlocal hours = math.floor(sessionTime / 3600)\nif hours &gt;= 2 then\n    player:notifySuccess(\"Long session! \" .. hours .. \" hours online\")\n    -- Give session bonus\n    player:addMoney(100 * hours)\nend\n</code></pre></p>"},{"location":"meta/player/#createragdoll","title":"createRagdoll","text":"<p>Purpose</p> <p>Creates a ragdoll entity for the player with their current appearance and state</p> <p>When Called</p> <p>When implementing death systems, ragdoll creation, or player state changes</p> <p>Parameters</p> <ul> <li><code>freeze</code> (boolean, optional): Whether to freeze the ragdoll</li> <li><code>isDead</code> (boolean, optional): Whether the player is dead (affects ragdoll storage)</li> </ul> <p>Returns</p> <ul> <li>Entity - The created ragdoll entity</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create ragdoll\nlocal ragdoll = player:createRagdoll()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create ragdoll for death\nlocal ragdoll = player:createRagdoll(false, true)\nplayer:notify(\"Ragdoll created\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ragdoll system with effects\nlocal ragdoll = player:createRagdoll(false, true)\nif IsValid(ragdoll) then\n    ragdoll:setNetVar(\"player\", player)\n    ragdoll:setNetVar(\"deathTime\", os.time())\n    -- Apply death effects\n    if player:IsOnFire() then\n        ragdoll:Ignite(8)\n    end\n    hook.Run(\"OnPlayerRagdollCreated\", player, ragdoll)\nend\n</code></pre></p>"},{"location":"meta/player/#setragdolled","title":"setRagdolled","text":"<p>Purpose</p> <p>Sets the player's ragdoll state (knocked down or standing up)</p> <p>When Called</p> <p>When implementing knockdown systems, unconsciousness, or player state management</p> <p>Parameters</p> <ul> <li><code>state</code> (boolean): Whether to ragdoll the player (true) or stand them up (false)</li> <li><code>baseTime</code> (number, optional): Base time for ragdoll duration (default: 10)</li> <li><code>getUpGrace</code> (number, optional): Grace period for getting up</li> <li><code>getUpMessage</code> (string, optional): Message to display when getting up (default: \"Waking up\")</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Ragdoll player\nplayer:setRagdolled(true)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Ragdoll with custom time\nplayer:setRagdolled(true, 15, 5, \"Getting up...\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex ragdoll system with effects\nlocal state = true\nlocal duration = 20\nlocal grace = 10\nlocal message = \"Recovering from injury...\"\nplayer:setRagdolled(state, duration, grace, message)\nplayer:notifyWarning(\"You are unconscious for \" .. duration .. \" seconds\")\n</code></pre></p>"},{"location":"meta/player/#syncvars","title":"syncVars","text":"<p>Purpose</p> <p>Synchronizes network variables to the player client</p> <p>When Called</p> <p>When initializing player connection, updating network state, or ensuring client-server synchronization</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Sync variables to player\nplayer:syncVars()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Sync variables with validation\nif player:IsValid() and player:IsConnected() then\n    player:syncVars()\n    player:notify(\"Variables synchronized\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex synchronization with logging\nlocal varCount = 0\nfor entity, data in pairs(lia.net) do\n    if entity == \"globals\" then\n        varCount = varCount + table.Count(data)\n        elseif IsValid(entity) then\n            varCount = varCount + table.Count(data)\n        end\n    end\n    player:syncVars()\n    lia.log.add(\"Synced \" .. varCount .. \" variables to \" .. player:Name())\n</code></pre></p>"},{"location":"meta/player/#setnetvar","title":"setNetVar","text":"<p>Purpose</p> <p>Sets a network variable for the player that synchronizes to all clients</p> <p>When Called</p> <p>When updating player state, implementing networked properties, or when other players need to see the change (like handcuff status)</p> <p>Parameters</p> <ul> <li><code>key</code> (string): The network variable key</li> <li><code>value</code> (any): The value to set</li> </ul> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Server (only called on server side) Notes: Broadcasts to all clients so other players can see the player's state changes</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Set network variable\nplayer:setNetVar(\"health\", 100)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set network variable with validation\nlocal health = math.Clamp(newHealth, 0, 100)\nplayer:setNetVar(\"health\", health)\nplayer:notify(\"Health updated to \" .. health)\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex network variable system with hooks\nlocal oldValue = player:getNetVar(\"level\", 1)\nlocal newValue = oldValue + 1\nplayer:setNetVar(\"level\", newValue)\nhook.Run(\"OnPlayerLevelUp\", player, oldValue, newValue)\nplayer:notifySuccess(\"Level up! \" .. oldValue .. \" \u2192 \" .. newValue)\n</code></pre></p>"},{"location":"meta/player/#canoverrideview","title":"canOverrideView","text":"<p>Purpose</p> <p>Checks if the player can override their view (third person mode)</p> <p>When Called</p> <p>When implementing camera systems, view controls, or third person functionality for the player</p> <p>Returns</p> <ul> <li>boolean - True if player can override view, false otherwise</li> </ul> <p>Realm</p> <p>Client (only called on client side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player can override view\nif player:canOverrideView() then\n    print(\"Player can use third person\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional view override\nif player:canOverrideView() then\n    player:notify(\"Third person mode available\")\n    else\n        player:notify(\"Third person mode disabled\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex view system with validation\nif player:canOverrideView() then\n    local ragdoll = player:getNetVar(\"ragdoll\")\n    local inVehicle = IsValid(player:GetVehicle())\n    if not IsValid(ragdoll) and not inVehicle then\n        player:notifyInfo(\"Third person mode enabled\")\n        -- Enable third person camera\n        player:setData(\"thirdPerson\", true)\n    end\nend\n</code></pre></p>"},{"location":"meta/player/#isinthirdperson","title":"isInThirdPerson","text":"<p>Purpose</p> <p>Checks if the player is currently in third person mode</p> <p>When Called</p> <p>When implementing camera systems, view controls, or third person functionality for the player</p> <p>Returns</p> <ul> <li>boolean - True if player is in third person mode, false otherwise</li> </ul> <p>Realm</p> <p>Client (only called on client side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Check if player is in third person\nif player:isInThirdPerson() then\n    print(\"Player is in third person mode\")\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional third person handling\nif player:isInThirdPerson() then\n    player:notify(\"Third person mode active\")\n    else\n        player:notify(\"First person mode active\")\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex camera system with effects\nif player:isInThirdPerson() then\n    local distance = lia.option.get(\"thirdPersonDistance\", 100)\n    local angle = lia.option.get(\"thirdPersonAngle\", 0)\n    -- Apply third person camera effects\n    player:setData(\"cameraDistance\", distance)\n    player:setData(\"cameraAngle\", angle)\nend\n</code></pre></p>"},{"location":"meta/player/#getplaytime_1","title":"getPlayTime","text":"<p>Purpose</p> <p>Gets the player's total play time in seconds (client-side version)</p> <p>When Called</p> <p>When calculating play time, implementing time-based features, or displaying player statistics</p> <p>Returns</p> <ul> <li>number - The player's total play time in seconds</li> </ul> <p>Realm</p> <p>Client (only called on client side)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get player play time\nlocal playTime = player:getPlayTime()\nprint(\"Play time:\", playTime)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Display play time in hours\nlocal playTime = player:getPlayTime()\nlocal hours = math.floor(playTime / 3600)\nplayer:notify(\"You have played for \" .. hours .. \" hours\")\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Complex play time system with rewards\nlocal playTime = player:getPlayTime()\nlocal hours = math.floor(playTime / 3600)\nlocal days = math.floor(hours / 24)\nif days &gt;= 7 then\n    player:notifySuccess(\"Veteran player! \" .. days .. \" days played\")\n    elseif hours &gt;= 24 then\n        player:notifyInfo(\"Experienced player! \" .. hours .. \" hours played\")\n    end\n</code></pre></p>"},{"location":"meta/tool/","title":"Tool Gun Meta","text":"<p>Tool gun management system for the Lilia framework.</p> <p>Overview</p> <p>The tool gun meta table provides comprehensive functionality for managing tool gun instances, tool operations, and tool-specific functionality in the Lilia framework. It handles tool creation, configuration, object management, and tool-specific operations. The meta table operates on both server and client sides, with the server managing tool validation and data while the client provides tool interaction and display. It includes integration with the Garry's Mod tool system for tool functionality, object system for tool objects, network system for tool synchronization, and permission system for tool access control. The meta table ensures proper tool instance management, object handling, tool synchronization, and comprehensive tool lifecycle management from creation to destruction.</p>"},{"location":"meta/tool/#create","title":"create","text":"<p>Purpose</p> <p>Creates a new instance of the tool gun object with default properties</p> <p>When Called</p> <p>When initializing a new tool gun instance for a specific tool mode</p> <p>Returns</p> <ul> <li>table - The newly created tool gun object</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Create a basic tool gun instance\nlocal tool = toolGunMeta:create()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Create tool with custom properties\nlocal tool = toolGunMeta:create()\ntool.Mode = \"custom_tool\"\ntool.Stage = 1\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Create tool with full configuration and custom objects\nlocal tool = toolGunMeta:create()\ntool.Mode = \"advanced_builder\"\ntool.ClientConVar = {\n[\"build_size\"] = \"1\",\n[\"build_material\"] = \"wood\"\n}\ntool.Objects = {}\ntool.Stage = 0\n</code></pre></p>"},{"location":"meta/tool/#createconvars","title":"createConVars","text":"<p>Purpose</p> <p>Creates console variables (ConVars) for the tool gun based on the current mode</p> <p>When Called</p> <p>During tool initialization to set up configurable options for the tool</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (different behavior on client vs server)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Initialize basic ConVars for a tool\nlocal tool = toolGunMeta:create()\ntool:createConVars()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Set up tool with client-side options\nlocal tool = toolGunMeta:create()\ntool.ClientConVar = {[\"size\"] = \"1\", [\"material\"] = \"wood\"}\ntool:createConVars()\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced tool with multiple client and server ConVars\nlocal tool = toolGunMeta:create()\ntool.Mode = \"advanced_builder\"\ntool.ClientConVar = {\n[\"build_size\"] = \"1\",\n[\"build_material\"] = \"wood\",\n[\"auto_align\"] = \"1\"\n}\ntool:createConVars()\n</code></pre></p>"},{"location":"meta/tool/#updatedata","title":"updateData","text":"<p>Purpose</p> <p>Updates the tool's data and state information (placeholder for custom implementation)</p> <p>When Called</p> <p>During tool operation to refresh data or synchronize with server/client state</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic data update call\ntool:updateData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update data with custom logic\nfunction tool:updateData()\n    self.LastUpdate = CurTime()\n    self.ObjectCount = #self.Objects\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced data synchronization with networking\nfunction tool:updateData()\n    if SERVER then\n        -- Server-side data update\n        self:SyncDataToClients()\n    else\n        -- Client-side data refresh\n        self:RequestServerUpdate()\n    end\n    self.LastUpdate = CurTime()\nend\n</code></pre></p>"},{"location":"meta/tool/#updatedata_1","title":"updateData","text":"<p>Purpose</p> <p>Updates the tool's data and state information (placeholder for custom implementation)</p> <p>When Called</p> <p>During tool operation to refresh data or synchronize with server/client state</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic data update call\ntool:updateData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update data with custom logic\nfunction tool:updateData()\n    self.LastUpdate = CurTime()\n    self.ObjectCount = #self.Objects\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced data synchronization with networking\nfunction tool:updateData()\n    if SERVER then\n        -- Server-side data update\n        self:SyncDataToClients()\n    else\n        -- Client-side data refresh\n        self:RequestServerUpdate()\n    end\n    self.LastUpdate = CurTime()\nend\n</code></pre></p>"},{"location":"meta/tool/#updatedata_2","title":"updateData","text":"<p>Purpose</p> <p>Updates the tool's data and state information (placeholder for custom implementation)</p> <p>When Called</p> <p>During tool operation to refresh data or synchronize with server/client state</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic data update call\ntool:updateData()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Update data with custom logic\nfunction tool:updateData()\n    self.LastUpdate = CurTime()\n    self.ObjectCount = #self.Objects\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced data synchronization with networking\nfunction tool:updateData()\n    if SERVER then\n        -- Server-side data update\n        self:SyncDataToClients()\n    else\n        -- Client-side data refresh\n        self:RequestServerUpdate()\n    end\n    self.LastUpdate = CurTime()\nend\n</code></pre></p>"},{"location":"meta/tool/#freezemovement","title":"freezeMovement","text":"<p>Purpose</p> <p>Freezes player movement during tool operation (placeholder for custom implementation)</p> <p>When Called</p> <p>When the tool needs to restrict player movement for precise operations</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client (affects local player movement)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic movement freeze\ntool:freezeMovement()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional movement freezing\nfunction tool:freezeMovement()\n    if self:GetOwner():KeyDown(IN_ATTACK) then\n        self:GetOwner():SetMoveType(MOVETYPE_NONE)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced movement control with restoration\nfunction tool:freezeMovement()\n    local ply = self:GetOwner()\n    if not ply.FrozenPosition then\n        ply.FrozenPosition = ply:GetPos()\n        ply.FrozenAngles = ply:GetAngles()\n        ply:SetMoveType(MOVETYPE_NONE)\n    end\nend\nfunction tool:unfreezeMovement()\n    local ply = self:GetOwner()\n    if ply.FrozenPosition then\n        ply:SetMoveType(MOVETYPE_WALK)\n        ply.FrozenPosition = nil\n        ply.FrozenAngles = nil\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#freezemovement_1","title":"freezeMovement","text":"<p>Purpose</p> <p>Freezes player movement during tool operation (placeholder for custom implementation)</p> <p>When Called</p> <p>When the tool needs to restrict player movement for precise operations</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client (affects local player movement)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic movement freeze\ntool:freezeMovement()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional movement freezing\nfunction tool:freezeMovement()\n    if self:GetOwner():KeyDown(IN_ATTACK) then\n        self:GetOwner():SetMoveType(MOVETYPE_NONE)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced movement control with restoration\nfunction tool:freezeMovement()\n    local ply = self:GetOwner()\n    if not ply.FrozenPosition then\n        ply.FrozenPosition = ply:GetPos()\n        ply.FrozenAngles = ply:GetAngles()\n        ply:SetMoveType(MOVETYPE_NONE)\n    end\nend\nfunction tool:unfreezeMovement()\n    local ply = self:GetOwner()\n    if ply.FrozenPosition then\n        ply:SetMoveType(MOVETYPE_WALK)\n        ply.FrozenPosition = nil\n        ply.FrozenAngles = nil\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#unfreezemovement","title":"unfreezeMovement","text":"<p>Purpose</p> <p>Freezes player movement during tool operation (placeholder for custom implementation)</p> <p>When Called</p> <p>When the tool needs to restrict player movement for precise operations</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client (affects local player movement)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic movement freeze\ntool:freezeMovement()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional movement freezing\nfunction tool:freezeMovement()\n    if self:GetOwner():KeyDown(IN_ATTACK) then\n        self:GetOwner():SetMoveType(MOVETYPE_NONE)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced movement control with restoration\nfunction tool:freezeMovement()\n    local ply = self:GetOwner()\n    if not ply.FrozenPosition then\n        ply.FrozenPosition = ply:GetPos()\n        ply.FrozenAngles = ply:GetAngles()\n        ply:SetMoveType(MOVETYPE_NONE)\n    end\nend\nfunction tool:unfreezeMovement()\n    local ply = self:GetOwner()\n    if ply.FrozenPosition then\n        ply:SetMoveType(MOVETYPE_WALK)\n        ply.FrozenPosition = nil\n        ply.FrozenAngles = nil\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#freezemovement_2","title":"freezeMovement","text":"<p>Purpose</p> <p>Freezes player movement during tool operation (placeholder for custom implementation)</p> <p>When Called</p> <p>When the tool needs to restrict player movement for precise operations</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client (affects local player movement)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic movement freeze\ntool:freezeMovement()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Conditional movement freezing\nfunction tool:freezeMovement()\n    if self:GetOwner():KeyDown(IN_ATTACK) then\n        self:GetOwner():SetMoveType(MOVETYPE_NONE)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced movement control with restoration\nfunction tool:freezeMovement()\n    local ply = self:GetOwner()\n    if not ply.FrozenPosition then\n        ply.FrozenPosition = ply:GetPos()\n        ply.FrozenAngles = ply:GetAngles()\n        ply:SetMoveType(MOVETYPE_NONE)\n    end\nend\nfunction tool:unfreezeMovement()\n    local ply = self:GetOwner()\n    if ply.FrozenPosition then\n        ply:SetMoveType(MOVETYPE_WALK)\n        ply.FrozenPosition = nil\n        ply.FrozenAngles = nil\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#drawhud","title":"drawHUD","text":"<p>Purpose</p> <p>Draws HUD elements for the tool gun interface (placeholder for custom implementation)</p> <p>When Called</p> <p>Every frame when the tool gun is active and HUD should be displayed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client (HUD rendering only occurs on client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw basic tool information\nfunction tool:drawHUD()\n    draw.SimpleText(self.Message, \"default\", 10, 10, color_white)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw tool progress and object count\nfunction tool:drawHUD()\n    local scrW, scrH = ScrW(), ScrH()\n    -- Draw tool name and stage\n    draw.SimpleText(self:getMode(), \"liaGenericFont\", scrW/2, scrH - 100, color_white, TEXT_ALIGN_CENTER)\n    -- Draw progress bar\n    local progress = self.Stage / 3\n    surface.SetDrawColor(0, 255, 0, 255)\n    surface.DrawRect(scrW/2 - 50, scrH - 80, progress * 100, 10)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced HUD with object preview and controls\nfunction tool:drawHUD()\n    local scrW, scrH = ScrW(), ScrH()\n    -- Draw tool header\n    surface.SetDrawColor(0, 0, 0, 200)\n    surface.DrawRect(0, scrH - 150, scrW, 150)\n    -- Draw tool name and status\n    draw.SimpleText(self:getMode():upper(), \"liaGenericFont\", 10, scrH - 140, color_white)\n    -- Draw object list\n    local y = scrH - 120\n    for i, obj in ipairs(self.Objects) do\n        draw.SimpleText(\"Object \" .. i .. \": \" .. tostring(obj.Ent), \"liaSmallFont\", 10, y, color_white)\n        y = y + 20\n    end\n    -- Draw control hints\n    draw.SimpleText(\"Left Click: Place | Right Click: Cancel | Reload: Clear\", \"liaSmallFont\", scrW/2, scrH - 20, color_white, TEXT_ALIGN_CENTER)\nend\n</code></pre></p>"},{"location":"meta/tool/#drawhud_1","title":"drawHUD","text":"<p>Purpose</p> <p>Draws HUD elements for the tool gun interface (placeholder for custom implementation)</p> <p>When Called</p> <p>Every frame when the tool gun is active and HUD should be displayed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client (HUD rendering only occurs on client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw basic tool information\nfunction tool:drawHUD()\n    draw.SimpleText(self.Message, \"default\", 10, 10, color_white)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw tool progress and object count\nfunction tool:drawHUD()\n    local scrW, scrH = ScrW(), ScrH()\n    -- Draw tool name and stage\n    draw.SimpleText(self:getMode(), \"liaGenericFont\", scrW/2, scrH - 100, color_white, TEXT_ALIGN_CENTER)\n    -- Draw progress bar\n    local progress = self.Stage / 3\n    surface.SetDrawColor(0, 255, 0, 255)\n    surface.DrawRect(scrW/2 - 50, scrH - 80, progress * 100, 10)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced HUD with object preview and controls\nfunction tool:drawHUD()\n    local scrW, scrH = ScrW(), ScrH()\n    -- Draw tool header\n    surface.SetDrawColor(0, 0, 0, 200)\n    surface.DrawRect(0, scrH - 150, scrW, 150)\n    -- Draw tool name and status\n    draw.SimpleText(self:getMode():upper(), \"liaGenericFont\", 10, scrH - 140, color_white)\n    -- Draw object list\n    local y = scrH - 120\n    for i, obj in ipairs(self.Objects) do\n        draw.SimpleText(\"Object \" .. i .. \": \" .. tostring(obj.Ent), \"liaSmallFont\", 10, y, color_white)\n        y = y + 20\n    end\n    -- Draw control hints\n    draw.SimpleText(\"Left Click: Place | Right Click: Cancel | Reload: Clear\", \"liaSmallFont\", scrW/2, scrH - 20, color_white, TEXT_ALIGN_CENTER)\nend\n</code></pre></p>"},{"location":"meta/tool/#drawhud_2","title":"drawHUD","text":"<p>Purpose</p> <p>Draws HUD elements for the tool gun interface (placeholder for custom implementation)</p> <p>When Called</p> <p>Every frame when the tool gun is active and HUD should be displayed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client (HUD rendering only occurs on client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw basic tool information\nfunction tool:drawHUD()\n    draw.SimpleText(self.Message, \"default\", 10, 10, color_white)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw tool progress and object count\nfunction tool:drawHUD()\n    local scrW, scrH = ScrW(), ScrH()\n    -- Draw tool name and stage\n    draw.SimpleText(self:getMode(), \"liaGenericFont\", scrW/2, scrH - 100, color_white, TEXT_ALIGN_CENTER)\n    -- Draw progress bar\n    local progress = self.Stage / 3\n    surface.SetDrawColor(0, 255, 0, 255)\n    surface.DrawRect(scrW/2 - 50, scrH - 80, progress * 100, 10)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced HUD with object preview and controls\nfunction tool:drawHUD()\n    local scrW, scrH = ScrW(), ScrH()\n    -- Draw tool header\n    surface.SetDrawColor(0, 0, 0, 200)\n    surface.DrawRect(0, scrH - 150, scrW, 150)\n    -- Draw tool name and status\n    draw.SimpleText(self:getMode():upper(), \"liaGenericFont\", 10, scrH - 140, color_white)\n    -- Draw object list\n    local y = scrH - 120\n    for i, obj in ipairs(self.Objects) do\n        draw.SimpleText(\"Object \" .. i .. \": \" .. tostring(obj.Ent), \"liaSmallFont\", 10, y, color_white)\n        y = y + 20\n    end\n    -- Draw control hints\n    draw.SimpleText(\"Left Click: Place | Right Click: Cancel | Reload: Clear\", \"liaSmallFont\", scrW/2, scrH - 20, color_white, TEXT_ALIGN_CENTER)\nend\n</code></pre></p>"},{"location":"meta/tool/#drawhud_3","title":"drawHUD","text":"<p>Purpose</p> <p>Draws HUD elements for the tool gun interface (placeholder for custom implementation)</p> <p>When Called</p> <p>Every frame when the tool gun is active and HUD should be displayed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Client (HUD rendering only occurs on client)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Draw basic tool information\nfunction tool:drawHUD()\n    draw.SimpleText(self.Message, \"default\", 10, 10, color_white)\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Draw tool progress and object count\nfunction tool:drawHUD()\n    local scrW, scrH = ScrW(), ScrH()\n    -- Draw tool name and stage\n    draw.SimpleText(self:getMode(), \"liaGenericFont\", scrW/2, scrH - 100, color_white, TEXT_ALIGN_CENTER)\n    -- Draw progress bar\n    local progress = self.Stage / 3\n    surface.SetDrawColor(0, 255, 0, 255)\n    surface.DrawRect(scrW/2 - 50, scrH - 80, progress * 100, 10)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced HUD with object preview and controls\nfunction tool:drawHUD()\n    local scrW, scrH = ScrW(), ScrH()\n    -- Draw tool header\n    surface.SetDrawColor(0, 0, 0, 200)\n    surface.DrawRect(0, scrH - 150, scrW, 150)\n    -- Draw tool name and status\n    draw.SimpleText(self:getMode():upper(), \"liaGenericFont\", 10, scrH - 140, color_white)\n    -- Draw object list\n    local y = scrH - 120\n    for i, obj in ipairs(self.Objects) do\n        draw.SimpleText(\"Object \" .. i .. \": \" .. tostring(obj.Ent), \"liaSmallFont\", 10, y, color_white)\n        y = y + 20\n    end\n    -- Draw control hints\n    draw.SimpleText(\"Left Click: Place | Right Click: Cancel | Reload: Clear\", \"liaSmallFont\", scrW/2, scrH - 20, color_white, TEXT_ALIGN_CENTER)\nend\n</code></pre></p>"},{"location":"meta/tool/#getserverinfo","title":"getServerInfo","text":"<p>Purpose</p> <p>Retrieves server-side ConVar information for the current tool mode</p> <p>When Called</p> <p>When the tool needs to access server configuration values</p> <p>Parameters</p> <ul> <li><code>property</code> (string): The name of the ConVar property to retrieve</li> </ul> <p>Returns</p> <ul> <li>ConVar - The server ConVar object for the specified property</li> </ul> <p>Realm</p> <p>Server (accesses server-side console variables)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get basic server ConVar\nlocal maxObjects = tool:getServerInfo(\"max_objects\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use server info for validation\nlocal maxObjects = tool:getServerInfo(\"max_objects\")\nif #tool.Objects &gt;= maxObjects:GetInt() then\n    tool.Message = \"Maximum objects reached\"\n    return false\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced server configuration management\nlocal serverConfig = {}\nlocal properties = {\"max_objects\", \"build_speed\", \"auto_save\"}\nfor _, prop in ipairs(properties) do\n    local convar = tool:getServerInfo(prop)\n    serverConfig[prop] = convar:GetInt()\nend\nif serverConfig.auto_save &gt; 0 then\n    tool:ScheduleAutoSave(serverConfig.auto_save)\nend\n</code></pre></p>"},{"location":"meta/tool/#buildconvarlist","title":"buildConVarList","text":"<p>Purpose</p> <p>Builds a formatted list of ConVars for the current tool mode</p> <p>When Called</p> <p>When the tool needs to provide a list of available ConVars for UI or configuration</p> <p>Returns</p> <ul> <li>table - A table mapping ConVar names to their default values</li> </ul> <p>Realm</p> <p>Shared (can be used on both client and server)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get basic ConVar list\nlocal convars = tool:buildConVarList()\nPrintTable(convars)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use ConVar list for UI population\nlocal convars = tool:buildConVarList()\nfor name, default in pairs(convars) do\n    local panel = vgui.Create(\"DTextEntry\")\n    panel:SetConVar(name)\n    panel:SetValue(default)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced ConVar management with validation\nlocal convars = tool:buildConVarList()\nlocal validatedConfig = {}\nfor name, default in pairs(convars) do\n    local value = GetConVar(name):GetString()\n    if self:ValidateConVar(name, value) then\n        validatedConfig[name] = value\n    else\n        validatedConfig[name] = default\n        -- Invalid ConVar value for \" .. name .. \", using default\n    end\nend\nself:ApplyConfiguration(validatedConfig)\n</code></pre></p>"},{"location":"meta/tool/#getclientinfo","title":"getClientInfo","text":"<p>Purpose</p> <p>Retrieves client-side ConVar information for the current tool mode</p> <p>When Called</p> <p>When the tool needs to access client configuration values from the owner</p> <p>Parameters</p> <ul> <li><code>property</code> (string): The name of the ConVar property to retrieve</li> </ul> <p>Returns</p> <ul> <li>string - The current value of the client's ConVar for the specified property</li> </ul> <p>Realm</p> <p>Shared (accesses client-side data through the owner)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get basic client ConVar value\nlocal size = tool:getClientInfo(\"build_size\")\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use client info for tool behavior\nlocal material = tool:getClientInfo(\"build_material\")\nif material == \"wood\" then\n    self.GhostEntity:SetMaterial(\"wood\")\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced client configuration with fallback\nlocal properties = {\"build_size\", \"build_material\", \"auto_align\"}\nlocal config = {}\nfor _, prop in ipairs(properties) do\n    local value = tool:getClientInfo(prop)\n    if value and value ~= \"0\" then\n        config[prop] = value\n    else\n        config[prop] = self.ClientConVar[prop] or \"1\"\n    end\nend\nself:ApplyClientConfiguration(config)\n</code></pre></p>"},{"location":"meta/tool/#getclientnumber","title":"getClientNumber","text":"<p>Purpose</p> <p>Retrieves client-side ConVar information as a number for the current tool mode</p> <p>When Called</p> <p>When the tool needs numeric client configuration values with fallback defaults</p> <p>Parameters</p> <ul> <li><code>property</code> (string): The name of the ConVar property to retrieve</li> <li><code>default</code> (number): Default value if ConVar is not found or invalid</li> </ul> <p>Returns</p> <ul> <li>number - The numeric value of the client's ConVar or the default value</li> </ul> <p>Realm</p> <p>Shared (accesses client-side data through the owner)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get basic numeric client ConVar\nlocal size = tool:getClientNumber(\"build_size\", 1)\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use numeric client info for calculations\nlocal count = tool:getClientNumber(\"object_count\", 5)\nlocal spacing = tool:getClientNumber(\"build_spacing\", 10)\nfor i = 1, count do\n    local pos = Vector(i * spacing, 0, 0)\n    self:CreateObjectAt(pos)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced numeric configuration with validation\nlocal numericConfig = {\n[\"build_size\"] = {default = 1, min = 0.1, max = 10},\n[\"build_speed\"] = {default = 1, min = 0.1, max = 5},\n[\"max_objects\"] = {default = 50, min = 1, max = 1000}\n}\nlocal validatedNumbers = {}\nfor prop, config in pairs(numericConfig) do\n    local value = tool:getClientNumber(prop, config.default)\n    value = math.Clamp(value, config.min, config.max)\n    validatedNumbers[prop] = value\nend\nself:ApplyNumericConfiguration(validatedNumbers)\n</code></pre></p>"},{"location":"meta/tool/#allowed","title":"allowed","text":"<p>Purpose</p> <p>Checks if the tool is allowed to be used based on server configuration</p> <p>When Called</p> <p>Before performing tool operations to verify permissions</p> <p>Returns</p> <ul> <li>boolean - True if the tool is allowed, false otherwise</li> </ul> <p>Realm</p> <p>Shared (client always returns true, server checks ConVar)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic permission check\nif not tool:allowed() then return false end\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Permission-based tool behavior\nif tool:allowed() then\n    tool:PerformAction()\nelse\n    tool.Message = \"Tool usage not allowed\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced permission system with logging\nif not tool:allowed() then\n    local playerName = tool:GetOwner():Name()\n    local toolMode = tool:getMode()\n    print(string.format(\"Player %s attempted to use %s but was denied\", playerName, toolMode))\n    if SERVER then\n        tool:GetOwner():ChatPrint(\"Tool usage is currently disabled\")\n    end\n    return false\nend\n-- Continue with allowed operation\ntool:PerformAction()\n</code></pre></p>"},{"location":"meta/tool/#init","title":"init","text":"<p>Purpose</p> <p>Initializes the tool gun instance (placeholder for custom implementation)</p> <p>When Called</p> <p>When the tool gun is first created or deployed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool initialization)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic initialization\ntool:init()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize with custom setup\nfunction tool:init()\n    self.Stage = 0\n    self.LastUpdate = CurTime()\n    self.Objects = {}\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced initialization with networking and validation\nfunction tool:init()\n    -- Initialize basic properties\n    self.Stage = 0\n    self.Objects = {}\n    -- Set up networking if server\n    if SERVER then\n        self:InitializeNetworkChannels()\n    end\n    -- Load saved data if available\n    if file.Exists(self.SavePath, \"DATA\") then\n        self:LoadToolData()\n    end\n    -- Initialize ghost entity\n    self:CreateGhostEntity()\n    print(\"Tool \" .. self:getMode() .. \" initialized for \" .. self:GetOwner():Name())\nend\n</code></pre></p>"},{"location":"meta/tool/#init_1","title":"init","text":"<p>Purpose</p> <p>Initializes the tool gun instance (placeholder for custom implementation)</p> <p>When Called</p> <p>When the tool gun is first created or deployed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool initialization)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic initialization\ntool:init()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize with custom setup\nfunction tool:init()\n    self.Stage = 0\n    self.LastUpdate = CurTime()\n    self.Objects = {}\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced initialization with networking and validation\nfunction tool:init()\n    -- Initialize basic properties\n    self.Stage = 0\n    self.Objects = {}\n    -- Set up networking if server\n    if SERVER then\n        self:InitializeNetworkChannels()\n    end\n    -- Load saved data if available\n    if file.Exists(self.SavePath, \"DATA\") then\n        self:LoadToolData()\n    end\n    -- Initialize ghost entity\n    self:CreateGhostEntity()\n    print(\"Tool \" .. self:getMode() .. \" initialized for \" .. self:GetOwner():Name())\nend\n</code></pre></p>"},{"location":"meta/tool/#init_2","title":"init","text":"<p>Purpose</p> <p>Initializes the tool gun instance (placeholder for custom implementation)</p> <p>When Called</p> <p>When the tool gun is first created or deployed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool initialization)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic initialization\ntool:init()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Initialize with custom setup\nfunction tool:init()\n    self.Stage = 0\n    self.LastUpdate = CurTime()\n    self.Objects = {}\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced initialization with networking and validation\nfunction tool:init()\n    -- Initialize basic properties\n    self.Stage = 0\n    self.Objects = {}\n    -- Set up networking if server\n    if SERVER then\n        self:InitializeNetworkChannels()\n    end\n    -- Load saved data if available\n    if file.Exists(self.SavePath, \"DATA\") then\n        self:LoadToolData()\n    end\n    -- Initialize ghost entity\n    self:CreateGhostEntity()\n    print(\"Tool \" .. self:getMode() .. \" initialized for \" .. self:GetOwner():Name())\nend\n</code></pre></p>"},{"location":"meta/tool/#getmode","title":"getMode","text":"<p>Purpose</p> <p>Retrieves the current tool mode identifier</p> <p>When Called</p> <p>When other methods need to know which tool mode is active</p> <p>Returns</p> <ul> <li>string - The current tool mode name</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get current tool mode\nlocal mode = tool:getMode()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use mode for conditional behavior\nlocal mode = tool:getMode()\nif mode == \"builder\" then\n    tool:EnableBuildMode()\n    elseif mode == \"remover\" then\n        tool:EnableRemoveMode()\n    end\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced mode-based configuration and validation\nlocal mode = tool:getMode()\n-- Validate mode exists and is allowed\nif not self.ToolModes[mode] then\n    error(\"Invalid tool mode: \" .. mode)\n    return\nend\n-- Apply mode-specific configuration\nlocal modeConfig = self.ToolModes[mode]\nfor setting, value in pairs(modeConfig) do\n    self[setting] = value\nend\n-- Initialize mode-specific systems\nself:InitializeModeSystems(mode)\n</code></pre></p>"},{"location":"meta/tool/#getswep","title":"getSWEP","text":"<p>Purpose</p> <p>Retrieves the SWEP (Scripted Weapon) instance associated with this tool</p> <p>When Called</p> <p>When the tool needs to access the underlying weapon entity</p> <p>Returns</p> <ul> <li>Weapon - The SWEP entity instance</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get the weapon instance\nlocal swep = tool:getSWEP()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use SWEP for weapon-specific operations\nlocal swep = tool:getSWEP()\nif IsValid(swep) then\n    local ammo = swep:GetPrimaryAmmoType()\n    print(\"Primary ammo type: \" .. ammo)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced SWEP interaction and validation\nlocal swep = tool:getSWEP()\n-- Validate SWEP exists and is valid\nif not IsValid(swep) then\n    error(\"Tool SWEP is not valid\")\n    return\nend\n-- Access weapon properties\nlocal weaponClass = swep:GetClass()\nlocal isReloading = swep:IsReloading()\n-- Perform weapon-specific operations\nif weaponClass == \"weapon_physgun\" then\n    self:HandlePhysgunSpecificLogic(swep)\n    elseif weaponClass == \"weapon_physcannon\" then\n        self:HandleGravityGunSpecificLogic(swep)\n    end\n    -- Update tool state based on weapon\n    self.LastWeaponCheck = CurTime()\n</code></pre></p>"},{"location":"meta/tool/#getowner","title":"GetOwner","text":"<p>Purpose</p> <p>Retrieves the player who owns/holds this tool gun</p> <p>When Called</p> <p>When the tool needs to access the owning player for permissions, communication, or data</p> <p>Returns</p> <ul> <li>Player - The player entity that owns this tool</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get the tool owner\nlocal owner = tool:GetOwner()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use owner for player-specific operations\nlocal owner = tool:GetOwner()\nif IsValid(owner) then\n    local health = owner:Health()\n    tool.Message = \"Owner health: \" .. health\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced owner validation and management\nlocal owner = tool:GetOwner()\n-- Validate owner exists and is valid\nif not IsValid(owner) then\n    print(\"Tool has no valid owner\")\n    return false\nend\n-- Check owner permissions\nif not owner:IsAdmin() and not owner:IsSuperAdmin() then\n    tool.Message = \"Insufficient permissions\"\n    return false\nend\n-- Perform owner-specific operations\nlocal steamID = owner:SteamID()\nlocal team = owner:Team()\n-- Log tool usage\nprint(string.format(\"Player %s (Team %d) used tool %s\",\nowner:Name(), team, tool:getMode()))\n-- Apply team-based restrictions\nif self:HasTeamRestrictions(team) then\n    tool.Message = \"Your team cannot use this tool\"\n    return false\nend\nreturn true\n</code></pre></p>"},{"location":"meta/tool/#getweapon","title":"getWeapon","text":"<p>Purpose</p> <p>Retrieves the weapon entity associated with this tool gun</p> <p>When Called</p> <p>When the tool needs to access the weapon entity for physics or rendering operations</p> <p>Returns</p> <ul> <li>Weapon - The weapon entity instance</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Get the weapon entity\nlocal weapon = tool:getWeapon()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Use weapon for position and angle operations\nlocal weapon = tool:getWeapon()\nif IsValid(weapon) then\n    local pos = weapon:GetPos()\n    local ang = weapon:GetAngles()\n    self.GhostEntity:SetPos(pos + ang:Forward() * 50)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced weapon interaction and validation\nlocal weapon = tool:getWeapon()\n-- Validate weapon exists and is valid\nif not IsValid(weapon) then\n    print(\"Tool weapon is not valid\")\n    return false\nend\n-- Access weapon properties\nlocal weaponClass = weapon:GetClass()\nlocal worldModel = weapon:GetModel()\n-- Perform weapon-specific operations\nif weaponClass == \"weapon_physgun\" then\n    -- Handle physics gun specific logic\n    local heldEntity = weapon:GetParent()\n    if IsValid(heldEntity) then\n        self:HandleHeldEntity(heldEntity)\n    end\n    elseif weaponClass == \"weapon_toolgun\" then\n        -- Handle tool gun specific logic\n        local toolMode = self:getMode()\n        if toolMode == \"builder\" then\n            self:UpdateGhostEntity()\n        end\n    end\n    -- Update tool state based on weapon\n    self.LastWeaponUpdate = CurTime()\n</code></pre></p>"},{"location":"meta/tool/#leftclick","title":"leftClick","text":"<p>Purpose</p> <p>Handles left mouse button click interactions (placeholder for custom implementation)</p> <p>When Called</p> <p>When the player left-clicks while holding the tool gun</p> <p>Returns</p> <ul> <li>boolean - True if the click was handled, false otherwise</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic left click handling\nfunction tool:leftClick()\n    print(\"Left clicked!\")\n    return true\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Left click with object placement\nfunction tool:leftClick()\n    if not tool:allowed() then return false end\n    local trace = self:GetOwner():GetEyeTrace()\n    if not trace.Hit then return false end\n    local entity = ents.Create(\"prop_physics\")\n    entity:SetPos(trace.HitPos)\n    entity:Spawn()\n    table.insert(self.Objects, {Ent = entity, Time = CurTime()})\n    return true\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced left click with validation and networking\nfunction tool:leftClick()\n    local owner = self:GetOwner()\n    -- Validate permissions and conditions\n    if not self:allowed() then return false end\n    if not owner:KeyDown(IN_USE) then return false end\n    -- Get target position and validate\n    local trace = owner:GetEyeTrace()\n    if not trace.Hit or trace.HitWorld then\n        self.Message = \"Invalid target\"\n        return false\n    end\n    -- Check distance and line of sight\n    local distance = owner:GetPos():Distance(trace.HitPos)\n    if distance &gt; self:getClientNumber(\"max_distance\", 100) then\n        self.Message = \"Too far away\"\n        return false\n    end\n    -- Create object with server validation\n    if SERVER then\n        local success = self:CreateServerObject(trace.HitPos, trace.HitNormal)\n        if success then\n            -- Network to clients\n            net.Start(\"tool_object_created\")\n            net.WriteVector(trace.HitPos)\n            net.Broadcast()\n            return true\n        end\n    else\n        -- Send request to server\n        net.Start(\"tool_create_request\")\n        net.WriteVector(trace.HitPos)\n        net.SendToServer()\n        return true\n    end\n    return false\nend\n</code></pre></p>"},{"location":"meta/tool/#leftclick_1","title":"leftClick","text":"<p>Purpose</p> <p>Handles left mouse button click interactions (placeholder for custom implementation)</p> <p>When Called</p> <p>When the player left-clicks while holding the tool gun</p> <p>Returns</p> <ul> <li>boolean - True if the click was handled, false otherwise</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic left click handling\nfunction tool:leftClick()\n    print(\"Left clicked!\")\n    return true\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Left click with object placement\nfunction tool:leftClick()\n    if not tool:allowed() then return false end\n    local trace = self:GetOwner():GetEyeTrace()\n    if not trace.Hit then return false end\n    local entity = ents.Create(\"prop_physics\")\n    entity:SetPos(trace.HitPos)\n    entity:Spawn()\n    table.insert(self.Objects, {Ent = entity, Time = CurTime()})\n    return true\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced left click with validation and networking\nfunction tool:leftClick()\n    local owner = self:GetOwner()\n    -- Validate permissions and conditions\n    if not self:allowed() then return false end\n    if not owner:KeyDown(IN_USE) then return false end\n    -- Get target position and validate\n    local trace = owner:GetEyeTrace()\n    if not trace.Hit or trace.HitWorld then\n        self.Message = \"Invalid target\"\n        return false\n    end\n    -- Check distance and line of sight\n    local distance = owner:GetPos():Distance(trace.HitPos)\n    if distance &gt; self:getClientNumber(\"max_distance\", 100) then\n        self.Message = \"Too far away\"\n        return false\n    end\n    -- Create object with server validation\n    if SERVER then\n        local success = self:CreateServerObject(trace.HitPos, trace.HitNormal)\n        if success then\n            -- Network to clients\n            net.Start(\"tool_object_created\")\n            net.WriteVector(trace.HitPos)\n            net.Broadcast()\n            return true\n        end\n    else\n        -- Send request to server\n        net.Start(\"tool_create_request\")\n        net.WriteVector(trace.HitPos)\n        net.SendToServer()\n        return true\n    end\n    return false\nend\n</code></pre></p>"},{"location":"meta/tool/#leftclick_2","title":"leftClick","text":"<p>Purpose</p> <p>Handles left mouse button click interactions (placeholder for custom implementation)</p> <p>When Called</p> <p>When the player left-clicks while holding the tool gun</p> <p>Returns</p> <ul> <li>boolean - True if the click was handled, false otherwise</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic left click handling\nfunction tool:leftClick()\n    print(\"Left clicked!\")\n    return true\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Left click with object placement\nfunction tool:leftClick()\n    if not tool:allowed() then return false end\n    local trace = self:GetOwner():GetEyeTrace()\n    if not trace.Hit then return false end\n    local entity = ents.Create(\"prop_physics\")\n    entity:SetPos(trace.HitPos)\n    entity:Spawn()\n    table.insert(self.Objects, {Ent = entity, Time = CurTime()})\n    return true\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced left click with validation and networking\nfunction tool:leftClick()\n    local owner = self:GetOwner()\n    -- Validate permissions and conditions\n    if not self:allowed() then return false end\n    if not owner:KeyDown(IN_USE) then return false end\n    -- Get target position and validate\n    local trace = owner:GetEyeTrace()\n    if not trace.Hit or trace.HitWorld then\n        self.Message = \"Invalid target\"\n        return false\n    end\n    -- Check distance and line of sight\n    local distance = owner:GetPos():Distance(trace.HitPos)\n    if distance &gt; self:getClientNumber(\"max_distance\", 100) then\n        self.Message = \"Too far away\"\n        return false\n    end\n    -- Create object with server validation\n    if SERVER then\n        local success = self:CreateServerObject(trace.HitPos, trace.HitNormal)\n        if success then\n            -- Network to clients\n            net.Start(\"tool_object_created\")\n            net.WriteVector(trace.HitPos)\n            net.Broadcast()\n            return true\n        end\n    else\n        -- Send request to server\n        net.Start(\"tool_create_request\")\n        net.WriteVector(trace.HitPos)\n        net.SendToServer()\n        return true\n    end\n    return false\nend\n</code></pre></p>"},{"location":"meta/tool/#leftclick_3","title":"leftClick","text":"<p>Purpose</p> <p>Handles left mouse button click interactions (placeholder for custom implementation)</p> <p>When Called</p> <p>When the player left-clicks while holding the tool gun</p> <p>Returns</p> <ul> <li>boolean - True if the click was handled, false otherwise</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic left click handling\nfunction tool:leftClick()\n    print(\"Left clicked!\")\n    return true\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Left click with object placement\nfunction tool:leftClick()\n    if not tool:allowed() then return false end\n    local trace = self:GetOwner():GetEyeTrace()\n    if not trace.Hit then return false end\n    local entity = ents.Create(\"prop_physics\")\n    entity:SetPos(trace.HitPos)\n    entity:Spawn()\n    table.insert(self.Objects, {Ent = entity, Time = CurTime()})\n    return true\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced left click with validation and networking\nfunction tool:leftClick()\n    local owner = self:GetOwner()\n    -- Validate permissions and conditions\n    if not self:allowed() then return false end\n    if not owner:KeyDown(IN_USE) then return false end\n    -- Get target position and validate\n    local trace = owner:GetEyeTrace()\n    if not trace.Hit or trace.HitWorld then\n        self.Message = \"Invalid target\"\n        return false\n    end\n    -- Check distance and line of sight\n    local distance = owner:GetPos():Distance(trace.HitPos)\n    if distance &gt; self:getClientNumber(\"max_distance\", 100) then\n        self.Message = \"Too far away\"\n        return false\n    end\n    -- Create object with server validation\n    if SERVER then\n        local success = self:CreateServerObject(trace.HitPos, trace.HitNormal)\n        if success then\n            -- Network to clients\n            net.Start(\"tool_object_created\")\n            net.WriteVector(trace.HitPos)\n            net.Broadcast()\n            return true\n        end\n    else\n        -- Send request to server\n        net.Start(\"tool_create_request\")\n        net.WriteVector(trace.HitPos)\n        net.SendToServer()\n        return true\n    end\n    return false\nend\n</code></pre></p>"},{"location":"meta/tool/#rightclick","title":"rightClick","text":"<p>Purpose</p> <p>Handles right mouse button click interactions (placeholder for custom implementation)</p> <p>When Called</p> <p>When the player right-clicks while holding the tool gun</p> <p>Returns</p> <ul> <li>boolean - True if the click was handled, false otherwise</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic right click handling\nfunction tool:rightClick()\n    self.Message = \"Right clicked!\"\n    return true\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Right click for object selection/manipulation\nfunction tool:rightClick()\n    local trace = self:GetOwner():GetEyeTrace()\n    if not trace.Hit then return false end\n    local hitEntity = trace.Entity\n    if IsValid(hitEntity) and hitEntity:GetClass() == \"prop_physics\" then\n        self.SelectedEntity = hitEntity\n        self.Message = \"Selected: \" .. hitEntity:GetModel()\n        return true\n    end\n    return false\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced right click with context menus and validation\nfunction tool:rightClick()\n    local owner = self:GetOwner()\n    -- Get target and validate\n    local trace = owner:GetEyeTrace()\n    if not trace.Hit then return false end\n    local hitEntity = trace.Entity\n    -- Handle different target types\n    if trace.HitWorld then\n        -- World click - show position info\n        self.Message = string.format(\n            \"World: %.2f, %.2f, %.2f\",\n            trace.HitPos.x,\n            trace.HitPos.y,\n            trace.HitPos.z\n        )\n        return true\n    elseif IsValid(hitEntity) then\n        -- Entity click - show context menu or manipulate\n        if hitEntity:IsPlayer() then\n            -- Player interaction\n            if owner:KeyDown(IN_SPEED) then\n                self:OpenPlayerMenu(hitEntity)\n            else\n                self.Message = \"Hold SHIFT for player menu\"\n            end\n            return true\n        elseif hitEntity:GetClass() == \"prop_physics\" then\n            -- Prop manipulation\n            if self:CanManipulateEntity(hitEntity) then\n                if owner:KeyDown(IN_DUCK) then\n                    self:RemoveEntity(hitEntity)\n                else\n                    self:SelectEntity(hitEntity)\n                end\n                return true\n            end\n        end\n    end\n    return false\nend\n</code></pre></p>"},{"location":"meta/tool/#rightclick_1","title":"rightClick","text":"<p>Purpose</p> <p>Handles right mouse button click interactions (placeholder for custom implementation)</p> <p>When Called</p> <p>When the player right-clicks while holding the tool gun</p> <p>Returns</p> <ul> <li>boolean - True if the click was handled, false otherwise</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic right click handling\nfunction tool:rightClick()\n    self.Message = \"Right clicked!\"\n    return true\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Right click for object selection/manipulation\nfunction tool:rightClick()\n    local trace = self:GetOwner():GetEyeTrace()\n    if not trace.Hit then return false end\n    local hitEntity = trace.Entity\n    if IsValid(hitEntity) and hitEntity:GetClass() == \"prop_physics\" then\n        self.SelectedEntity = hitEntity\n        self.Message = \"Selected: \" .. hitEntity:GetModel()\n        return true\n    end\n    return false\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced right click with context menus and validation\nfunction tool:rightClick()\n    local owner = self:GetOwner()\n    -- Get target and validate\n    local trace = owner:GetEyeTrace()\n    if not trace.Hit then return false end\n    local hitEntity = trace.Entity\n    -- Handle different target types\n    if trace.HitWorld then\n        -- World click - show position info\n        self.Message = string.format(\n            \"World: %.2f, %.2f, %.2f\",\n            trace.HitPos.x,\n            trace.HitPos.y,\n            trace.HitPos.z\n        )\n        return true\n    elseif IsValid(hitEntity) then\n        -- Entity click - show context menu or manipulate\n        if hitEntity:IsPlayer() then\n            -- Player interaction\n            if owner:KeyDown(IN_SPEED) then\n                self:OpenPlayerMenu(hitEntity)\n            else\n                self.Message = \"Hold SHIFT for player menu\"\n            end\n            return true\n        elseif hitEntity:GetClass() == \"prop_physics\" then\n            -- Prop manipulation\n            if self:CanManipulateEntity(hitEntity) then\n                if owner:KeyDown(IN_DUCK) then\n                    self:RemoveEntity(hitEntity)\n                else\n                    self:SelectEntity(hitEntity)\n                end\n                return true\n            end\n        end\n    end\n    return false\nend\n</code></pre></p>"},{"location":"meta/tool/#rightclick_2","title":"rightClick","text":"<p>Purpose</p> <p>Handles right mouse button click interactions (placeholder for custom implementation)</p> <p>When Called</p> <p>When the player right-clicks while holding the tool gun</p> <p>Returns</p> <ul> <li>boolean - True if the click was handled, false otherwise</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic right click handling\nfunction tool:rightClick()\n    self.Message = \"Right clicked!\"\n    return true\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Right click for object selection/manipulation\nfunction tool:rightClick()\n    local trace = self:GetOwner():GetEyeTrace()\n    if not trace.Hit then return false end\n    local hitEntity = trace.Entity\n    if IsValid(hitEntity) and hitEntity:GetClass() == \"prop_physics\" then\n        self.SelectedEntity = hitEntity\n        self.Message = \"Selected: \" .. hitEntity:GetModel()\n        return true\n    end\n    return false\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced right click with context menus and validation\nfunction tool:rightClick()\n    local owner = self:GetOwner()\n    -- Get target and validate\n    local trace = owner:GetEyeTrace()\n    if not trace.Hit then return false end\n    local hitEntity = trace.Entity\n    -- Handle different target types\n    if trace.HitWorld then\n        -- World click - show position info\n        self.Message = string.format(\n            \"World: %.2f, %.2f, %.2f\",\n            trace.HitPos.x,\n            trace.HitPos.y,\n            trace.HitPos.z\n        )\n        return true\n    elseif IsValid(hitEntity) then\n        -- Entity click - show context menu or manipulate\n        if hitEntity:IsPlayer() then\n            -- Player interaction\n            if owner:KeyDown(IN_SPEED) then\n                self:OpenPlayerMenu(hitEntity)\n            else\n                self.Message = \"Hold SHIFT for player menu\"\n            end\n            return true\n        elseif hitEntity:GetClass() == \"prop_physics\" then\n            -- Prop manipulation\n            if self:CanManipulateEntity(hitEntity) then\n                if owner:KeyDown(IN_DUCK) then\n                    self:RemoveEntity(hitEntity)\n                else\n                    self:SelectEntity(hitEntity)\n                end\n                return true\n            end\n        end\n    end\n    return false\nend\n</code></pre></p>"},{"location":"meta/tool/#rightclick_3","title":"rightClick","text":"<p>Purpose</p> <p>Handles right mouse button click interactions (placeholder for custom implementation)</p> <p>When Called</p> <p>When the player right-clicks while holding the tool gun</p> <p>Returns</p> <ul> <li>boolean - True if the click was handled, false otherwise</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic right click handling\nfunction tool:rightClick()\n    self.Message = \"Right clicked!\"\n    return true\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Right click for object selection/manipulation\nfunction tool:rightClick()\n    local trace = self:GetOwner():GetEyeTrace()\n    if not trace.Hit then return false end\n    local hitEntity = trace.Entity\n    if IsValid(hitEntity) and hitEntity:GetClass() == \"prop_physics\" then\n        self.SelectedEntity = hitEntity\n        self.Message = \"Selected: \" .. hitEntity:GetModel()\n        return true\n    end\n    return false\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced right click with context menus and validation\nfunction tool:rightClick()\n    local owner = self:GetOwner()\n    -- Get target and validate\n    local trace = owner:GetEyeTrace()\n    if not trace.Hit then return false end\n    local hitEntity = trace.Entity\n    -- Handle different target types\n    if trace.HitWorld then\n        -- World click - show position info\n        self.Message = string.format(\n            \"World: %.2f, %.2f, %.2f\",\n            trace.HitPos.x,\n            trace.HitPos.y,\n            trace.HitPos.z\n        )\n        return true\n    elseif IsValid(hitEntity) then\n        -- Entity click - show context menu or manipulate\n        if hitEntity:IsPlayer() then\n            -- Player interaction\n            if owner:KeyDown(IN_SPEED) then\n                self:OpenPlayerMenu(hitEntity)\n            else\n                self.Message = \"Hold SHIFT for player menu\"\n            end\n            return true\n        elseif hitEntity:GetClass() == \"prop_physics\" then\n            -- Prop manipulation\n            if self:CanManipulateEntity(hitEntity) then\n                if owner:KeyDown(IN_DUCK) then\n                    self:RemoveEntity(hitEntity)\n                else\n                    self:SelectEntity(hitEntity)\n                end\n                return true\n            end\n        end\n    end\n    return false\nend\n</code></pre></p>"},{"location":"meta/tool/#reload","title":"reload","text":"<p>Purpose</p> <p>Handles reload key press to clear/reset tool objects and state</p> <p>When Called</p> <p>When the player presses the reload key (default R) while holding the tool gun</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic reload functionality\nfunction tool:reload()\n    self:clearObjects()\n    self.Message = \"Objects cleared\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Reload with confirmation and logging\nfunction tool:reload()\n    if #self.Objects == 0 then\n        self.Message = \"No objects to clear\"\n        return\n    end\n    local count = #self.Objects\n    self:clearObjects()\n    self.Message = string.format(\"Cleared %d objects\", count)\n    if SERVER then\n        print(\"Player \" .. self:GetOwner():Name() .. \" cleared \" .. count .. \" objects\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced reload with backup and networking\nfunction tool:reload()\n    local owner = self:GetOwner()\n    -- Check if there are objects to clear\n    if #self.Objects == 0 then\n        self.Message = \"No objects to clear\"\n        return\n    end\n    -- Create backup before clearing (if configured)\n    if self:getClientInfo(\"backup_on_reload\") == \"1\" then\n        self:CreateBackup()\n    end\n    -- Clear objects with individual cleanup\n    local clearedCount = 0\n    for i = #self.Objects, 1, -1 do\n        local obj = self.Objects[i]\n        if IsValid(obj.Ent) then\n            if SERVER then\n                obj.Ent:Remove()\n            end\n            clearedCount = clearedCount + 1\n        end\n        table.remove(self.Objects, i)\n    end\n    -- Reset tool state\n    self.Stage = 0\n    self.GhostEntity = nil\n    -- Notify and log\n    self.Message = string.format(\"Cleared %d objects\", clearedCount)\n    if SERVER then\n        -- Network cleanup confirmation to client\n        net.Start(\"tool_objects_cleared\")\n        net.WriteUInt(clearedCount, 16)\n        net.Send(owner)\n        -- Player \" .. owner:Name() .. \" cleared \" .. clearedCount .. \" tool objects\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#reload_1","title":"reload","text":"<p>Purpose</p> <p>Handles reload key press to clear/reset tool objects and state</p> <p>When Called</p> <p>When the player presses the reload key (default R) while holding the tool gun</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic reload functionality\nfunction tool:reload()\n    self:clearObjects()\n    self.Message = \"Objects cleared\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Reload with confirmation and logging\nfunction tool:reload()\n    if #self.Objects == 0 then\n        self.Message = \"No objects to clear\"\n        return\n    end\n    local count = #self.Objects\n    self:clearObjects()\n    self.Message = string.format(\"Cleared %d objects\", count)\n    if SERVER then\n        print(\"Player \" .. self:GetOwner():Name() .. \" cleared \" .. count .. \" objects\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced reload with backup and networking\nfunction tool:reload()\n    local owner = self:GetOwner()\n    -- Check if there are objects to clear\n    if #self.Objects == 0 then\n        self.Message = \"No objects to clear\"\n        return\n    end\n    -- Create backup before clearing (if configured)\n    if self:getClientInfo(\"backup_on_reload\") == \"1\" then\n        self:CreateBackup()\n    end\n    -- Clear objects with individual cleanup\n    local clearedCount = 0\n    for i = #self.Objects, 1, -1 do\n        local obj = self.Objects[i]\n        if IsValid(obj.Ent) then\n            if SERVER then\n                obj.Ent:Remove()\n            end\n            clearedCount = clearedCount + 1\n        end\n        table.remove(self.Objects, i)\n    end\n    -- Reset tool state\n    self.Stage = 0\n    self.GhostEntity = nil\n    -- Notify and log\n    self.Message = string.format(\"Cleared %d objects\", clearedCount)\n    if SERVER then\n        -- Network cleanup confirmation to client\n        net.Start(\"tool_objects_cleared\")\n        net.WriteUInt(clearedCount, 16)\n        net.Send(owner)\n        -- Player \" .. owner:Name() .. \" cleared \" .. clearedCount .. \" tool objects\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#reload_2","title":"reload","text":"<p>Purpose</p> <p>Handles reload key press to clear/reset tool objects and state</p> <p>When Called</p> <p>When the player presses the reload key (default R) while holding the tool gun</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic reload functionality\nfunction tool:reload()\n    self:clearObjects()\n    self.Message = \"Objects cleared\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Reload with confirmation and logging\nfunction tool:reload()\n    if #self.Objects == 0 then\n        self.Message = \"No objects to clear\"\n        return\n    end\n    local count = #self.Objects\n    self:clearObjects()\n    self.Message = string.format(\"Cleared %d objects\", count)\n    if SERVER then\n        print(\"Player \" .. self:GetOwner():Name() .. \" cleared \" .. count .. \" objects\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced reload with backup and networking\nfunction tool:reload()\n    local owner = self:GetOwner()\n    -- Check if there are objects to clear\n    if #self.Objects == 0 then\n        self.Message = \"No objects to clear\"\n        return\n    end\n    -- Create backup before clearing (if configured)\n    if self:getClientInfo(\"backup_on_reload\") == \"1\" then\n        self:CreateBackup()\n    end\n    -- Clear objects with individual cleanup\n    local clearedCount = 0\n    for i = #self.Objects, 1, -1 do\n        local obj = self.Objects[i]\n        if IsValid(obj.Ent) then\n            if SERVER then\n                obj.Ent:Remove()\n            end\n            clearedCount = clearedCount + 1\n        end\n        table.remove(self.Objects, i)\n    end\n    -- Reset tool state\n    self.Stage = 0\n    self.GhostEntity = nil\n    -- Notify and log\n    self.Message = string.format(\"Cleared %d objects\", clearedCount)\n    if SERVER then\n        -- Network cleanup confirmation to client\n        net.Start(\"tool_objects_cleared\")\n        net.WriteUInt(clearedCount, 16)\n        net.Send(owner)\n        -- Player \" .. owner:Name() .. \" cleared \" .. clearedCount .. \" tool objects\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#reload_3","title":"reload","text":"<p>Purpose</p> <p>Handles reload key press to clear/reset tool objects and state</p> <p>When Called</p> <p>When the player presses the reload key (default R) while holding the tool gun</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic reload functionality\nfunction tool:reload()\n    self:clearObjects()\n    self.Message = \"Objects cleared\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Reload with confirmation and logging\nfunction tool:reload()\n    if #self.Objects == 0 then\n        self.Message = \"No objects to clear\"\n        return\n    end\n    local count = #self.Objects\n    self:clearObjects()\n    self.Message = string.format(\"Cleared %d objects\", count)\n    if SERVER then\n        print(\"Player \" .. self:GetOwner():Name() .. \" cleared \" .. count .. \" objects\")\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced reload with backup and networking\nfunction tool:reload()\n    local owner = self:GetOwner()\n    -- Check if there are objects to clear\n    if #self.Objects == 0 then\n        self.Message = \"No objects to clear\"\n        return\n    end\n    -- Create backup before clearing (if configured)\n    if self:getClientInfo(\"backup_on_reload\") == \"1\" then\n        self:CreateBackup()\n    end\n    -- Clear objects with individual cleanup\n    local clearedCount = 0\n    for i = #self.Objects, 1, -1 do\n        local obj = self.Objects[i]\n        if IsValid(obj.Ent) then\n            if SERVER then\n                obj.Ent:Remove()\n            end\n            clearedCount = clearedCount + 1\n        end\n        table.remove(self.Objects, i)\n    end\n    -- Reset tool state\n    self.Stage = 0\n    self.GhostEntity = nil\n    -- Notify and log\n    self.Message = string.format(\"Cleared %d objects\", clearedCount)\n    if SERVER then\n        -- Network cleanup confirmation to client\n        net.Start(\"tool_objects_cleared\")\n        net.WriteUInt(clearedCount, 16)\n        net.Send(owner)\n        -- Player \" .. owner:Name() .. \" cleared \" .. clearedCount .. \" tool objects\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#deploy","title":"deploy","text":"<p>Purpose</p> <p>Handles tool deployment when the weapon is drawn/equipped</p> <p>When Called</p> <p>When the player switches to or initially equips the tool gun</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic deploy functionality\nfunction tool:deploy()\n    self.Message = \"Tool deployed\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Deploy with initialization\nfunction tool:deploy()\n    self:releaseGhostEntity()\n    self:init()\n    self:createConVars()\n    self.Message = \"Tool ready\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced deploy with validation and networking\nfunction tool:deploy()\n    local owner = self:GetOwner()\n    -- Release any existing ghost entity\n    self:releaseGhostEntity()\n    -- Initialize tool systems\n    self:init()\n    -- Create ConVars for this session\n    self:createConVars()\n    -- Validate tool mode and permissions\n    if not self:allowed() then\n        self.Message = \"Tool usage disabled\"\n        return\n    end\n    -- Check if tool mode is valid\n    local mode = self:getMode()\n    if not self.ToolModes or not self.ToolModes[mode] then\n        self.Message = \"Invalid tool mode\"\n        return\n    end\n    -- Initialize mode-specific systems\n    if SERVER then\n        -- Server-side initialization\n        self:InitializeServerSystems()\n        self:LoadPlayerData(owner)\n        -- Network tool state to client\n        net.Start(\"tool_deployed\")\n        net.WriteString(mode)\n        net.Send(owner)\n    else\n        -- Client-side initialization\n        self:InitializeClientSystems()\n        self:CreateGhostEntity()\n    end\n    -- Set initial state\n    self.Stage = 0\n    self.LastDeploy = CurTime()\n    self.Message = string.format(\"%s tool ready\", mode)\n    -- Player \" .. owner:Name() .. \" deployed \" .. mode .. \" tool\nend\n</code></pre></p>"},{"location":"meta/tool/#deploy_1","title":"deploy","text":"<p>Purpose</p> <p>Handles tool deployment when the weapon is drawn/equipped</p> <p>When Called</p> <p>When the player switches to or initially equips the tool gun</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic deploy functionality\nfunction tool:deploy()\n    self.Message = \"Tool deployed\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Deploy with initialization\nfunction tool:deploy()\n    self:releaseGhostEntity()\n    self:init()\n    self:createConVars()\n    self.Message = \"Tool ready\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced deploy with validation and networking\nfunction tool:deploy()\n    local owner = self:GetOwner()\n    -- Release any existing ghost entity\n    self:releaseGhostEntity()\n    -- Initialize tool systems\n    self:init()\n    -- Create ConVars for this session\n    self:createConVars()\n    -- Validate tool mode and permissions\n    if not self:allowed() then\n        self.Message = \"Tool usage disabled\"\n        return\n    end\n    -- Check if tool mode is valid\n    local mode = self:getMode()\n    if not self.ToolModes or not self.ToolModes[mode] then\n        self.Message = \"Invalid tool mode\"\n        return\n    end\n    -- Initialize mode-specific systems\n    if SERVER then\n        -- Server-side initialization\n        self:InitializeServerSystems()\n        self:LoadPlayerData(owner)\n        -- Network tool state to client\n        net.Start(\"tool_deployed\")\n        net.WriteString(mode)\n        net.Send(owner)\n    else\n        -- Client-side initialization\n        self:InitializeClientSystems()\n        self:CreateGhostEntity()\n    end\n    -- Set initial state\n    self.Stage = 0\n    self.LastDeploy = CurTime()\n    self.Message = string.format(\"%s tool ready\", mode)\n    -- Player \" .. owner:Name() .. \" deployed \" .. mode .. \" tool\nend\n</code></pre></p>"},{"location":"meta/tool/#deploy_2","title":"deploy","text":"<p>Purpose</p> <p>Handles tool deployment when the weapon is drawn/equipped</p> <p>When Called</p> <p>When the player switches to or initially equips the tool gun</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic deploy functionality\nfunction tool:deploy()\n    self.Message = \"Tool deployed\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Deploy with initialization\nfunction tool:deploy()\n    self:releaseGhostEntity()\n    self:init()\n    self:createConVars()\n    self.Message = \"Tool ready\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced deploy with validation and networking\nfunction tool:deploy()\n    local owner = self:GetOwner()\n    -- Release any existing ghost entity\n    self:releaseGhostEntity()\n    -- Initialize tool systems\n    self:init()\n    -- Create ConVars for this session\n    self:createConVars()\n    -- Validate tool mode and permissions\n    if not self:allowed() then\n        self.Message = \"Tool usage disabled\"\n        return\n    end\n    -- Check if tool mode is valid\n    local mode = self:getMode()\n    if not self.ToolModes or not self.ToolModes[mode] then\n        self.Message = \"Invalid tool mode\"\n        return\n    end\n    -- Initialize mode-specific systems\n    if SERVER then\n        -- Server-side initialization\n        self:InitializeServerSystems()\n        self:LoadPlayerData(owner)\n        -- Network tool state to client\n        net.Start(\"tool_deployed\")\n        net.WriteString(mode)\n        net.Send(owner)\n    else\n        -- Client-side initialization\n        self:InitializeClientSystems()\n        self:CreateGhostEntity()\n    end\n    -- Set initial state\n    self.Stage = 0\n    self.LastDeploy = CurTime()\n    self.Message = string.format(\"%s tool ready\", mode)\n    -- Player \" .. owner:Name() .. \" deployed \" .. mode .. \" tool\nend\n</code></pre></p>"},{"location":"meta/tool/#deploy_3","title":"deploy","text":"<p>Purpose</p> <p>Handles tool deployment when the weapon is drawn/equipped</p> <p>When Called</p> <p>When the player switches to or initially equips the tool gun</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic deploy functionality\nfunction tool:deploy()\n    self.Message = \"Tool deployed\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Deploy with initialization\nfunction tool:deploy()\n    self:releaseGhostEntity()\n    self:init()\n    self:createConVars()\n    self.Message = \"Tool ready\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced deploy with validation and networking\nfunction tool:deploy()\n    local owner = self:GetOwner()\n    -- Release any existing ghost entity\n    self:releaseGhostEntity()\n    -- Initialize tool systems\n    self:init()\n    -- Create ConVars for this session\n    self:createConVars()\n    -- Validate tool mode and permissions\n    if not self:allowed() then\n        self.Message = \"Tool usage disabled\"\n        return\n    end\n    -- Check if tool mode is valid\n    local mode = self:getMode()\n    if not self.ToolModes or not self.ToolModes[mode] then\n        self.Message = \"Invalid tool mode\"\n        return\n    end\n    -- Initialize mode-specific systems\n    if SERVER then\n        -- Server-side initialization\n        self:InitializeServerSystems()\n        self:LoadPlayerData(owner)\n        -- Network tool state to client\n        net.Start(\"tool_deployed\")\n        net.WriteString(mode)\n        net.Send(owner)\n    else\n        -- Client-side initialization\n        self:InitializeClientSystems()\n        self:CreateGhostEntity()\n    end\n    -- Set initial state\n    self.Stage = 0\n    self.LastDeploy = CurTime()\n    self.Message = string.format(\"%s tool ready\", mode)\n    -- Player \" .. owner:Name() .. \" deployed \" .. mode .. \" tool\nend\n</code></pre></p>"},{"location":"meta/tool/#holster","title":"holster","text":"<p>Purpose</p> <p>Handles tool holstering when the weapon is put away/switched from</p> <p>When Called</p> <p>When the player switches away from the tool gun or puts it away</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic holster functionality\nfunction tool:holster()\n    self:releaseGhostEntity()\n    self.Message = \"Tool holstered\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Holster with cleanup\nfunction tool:holster()\n    self:releaseGhostEntity()\n    self:SaveToolData()\n    self.Stage = 0\n    self.Message = \"\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced holster with state preservation and networking\nfunction tool:holster()\n    local owner = self:GetOwner()\n    -- Release ghost entity and clean up visual elements\n    self:releaseGhostEntity()\n    -- Save current tool state if configured\n    if self:getClientInfo(\"save_state_on_holster\") == \"1\" then\n        self:SaveToolState()\n    end\n    -- Clean up temporary objects and effects\n    self:CleanupTemporaryObjects()\n    -- Reset tool state\n    self.Stage = 0\n    self.LastInteraction = nil\n    self.Message = \"\"\n    -- Handle realm-specific cleanup\n    if SERVER then\n        -- Server-side cleanup\n        self:SavePlayerData(owner)\n        self:CleanupServerObjects()\n        -- Network holster state to client\n        net.Start(\"tool_holstered\")\n        net.WriteBool(true) -- Successfully holstered\n        net.Send(owner)\n    else\n        -- Client-side cleanup\n        self:CleanupClientEffects()\n        self:ResetClientState()\n    end\n    -- Log holster action\n    -- Player \" .. owner:Name() .. \" holstered \" .. self:getMode() .. \" tool\nend\n</code></pre></p>"},{"location":"meta/tool/#holster_1","title":"holster","text":"<p>Purpose</p> <p>Handles tool holstering when the weapon is put away/switched from</p> <p>When Called</p> <p>When the player switches away from the tool gun or puts it away</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic holster functionality\nfunction tool:holster()\n    self:releaseGhostEntity()\n    self.Message = \"Tool holstered\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Holster with cleanup\nfunction tool:holster()\n    self:releaseGhostEntity()\n    self:SaveToolData()\n    self.Stage = 0\n    self.Message = \"\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced holster with state preservation and networking\nfunction tool:holster()\n    local owner = self:GetOwner()\n    -- Release ghost entity and clean up visual elements\n    self:releaseGhostEntity()\n    -- Save current tool state if configured\n    if self:getClientInfo(\"save_state_on_holster\") == \"1\" then\n        self:SaveToolState()\n    end\n    -- Clean up temporary objects and effects\n    self:CleanupTemporaryObjects()\n    -- Reset tool state\n    self.Stage = 0\n    self.LastInteraction = nil\n    self.Message = \"\"\n    -- Handle realm-specific cleanup\n    if SERVER then\n        -- Server-side cleanup\n        self:SavePlayerData(owner)\n        self:CleanupServerObjects()\n        -- Network holster state to client\n        net.Start(\"tool_holstered\")\n        net.WriteBool(true) -- Successfully holstered\n        net.Send(owner)\n    else\n        -- Client-side cleanup\n        self:CleanupClientEffects()\n        self:ResetClientState()\n    end\n    -- Log holster action\n    -- Player \" .. owner:Name() .. \" holstered \" .. self:getMode() .. \" tool\nend\n</code></pre></p>"},{"location":"meta/tool/#holster_2","title":"holster","text":"<p>Purpose</p> <p>Handles tool holstering when the weapon is put away/switched from</p> <p>When Called</p> <p>When the player switches away from the tool gun or puts it away</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic holster functionality\nfunction tool:holster()\n    self:releaseGhostEntity()\n    self.Message = \"Tool holstered\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Holster with cleanup\nfunction tool:holster()\n    self:releaseGhostEntity()\n    self:SaveToolData()\n    self.Stage = 0\n    self.Message = \"\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced holster with state preservation and networking\nfunction tool:holster()\n    local owner = self:GetOwner()\n    -- Release ghost entity and clean up visual elements\n    self:releaseGhostEntity()\n    -- Save current tool state if configured\n    if self:getClientInfo(\"save_state_on_holster\") == \"1\" then\n        self:SaveToolState()\n    end\n    -- Clean up temporary objects and effects\n    self:CleanupTemporaryObjects()\n    -- Reset tool state\n    self.Stage = 0\n    self.LastInteraction = nil\n    self.Message = \"\"\n    -- Handle realm-specific cleanup\n    if SERVER then\n        -- Server-side cleanup\n        self:SavePlayerData(owner)\n        self:CleanupServerObjects()\n        -- Network holster state to client\n        net.Start(\"tool_holstered\")\n        net.WriteBool(true) -- Successfully holstered\n        net.Send(owner)\n    else\n        -- Client-side cleanup\n        self:CleanupClientEffects()\n        self:ResetClientState()\n    end\n    -- Log holster action\n    -- Player \" .. owner:Name() .. \" holstered \" .. self:getMode() .. \" tool\nend\n</code></pre></p>"},{"location":"meta/tool/#holster_3","title":"holster","text":"<p>Purpose</p> <p>Handles tool holstering when the weapon is put away/switched from</p> <p>When Called</p> <p>When the player switches away from the tool gun or puts it away</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic holster functionality\nfunction tool:holster()\n    self:releaseGhostEntity()\n    self.Message = \"Tool holstered\"\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Holster with cleanup\nfunction tool:holster()\n    self:releaseGhostEntity()\n    self:SaveToolData()\n    self.Stage = 0\n    self.Message = \"\"\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced holster with state preservation and networking\nfunction tool:holster()\n    local owner = self:GetOwner()\n    -- Release ghost entity and clean up visual elements\n    self:releaseGhostEntity()\n    -- Save current tool state if configured\n    if self:getClientInfo(\"save_state_on_holster\") == \"1\" then\n        self:SaveToolState()\n    end\n    -- Clean up temporary objects and effects\n    self:CleanupTemporaryObjects()\n    -- Reset tool state\n    self.Stage = 0\n    self.LastInteraction = nil\n    self.Message = \"\"\n    -- Handle realm-specific cleanup\n    if SERVER then\n        -- Server-side cleanup\n        self:SavePlayerData(owner)\n        self:CleanupServerObjects()\n        -- Network holster state to client\n        net.Start(\"tool_holstered\")\n        net.WriteBool(true) -- Successfully holstered\n        net.Send(owner)\n    else\n        -- Client-side cleanup\n        self:CleanupClientEffects()\n        self:ResetClientState()\n    end\n    -- Log holster action\n    -- Player \" .. owner:Name() .. \" holstered \" .. self:getMode() .. \" tool\nend\n</code></pre></p>"},{"location":"meta/tool/#think","title":"think","text":"<p>Purpose</p> <p>Main think function called every frame while the tool is active (placeholder for custom implementation)</p> <p>When Called</p> <p>Every frame/tick while the tool gun is deployed and active</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic per-frame updates\nfunction tool:think()\n    self:releaseGhostEntity()\n    self:updateData()\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Think with ghost entity management\nfunction tool:think()\n    local owner = self:GetOwner()\n    -- Update ghost entity position if it exists\n    if not IsValid(self.GhostEntity) then\n        self:CreateGhostEntity()\n    else\n        local trace = owner:GetEyeTrace()\n        if trace.Hit then\n            self.GhostEntity:SetPos(trace.HitPos)\n            self.GhostEntity:SetAngles(trace.HitNormal:Angle())\n        end\n    end\n    -- Update tool state\n    self:updateData()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced think with multiple systems and networking\nfunction tool:think()\n    local owner = self:GetOwner()\n    local curTime = CurTime()\n    -- Rate limiting for performance\n    if not self.LastThink or curTime - self.LastThink &gt; 0.1 then\n        self.LastThink = curTime\n        -- Update ghost entity with advanced positioning\n        self:UpdateGhostEntity()\n        -- Check object validity and cleanup invalid ones\n        self:checkObjects()\n        -- Update tool data and state\n        self:updateData()\n        -- Handle player input and interactions\n        if owner:KeyDown(IN_ATTACK) and not self.LastLeftClick then\n            self:leftClick()\n            self.LastLeftClick = true\n        elseif not owner:KeyDown(IN_ATTACK) then\n            self.LastLeftClick = false\n        end\n        -- Network updates to clients (server only)\n        if SERVER and curTime - (self.LastNetworkUpdate or 0) &gt; 1.0 then\n            self:NetworkToolState()\n            self.LastNetworkUpdate = curTime\n        end\n        -- Update effects and visual feedback\n        self:UpdateVisualEffects()\n        -- Check for tool mode changes\n        if self:ShouldChangeMode() then\n            self:ChangeToolMode()\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#think_1","title":"think","text":"<p>Purpose</p> <p>Main think function called every frame while the tool is active (placeholder for custom implementation)</p> <p>When Called</p> <p>Every frame/tick while the tool gun is deployed and active</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic per-frame updates\nfunction tool:think()\n    self:releaseGhostEntity()\n    self:updateData()\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Think with ghost entity management\nfunction tool:think()\n    local owner = self:GetOwner()\n    -- Update ghost entity position if it exists\n    if not IsValid(self.GhostEntity) then\n        self:CreateGhostEntity()\n    else\n        local trace = owner:GetEyeTrace()\n        if trace.Hit then\n            self.GhostEntity:SetPos(trace.HitPos)\n            self.GhostEntity:SetAngles(trace.HitNormal:Angle())\n        end\n    end\n    -- Update tool state\n    self:updateData()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced think with multiple systems and networking\nfunction tool:think()\n    local owner = self:GetOwner()\n    local curTime = CurTime()\n    -- Rate limiting for performance\n    if not self.LastThink or curTime - self.LastThink &gt; 0.1 then\n        self.LastThink = curTime\n        -- Update ghost entity with advanced positioning\n        self:UpdateGhostEntity()\n        -- Check object validity and cleanup invalid ones\n        self:checkObjects()\n        -- Update tool data and state\n        self:updateData()\n        -- Handle player input and interactions\n        if owner:KeyDown(IN_ATTACK) and not self.LastLeftClick then\n            self:leftClick()\n            self.LastLeftClick = true\n        elseif not owner:KeyDown(IN_ATTACK) then\n            self.LastLeftClick = false\n        end\n        -- Network updates to clients (server only)\n        if SERVER and curTime - (self.LastNetworkUpdate or 0) &gt; 1.0 then\n            self:NetworkToolState()\n            self.LastNetworkUpdate = curTime\n        end\n        -- Update effects and visual feedback\n        self:UpdateVisualEffects()\n        -- Check for tool mode changes\n        if self:ShouldChangeMode() then\n            self:ChangeToolMode()\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#think_2","title":"think","text":"<p>Purpose</p> <p>Main think function called every frame while the tool is active (placeholder for custom implementation)</p> <p>When Called</p> <p>Every frame/tick while the tool gun is deployed and active</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic per-frame updates\nfunction tool:think()\n    self:releaseGhostEntity()\n    self:updateData()\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Think with ghost entity management\nfunction tool:think()\n    local owner = self:GetOwner()\n    -- Update ghost entity position if it exists\n    if not IsValid(self.GhostEntity) then\n        self:CreateGhostEntity()\n    else\n        local trace = owner:GetEyeTrace()\n        if trace.Hit then\n            self.GhostEntity:SetPos(trace.HitPos)\n            self.GhostEntity:SetAngles(trace.HitNormal:Angle())\n        end\n    end\n    -- Update tool state\n    self:updateData()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced think with multiple systems and networking\nfunction tool:think()\n    local owner = self:GetOwner()\n    local curTime = CurTime()\n    -- Rate limiting for performance\n    if not self.LastThink or curTime - self.LastThink &gt; 0.1 then\n        self.LastThink = curTime\n        -- Update ghost entity with advanced positioning\n        self:UpdateGhostEntity()\n        -- Check object validity and cleanup invalid ones\n        self:checkObjects()\n        -- Update tool data and state\n        self:updateData()\n        -- Handle player input and interactions\n        if owner:KeyDown(IN_ATTACK) and not self.LastLeftClick then\n            self:leftClick()\n            self.LastLeftClick = true\n        elseif not owner:KeyDown(IN_ATTACK) then\n            self.LastLeftClick = false\n        end\n        -- Network updates to clients (server only)\n        if SERVER and curTime - (self.LastNetworkUpdate or 0) &gt; 1.0 then\n            self:NetworkToolState()\n            self.LastNetworkUpdate = curTime\n        end\n        -- Update effects and visual feedback\n        self:UpdateVisualEffects()\n        -- Check for tool mode changes\n        if self:ShouldChangeMode() then\n            self:ChangeToolMode()\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#think_3","title":"think","text":"<p>Purpose</p> <p>Main think function called every frame while the tool is active (placeholder for custom implementation)</p> <p>When Called</p> <p>Every frame/tick while the tool gun is deployed and active</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared (can be overridden for specific tool behavior)</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic per-frame updates\nfunction tool:think()\n    self:releaseGhostEntity()\n    self:updateData()\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Think with ghost entity management\nfunction tool:think()\n    local owner = self:GetOwner()\n    -- Update ghost entity position if it exists\n    if not IsValid(self.GhostEntity) then\n        self:CreateGhostEntity()\n    else\n        local trace = owner:GetEyeTrace()\n        if trace.Hit then\n            self.GhostEntity:SetPos(trace.HitPos)\n            self.GhostEntity:SetAngles(trace.HitNormal:Angle())\n        end\n    end\n    -- Update tool state\n    self:updateData()\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced think with multiple systems and networking\nfunction tool:think()\n    local owner = self:GetOwner()\n    local curTime = CurTime()\n    -- Rate limiting for performance\n    if not self.LastThink or curTime - self.LastThink &gt; 0.1 then\n        self.LastThink = curTime\n        -- Update ghost entity with advanced positioning\n        self:UpdateGhostEntity()\n        -- Check object validity and cleanup invalid ones\n        self:checkObjects()\n        -- Update tool data and state\n        self:updateData()\n        -- Handle player input and interactions\n        if owner:KeyDown(IN_ATTACK) and not self.LastLeftClick then\n            self:leftClick()\n            self.LastLeftClick = true\n        elseif not owner:KeyDown(IN_ATTACK) then\n            self.LastLeftClick = false\n        end\n        -- Network updates to clients (server only)\n        if SERVER and curTime - (self.LastNetworkUpdate or 0) &gt; 1.0 then\n            self:NetworkToolState()\n            self.LastNetworkUpdate = curTime\n        end\n        -- Update effects and visual feedback\n        self:UpdateVisualEffects()\n        -- Check for tool mode changes\n        if self:ShouldChangeMode() then\n            self:ChangeToolMode()\n        end\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#checkobjects","title":"checkObjects","text":"<p>Purpose</p> <p>Validates and cleans up invalid objects in the tool's object list</p> <p>When Called</p> <p>Periodically during tool operation to maintain object integrity</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic object validation\nfunction tool:checkObjects()\n    for _, v in pairs(self.Objects) do\n        if not IsValid(v.Ent) then\n            self:clearObjects()\n        end\n    end\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check objects with individual cleanup\nfunction tool:checkObjects()\n    local invalidObjects = {}\n    for i, v in pairs(self.Objects) do\n        if not IsValid(v.Ent) or v.Ent:IsWorld() then\n            table.insert(invalidObjects, i)\n        end\n    end\n    -- Remove invalid objects\n    for i = #invalidObjects, 1, -1 do\n        table.remove(self.Objects, invalidObjects[i])\n    end\n    if #invalidObjects &gt; 0 then\n        self.Message = string.format(\"Cleaned up %d invalid objects\", #invalidObjects)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced object validation with networking and logging\nfunction tool:checkObjects()\n    local owner = self:GetOwner()\n    local invalidObjects = {}\n    local removedCount = 0\n    for i, obj in pairs(self.Objects) do\n        local isValid = true\n        -- Multiple validation checks\n        if not IsValid(obj.Ent) then\n            isValid = false\n        elseif obj.Ent:IsWorld() then\n            isValid = false\n        elseif SERVER and obj.Ent:GetPos():Distance(owner:GetPos()) &gt; 5000 then\n            -- Server-side distance check\n            isValid = false\n        elseif CLIENT and not obj.Ent:GetNoDraw() == false then\n            -- Client-side visibility check\n            isValid = false\n        end\n        if not isValid then\n            table.insert(invalidObjects, i)\n            -- Handle object cleanup\n            if SERVER and IsValid(obj.Ent) then\n                obj.Ent:Remove()\n            end\n            removedCount = removedCount + 1\n        end\n    end\n    -- Remove invalid object references\n    for i = #invalidObjects, 1, -1 do\n        table.remove(self.Objects, invalidObjects[i])\n    end\n    -- Handle results\n    if removedCount &gt; 0 then\n        self.Message = string.format(\"Cleaned up %d invalid objects\", removedCount)\n        if SERVER then\n            -- Network cleanup to clients\n            net.Start(\"tool_objects_cleaned\")\n            net.WriteUInt(removedCount, 8)\n            net.Broadcast()\n            -- Log cleanup action\n            -- Player \" .. owner:Name() .. \" had \" .. removedCount .. \" invalid tool objects cleaned up\n        end\n    end\n    -- Update cleanup timestamp\n    self.LastObjectCheck = CurTime()\nend\n</code></pre></p>"},{"location":"meta/tool/#checkobjects_1","title":"checkObjects","text":"<p>Purpose</p> <p>Validates and cleans up invalid objects in the tool's object list</p> <p>When Called</p> <p>Periodically during tool operation to maintain object integrity</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic object validation\nfunction tool:checkObjects()\n    for _, v in pairs(self.Objects) do\n        if not IsValid(v.Ent) then\n            self:clearObjects()\n        end\n    end\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check objects with individual cleanup\nfunction tool:checkObjects()\n    local invalidObjects = {}\n    for i, v in pairs(self.Objects) do\n        if not IsValid(v.Ent) or v.Ent:IsWorld() then\n            table.insert(invalidObjects, i)\n        end\n    end\n    -- Remove invalid objects\n    for i = #invalidObjects, 1, -1 do\n        table.remove(self.Objects, invalidObjects[i])\n    end\n    if #invalidObjects &gt; 0 then\n        self.Message = string.format(\"Cleaned up %d invalid objects\", #invalidObjects)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced object validation with networking and logging\nfunction tool:checkObjects()\n    local owner = self:GetOwner()\n    local invalidObjects = {}\n    local removedCount = 0\n    for i, obj in pairs(self.Objects) do\n        local isValid = true\n        -- Multiple validation checks\n        if not IsValid(obj.Ent) then\n            isValid = false\n        elseif obj.Ent:IsWorld() then\n            isValid = false\n        elseif SERVER and obj.Ent:GetPos():Distance(owner:GetPos()) &gt; 5000 then\n            -- Server-side distance check\n            isValid = false\n        elseif CLIENT and not obj.Ent:GetNoDraw() == false then\n            -- Client-side visibility check\n            isValid = false\n        end\n        if not isValid then\n            table.insert(invalidObjects, i)\n            -- Handle object cleanup\n            if SERVER and IsValid(obj.Ent) then\n                obj.Ent:Remove()\n            end\n            removedCount = removedCount + 1\n        end\n    end\n    -- Remove invalid object references\n    for i = #invalidObjects, 1, -1 do\n        table.remove(self.Objects, invalidObjects[i])\n    end\n    -- Handle results\n    if removedCount &gt; 0 then\n        self.Message = string.format(\"Cleaned up %d invalid objects\", removedCount)\n        if SERVER then\n            -- Network cleanup to clients\n            net.Start(\"tool_objects_cleaned\")\n            net.WriteUInt(removedCount, 8)\n            net.Broadcast()\n            -- Log cleanup action\n            -- Player \" .. owner:Name() .. \" had \" .. removedCount .. \" invalid tool objects cleaned up\n        end\n    end\n    -- Update cleanup timestamp\n    self.LastObjectCheck = CurTime()\nend\n</code></pre></p>"},{"location":"meta/tool/#checkobjects_2","title":"checkObjects","text":"<p>Purpose</p> <p>Validates and cleans up invalid objects in the tool's object list</p> <p>When Called</p> <p>Periodically during tool operation to maintain object integrity</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic object validation\nfunction tool:checkObjects()\n    for _, v in pairs(self.Objects) do\n        if not IsValid(v.Ent) then\n            self:clearObjects()\n        end\n    end\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check objects with individual cleanup\nfunction tool:checkObjects()\n    local invalidObjects = {}\n    for i, v in pairs(self.Objects) do\n        if not IsValid(v.Ent) or v.Ent:IsWorld() then\n            table.insert(invalidObjects, i)\n        end\n    end\n    -- Remove invalid objects\n    for i = #invalidObjects, 1, -1 do\n        table.remove(self.Objects, invalidObjects[i])\n    end\n    if #invalidObjects &gt; 0 then\n        self.Message = string.format(\"Cleaned up %d invalid objects\", #invalidObjects)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced object validation with networking and logging\nfunction tool:checkObjects()\n    local owner = self:GetOwner()\n    local invalidObjects = {}\n    local removedCount = 0\n    for i, obj in pairs(self.Objects) do\n        local isValid = true\n        -- Multiple validation checks\n        if not IsValid(obj.Ent) then\n            isValid = false\n        elseif obj.Ent:IsWorld() then\n            isValid = false\n        elseif SERVER and obj.Ent:GetPos():Distance(owner:GetPos()) &gt; 5000 then\n            -- Server-side distance check\n            isValid = false\n        elseif CLIENT and not obj.Ent:GetNoDraw() == false then\n            -- Client-side visibility check\n            isValid = false\n        end\n        if not isValid then\n            table.insert(invalidObjects, i)\n            -- Handle object cleanup\n            if SERVER and IsValid(obj.Ent) then\n                obj.Ent:Remove()\n            end\n            removedCount = removedCount + 1\n        end\n    end\n    -- Remove invalid object references\n    for i = #invalidObjects, 1, -1 do\n        table.remove(self.Objects, invalidObjects[i])\n    end\n    -- Handle results\n    if removedCount &gt; 0 then\n        self.Message = string.format(\"Cleaned up %d invalid objects\", removedCount)\n        if SERVER then\n            -- Network cleanup to clients\n            net.Start(\"tool_objects_cleaned\")\n            net.WriteUInt(removedCount, 8)\n            net.Broadcast()\n            -- Log cleanup action\n            -- Player \" .. owner:Name() .. \" had \" .. removedCount .. \" invalid tool objects cleaned up\n        end\n    end\n    -- Update cleanup timestamp\n    self.LastObjectCheck = CurTime()\nend\n</code></pre></p>"},{"location":"meta/tool/#checkobjects_3","title":"checkObjects","text":"<p>Purpose</p> <p>Validates and cleans up invalid objects in the tool's object list</p> <p>When Called</p> <p>Periodically during tool operation to maintain object integrity</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic object validation\nfunction tool:checkObjects()\n    for _, v in pairs(self.Objects) do\n        if not IsValid(v.Ent) then\n            self:clearObjects()\n        end\n    end\nend\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Check objects with individual cleanup\nfunction tool:checkObjects()\n    local invalidObjects = {}\n    for i, v in pairs(self.Objects) do\n        if not IsValid(v.Ent) or v.Ent:IsWorld() then\n            table.insert(invalidObjects, i)\n        end\n    end\n    -- Remove invalid objects\n    for i = #invalidObjects, 1, -1 do\n        table.remove(self.Objects, invalidObjects[i])\n    end\n    if #invalidObjects &gt; 0 then\n        self.Message = string.format(\"Cleaned up %d invalid objects\", #invalidObjects)\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced object validation with networking and logging\nfunction tool:checkObjects()\n    local owner = self:GetOwner()\n    local invalidObjects = {}\n    local removedCount = 0\n    for i, obj in pairs(self.Objects) do\n        local isValid = true\n        -- Multiple validation checks\n        if not IsValid(obj.Ent) then\n            isValid = false\n        elseif obj.Ent:IsWorld() then\n            isValid = false\n        elseif SERVER and obj.Ent:GetPos():Distance(owner:GetPos()) &gt; 5000 then\n            -- Server-side distance check\n            isValid = false\n        elseif CLIENT and not obj.Ent:GetNoDraw() == false then\n            -- Client-side visibility check\n            isValid = false\n        end\n        if not isValid then\n            table.insert(invalidObjects, i)\n            -- Handle object cleanup\n            if SERVER and IsValid(obj.Ent) then\n                obj.Ent:Remove()\n            end\n            removedCount = removedCount + 1\n        end\n    end\n    -- Remove invalid object references\n    for i = #invalidObjects, 1, -1 do\n        table.remove(self.Objects, invalidObjects[i])\n    end\n    -- Handle results\n    if removedCount &gt; 0 then\n        self.Message = string.format(\"Cleaned up %d invalid objects\", removedCount)\n        if SERVER then\n            -- Network cleanup to clients\n            net.Start(\"tool_objects_cleaned\")\n            net.WriteUInt(removedCount, 8)\n            net.Broadcast()\n            -- Log cleanup action\n            -- Player \" .. owner:Name() .. \" had \" .. removedCount .. \" invalid tool objects cleaned up\n        end\n    end\n    -- Update cleanup timestamp\n    self.LastObjectCheck = CurTime()\nend\n</code></pre></p>"},{"location":"meta/tool/#clearobjects","title":"clearObjects","text":"<p>Purpose</p> <p>Completely clears all objects from the tool's object list and performs cleanup</p> <p>When Called</p> <p>When explicitly clearing all tool objects or during error recovery</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic object clearing\ntool:clearObjects()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clear with confirmation message\nfunction tool:clearObjects()\n    local count = #self.Objects\n    self.Objects = {}\n    self.Message = string.format(\"Cleared %d objects\", count)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced clearing with individual cleanup and networking\nfunction tool:clearObjects()\n    local owner = self:GetOwner()\n    local clearedCount = #self.Objects\n    if clearedCount == 0 then return end\n    -- Clean up each object individually\n    for _, obj in pairs(self.Objects) do\n        if SERVER and IsValid(obj.Ent) then\n            -- Server-side entity cleanup\n            obj.Ent:Remove()\n            -- Remove associated data\n            if obj.Data then\n                self:CleanupObjectData(obj.Data)\n            end\n        end\n    end\n    -- Clear the objects table\n    self.Objects = {}\n    -- Reset related state\n    self.Stage = 0\n    self.SelectedEntity = nil\n    -- Update UI and notify\n    self.Message = string.format(\"Cleared %d objects\", clearedCount)\n    if SERVER then\n        -- Network clear confirmation to client\n        net.Start(\"tool_objects_cleared\")\n        net.WriteUInt(clearedCount, 16)\n        net.Send(owner)\n        -- Log the clearing action\n        print(\"Player \" .. owner:Name() .. \" cleared all \" .. clearedCount .. \" tool objects\")\n        -- Save state after clearing\n        self:SaveToolState()\n    end\n    -- Reset ghost entity if needed\n    if IsValid(self.GhostEntity) then\n        self:releaseGhostEntity()\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#clearobjects_1","title":"clearObjects","text":"<p>Purpose</p> <p>Completely clears all objects from the tool's object list and performs cleanup</p> <p>When Called</p> <p>When explicitly clearing all tool objects or during error recovery</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic object clearing\ntool:clearObjects()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clear with confirmation message\nfunction tool:clearObjects()\n    local count = #self.Objects\n    self.Objects = {}\n    self.Message = string.format(\"Cleared %d objects\", count)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced clearing with individual cleanup and networking\nfunction tool:clearObjects()\n    local owner = self:GetOwner()\n    local clearedCount = #self.Objects\n    if clearedCount == 0 then return end\n    -- Clean up each object individually\n    for _, obj in pairs(self.Objects) do\n        if SERVER and IsValid(obj.Ent) then\n            -- Server-side entity cleanup\n            obj.Ent:Remove()\n            -- Remove associated data\n            if obj.Data then\n                self:CleanupObjectData(obj.Data)\n            end\n        end\n    end\n    -- Clear the objects table\n    self.Objects = {}\n    -- Reset related state\n    self.Stage = 0\n    self.SelectedEntity = nil\n    -- Update UI and notify\n    self.Message = string.format(\"Cleared %d objects\", clearedCount)\n    if SERVER then\n        -- Network clear confirmation to client\n        net.Start(\"tool_objects_cleared\")\n        net.WriteUInt(clearedCount, 16)\n        net.Send(owner)\n        -- Log the clearing action\n        print(\"Player \" .. owner:Name() .. \" cleared all \" .. clearedCount .. \" tool objects\")\n        -- Save state after clearing\n        self:SaveToolState()\n    end\n    -- Reset ghost entity if needed\n    if IsValid(self.GhostEntity) then\n        self:releaseGhostEntity()\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#clearobjects_2","title":"clearObjects","text":"<p>Purpose</p> <p>Completely clears all objects from the tool's object list and performs cleanup</p> <p>When Called</p> <p>When explicitly clearing all tool objects or during error recovery</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic object clearing\ntool:clearObjects()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Clear with confirmation message\nfunction tool:clearObjects()\n    local count = #self.Objects\n    self.Objects = {}\n    self.Message = string.format(\"Cleared %d objects\", count)\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced clearing with individual cleanup and networking\nfunction tool:clearObjects()\n    local owner = self:GetOwner()\n    local clearedCount = #self.Objects\n    if clearedCount == 0 then return end\n    -- Clean up each object individually\n    for _, obj in pairs(self.Objects) do\n        if SERVER and IsValid(obj.Ent) then\n            -- Server-side entity cleanup\n            obj.Ent:Remove()\n            -- Remove associated data\n            if obj.Data then\n                self:CleanupObjectData(obj.Data)\n            end\n        end\n    end\n    -- Clear the objects table\n    self.Objects = {}\n    -- Reset related state\n    self.Stage = 0\n    self.SelectedEntity = nil\n    -- Update UI and notify\n    self.Message = string.format(\"Cleared %d objects\", clearedCount)\n    if SERVER then\n        -- Network clear confirmation to client\n        net.Start(\"tool_objects_cleared\")\n        net.WriteUInt(clearedCount, 16)\n        net.Send(owner)\n        -- Log the clearing action\n        print(\"Player \" .. owner:Name() .. \" cleared all \" .. clearedCount .. \" tool objects\")\n        -- Save state after clearing\n        self:SaveToolState()\n    end\n    -- Reset ghost entity if needed\n    if IsValid(self.GhostEntity) then\n        self:releaseGhostEntity()\n    end\nend\n</code></pre></p>"},{"location":"meta/tool/#releaseghostentity","title":"releaseGhostEntity","text":"<p>Purpose</p> <p>Safely removes and cleans up the ghost entity used for preview/placement</p> <p>When Called</p> <p>When switching tools, holstering, or when the ghost entity is no longer needed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic ghost entity cleanup\ntool:releaseGhostEntity()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Release with effects cleanup\nfunction tool:releaseGhostEntity()\n    if IsValid(self.GhostEntity) then\n        -- Remove associated effects\n        if self.GhostEffects then\n            for _, effect in pairs(self.GhostEffects) do\n                effect:Remove()\n            end\n            self.GhostEffects = nil\n        end\n        SafeRemoveEntity(self.GhostEntity)\n        self.GhostEntity = nil\n        self.Message = \"Ghost entity removed\"\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced ghost entity management with networking\nfunction tool:releaseGhostEntity()\n    local owner = self:GetOwner()\n    if IsValid(self.GhostEntity) then\n        -- Store ghost entity data before removal (if needed)\n        if self:getClientInfo(\"preserve_ghost_data\") == \"1\" then\n            self.LastGhostData = {\n            Model = self.GhostEntity:GetModel(),\n            Pos = self.GhostEntity:GetPos(),\n            Ang = self.GhostEntity:GetAngles(),\n            Time = CurTime()\n            }\n        end\n        -- Clean up associated effects and particles\n        self:CleanupGhostEffects()\n        -- Remove the ghost entity safely\n        SafeRemoveEntity(self.GhostEntity)\n        self.GhostEntity = nil\n        -- Reset ghost-related state\n        self.GhostStage = 0\n        self.GhostLastUpdate = nil\n        -- Update UI\n        self.Message = \"Preview removed\"\n        if SERVER then\n            -- Network ghost removal to clients\n            net.Start(\"tool_ghost_removed\")\n            net.WriteEntity(owner)\n            net.Broadcast()\n            -- Log ghost entity removal\n            print(string.format(\"Player %s removed ghost entity for %s tool\",\n            owner:Name(), self:getMode()))\n            else\n                -- Client-side cleanup confirmation\n                self:ResetGhostMaterials()\n            end\n        end\n    end\n</code></pre></p>"},{"location":"meta/tool/#releaseghostentity_1","title":"releaseGhostEntity","text":"<p>Purpose</p> <p>Safely removes and cleans up the ghost entity used for preview/placement</p> <p>When Called</p> <p>When switching tools, holstering, or when the ghost entity is no longer needed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic ghost entity cleanup\ntool:releaseGhostEntity()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Release with effects cleanup\nfunction tool:releaseGhostEntity()\n    if IsValid(self.GhostEntity) then\n        -- Remove associated effects\n        if self.GhostEffects then\n            for _, effect in pairs(self.GhostEffects) do\n                effect:Remove()\n            end\n            self.GhostEffects = nil\n        end\n        SafeRemoveEntity(self.GhostEntity)\n        self.GhostEntity = nil\n        self.Message = \"Ghost entity removed\"\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced ghost entity management with networking\nfunction tool:releaseGhostEntity()\n    local owner = self:GetOwner()\n    if IsValid(self.GhostEntity) then\n        -- Store ghost entity data before removal (if needed)\n        if self:getClientInfo(\"preserve_ghost_data\") == \"1\" then\n            self.LastGhostData = {\n            Model = self.GhostEntity:GetModel(),\n            Pos = self.GhostEntity:GetPos(),\n            Ang = self.GhostEntity:GetAngles(),\n            Time = CurTime()\n            }\n        end\n        -- Clean up associated effects and particles\n        self:CleanupGhostEffects()\n        -- Remove the ghost entity safely\n        SafeRemoveEntity(self.GhostEntity)\n        self.GhostEntity = nil\n        -- Reset ghost-related state\n        self.GhostStage = 0\n        self.GhostLastUpdate = nil\n        -- Update UI\n        self.Message = \"Preview removed\"\n        if SERVER then\n            -- Network ghost removal to clients\n            net.Start(\"tool_ghost_removed\")\n            net.WriteEntity(owner)\n            net.Broadcast()\n            -- Log ghost entity removal\n            print(string.format(\"Player %s removed ghost entity for %s tool\",\n            owner:Name(), self:getMode()))\n            else\n                -- Client-side cleanup confirmation\n                self:ResetGhostMaterials()\n            end\n        end\n    end\n</code></pre></p>"},{"location":"meta/tool/#releaseghostentity_2","title":"releaseGhostEntity","text":"<p>Purpose</p> <p>Safely removes and cleans up the ghost entity used for preview/placement</p> <p>When Called</p> <p>When switching tools, holstering, or when the ghost entity is no longer needed</p> <p>Returns</p> <ul> <li>None</li> </ul> <p>Realm</p> <p>Shared</p> <p>Example Usage</p> <p>Low Complexity: <pre><code>-- Simple: Basic ghost entity cleanup\ntool:releaseGhostEntity()\n</code></pre></p> <p>Medium Complexity: <pre><code>-- Medium: Release with effects cleanup\nfunction tool:releaseGhostEntity()\n    if IsValid(self.GhostEntity) then\n        -- Remove associated effects\n        if self.GhostEffects then\n            for _, effect in pairs(self.GhostEffects) do\n                effect:Remove()\n            end\n            self.GhostEffects = nil\n        end\n        SafeRemoveEntity(self.GhostEntity)\n        self.GhostEntity = nil\n        self.Message = \"Ghost entity removed\"\n    end\nend\n</code></pre></p> <p>High Complexity: <pre><code>-- High: Advanced ghost entity management with networking\nfunction tool:releaseGhostEntity()\n    local owner = self:GetOwner()\n    if IsValid(self.GhostEntity) then\n        -- Store ghost entity data before removal (if needed)\n        if self:getClientInfo(\"preserve_ghost_data\") == \"1\" then\n            self.LastGhostData = {\n            Model = self.GhostEntity:GetModel(),\n            Pos = self.GhostEntity:GetPos(),\n            Ang = self.GhostEntity:GetAngles(),\n            Time = CurTime()\n            }\n        end\n        -- Clean up associated effects and particles\n        self:CleanupGhostEffects()\n        -- Remove the ghost entity safely\n        SafeRemoveEntity(self.GhostEntity)\n        self.GhostEntity = nil\n        -- Reset ghost-related state\n        self.GhostStage = 0\n        self.GhostLastUpdate = nil\n        -- Update UI\n        self.Message = \"Preview removed\"\n        if SERVER then\n            -- Network ghost removal to clients\n            net.Start(\"tool_ghost_removed\")\n            net.WriteEntity(owner)\n            net.Broadcast()\n            -- Log ghost entity removal\n            print(string.format(\"Player %s removed ghost entity for %s tool\",\n            owner:Name(), self:getMode()))\n            else\n                -- Client-side cleanup confirmation\n                self:ResetGhostMaterials()\n            end\n        end\n    end\n</code></pre></p>"},{"location":"modules/","title":"Modules","text":"<ul> <li> <p>AFK Protection</p> </li> <li> <p>Advertisements</p> </li> <li> <p>Alcoholism</p> </li> <li> <p>Anonymous Rumors</p> </li> <li> <p>Anonymous Rumors</p> </li> <li> <p>Auto Restarter</p> </li> <li> <p>Body Group Editor</p> </li> <li> <p>Broadcasts</p> </li> <li> <p>Captions</p> </li> <li> <p>Cards</p> </li> <li> <p>Chat Messages</p> </li> <li> <p>Cinematic Text</p> </li> <li> <p>Cinematic Text</p> </li> <li> <p>Code Utilities</p> </li> <li> <p>Code Utilities</p> </li> <li> <p>Code Utilities</p> </li> <li> <p>Community Commands</p> </li> <li> <p>Corpse ID</p> </li> <li> <p>Corpse ID</p> </li> <li> <p>Cutscenes</p> </li> <li> <p>Damage Numbers</p> </li> <li> <p>Development HUD</p> </li> <li> <p>Development Server</p> </li> <li> <p>Donator</p> </li> <li> <p>Door Kick</p> </li> <li> <p>Enhanced Death</p> </li> <li> <p>Extended Descriptions</p> </li> <li> <p>Extended Descriptions</p> </li> <li> <p>Flashlight</p> </li> <li> <p>Free Look</p> </li> <li> <p>Gamemaster Points</p> </li> <li> <p>HUD Extras</p> </li> <li> <p>Instakill</p> </li> <li> <p>Join Leave Messages</p> </li> <li> <p>Join Leave Messages</p> </li> <li> <p>Loyalism</p> </li> <li> <p>Map Cleaner</p> </li> <li> <p>Map Cleaner</p> </li> <li> <p>Model Tweaker</p> </li> <li> <p>Model Tweaker</p> </li> <li> <p>NPC Spawner</p> </li> <li> <p>Perma Remove</p> </li> <li> <p>Radio</p> </li> <li> <p>Raised Weapons</p> </li> <li> <p>Raised Weapons</p> </li> <li> <p>Simple Lockpicking</p> </li> <li> <p>Slot Machine</p> </li> <li> <p>Slot Machine</p> </li> <li> <p>Slot Machine</p> </li> <li> <p>Tying</p> </li> <li> <p>War Table</p> </li> <li> <p>Word Filter</p> </li> </ul>"},{"location":"modules/advert/about/","title":"About","text":"About <p>Name: Advertisements</p> <p>Description:</p> <p>Implements a paid /advert command for server-wide announcements. Messages are colored, logged, and throttled by a cooldown to curb spam.</p> Features <ul> <li>Adds a paid /advert command players can use</li> <li>Adds a cooldown via AdvertCooldown to limit spam</li> <li>Adds colored broadcast messages across the server</li> <li>Adds price control via AdvertPrice configuration</li> <li>Adds notifications when players lack funds</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/advert/changelog/","title":"Changelog","text":""},{"location":"modules/advert/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/advert/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/advert/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Advertisement module.</p>"},{"location":"modules/advert/hooks/#advertsent","title":"AdvertSent","text":"<p>Purpose</p> <p>Called when a player successfully sends an advertisement message through the <code>/advert</code> command.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who sent the advertisement.</li> <li><code>message</code> (string): The advertisement message content.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - The player has sufficient funds to pay for the advertisement - The cooldown period has passed - The money has been deducted from the player's character - The advertisement has been broadcast to all players - The advertisement has been logged</p> <p>Example Usage</p> <pre><code>-- Track advertisement statistics\nhook.Add(\"AdvertSent\", \"TrackAdvertStats\", function(client, message)\n    local char = client:getChar()\n    if char then\n        local currentAds = char:getData(\"advertisements_sent\", 0)\n        char:setData(\"advertisements_sent\", currentAds + 1)\n    end\nend)\n\n-- Log advertisements to external system\nhook.Add(\"AdvertSent\", \"LogToExternalSystem\", function(client, message)\n    local data = {\n        player = client:SteamID(),\n        name = client:Name(),\n        message = message,\n        timestamp = os.time()\n    }\n\n    -- Send to external logging service\n    http.Post(\"https://your-logging-service.com/advertisements\", data, function(response)\n        print(\"Advertisement logged to external system\")\n    end)\nend)\n\n-- Award achievement for first advertisement\nhook.Add(\"AdvertSent\", \"FirstAdvertAchievement\", function(client, message)\n    local char = client:getChar()\n    if char and not char:getData(\"first_advertisement\", false) then\n        char:setData(\"first_advertisement\", true)\n        client:notify(\"Congratulations! You've sent your first advertisement!\")\n\n        -- Award some bonus money for first advertisement\n        char:giveMoney(50)\n        client:notify(\"You received a 50 credit bonus for your first advertisement!\")\n    end\nend)\n\n-- Filter inappropriate content\nhook.Add(\"AdvertSent\", \"ContentFilter\", function(client, message)\n    local filteredWords = {\"spam\", \"scam\", \"hack\"}\n\n    for _, word in ipairs(filteredWords) do\n        if string.find(string.lower(message), word) then\n            client:notify(\"Your advertisement contains inappropriate content and has been flagged for review.\")\n\n            -- Notify administrators\n            for _, admin in player.Iterator() do\n                if admin:IsAdmin() then\n                    admin:notify(client:Name() .. \" sent a potentially inappropriate advertisement: \" .. message)\n                end\n            end\n            break\n        end\n    end\nend)\n\n-- Track advertisement costs for analytics\nhook.Add(\"AdvertSent\", \"AdvertAnalytics\", function(client, message)\n    local advertPrice = lia.config.get(\"AdvertPrice\", 10)\n    local char = client:getChar()\n\n    if char then\n        local totalSpent = char:getData(\"total_advert_spent\", 0)\n        char:setData(\"total_advert_spent\", totalSpent + advertPrice)\n\n        -- Check if player has spent over 100 credits on advertisements\n        if totalSpent + advertPrice &gt;= 100 then\n            client:notify(\"You've spent over 100 credits on advertisements! You're a true advertiser!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/afk/about/","title":"About","text":"About <p>Name: AFK Protection</p> <p>Description:</p> <p>Comprehensive AFK protection system that automatically detects inactive players and prevents exploitation of AFK players.</p> Features <ul> <li>Adds automatic AFK detection based on player activity</li> <li>Adds protection against tying up, arresting, or stunning AFK players</li> <li>Adds configurable AFK timeout duration and enable/disable toggle</li> <li>Adds admin commands for managing player AFK status</li> <li>Adds visual indicators for AFK status in character info and HUD</li> <li>Adds multi-language support for all text elements</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/afk/changelog/","title":"Changelog","text":""},{"location":"modules/afk/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Better UI</li> </ul>"},{"location":"modules/afk/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Added comprehensive multi-language support (English, Spanish, French, German, Portuguese, Italian)</li> <li>Updated all hardcoded strings to use language system</li> <li>Enhanced module description with detailed feature list</li> <li>Improved documentation with complete feature overview</li> <li>Updated version number to reflect improvements</li> <li>Add Docs</li> </ul>"},{"location":"modules/afk/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/alcoholism/about/","title":"About","text":"About <p>Name: Alcoholism</p> <p>Description:</p> <p>Adds drinkable alcohol that increases a player's intoxication level. High BAC blurs vision and slows movement until the effect wears off.</p> Features <ul> <li>Adds alcohol items that raise BAC and gradually wear off</li> <li>Adds screen blur and movement effects that scale with intoxication</li> <li>Adds player notification when reaching DrunkNotifyThreshold</li> <li>Adds configurable BAC settings like AlcoholTickTime</li> <li>Adds multiple drink items with varying strength</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/alcoholism/changelog/","title":"Changelog","text":""},{"location":"modules/alcoholism/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency:</li> <li><code>ResetBAC()</code> \u2192 <code>resetBAC()</code></li> <li><code>AddBAC()</code> \u2192 <code>addBAC()</code></li> <li><code>IsDrunk()</code> \u2192 <code>isDrunk()</code></li> <li><code>GetBAC()</code> \u2192 <code>getBAC()</code></li> </ul>"},{"location":"modules/alcoholism/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/alcoholism/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/alcoholism/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Alcoholism module for managing Blood Alcohol Content (BAC) and alcohol-related effects.</p>"},{"location":"modules/alcoholism/hooks/#alcoholconsumed","title":"AlcoholConsumed","text":"<p>Purpose</p> <p>Called when a player consumes an alcoholic item.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who consumed the alcohol.</li> <li><code>item</code> (Item): The alcohol item that was consumed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - The player uses an alcohol item - The BAC has been increased via <code>AddBAC()</code> - The item has been consumed</p> <p>Example Usage</p> <pre><code>-- Track alcohol consumption statistics\nhook.Add(\"AlcoholConsumed\", \"TrackAlcoholStats\", function(client, item)\n    local char = client:getChar()\n    if char then\n        local drinksConsumed = char:getData(\"drinks_consumed\", 0)\n        char:setData(\"drinks_consumed\", drinksConsumed + 1)\n\n        -- Track specific alcohol types\n        local alcoholType = char:getData(\"alcohol_\" .. item.uniqueID, 0)\n        char:setData(\"alcohol_\" .. item.uniqueID, alcoholType + 1)\n    end\nend)\n\n-- Award achievement for first drink\nhook.Add(\"AlcoholConsumed\", \"FirstDrinkAchievement\", function(client, item)\n    local char = client:getChar()\n    if char and not char:getData(\"first_drink\", false) then\n        char:setData(\"first_drink\", true)\n        client:notify(\"Achievement Unlocked: First Sip!\")\n    end\nend)\n\n-- Log alcohol consumption for moderation\nhook.Add(\"AlcoholConsumed\", \"LogAlcoholConsumption\", function(client, item)\n    lia.log.add(client, \"alcoholConsumed\", item.name, item.abv)\n\n    -- Notify moderators if high ABV alcohol is consumed\n    if item.abv &gt; 50 then\n        for _, admin in player.Iterator() do\n            if admin:IsAdmin() then\n                admin:notify(client:Name() .. \" consumed \" .. item.name .. \" (\" .. item.abv .. \"% ABV)\")\n            end\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/alcoholism/hooks/#bacchanged","title":"BACChanged","text":"<p>Purpose</p> <p>Called whenever a player's Blood Alcohol Content (BAC) changes, either through increase or decrease.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose BAC changed.</li> <li><code>newBac</code> (number): The new BAC value (0-100).</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered: - When BAC is increased via <code>AddBAC()</code> - When BAC is decreased through natural degradation - When BAC is reset via <code>ResetBAC()</code></p> <p>Example Usage</p> <pre><code>-- Update client-side effects based on BAC\nhook.Add(\"BACChanged\", \"UpdateAlcoholEffects\", function(client, newBac)\n    -- Send BAC update to client\n    net.Start(\"UpdateBAC\")\n    net.WriteFloat(newBac)\n    net.Send(client)\n\n    -- Update player's drunk status\n    if newBac &gt; 50 then\n        client:setNetVar(\"isDrunk\", true)\n    else\n        client:setNetVar(\"isDrunk\", false)\n    end\nend)\n\n-- Track BAC changes for analytics\nhook.Add(\"BACChanged\", \"TrackBACChanges\", function(client, newBac)\n    local char = client:getChar()\n    if char then\n        char:setData(\"last_bac_change\", os.time())\n        char:setData(\"peak_bac\", math.max(char:getData(\"peak_bac\", 0), newBac))\n    end\nend)\n</code></pre>"},{"location":"modules/alcoholism/hooks/#bacincreased","title":"BACIncreased","text":"<p>Purpose</p> <p>Called when a player's BAC is increased through alcohol consumption.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose BAC increased.</li> <li><code>amount</code> (number): The amount of BAC that was added.</li> <li><code>newBac</code> (number): The new BAC value after the increase.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - <code>PreBACIncrease</code> hook - BAC has been increased via <code>AddBAC()</code> - <code>BACChanged</code> hook</p> <p>Example Usage</p> <pre><code>-- Apply immediate effects for BAC increase\nhook.Add(\"BACIncreased\", \"ApplyBACEffects\", function(client, amount, newBac)\n    -- Apply screen effects based on BAC level\n    if newBac &gt; 30 then\n        client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 1, 0)\n    end\n\n    -- Apply movement effects\n    if newBac &gt; 50 then\n        client:SetWalkSpeed(client:GetWalkSpeed() * 0.8)\n        client:SetRunSpeed(client:GetRunSpeed() * 0.8)\n    end\nend)\n\n-- Track BAC increase patterns\nhook.Add(\"BACIncreased\", \"TrackBACPatterns\", function(client, amount, newBac)\n    local char = client:getChar()\n    if char then\n        local increases = char:getData(\"bac_increases\", 0)\n        char:setData(\"bac_increases\", increases + 1)\n\n        -- Track rapid drinking\n        local lastIncrease = char:getData(\"last_bac_increase\", 0)\n        if os.time() - lastIncrease &lt; 60 then\n            char:setData(\"rapid_drinking\", true)\n        end\n        char:setData(\"last_bac_increase\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/alcoholism/hooks/#bacreset","title":"BACReset","text":"<p>Purpose</p> <p>Called when a player's BAC is reset to 0.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose BAC was reset.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - <code>PreBACReset</code> hook - BAC has been set to 0 - <code>BACChanged</code> hook</p> <p>Example Usage</p> <pre><code>-- Restore player abilities when BAC is reset\nhook.Add(\"BACReset\", \"RestorePlayerAbilities\", function(client)\n    -- Restore normal movement speeds\n    client:SetWalkSpeed(200)\n    client:SetRunSpeed(400)\n\n    -- Clear drunk status\n    client:setNetVar(\"isDrunk\", false)\n\n    -- Remove screen effects\n    client:ScreenFade(SCREENFADE.OUT, Color(0, 0, 0, 0), 0.5, 0)\nend)\n\n-- Track sobriety achievements\nhook.Add(\"BACReset\", \"SobrietyAchievement\", function(client)\n    local char = client:getChar()\n    if char then\n        local soberResets = char:getData(\"sober_resets\", 0)\n        char:setData(\"sober_resets\", soberResets + 1)\n\n        if soberResets &gt;= 10 then\n            client:notify(\"Achievement: Sober as a Judge!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/alcoholism/hooks/#bacthresholdreached","title":"BACThresholdReached","text":"<p>Purpose</p> <p>Called when a player's BAC reaches or exceeds the drunk notification threshold.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who reached the threshold.</li> <li><code>newBac</code> (number): The BAC value that triggered the threshold.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - BAC increases from below the threshold to at or above it - The threshold is defined by <code>DrunkNotifyThreshold</code> config (default: 50)</p> <p>Example Usage</p> <pre><code>-- Notify player they are now drunk\nhook.Add(\"BACThresholdReached\", \"NotifyDrunkStatus\", function(client, newBac)\n    client:notify(\"You are now feeling the effects of alcohol!\")\n    client:ChatPrint(\"Your BAC is \" .. newBac .. \"% - you are legally drunk!\")\nend)\n\n-- Apply drunk status effects\nhook.Add(\"BACThresholdReached\", \"ApplyDrunkEffects\", function(client, newBac)\n    -- Apply drunk HUD overlay\n    client:setNetVar(\"showDrunkHUD\", true)\n\n    -- Start drunk camera effects\n    net.Start(\"StartDrunkEffects\")\n    net.WriteFloat(newBac)\n    net.Send(client)\nend)\n\n-- Track drunk incidents\nhook.Add(\"BACThresholdReached\", \"TrackDrunkIncidents\", function(client, newBac)\n    lia.log.add(client, \"drunkThreshold\", newBac)\n\n    -- Notify staff\n    for _, admin in player.Iterator() do\n        if admin:IsAdmin() then\n            admin:notify(client:Name() .. \" has reached drunk threshold (BAC: \" .. newBac .. \"%)\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/alcoholism/hooks/#postbacdecrease","title":"PostBACDecrease","text":"<p>Purpose</p> <p>Called after a player's BAC has been decreased through natural degradation.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose BAC decreased.</li> <li><code>newBac</code> (number): The new BAC value after the decrease.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - <code>PreBACDecrease</code> hook - BAC has been decreased through the Think loop - <code>BACChanged</code> hook</p> <p>Example Usage</p> <pre><code>-- Update effects based on decreased BAC\nhook.Add(\"PostBACDecrease\", \"UpdateDecreasedBAC\", function(client, newBac)\n    -- Reduce screen effects as BAC decreases\n    if newBac &lt; 30 then\n        client:ScreenFade(SCREENFADE.OUT, Color(0, 0, 0, 0), 2, 0)\n    end\n\n    -- Gradually restore movement speed\n    local baseWalkSpeed = 200\n    local baseRunSpeed = 400\n    local speedMultiplier = math.max(0.8, 1 - (newBac / 100))\n\n    client:SetWalkSpeed(baseWalkSpeed * speedMultiplier)\n    client:SetRunSpeed(baseRunSpeed * speedMultiplier)\nend)\n\n-- Track recovery time\nhook.Add(\"PostBACDecrease\", \"TrackRecovery\", function(client, newBac)\n    local char = client:getChar()\n    if char and newBac == 0 then\n        local recoveryTime = os.time() - char:getData(\"last_drunk_time\", 0)\n        char:setData(\"last_recovery_time\", recoveryTime)\n        client:notify(\"You have fully recovered from alcohol effects!\")\n    end\nend)\n</code></pre>"},{"location":"modules/alcoholism/hooks/#postbacreset","title":"PostBACReset","text":"<p>Purpose</p> <p>Called after a player's BAC has been completely reset to 0.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose BAC was reset.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - <code>PreBACReset</code> hook - BAC has been set to 0 - <code>BACChanged</code> hook - <code>BACReset</code> hook</p> <p>Example Usage</p> <pre><code>-- Clean up all alcohol-related effects\nhook.Add(\"PostBACReset\", \"CleanupAlcoholEffects\", function(client)\n    -- Remove all drunk-related netvars\n    client:setNetVar(\"isDrunk\", false)\n    client:setNetVar(\"showDrunkHUD\", false)\n\n    -- Stop all drunk effects on client\n    net.Start(\"StopAllDrunkEffects\")\n    net.Send(client)\n\n    -- Restore normal player state\n    client:SetWalkSpeed(200)\n    client:SetRunSpeed(400)\nend)\n\n-- Award sobriety bonus\nhook.Add(\"PostBACReset\", \"SobrietyBonus\", function(client)\n    local char = client:getChar()\n    if char then\n        -- Give small money bonus for staying sober\n        char:giveMoney(10)\n        client:notify(\"You received 10 credits for maintaining sobriety!\")\n    end\nend)\n</code></pre>"},{"location":"modules/alcoholism/hooks/#prebacdecrease","title":"PreBACDecrease","text":"<p>Purpose</p> <p>Called before a player's BAC is decreased through natural degradation.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose BAC will decrease.</li> <li><code>currentBac</code> (number): The current BAC value before the decrease.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered before: - BAC is decreased through the Think loop - <code>BACChanged</code> hook - <code>PostBACDecrease</code> hook</p> <p>Example Usage</p> <pre><code>-- Track when BAC starts decreasing\nhook.Add(\"PreBACDecrease\", \"TrackBACDecrease\", function(client, currentBac)\n    local char = client:getChar()\n    if char then\n        char:setData(\"last_bac_decrease\", os.time())\n\n        -- Track how long player was drunk\n        if currentBac &gt;= 50 then\n            local drunkStartTime = char:getData(\"drunk_start_time\", 0)\n            if drunkStartTime &gt; 0 then\n                local drunkDuration = os.time() - drunkStartTime\n                char:setData(\"total_drunk_time\", char:getData(\"total_drunk_time\", 0) + drunkDuration)\n            end\n        end\n    end\nend)\n\n-- Prevent BAC decrease under certain conditions\nhook.Add(\"PreBACDecrease\", \"PreventBACDecrease\", function(client, currentBac)\n    local char = client:getChar()\n    if char and char:getData(\"alcohol_immunity\", false) then\n        -- Player has alcohol immunity, prevent decrease\n        return false\n    end\nend)\n</code></pre>"},{"location":"modules/alcoholism/hooks/#prebacincrease","title":"PreBACIncrease","text":"<p>Purpose</p> <p>Called before a player's BAC is increased through alcohol consumption.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose BAC will increase.</li> <li><code>amount</code> (number): The amount of BAC that will be added.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered before: - BAC is increased via <code>AddBAC()</code> - <code>BACChanged</code> hook - <code>BACIncreased</code> hook</p> <p>Example Usage</p> <pre><code>-- Modify BAC increase amount based on player traits\nhook.Add(\"PreBACIncrease\", \"ModifyBACIncrease\", function(client, amount)\n    local char = client:getChar()\n    if char then\n        -- Check for alcohol tolerance trait\n        local tolerance = char:getData(\"alcohol_tolerance\", 1)\n        if tolerance &gt; 1 then\n            -- Reduce BAC increase for tolerant players\n            amount = amount * (1 / tolerance)\n        end\n\n        -- Check for alcohol resistance\n        local resistance = char:getData(\"alcohol_resistance\", 0)\n        if resistance &gt; 0 then\n            amount = math.max(0, amount - resistance)\n        end\n    end\n\n    return amount\nend)\n\n-- Track BAC increase attempts\nhook.Add(\"PreBACIncrease\", \"TrackBACAttempts\", function(client, amount)\n    local char = client:getChar()\n    if char then\n        local attempts = char:getData(\"bac_increase_attempts\", 0)\n        char:setData(\"bac_increase_attempts\", attempts + 1)\n\n        -- Log large BAC increases\n        if amount &gt; 20 then\n            lia.log.add(client, \"largeBACIncrease\", amount)\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/alcoholism/hooks/#prebacreset","title":"PreBACReset","text":"<p>Purpose</p> <p>Called before a player's BAC is reset to 0.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose BAC will be reset.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered before: - BAC is set to 0 - <code>BACChanged</code> hook - <code>BACReset</code> hook - <code>PostBACReset</code> hook</p> <p>Example Usage</p> <pre><code>-- Track BAC reset events\nhook.Add(\"PreBACReset\", \"TrackBACReset\", function(client)\n    local char = client:getChar()\n    if char then\n        local currentBac = client:GetBAC()\n        char:setData(\"last_reset_bac\", currentBac)\n        char:setData(\"total_resets\", char:getData(\"total_resets\", 0) + 1)\n\n        -- Log BAC reset\n        lia.log.add(client, \"bacReset\", currentBac)\n    end\nend)\n\n-- Prevent BAC reset under certain conditions\nhook.Add(\"PreBACReset\", \"PreventBACReset\", function(client)\n    local char = client:getChar()\n    if char and char:getData(\"forced_drunk\", false) then\n        -- Player is forced to be drunk, prevent reset\n        client:notify(\"You cannot sober up right now!\")\n        return false\n    end\nend)\n\n-- Apply reset penalties\nhook.Add(\"PreBACReset\", \"ApplyResetPenalties\", function(client)\n    local char = client:getChar()\n    if char then\n        local currentBac = client:GetBAC()\n        if currentBac &gt; 80 then\n            -- Heavy penalty for resetting while very drunk\n            char:takeMoney(50)\n            client:notify(\"You lost 50 credits for resetting while heavily intoxicated!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/autorestarter/about/","title":"About","text":"About <p>Name: Auto Restarter</p> <p>Description:</p> <p>Schedules automatic server restarts at set intervals. Players see a countdown so they can prepare before the map changes.</p> Features <ul> <li>Adds scheduling for automatic restarts using RestartInterval</li> <li>Adds a countdown overlay configurable via RestartCountdownFont</li> <li>Adds syncing of next restart time to clients</li> <li>Adds automatic changelevel when the timer expires</li> <li>Adds network messages to sync the restart countdown</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/autorestarter/changelog/","title":"Changelog","text":""},{"location":"modules/autorestarter/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/autorestarter/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/autorestarter/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Auto Restarter module for managing automatic server restarts and countdown notifications.</p>"},{"location":"modules/autorestarter/hooks/#autorestart","title":"AutoRestart","text":"<p>Purpose</p> <p>Called when the server is about to restart due to the automatic restart timer.</p> <p>Parameters</p> <ul> <li><code>timestamp</code> (number): The Unix timestamp when the restart was triggered.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The restart timer expires - The server is about to execute the changelevel command - After <code>AutoRestartScheduled</code> hook</p> <p>Example Usage</p> <pre><code>-- Save important data before restart\nhook.Add(\"AutoRestart\", \"SaveDataBeforeRestart\", function(timestamp)\n    -- Save player data\n    for _, ply in player.Iterator() do\n        if ply:getChar() then\n            ply:getChar():save()\n        end\n    end\n\n    -- Save server statistics\n    local stats = {\n        restart_time = timestamp,\n        player_count = #player.GetAll(),\n        uptime = os.time() - server_start_time\n    }\n\n    file.Write(\"server_restart_stats.json\", util.TableToJSON(stats))\nend)\n\n-- Notify external systems about restart\nhook.Add(\"AutoRestart\", \"NotifyExternalSystems\", function(timestamp)\n    -- Send restart notification to Discord webhook\n    local webhook = \"https://discord.com/api/webhooks/YOUR_WEBHOOK_URL\"\n    local data = {\n        content = \"Server is restarting automatically at \" .. os.date(\"%Y-%m-%d %H:%M:%S\", timestamp)\n    }\n\n    http.Post(webhook, data, function(response)\n        print(\"Restart notification sent to Discord\")\n    end)\nend)\n\n-- Log restart event\nhook.Add(\"AutoRestart\", \"LogRestartEvent\", function(timestamp)\n    lia.log.add(nil, \"autoRestart\", timestamp)\n    print(\"Auto restart triggered at \" .. os.date(\"%Y-%m-%d %H:%M:%S\", timestamp))\nend)\n</code></pre>"},{"location":"modules/autorestarter/hooks/#autorestartcountdown","title":"AutoRestartCountdown","text":"<p>Purpose</p> <p>Called when the restart countdown is active (within 25% of the restart interval).</p> <p>Parameters</p> <ul> <li><code>remaining</code> (number): The remaining seconds until restart.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The remaining time is within 25% of the restart interval - The countdown display is shown to players - Every second during the countdown period</p> <p>Example Usage</p> <pre><code>-- Custom countdown announcements\nhook.Add(\"AutoRestartCountdown\", \"CustomCountdownAnnouncements\", function(remaining)\n    -- Announce at specific intervals\n    if remaining == 300 then -- 5 minutes\n        for _, ply in player.Iterator() do\n            ply:ChatPrint(\"Server will restart in 5 minutes!\")\n        end\n    elseif remaining == 60 then -- 1 minute\n        for _, ply in player.Iterator() do\n            ply:ChatPrint(\"Server will restart in 1 minute!\")\n        end\n    elseif remaining == 30 then -- 30 seconds\n        for _, ply in player.Iterator() do\n            ply:ChatPrint(\"Server will restart in 30 seconds!\")\n        end\n    elseif remaining &lt;= 10 then -- Final countdown\n        for _, ply in player.Iterator() do\n            ply:ChatPrint(\"Server restarting in \" .. remaining .. \" seconds!\")\n        end\n    end\nend)\n\n-- Apply countdown effects\nhook.Add(\"AutoRestartCountdown\", \"ApplyCountdownEffects\", function(remaining)\n    -- Apply screen effects during countdown\n    if remaining &lt;= 60 then\n        for _, ply in player.Iterator() do\n            ply:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 10), 0.5, 0)\n        end\n    end\n\n    -- Play countdown sound\n    if remaining &lt;= 10 and remaining &gt; 0 then\n        for _, ply in player.Iterator() do\n            ply:EmitSound(\"buttons/button15.wav\", 75, 100)\n        end\n    end\nend)\n\n-- Track countdown events\nhook.Add(\"AutoRestartCountdown\", \"TrackCountdownEvents\", function(remaining)\n    -- Log countdown milestones\n    if remaining == 300 or remaining == 60 or remaining == 30 or remaining == 10 then\n        lia.log.add(nil, \"restartCountdown\", remaining)\n    end\nend)\n</code></pre>"},{"location":"modules/autorestarter/hooks/#autorestartscheduled","title":"AutoRestartScheduled","text":"<p>Purpose</p> <p>Called when a new restart is scheduled or rescheduled.</p> <p>Parameters</p> <ul> <li><code>nextRestart</code> (number): The Unix timestamp of the next scheduled restart.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The module initializes and schedules the first restart - A restart occurs and the next restart is scheduled - The restart interval configuration changes</p> <p>Example Usage</p> <pre><code>-- Notify administrators about restart schedule\nhook.Add(\"AutoRestartScheduled\", \"NotifyAdmins\", function(nextRestart)\n    local restartTime = os.date(\"%Y-%m-%d %H:%M:%S\", nextRestart)\n\n    for _, ply in player.Iterator() do\n        if ply:IsAdmin() then\n            ply:ChatPrint(\"Next server restart scheduled for: \" .. restartTime)\n        end\n    end\n\n    print(\"Next restart scheduled for: \" .. restartTime)\nend)\n\n-- Update external monitoring systems\nhook.Add(\"AutoRestartScheduled\", \"UpdateMonitoring\", function(nextRestart)\n    -- Send restart schedule to monitoring service\n    local data = {\n        next_restart = nextRestart,\n        restart_time = os.date(\"%Y-%m-%d %H:%M:%S\", nextRestart),\n        server_name = GetHostName()\n    }\n\n    http.Post(\"https://your-monitoring-service.com/restart-schedule\", data, function(response)\n        print(\"Restart schedule updated in monitoring system\")\n    end)\nend)\n\n-- Log restart scheduling\nhook.Add(\"AutoRestartScheduled\", \"LogRestartSchedule\", function(nextRestart)\n    lia.log.add(nil, \"restartScheduled\", nextRestart)\n\n    -- Calculate time until restart\n    local timeUntilRestart = nextRestart - os.time()\n    local hours = math.floor(timeUntilRestart / 3600)\n    local minutes = math.floor((timeUntilRestart % 3600) / 60)\n\n    print(\"Restart scheduled in \" .. hours .. \" hours and \" .. minutes .. \" minutes\")\nend)\n</code></pre>"},{"location":"modules/autorestarter/hooks/#autorestartstarted","title":"AutoRestartStarted","text":"<p>Purpose</p> <p>Called when the restart process has actually begun (after the changelevel command is issued).</p> <p>Parameters</p> <ul> <li><code>mapName</code> (string): The name of the map the server is restarting to.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The <code>changelevel</code> command has been executed - The server is about to change maps - After <code>AutoRestart</code> hook</p> <p>Example Usage</p> <pre><code>-- Final cleanup before map change\nhook.Add(\"AutoRestartStarted\", \"FinalCleanup\", function(mapName)\n    -- Save all character data\n    for _, ply in player.Iterator() do\n        if ply:getChar() then\n            ply:getChar():save()\n        end\n    end\n\n    -- Save server state\n    local serverState = {\n        map = mapName,\n        restart_time = os.time(),\n        players = {}\n    }\n\n    for _, ply in player.Iterator() do\n        table.insert(serverState.players, {\n            steamid = ply:SteamID(),\n            name = ply:Name(),\n            char_id = ply:getChar() and ply:getChar():getID() or nil\n        })\n    end\n\n    file.Write(\"server_state.json\", util.TableToJSON(serverState))\nend)\n\n-- Send final notifications\nhook.Add(\"AutoRestartStarted\", \"FinalNotifications\", function(mapName)\n    -- Notify all players\n    for _, ply in player.Iterator() do\n        ply:ChatPrint(\"Server is now restarting to \" .. mapName .. \"!\")\n    end\n\n    -- Send to external systems\n    local data = {\n        content = \"Server restarting to map: \" .. mapName,\n        timestamp = os.time()\n    }\n\n    http.Post(\"https://discord.com/api/webhooks/YOUR_WEBHOOK_URL\", data, function(response)\n        print(\"Restart notification sent\")\n    end)\nend)\n\n-- Log restart completion\nhook.Add(\"AutoRestartStarted\", \"LogRestartCompletion\", function(mapName)\n    lia.log.add(nil, \"restartStarted\", mapName)\n    print(\"Auto restart started - changing to map: \" .. mapName)\nend)\n</code></pre>"},{"location":"modules/bodygrouper/about/","title":"About","text":"About <p>Name: Body Group Editor</p> <p>Description:</p> <p>Spawns a bodygroup closet where players can edit their model's bodygroups. Admins may inspect others and configure the closet's model.</p> Features <ul> <li>Adds a spawnable closet entity for editing bodygroups</li> <li>Adds the ability to customize its model via BodyGrouperModel</li> <li>Adds menu access that requires proximity or privilege</li> <li>Adds an admin command to view another player's bodygroups</li> <li>Adds a networked menu for editing bodygroups</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/bodygrouper/changelog/","title":"Changelog","text":""},{"location":"modules/bodygrouper/changelog/#version-13","title":"Version 1.3","text":"<ul> <li>Updated: Language files for all supported languages (English, French, German, Italian, Portuguese, Spanish)</li> </ul>"},{"location":"modules/bodygrouper/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/bodygrouper/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/bodygrouper/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/bodygrouper/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Bodygrouper module for managing bodygroup editing and closet interactions.</p>"},{"location":"modules/bodygrouper/hooks/#bodygrouperapplyattempt","title":"BodygrouperApplyAttempt","text":"<p>Purpose</p> <p>Called when a player attempts to apply bodygroup changes to a target.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to apply bodygroup changes.</li> <li><code>target</code> (Player): The target player whose bodygroups are being modified.</li> <li><code>skin</code> (number): The skin ID being applied.</li> <li><code>groups</code> (table): Table of bodygroup changes (key = bodygroup index, value = bodygroup value).</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player sends bodygroup changes via the menu - Before any validation checks are performed - Before permission checks</p> <p>Example Usage</p> <pre><code>-- Log all bodygroup apply attempts\nhook.Add(\"BodygrouperApplyAttempt\", \"LogBodygroupAttempts\", function(client, target, skin, groups)\n    lia.log.add(client, \"bodygroupAttempt\", target:Name(), skin, util.TableToJSON(groups))\nend)\n\n-- Track bodygroup modification statistics\nhook.Add(\"BodygrouperApplyAttempt\", \"TrackBodygroupStats\", function(client, target, skin, groups)\n    local char = client:getChar()\n    if char then\n        local attempts = char:getData(\"bodygroup_attempts\", 0)\n        char:setData(\"bodygroup_attempts\", attempts + 1)\n\n        -- Track self-modification vs others\n        if client == target then\n            char:setData(\"self_bodygroup_changes\", char:getData(\"self_bodygroup_changes\", 0) + 1)\n        else\n            char:setData(\"other_bodygroup_changes\", char:getData(\"other_bodygroup_changes\", 0) + 1)\n        end\n    end\nend)\n\n-- Prevent bodygroup changes during certain events\nhook.Add(\"BodygrouperApplyAttempt\", \"PreventDuringEvents\", function(client, target, skin, groups)\n    if target:getChar() and target:getChar():getData(\"inEvent\", false) then\n        client:notify(\"Cannot modify bodygroups during events!\")\n        return false\n    end\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#bodygrouperclosetadduser","title":"BodygrouperClosetAddUser","text":"<p>Purpose</p> <p>Called when a player is added to a bodygroup closet's user list.</p> <p>Parameters</p> <ul> <li><code>closet</code> (Entity): The bodygroup closet entity.</li> <li><code>user</code> (Player): The player being added to the closet.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player enters a bodygroup closet - The closet's <code>AddUser</code> method is called</p> <p>Example Usage</p> <pre><code>-- Track closet usage\nhook.Add(\"BodygrouperClosetAddUser\", \"TrackClosetUsage\", function(closet, user)\n    local char = user:getChar()\n    if char then\n        local closetUses = char:getData(\"closet_uses\", 0)\n        char:setData(\"closet_uses\", closetUses + 1)\n    end\n\n    -- Log closet entry\n    lia.log.add(user, \"closetEntry\", closet:GetPos())\nend)\n\n-- Apply special effects when entering closet\nhook.Add(\"BodygrouperClosetAddUser\", \"ClosetEntryEffects\", function(closet, user)\n    -- Play custom sound\n    user:EmitSound(\"doors/door_metal_thin_open1.wav\", 75, 100)\n\n    -- Apply screen effect\n    user:ScreenFade(SCREENFADE.IN, Color(100, 100, 255, 10), 1, 0)\n\n    -- Notify player\n    user:notify(\"You entered the bodygroup closet!\")\nend)\n\n-- Limit closet capacity\nhook.Add(\"BodygrouperClosetAddUser\", \"LimitClosetCapacity\", function(closet, user)\n    local currentUsers = 0\n    for _, ply in player.Iterator() do\n        if closet:HasUser(ply) then\n            currentUsers = currentUsers + 1\n        end\n    end\n\n    if currentUsers &gt;= 3 then -- Max 3 users\n        user:notify(\"The closet is full!\")\n        closet:RemoveUser(user)\n        return false\n    end\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#bodygrouperclosetclosed","title":"BodygrouperClosetClosed","text":"<p>Purpose</p> <p>Called when a bodygroup closet is closed (no longer has any users).</p> <p>Parameters</p> <ul> <li><code>closet</code> (Entity): The bodygroup closet entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The last user leaves the closet - The closet's <code>RemoveUser</code> method is called and no users remain</p> <p>Example Usage</p> <pre><code>-- Track closet closure\nhook.Add(\"BodygrouperClosetClosed\", \"TrackClosetClosure\", function(closet)\n    lia.log.add(nil, \"closetClosed\", closet:GetPos())\n\n    -- Reset closet state\n    closet:setData(\"last_used\", os.time())\nend)\n\n-- Apply closure effects\nhook.Add(\"BodygrouperClosetClosed\", \"ClosetClosureEffects\", function(closet)\n    -- Play closing sound\n    closet:EmitSound(\"doors/door_metal_thin_close2.wav\", 75, 100)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(closet:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Clean up closet data\nhook.Add(\"BodygrouperClosetClosed\", \"CleanupClosetData\", function(closet)\n    -- Clear any temporary data\n    closet:setData(\"active_users\", {})\n    closet:setData(\"last_activity\", os.time())\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#bodygrouperclosetopened","title":"BodygrouperClosetOpened","text":"<p>Purpose</p> <p>Called when a bodygroup closet is opened (first user enters).</p> <p>Parameters</p> <ul> <li><code>closet</code> (Entity): The bodygroup closet entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The first user enters the closet - The closet's <code>AddUser</code> method is called for the first user</p> <p>Example Usage</p> <pre><code>-- Track closet opening\nhook.Add(\"BodygrouperClosetOpened\", \"TrackClosetOpening\", function(closet)\n    lia.log.add(nil, \"closetOpened\", closet:GetPos())\n\n    -- Set closet as active\n    closet:setData(\"is_active\", true)\n    closet:setData(\"opened_time\", os.time())\nend)\n\n-- Apply opening effects\nhook.Add(\"BodygrouperClosetOpened\", \"ClosetOpeningEffects\", function(closet)\n    -- Play opening sound\n    closet:EmitSound(\"doors/door_metal_thin_open1.wav\", 75, 100)\n\n    -- Create light effect\n    local light = ents.Create(\"light_dynamic\")\n    light:SetPos(closet:GetPos() + Vector(0, 0, 50))\n    light:SetKeyValue(\"brightness\", \"2\")\n    light:SetKeyValue(\"distance\", \"200\")\n    light:SetKeyValue(\"_light\", \"255 255 255\")\n    light:Spawn()\n\n    -- Remove light after 5 seconds\n    timer.Simple(5, function()\n        if IsValid(light) then light:Remove() end\n    end)\nend)\n\n-- Notify nearby players\nhook.Add(\"BodygrouperClosetOpened\", \"NotifyNearbyPlayers\", function(closet)\n    for _, ply in player.Iterator() do\n        if ply:GetPos():Distance(closet:GetPos()) &lt; 500 then\n            ply:notify(\"A bodygroup closet has been opened nearby!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#bodygrouperclosetremoveuser","title":"BodygrouperClosetRemoveUser","text":"<p>Purpose</p> <p>Called when a player is removed from a bodygroup closet's user list.</p> <p>Parameters</p> <ul> <li><code>closet</code> (Entity): The bodygroup closet entity.</li> <li><code>user</code> (Player): The player being removed from the closet.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player leaves a bodygroup closet - The closet's <code>RemoveUser</code> method is called</p> <p>Example Usage</p> <pre><code>-- Track closet exit\nhook.Add(\"BodygrouperClosetRemoveUser\", \"TrackClosetExit\", function(closet, user)\n    local char = user:getChar()\n    if char then\n        local timeSpent = os.time() - char:getData(\"closet_entry_time\", 0)\n        char:setData(\"total_closet_time\", char:getData(\"total_closet_time\", 0) + timeSpent)\n    end\n\n    lia.log.add(user, \"closetExit\", closet:GetPos())\nend)\n\n-- Apply exit effects\nhook.Add(\"BodygrouperClosetRemoveUser\", \"ClosetExitEffects\", function(closet, user)\n    -- Play exit sound\n    user:EmitSound(\"doors/door_metal_thin_close2.wav\", 75, 100)\n\n    -- Clear screen effects\n    user:ScreenFade(SCREENFADE.OUT, Color(0, 0, 0, 0), 1, 0)\n\n    -- Notify player\n    user:notify(\"You left the bodygroup closet!\")\nend)\n\n-- Check if closet should close\nhook.Add(\"BodygrouperClosetRemoveUser\", \"CheckClosetClosure\", function(closet, user)\n    local hasUsers = false\n    for _, ply in player.Iterator() do\n        if closet:HasUser(ply) then\n            hasUsers = true\n            break\n        end\n    end\n\n    if not hasUsers then\n        hook.Run(\"BodygrouperClosetClosed\", closet)\n    end\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#bodygrouperinvalidgroup","title":"BodygrouperInvalidGroup","text":"<p>Purpose</p> <p>Called when an invalid bodygroup value is provided.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who provided the invalid bodygroup.</li> <li><code>target</code> (Player): The target player.</li> <li><code>groupIndex</code> (number): The bodygroup index that was invalid.</li> <li><code>groupValue</code> (number): The invalid bodygroup value.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A bodygroup value exceeds the maximum allowed for that bodygroup - Before the error notification is sent to the client</p> <p>Example Usage</p> <pre><code>-- Log invalid bodygroup attempts\nhook.Add(\"BodygrouperInvalidGroup\", \"LogInvalidGroups\", function(client, target, groupIndex, groupValue)\n    lia.log.add(client, \"invalidBodygroup\", target:Name(), groupIndex, groupValue)\n\n    -- Notify administrators\n    for _, admin in player.Iterator() do\n        if admin:IsAdmin() then\n            admin:notify(client:Name() .. \" attempted invalid bodygroup \" .. groupIndex .. \" = \" .. groupValue)\n        end\n    end\nend)\n\n-- Track invalid attempts for moderation\nhook.Add(\"BodygrouperInvalidGroup\", \"TrackInvalidAttempts\", function(client, target, groupIndex, groupValue)\n    local char = client:getChar()\n    if char then\n        local invalidAttempts = char:getData(\"invalid_bodygroup_attempts\", 0)\n        char:setData(\"invalid_bodygroup_attempts\", invalidAttempts + 1)\n\n        -- Flag for review if too many invalid attempts\n        if invalidAttempts &gt;= 10 then\n            char:setData(\"flagged_for_review\", true)\n            lia.log.add(client, \"flaggedForReview\", \"Too many invalid bodygroup attempts\")\n        end\n    end\nend)\n\n-- Provide helpful error messages\nhook.Add(\"BodygrouperInvalidGroup\", \"HelpfulErrorMessages\", function(client, target, groupIndex, groupValue)\n    local maxValue = target:GetBodygroupCount(groupIndex) - 1\n    client:notify(\"Invalid bodygroup! Group \" .. groupIndex .. \" only accepts values 0-\" .. maxValue .. \" (you provided \" .. groupValue .. \")\")\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#bodygrouperinvalidskin","title":"BodygrouperInvalidSkin","text":"<p>Purpose</p> <p>Called when an invalid skin value is provided.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who provided the invalid skin.</li> <li><code>target</code> (Player): The target player.</li> <li><code>skin</code> (number): The invalid skin value.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A skin value exceeds the maximum allowed for the model - Before the error notification is sent to the client</p> <p>Example Usage</p> <pre><code>-- Log invalid skin attempts\nhook.Add(\"BodygrouperInvalidSkin\", \"LogInvalidSkins\", function(client, target, skin)\n    lia.log.add(client, \"invalidSkin\", target:Name(), skin)\n\n    -- Notify administrators\n    for _, admin in player.Iterator() do\n        if admin:IsAdmin() then\n            admin:notify(client:Name() .. \" attempted invalid skin \" .. skin)\n        end\n    end\nend)\n\n-- Track invalid skin attempts\nhook.Add(\"BodygrouperInvalidSkin\", \"TrackInvalidSkinAttempts\", function(client, target, skin)\n    local char = client:getChar()\n    if char then\n        local invalidSkins = char:getData(\"invalid_skin_attempts\", 0)\n        char:setData(\"invalid_skin_attempts\", invalidSkins + 1)\n    end\nend)\n\n-- Provide helpful error messages\nhook.Add(\"BodygrouperInvalidSkin\", \"HelpfulSkinErrors\", function(client, target, skin)\n    local maxSkin = target:SkinCount() - 1\n    client:notify(\"Invalid skin! This model only supports skins 0-\" .. maxSkin .. \" (you provided \" .. skin .. \")\")\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#bodygroupermenuclosed","title":"BodygrouperMenuClosed","text":"<p>Purpose</p> <p>Called when the bodygroup menu is closed on the client side.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The bodygroup menu is closed - The menu is removed from the client</p> <p>Example Usage</p> <pre><code>-- Clean up client-side effects\nhook.Add(\"BodygrouperMenuClosed\", \"CleanupMenuEffects\", function()\n    -- Remove any custom HUD elements\n    if IsValid(BodygroupHUD) then\n        BodygroupHUD:Remove()\n    end\n\n    -- Clear screen effects\n    LocalPlayer():ScreenFade(SCREENFADE.OUT, Color(0, 0, 0, 0), 0.5, 0)\nend)\n\n-- Track menu usage\nhook.Add(\"BodygrouperMenuClosed\", \"TrackMenuUsage\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local menuUses = char:getData(\"bodygroup_menu_uses\", 0)\n        char:setData(\"bodygroup_menu_uses\", menuUses + 1)\n    end\nend)\n\n-- Play close sound\nhook.Add(\"BodygrouperMenuClosed\", \"MenuCloseSound\", function()\n    LocalPlayer():EmitSound(\"ui/buttonclickrelease.wav\", 75, 100)\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#bodygroupermenuclosedserver","title":"BodygrouperMenuClosedServer","text":"<p>Purpose</p> <p>Called when the bodygroup menu is closed on the server side.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client whose menu was closed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The server receives a menu close network message - The client's closet users are removed</p> <p>Example Usage</p> <pre><code>-- Clean up server-side data\nhook.Add(\"BodygrouperMenuClosedServer\", \"CleanupServerData\", function(client)\n    -- Remove client from all closets\n    for _, closet in pairs(ents.FindByClass(\"lia_bodygrouper\")) do\n        if closet:HasUser(client) then\n            closet:RemoveUser(client)\n        end\n    end\n\n    -- Clear any temporary data\n    client:setData(\"in_bodygroup_menu\", false)\nend)\n\n-- Track menu closure\nhook.Add(\"BodygrouperMenuClosedServer\", \"TrackMenuClosure\", function(client)\n    lia.log.add(client, \"bodygroupMenuClosed\")\n\n    -- Notify if client was in menu for too long\n    local menuStartTime = client:getData(\"menu_start_time\", 0)\n    if menuStartTime &gt; 0 then\n        local timeSpent = os.time() - menuStartTime\n        if timeSpent &gt; 300 then -- 5 minutes\n            lia.log.add(client, \"longMenuSession\", timeSpent)\n        end\n    end\nend)\n\n-- Apply closure effects\nhook.Add(\"BodygrouperMenuClosedServer\", \"MenuClosureEffects\", function(client)\n    -- Notify client\n    client:notify(\"Bodygroup menu closed!\")\n\n    -- Clear any temporary permissions\n    client:setData(\"temp_bodygroup_access\", false)\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#bodygroupermenuopened","title":"BodygrouperMenuOpened","text":"<p>Purpose</p> <p>Called when the bodygroup menu is opened on the client side.</p> <p>Parameters</p> <ul> <li><code>menu</code> (Panel): The bodygroup menu panel.</li> <li><code>target</code> (Player): The target player whose bodygroups are being edited.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The bodygroup menu is created and displayed - The menu is set up with the target player</p> <p>Example Usage</p> <pre><code>-- Apply custom styling to the menu\nhook.Add(\"BodygrouperMenuOpened\", \"CustomMenuStyling\", function(menu, target)\n    -- Set custom colors\n    menu:SetBackgroundColor(Color(50, 50, 50, 200))\n\n    -- Add custom title\n    local title = menu:Add(\"DLabel\")\n    title:SetText(\"Custom Bodygroup Editor\")\n    title:SetFont(\"DermaDefault\")\n    title:SetTextColor(Color(255, 255, 255))\n    title:Dock(TOP)\nend)\n\n-- Track menu opening\nhook.Add(\"BodygrouperMenuOpened\", \"TrackMenuOpening\", function(menu, target)\n    local char = LocalPlayer():getChar()\n    if char then\n        char:setData(\"last_menu_open\", os.time())\n        char:setData(\"menu_target\", target:Name())\n    end\nend)\n\n-- Apply opening effects\nhook.Add(\"BodygrouperMenuOpened\", \"MenuOpeningEffects\", function(menu, target)\n    -- Play opening sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(100, 100, 255, 5), 1, 0)\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#bodygroupervalidated","title":"BodygrouperValidated","text":"<p>Purpose</p> <p>Called when bodygroup changes pass all validation checks.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player applying the changes.</li> <li><code>target</code> (Player): The target player.</li> <li><code>skin</code> (number): The skin ID being applied.</li> <li><code>groups</code> (table): Table of bodygroup changes.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - All validation checks pass (skin and bodygroup values are valid) - Before the actual bodygroup changes are applied - After permission checks</p> <p>Example Usage</p> <pre><code>-- Log successful validations\nhook.Add(\"BodygrouperValidated\", \"LogSuccessfulValidations\", function(client, target, skin, groups)\n    lia.log.add(client, \"bodygroupValidated\", target:Name(), skin, util.TableToJSON(groups))\nend)\n\n-- Apply pre-application effects\nhook.Add(\"BodygrouperValidated\", \"PreApplicationEffects\", function(client, target, skin, groups)\n    -- Notify target if someone else is changing their bodygroups\n    if client ~= target then\n        target:notify(client:Name() .. \" is about to modify your appearance!\")\n    end\n\n    -- Apply temporary effects\n    target:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.5, 0)\nend)\n\n-- Track validation statistics\nhook.Add(\"BodygrouperValidated\", \"TrackValidationStats\", function(client, target, skin, groups)\n    local char = client:getChar()\n    if char then\n        local validations = char:getData(\"bodygroup_validations\", 0)\n        char:setData(\"bodygroup_validations\", validations + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#postbodygroupapply","title":"PostBodygroupApply","text":"<p>Purpose</p> <p>Called after bodygroup changes have been successfully applied.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who applied the changes.</li> <li><code>target</code> (Player): The target player whose bodygroups were changed.</li> <li><code>skin</code> (number): The skin ID that was applied.</li> <li><code>groups</code> (table): Table of bodygroup changes that were applied.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - Bodygroup changes have been applied to the target - Character data has been updated - Before success notifications are sent</p> <p>Example Usage</p> <pre><code>-- Log successful bodygroup applications\nhook.Add(\"PostBodygroupApply\", \"LogBodygroupApplications\", function(client, target, skin, groups)\n    lia.log.add(client, \"bodygroupApplied\", target:Name(), skin, util.TableToJSON(groups))\nend)\n\n-- Apply post-application effects\nhook.Add(\"PostBodygroupApply\", \"PostApplicationEffects\", function(client, target, skin, groups)\n    -- Clear screen effects\n    target:ScreenFade(SCREENFADE.OUT, Color(0, 0, 0, 0), 1, 0)\n\n    -- Play success sound\n    target:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(target:GetPos() + Vector(0, 0, 50))\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track bodygroup change statistics\nhook.Add(\"PostBodygroupApply\", \"TrackBodygroupStats\", function(client, target, skin, groups)\n    local char = target:getChar()\n    if char then\n        local changes = char:getData(\"bodygroup_changes\", 0)\n        char:setData(\"bodygroup_changes\", changes + 1)\n\n        -- Track specific changes\n        for groupIndex, groupValue in pairs(groups) do\n            local groupChanges = char:getData(\"bodygroup_\" .. groupIndex .. \"_changes\", 0)\n            char:setData(\"bodygroup_\" .. groupIndex .. \"_changes\", groupChanges + 1)\n        end\n    end\nend)\n\n-- Award achievements\nhook.Add(\"PostBodygroupApply\", \"BodygroupAchievements\", function(client, target, skin, groups)\n    local char = target:getChar()\n    if char then\n        local totalChanges = char:getData(\"bodygroup_changes\", 0)\n\n        if totalChanges == 1 then\n            target:notify(\"Achievement: First Makeover!\")\n        elseif totalChanges == 10 then\n            target:notify(\"Achievement: Fashion Enthusiast!\")\n        elseif totalChanges == 50 then\n            target:notify(\"Achievement: Style Master!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#prebodygroupapply","title":"PreBodygroupApply","text":"<p>Purpose</p> <p>Called before bodygroup changes are applied to the target.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player applying the changes.</li> <li><code>target</code> (Player): The target player.</li> <li><code>skin</code> (number): The skin ID being applied.</li> <li><code>groups</code> (table): Table of bodygroup changes.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - All validation checks have passed - Before the actual bodygroup changes are applied - Before character data is updated</p> <p>Example Usage</p> <pre><code>-- Prevent bodygroup changes under certain conditions\nhook.Add(\"PreBodygroupApply\", \"PreventBodygroupChanges\", function(client, target, skin, groups)\n    -- Prevent changes during combat\n    if target:getChar() and target:getChar():getData(\"inCombat\", false) then\n        client:notify(\"Cannot modify bodygroups during combat!\")\n        return false\n    end\n\n    -- Prevent changes if target is frozen\n    if target:GetMoveType() == MOVETYPE_NONE then\n        client:notify(\"Cannot modify bodygroups of frozen players!\")\n        return false\n    end\nend)\n\n-- Apply pre-application effects\nhook.Add(\"PreBodygroupApply\", \"PreApplicationEffects\", function(client, target, skin, groups)\n    -- Store original appearance for potential rollback\n    local char = target:getChar()\n    if char then\n        char:setData(\"original_skin\", target:GetSkin())\n        char:setData(\"original_bodygroups\", target:GetBodyGroups())\n    end\n\n    -- Apply preparation effects\n    target:ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 20), 0.5, 0)\nend)\n\n-- Log pre-application\nhook.Add(\"PreBodygroupApply\", \"LogPreApplication\", function(client, target, skin, groups)\n    lia.log.add(client, \"preBodygroupApply\", target:Name(), skin, util.TableToJSON(groups))\nend)\n</code></pre>"},{"location":"modules/bodygrouper/hooks/#prebodygroupermenuopen","title":"PreBodygrouperMenuOpen","text":"<p>Purpose</p> <p>Called before the bodygroup menu is opened for a target.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client opening the menu.</li> <li><code>target</code> (Player): The target player whose bodygroups will be edited.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The <code>viewBodygroups</code> command is executed - Before the menu network message is sent to the client</p> <p>Example Usage</p> <pre><code>-- Check additional permissions\nhook.Add(\"PreBodygrouperMenuOpen\", \"CheckAdditionalPermissions\", function(client, target)\n    -- Check if target allows bodygroup editing\n    if target:getChar() and target:getChar():getData(\"allowBodygroupEditing\", true) == false then\n        client:notify(\"This player has disabled bodygroup editing!\")\n        return false\n    end\n\n    -- Check cooldown\n    local lastEdit = target:getData(\"last_bodygroup_edit\", 0)\n    if os.time() - lastEdit &lt; 60 then -- 1 minute cooldown\n        client:notify(\"Please wait before editing this player's bodygroups again!\")\n        return false\n    end\nend)\n\n-- Log menu open attempts\nhook.Add(\"PreBodygrouperMenuOpen\", \"LogMenuOpenAttempts\", function(client, target)\n    lia.log.add(client, \"bodygroupMenuOpen\", target:Name())\n\n    -- Track menu open statistics\n    local char = client:getChar()\n    if char then\n        local menuOpens = char:getData(\"bodygroup_menu_opens\", 0)\n        char:setData(\"bodygroup_menu_opens\", menuOpens + 1)\n    end\nend)\n\n-- Apply pre-menu effects\nhook.Add(\"PreBodygrouperMenuOpen\", \"PreMenuEffects\", function(client, target)\n    -- Notify target if someone else is opening their menu\n    if client ~= target then\n        target:notify(client:Name() .. \" is opening your bodygroup editor!\")\n    end\n\n    -- Set menu start time\n    client:setData(\"menu_start_time\", os.time())\n    client:setData(\"in_bodygroup_menu\", true)\nend)\n</code></pre>"},{"location":"modules/broadcasts/about/","title":"About","text":"About <p>Name: Broadcasts</p> <p>Description:</p> <p>Allows staff to broadcast messages to chosen factions or classes. Every broadcast is logged and controlled through CAMI privileges.</p> Features <ul> <li>Adds faction and class broadcast commands with CAMI checks</li> <li>Adds logging of broadcast messages for staff review</li> <li>Adds CAMI privileges for broadcast access</li> <li>Adds menus to select factions or classes</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/broadcasts/changelog/","title":"Changelog","text":""},{"location":"modules/broadcasts/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/broadcasts/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/broadcasts/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Broadcasts module for managing class and faction broadcast systems.</p>"},{"location":"modules/broadcasts/hooks/#classbroadcastlogged","title":"ClassBroadcastLogged","text":"<p>Purpose</p> <p>Called when a class broadcast is logged to the server logs.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who sent the broadcast.</li> <li><code>message</code> (string): The broadcast message content.</li> <li><code>classList</code> (table): Array of class names that received the broadcast.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - The broadcast has been sent to all target players - The broadcast has been logged via <code>lia.log.add()</code></p> <p>Example Usage</p> <pre><code>-- Track broadcast statistics\nhook.Add(\"ClassBroadcastLogged\", \"TrackBroadcastStats\", function(client, message, classList)\n    local char = client:getChar()\n    if char then\n        local broadcasts = char:getData(\"class_broadcasts_sent\", 0)\n        char:setData(\"class_broadcasts_sent\", broadcasts + 1)\n\n        -- Track message length\n        local avgLength = char:getData(\"avg_broadcast_length\", 0)\n        local newAvg = (avgLength * broadcasts + #message) / (broadcasts + 1)\n        char:setData(\"avg_broadcast_length\", newAvg)\n    end\nend)\n\n-- Send to external logging system\nhook.Add(\"ClassBroadcastLogged\", \"ExternalLogging\", function(client, message, classList)\n    local data = {\n        type = \"class_broadcast\",\n        sender = client:SteamID(),\n        sender_name = client:Name(),\n        message = message,\n        targets = classList,\n        timestamp = os.time()\n    }\n\n    http.Post(\"https://your-logging-service.com/broadcasts\", data, function(response)\n        print(\"Class broadcast logged to external system\")\n    end)\nend)\n\n-- Notify administrators of broadcasts\nhook.Add(\"ClassBroadcastLogged\", \"NotifyAdmins\", function(client, message, classList)\n    for _, admin in player.Iterator() do\n        if admin:IsAdmin() then\n            admin:notify(client:Name() .. \" sent class broadcast to \" .. table.concat(classList, \", \") .. \": \" .. message)\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/broadcasts/hooks/#classbroadcastmenuclosed","title":"ClassBroadcastMenuClosed","text":"<p>Purpose</p> <p>Called when the class broadcast selection menu is closed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who closed the menu.</li> <li><code>selectedOptions</code> (table): Array of selected class options.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The player makes their selection from the class broadcast menu - Before the broadcast is processed</p> <p>Example Usage</p> <pre><code>-- Track menu usage\nhook.Add(\"ClassBroadcastMenuClosed\", \"TrackMenuUsage\", function(client, selectedOptions)\n    local char = client:getChar()\n    if char then\n        local menuUses = char:getData(\"broadcast_menu_uses\", 0)\n        char:setData(\"broadcast_menu_uses\", menuUses + 1)\n\n        -- Track selection patterns\n        local selections = char:getData(\"class_selections\", {})\n        for _, option in ipairs(selectedOptions) do\n            selections[option] = (selections[option] or 0) + 1\n        end\n        char:setData(\"class_selections\", selections)\n    end\nend)\n\n-- Validate selections\nhook.Add(\"ClassBroadcastMenuClosed\", \"ValidateSelections\", function(client, selectedOptions)\n    if #selectedOptions == 0 then\n        client:notify(\"No classes selected!\")\n        return false\n    end\n\n    if #selectedOptions &gt; 5 then\n        client:notify(\"Too many classes selected! Maximum 5 allowed.\")\n        return false\n    end\nend)\n\n-- Log menu closure\nhook.Add(\"ClassBroadcastMenuClosed\", \"LogMenuClosure\", function(client, selectedOptions)\n    lia.log.add(client, \"classBroadcastMenuClosed\", #selectedOptions .. \" classes selected\")\nend)\n</code></pre>"},{"location":"modules/broadcasts/hooks/#classbroadcastmenuopened","title":"ClassBroadcastMenuOpened","text":"<p>Purpose</p> <p>Called when the class broadcast selection menu is opened.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who opened the menu.</li> <li><code>options</code> (table): Array of available class options.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The <code>classbroadcast</code> command is executed - Before the menu is displayed to the client</p> <p>Example Usage</p> <pre><code>-- Track menu opening\nhook.Add(\"ClassBroadcastMenuOpened\", \"TrackMenuOpening\", function(client, options)\n    local char = client:getChar()\n    if char then\n        char:setData(\"last_broadcast_menu\", os.time())\n        char:setData(\"available_classes\", #options)\n    end\n\n    lia.log.add(client, \"classBroadcastMenuOpened\", #options .. \" classes available\")\nend)\n\n-- Filter available options\nhook.Add(\"ClassBroadcastMenuOpened\", \"FilterOptions\", function(client, options)\n    local char = client:getChar()\n    if char and char:getData(\"restricted_classes\", false) then\n        -- Remove restricted classes from options\n        local restricted = char:getData(\"restricted_class_list\", {})\n        for i = #options, 1, -1 do\n            for _, restrictedClass in ipairs(restricted) do\n                if string.find(options[i], restrictedClass) then\n                    table.remove(options, i)\n                    break\n                end\n            end\n        end\n    end\nend)\n\n-- Apply menu restrictions\nhook.Add(\"ClassBroadcastMenuOpened\", \"ApplyRestrictions\", function(client, options)\n    -- Check cooldown\n    local lastBroadcast = client:getData(\"last_class_broadcast\", 0)\n    if os.time() - lastBroadcast &lt; 300 then -- 5 minute cooldown\n        client:notify(\"Please wait before sending another class broadcast!\")\n        return false\n    end\nend)\n</code></pre>"},{"location":"modules/broadcasts/hooks/#classbroadcastsent","title":"ClassBroadcastSent","text":"<p>Purpose</p> <p>Called when a class broadcast has been successfully sent to all target players.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who sent the broadcast.</li> <li><code>message</code> (string): The broadcast message content.</li> <li><code>classList</code> (table): Array of class names that received the broadcast.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - The broadcast has been sent to all target players - Before the success notification is sent to the client</p> <p>Example Usage</p> <pre><code>-- Apply post-send effects\nhook.Add(\"ClassBroadcastSent\", \"PostSendEffects\", function(client, message, classList)\n    -- Play success sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 1, 0)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos() + Vector(0, 0, 50))\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track successful broadcasts\nhook.Add(\"ClassBroadcastSent\", \"TrackSuccessfulBroadcasts\", function(client, message, classList)\n    local char = client:getChar()\n    if char then\n        local successful = char:getData(\"successful_class_broadcasts\", 0)\n        char:setData(\"successful_class_broadcasts\", successful + 1)\n\n        -- Track reach\n        local totalReach = char:getData(\"total_class_reach\", 0)\n        char:setData(\"total_class_reach\", totalReach + #classList)\n    end\nend)\n\n-- Award achievements\nhook.Add(\"ClassBroadcastSent\", \"BroadcastAchievements\", function(client, message, classList)\n    local char = client:getChar()\n    if char then\n        local broadcasts = char:getData(\"successful_class_broadcasts\", 0)\n\n        if broadcasts == 1 then\n            client:notify(\"Achievement: First Class Broadcast!\")\n        elseif broadcasts == 10 then\n            client:notify(\"Achievement: Class Communicator!\")\n        elseif broadcasts == 50 then\n            client:notify(\"Achievement: Class Broadcast Master!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/broadcasts/hooks/#factionbroadcastlogged","title":"FactionBroadcastLogged","text":"<p>Purpose</p> <p>Called when a faction broadcast is logged to the server logs.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who sent the broadcast.</li> <li><code>message</code> (string): The broadcast message content.</li> <li><code>factionList</code> (table): Array of faction names that received the broadcast.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - The broadcast has been sent to all target players - The broadcast has been logged via <code>lia.log.add()</code></p> <p>Example Usage</p> <pre><code>-- Track faction broadcast statistics\nhook.Add(\"FactionBroadcastLogged\", \"TrackFactionBroadcastStats\", function(client, message, factionList)\n    local char = client:getChar()\n    if char then\n        local broadcasts = char:getData(\"faction_broadcasts_sent\", 0)\n        char:setData(\"faction_broadcasts_sent\", broadcasts + 1)\n\n        -- Track faction reach\n        for _, faction in ipairs(factionList) do\n            local factionReach = char:getData(\"faction_reach_\" .. faction, 0)\n            char:setData(\"faction_reach_\" .. faction, factionReach + 1)\n        end\n    end\nend)\n\n-- Send to external monitoring\nhook.Add(\"FactionBroadcastLogged\", \"ExternalMonitoring\", function(client, message, factionList)\n    local data = {\n        type = \"faction_broadcast\",\n        sender = client:SteamID(),\n        sender_name = client:Name(),\n        message = message,\n        targets = factionList,\n        timestamp = os.time()\n    }\n\n    http.Post(\"https://your-monitoring-service.com/faction-broadcasts\", data, function(response)\n        print(\"Faction broadcast sent to monitoring system\")\n    end)\nend)\n\n-- Alert high-priority factions\nhook.Add(\"FactionBroadcastLogged\", \"AlertHighPriorityFactions\", function(client, message, factionList)\n    local highPriorityFactions = {\"police\", \"government\", \"military\"}\n\n    for _, faction in ipairs(factionList) do\n        for _, priorityFaction in ipairs(highPriorityFactions) do\n            if string.find(string.lower(faction), priorityFaction) then\n                lia.log.add(client, \"highPriorityFactionBroadcast\", faction, message)\n                break\n            end\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/broadcasts/hooks/#factionbroadcastmenuclosed","title":"FactionBroadcastMenuClosed","text":"<p>Purpose</p> <p>Called when the faction broadcast selection menu is closed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who closed the menu.</li> <li><code>selectedOptions</code> (table): Array of selected faction options.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The player makes their selection from the faction broadcast menu - Before the broadcast is processed</p> <p>Example Usage</p> <pre><code>-- Track faction menu usage\nhook.Add(\"FactionBroadcastMenuClosed\", \"TrackFactionMenuUsage\", function(client, selectedOptions)\n    local char = client:getChar()\n    if char then\n        local menuUses = char:getData(\"faction_broadcast_menu_uses\", 0)\n        char:setData(\"faction_broadcast_menu_uses\", menuUses + 1)\n\n        -- Track faction selection patterns\n        local selections = char:getData(\"faction_selections\", {})\n        for _, option in ipairs(selectedOptions) do\n            selections[option] = (selections[option] or 0) + 1\n        end\n        char:setData(\"faction_selections\", selections)\n    end\nend)\n\n-- Validate faction selections\nhook.Add(\"FactionBroadcastMenuClosed\", \"ValidateFactionSelections\", function(client, selectedOptions)\n    if #selectedOptions == 0 then\n        client:notify(\"No factions selected!\")\n        return false\n    end\n\n    -- Check for conflicting factions\n    local conflictingFactions = {\"police\", \"criminal\"}\n    local hasPolice = false\n    local hasCriminal = false\n\n    for _, option in ipairs(selectedOptions) do\n        if string.find(string.lower(option), \"police\") then hasPolice = true end\n        if string.find(string.lower(option), \"criminal\") then hasCriminal = true end\n    end\n\n    if hasPolice and hasCriminal then\n        client:notify(\"Cannot broadcast to both police and criminal factions!\")\n        return false\n    end\nend)\n\n-- Log faction menu closure\nhook.Add(\"FactionBroadcastMenuClosed\", \"LogFactionMenuClosure\", function(client, selectedOptions)\n    lia.log.add(client, \"factionBroadcastMenuClosed\", #selectedOptions .. \" factions selected\")\nend)\n</code></pre>"},{"location":"modules/broadcasts/hooks/#factionbroadcastmenuopened","title":"FactionBroadcastMenuOpened","text":"<p>Purpose</p> <p>Called when the faction broadcast selection menu is opened.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who opened the menu.</li> <li><code>options</code> (table): Array of available faction options.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The <code>factionbroadcast</code> command is executed - Before the menu is displayed to the client</p> <p>Example Usage</p> <pre><code>-- Track faction menu opening\nhook.Add(\"FactionBroadcastMenuOpened\", \"TrackFactionMenuOpening\", function(client, options)\n    local char = client:getChar()\n    if char then\n        char:setData(\"last_faction_broadcast_menu\", os.time())\n        char:setData(\"available_factions\", #options)\n    end\n\n    lia.log.add(client, \"factionBroadcastMenuOpened\", #options .. \" factions available\")\nend)\n\n-- Filter faction options based on player permissions\nhook.Add(\"FactionBroadcastMenuOpened\", \"FilterFactionOptions\", function(client, options)\n    local char = client:getChar()\n    if char then\n        local faction = char:getFaction()\n\n        -- Remove own faction from options (can't broadcast to self)\n        for i = #options, 1, -1 do\n            if string.find(options[i], faction) then\n                table.remove(options, i)\n            end\n        end\n\n        -- Check for restricted factions\n        local restrictedFactions = char:getData(\"restricted_factions\", {})\n        for i = #options, 1, -1 do\n            for _, restricted in ipairs(restrictedFactions) do\n                if string.find(options[i], restricted) then\n                    table.remove(options, i)\n                    break\n                end\n            end\n        end\n    end\nend)\n\n-- Apply faction-specific restrictions\nhook.Add(\"FactionBroadcastMenuOpened\", \"ApplyFactionRestrictions\", function(client, options)\n    local char = client:getChar()\n    if char then\n        local faction = char:getFaction()\n\n        -- Check faction-specific cooldowns\n        local lastBroadcast = char:getData(\"last_faction_broadcast\", 0)\n        local cooldown = 600 -- 10 minutes for faction broadcasts\n\n        if os.time() - lastBroadcast &lt; cooldown then\n            client:notify(\"Please wait before sending another faction broadcast!\")\n            return false\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/broadcasts/hooks/#factionbroadcastsent","title":"FactionBroadcastSent","text":"<p>Purpose</p> <p>Called when a faction broadcast has been successfully sent to all target players.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who sent the broadcast.</li> <li><code>message</code> (string): The broadcast message content.</li> <li><code>factionList</code> (table): Array of faction names that received the broadcast.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered after: - The broadcast has been sent to all target players - Before the success notification is sent to the client</p> <p>Example Usage</p> <pre><code>-- Apply post-send effects for faction broadcasts\nhook.Add(\"FactionBroadcastSent\", \"PostFactionSendEffects\", function(client, message, factionList)\n    -- Play faction-specific sound\n    client:EmitSound(\"buttons/button15.wav\", 75, 100)\n\n    -- Apply faction-specific screen effect\n    local char = client:getChar()\n    if char then\n        local faction = char:getFaction()\n        local color = Color(255, 255, 255, 10)\n\n        if faction == \"police\" then\n            color = Color(0, 0, 255, 10)\n        elseif faction == \"criminal\" then\n            color = Color(255, 0, 0, 10)\n        end\n\n        client:ScreenFade(SCREENFADE.IN, color, 1, 0)\n    end\nend)\n\n-- Track successful faction broadcasts\nhook.Add(\"FactionBroadcastSent\", \"TrackSuccessfulFactionBroadcasts\", function(client, message, factionList)\n    local char = client:getChar()\n    if char then\n        local successful = char:getData(\"successful_faction_broadcasts\", 0)\n        char:setData(\"successful_faction_broadcasts\", successful + 1)\n\n        -- Track cross-faction communication\n        local ownFaction = char:getFaction()\n        local crossFaction = false\n        for _, faction in ipairs(factionList) do\n            if faction ~= ownFaction then\n                crossFaction = true\n                break\n            end\n        end\n\n        if crossFaction then\n            char:setData(\"cross_faction_broadcasts\", char:getData(\"cross_faction_broadcasts\", 0) + 1)\n        end\n    end\nend)\n\n-- Award faction-specific achievements\nhook.Add(\"FactionBroadcastSent\", \"FactionBroadcastAchievements\", function(client, message, factionList)\n    local char = client:getChar()\n    if char then\n        local broadcasts = char:getData(\"successful_faction_broadcasts\", 0)\n\n        if broadcasts == 1 then\n            client:notify(\"Achievement: First Faction Broadcast!\")\n        elseif broadcasts == 5 then\n            client:notify(\"Achievement: Faction Communicator!\")\n        elseif broadcasts == 25 then\n            client:notify(\"Achievement: Faction Broadcast Leader!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/broadcasts/hooks/#preclassbroadcastsend","title":"PreClassBroadcastSend","text":"<p>Purpose</p> <p>Called before a class broadcast is sent to target players.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is sending the broadcast.</li> <li><code>message</code> (string): The broadcast message content.</li> <li><code>classList</code> (table): Array of class names that will receive the broadcast.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - All validations have passed - Before the broadcast is sent to target players - Before <code>ClassBroadcastSent</code> hook</p> <p>Example Usage</p> <pre><code>-- Filter broadcast content\nhook.Add(\"PreClassBroadcastSend\", \"FilterBroadcastContent\", function(client, message, classList)\n    -- Check for inappropriate content\n    local filteredWords = {\"spam\", \"scam\", \"hack\"}\n\n    for _, word in ipairs(filteredWords) do\n        if string.find(string.lower(message), word) then\n            client:notify(\"Your broadcast contains inappropriate content!\")\n            return false\n        end\n    end\n\n    -- Check message length\n    if #message &gt; 200 then\n        client:notify(\"Broadcast message too long! Maximum 200 characters.\")\n        return false\n    end\nend)\n\n-- Apply pre-send effects\nhook.Add(\"PreClassBroadcastSend\", \"PreSendEffects\", function(client, message, classList)\n    -- Notify target classes about incoming broadcast\n    for _, ply in player.Iterator() do\n        if ply:getChar() then\n            local charClass = ply:getChar():getClass()\n            for _, className in ipairs(classList) do\n                if lia.class.list[charClass] and lia.class.list[charClass].name == className then\n                    ply:notify(\"Incoming class broadcast from \" .. client:Name() .. \"!\")\n                    break\n                end\n            end\n        end\n    end\nend)\n\n-- Track pre-send statistics\nhook.Add(\"PreClassBroadcastSend\", \"TrackPreSendStats\", function(client, message, classList)\n    local char = client:getChar()\n    if char then\n        char:setData(\"last_class_broadcast\", os.time())\n        char:setData(\"last_broadcast_message\", message)\n        char:setData(\"last_broadcast_targets\", classList)\n    end\nend)\n</code></pre>"},{"location":"modules/broadcasts/hooks/#prefactionbroadcastsend","title":"PreFactionBroadcastSend","text":"<p>Purpose</p> <p>Called before a faction broadcast is sent to target players.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is sending the broadcast.</li> <li><code>message</code> (string): The broadcast message content.</li> <li><code>factionList</code> (table): Array of faction names that will receive the broadcast.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - All validations have passed - Before the broadcast is sent to target players - Before <code>FactionBroadcastSent</code> hook</p> <p>Example Usage</p> <pre><code>-- Filter faction broadcast content\nhook.Add(\"PreFactionBroadcastSend\", \"FilterFactionBroadcastContent\", function(client, message, factionList)\n    -- Check for sensitive content\n    local sensitiveWords = {\"classified\", \"secret\", \"confidential\"}\n\n    for _, word in ipairs(sensitiveWords) do\n        if string.find(string.lower(message), word) then\n            client:notify(\"Cannot use sensitive words in faction broadcasts!\")\n            return false\n        end\n    end\n\n    -- Check for faction-specific restrictions\n    local char = client:getChar()\n    if char then\n        local faction = char:getFaction()\n\n        -- Police can't broadcast to criminal factions\n        if faction == \"police\" then\n            for _, targetFaction in ipairs(factionList) do\n                if string.find(string.lower(targetFaction), \"criminal\") then\n                    client:notify(\"Police cannot broadcast to criminal factions!\")\n                    return false\n                end\n            end\n        end\n    end\nend)\n\n-- Apply pre-send effects for faction broadcasts\nhook.Add(\"PreFactionBroadcastSend\", \"PreFactionSendEffects\", function(client, message, factionList)\n    -- Notify target factions about incoming broadcast\n    for _, ply in player.Iterator() do\n        if ply:getChar() then\n            local charFaction = ply:getChar():getFaction()\n            for _, factionName in ipairs(factionList) do\n                if lia.faction.indices[charFaction] and lia.faction.indices[charFaction].name == factionName then\n                    ply:notify(\"Incoming faction broadcast from \" .. client:Name() .. \"!\")\n                    break\n                end\n            end\n        end\n    end\nend)\n\n-- Track pre-send statistics for faction broadcasts\nhook.Add(\"PreFactionBroadcastSend\", \"TrackPreFactionSendStats\", function(client, message, factionList)\n    local char = client:getChar()\n    if char then\n        char:setData(\"last_faction_broadcast\", os.time())\n        char:setData(\"last_faction_broadcast_message\", message)\n        char:setData(\"last_faction_broadcast_targets\", factionList)\n    end\nend)\n</code></pre>"},{"location":"modules/captions/about/","title":"About","text":"About <p>Name: Captions</p> <p>Description:</p> <p>Offers an API for timed on-screen captions suited for tutorials or story events. Captions can be triggered from the server or client and last for a chosen duration.</p> Features <ul> <li>Adds an API for timed on-screen captions</li> <li>Adds support for both client and server use</li> <li>Adds an easy way to deliver story prompts</li> <li>Adds commands to send captions to players</li> <li>Adds duration control for each caption</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/captions/changelog/","title":"Changelog","text":""},{"location":"modules/captions/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/captions/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/captions/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Captions module for managing on-screen captions.</p>"},{"location":"modules/captions/hooks/#captionstarted","title":"CaptionStarted","text":"<p>Purpose</p> <p>Called when a caption is started for a player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player receiving the caption (Server only).</li> <li><code>text</code> (string): The text content of the caption.</li> <li><code>duration</code> (number): The duration in seconds the caption will be displayed.</li> </ul> <p>Realm</p> <p>Server and Client.</p> <p>When Called</p> <p>This hook is triggered when: - A caption is started via <code>lia.caption.start()</code> - A caption command is executed - A broadcast caption is sent</p> <p>Example Usage</p> <pre><code>-- Track caption starts\nhook.Add(\"CaptionStarted\", \"TrackCaptionStarts\", function(client, text, duration)\n    if SERVER then\n        print(\"Caption started for\", client:Name(), \":\", text, \"for\", duration, \"seconds\")\n\n        -- Log to server console\n        local char = client:getChar()\n        if char then\n            local captionStarts = char:getData(\"caption_starts\", 0)\n            char:setData(\"caption_starts\", captionStarts + 1)\n        end\n    else\n        print(\"Caption started:\", text, \"for\", duration, \"seconds\")\n    end\nend)\n\n-- Apply custom effects when caption starts\nhook.Add(\"CaptionStarted\", \"CaptionStartEffects\", function(client, text, duration)\n    if SERVER then\n        -- Play sound effect for the player\n        client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n        -- Notify the player\n        client:notify(\"Caption started: \" .. text)\n    else\n        -- Apply screen effect\n        LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 20), 0.5, 0)\n    end\nend)\n\n-- Modify caption content\nhook.Add(\"CaptionStarted\", \"ModifyCaptionContent\", function(client, text, duration)\n    if SERVER then\n        -- Add timestamp to caption\n        local timestamp = os.date(\"%H:%M:%S\")\n        local modifiedText = \"[\" .. timestamp .. \"] \" .. text\n\n        -- Send modified caption\n        lia.caption.start(client, modifiedText, duration)\n        return true -- Prevent original caption\n    end\nend)\n</code></pre>"},{"location":"modules/captions/hooks/#captionfinished","title":"CaptionFinished","text":"<p>Purpose</p> <p>Called when a caption finishes for a player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose caption finished (Server only).</li> </ul> <p>Realm</p> <p>Server and Client.</p> <p>When Called</p> <p>This hook is triggered when: - A caption duration expires - A caption is manually finished via <code>lia.caption.finish()</code> - A new caption replaces an existing one</p> <p>Example Usage</p> <pre><code>-- Track caption finishes\nhook.Add(\"CaptionFinished\", \"TrackCaptionFinishes\", function(client)\n    if SERVER then\n        print(\"Caption finished for\", client:Name())\n\n        -- Log to server console\n        local char = client:getChar()\n        if char then\n            local captionFinishes = char:getData(\"caption_finishes\", 0)\n            char:setData(\"caption_finishes\", captionFinishes + 1)\n        end\n    else\n        print(\"Caption finished\")\n    end\nend)\n\n-- Apply custom effects when caption finishes\nhook.Add(\"CaptionFinished\", \"CaptionFinishEffects\", function(client)\n    if SERVER then\n        -- Play sound effect for the player\n        client:EmitSound(\"buttons/button15.wav\", 75, 100)\n\n        -- Notify the player\n        client:notify(\"Caption finished\")\n    else\n        -- Apply screen effect\n        LocalPlayer():ScreenFade(SCREENFADE.OUT, Color(255, 0, 0, 20), 0.5, 0)\n    end\nend)\n\n-- Clean up caption data\nhook.Add(\"CaptionFinished\", \"CleanupCaptionData\", function(client)\n    if SERVER then\n        local char = client:getChar()\n        if char then\n            -- Clear caption-related data\n            char:setData(\"current_caption\", nil)\n            char:setData(\"caption_start_time\", nil)\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/captions/hooks/#sendcaptioncommand","title":"SendCaptionCommand","text":"<p>Purpose</p> <p>Called when the sendCaption command is executed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who executed the command.</li> <li><code>target</code> (Player): The target player who will receive the caption.</li> <li><code>text</code> (string): The text content of the caption.</li> <li><code>duration</code> (number): The duration in seconds the caption will be displayed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The <code>sendCaption</code> command is executed - Before the caption is sent to the target player</p> <p>Example Usage</p> <pre><code>-- Track sendCaption command usage\nhook.Add(\"SendCaptionCommand\", \"TrackSendCaptionUsage\", function(client, target, text, duration)\n    print(client:Name(), \"sent caption to\", target:Name(), \":\", text)\n\n    -- Log to server console\n    local char = client:getChar()\n    if char then\n        local sendCaptions = char:getData(\"send_captions\", 0)\n        char:setData(\"send_captions\", sendCaptions + 1)\n    end\nend)\n\n-- Apply custom effects for sendCaption command\nhook.Add(\"SendCaptionCommand\", \"SendCaptionEffects\", function(client, target, text, duration)\n    -- Play sound effect for both players\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n    target:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Notify both players\n    client:notify(\"Caption sent to \" .. target:Name())\n    target:notify(\"Caption received from \" .. client:Name())\nend)\n\n-- Modify sendCaption behavior\nhook.Add(\"SendCaptionCommand\", \"ModifySendCaptionBehavior\", function(client, target, text, duration)\n    -- Check if target is in range\n    local distance = client:GetPos():Distance(target:GetPos())\n    if distance &gt; 1000 then\n        client:notify(\"Target is too far away!\")\n        return false -- Prevent caption from being sent\n    end\n\n    -- Add sender information to caption\n    local modifiedText = \"[\" .. client:Name() .. \"] \" .. text\n    lia.caption.start(target, modifiedText, duration)\n    return true -- Prevent original caption\nend)\n</code></pre>"},{"location":"modules/captions/hooks/#broadcastcaptioncommand","title":"BroadcastCaptionCommand","text":"<p>Purpose</p> <p>Called when the broadcastCaption command is executed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who executed the command.</li> <li><code>text</code> (string): The text content of the caption.</li> <li><code>duration</code> (number): The duration in seconds the caption will be displayed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The <code>broadcastCaption</code> command is executed - Before the caption is sent to all players</p> <p>Example Usage</p> <pre><code>-- Track broadcastCaption command usage\nhook.Add(\"BroadcastCaptionCommand\", \"TrackBroadcastCaptionUsage\", function(client, text, duration)\n    print(client:Name(), \"broadcasted caption:\", text)\n\n    -- Log to server console\n    local char = client:getChar()\n    if char then\n        local broadcastCaptions = char:getData(\"broadcast_captions\", 0)\n        char:setData(\"broadcast_captions\", broadcastCaptions + 1)\n    end\nend)\n\n-- Apply custom effects for broadcastCaption command\nhook.Add(\"BroadcastCaptionCommand\", \"BroadcastCaptionEffects\", function(client, text, duration)\n    -- Play sound effect for all players\n    for _, ply in player.Iterator() do\n        ply:EmitSound(\"buttons/button14.wav\", 75, 100)\n    end\n\n    -- Notify all players\n    for _, ply in player.Iterator() do\n        ply:notify(\"Broadcast caption from \" .. client:Name())\n    end\nend)\n\n-- Modify broadcastCaption behavior\nhook.Add(\"BroadcastCaptionCommand\", \"ModifyBroadcastCaptionBehavior\", function(client, text, duration)\n    -- Add sender information to caption\n    local modifiedText = \"[BROADCAST from \" .. client:Name() .. \"] \" .. text\n\n    -- Send to all players\n    for _, ply in player.Iterator() do\n        lia.caption.start(ply, modifiedText, duration)\n    end\n\n    return true -- Prevent original caption\nend)\n\n-- Log broadcast captions\nhook.Add(\"BroadcastCaptionCommand\", \"LogBroadcastCaptions\", function(client, text, duration)\n    -- Log to server console\n    print(\"BROADCAST CAPTION:\", client:Name(), \"-&gt;\", text, \"(\" .. duration .. \"s)\")\n\n    -- Log to file if needed\n    file.Append(\"captions_log.txt\", os.date() .. \" - \" .. client:Name() .. \" - \" .. text .. \"\\n\")\nend)\n</code></pre>"},{"location":"modules/captions/libraries/","title":"lia.caption Library","text":""},{"location":"modules/captions/libraries/#overview","title":"Overview","text":"<p>Helpers to show and hide Closed Captions for players or locally on the client.</p>"},{"location":"modules/captions/libraries/#start","title":"start","text":"<p>Purpose</p> <p>Begin displaying a caption for a duration.</p> <p>When Called</p> <p>This function is used when: - Temporarily showing on-screen captions/subtitles</p> <p>Parameters</p> <p>Server variant: * <code>client</code> (Player): Recipient. * <code>text</code> (string): Caption text. * <code>duration</code> (number): Seconds to show.</p> <p>Client variant: * <code>text</code> (string): Caption text. * <code>duration</code> (number): Seconds to show.</p> <p>Returns</p> <p>None.</p> <p>Realm</p> <p>Server and Client variants exist.</p> <p>Example Usage</p> <pre><code>-- Server\nlia.caption.start(ply, \"Sector sweep in progress\", 5)\n\n-- Client\nlia.caption.start(\"Welcome\", 3)\n</code></pre>"},{"location":"modules/captions/libraries/#finish","title":"finish","text":"<p>Purpose</p> <p>Stop an active caption.</p> <p>Parameters</p> <p>Server variant: * <code>client</code> (Player): Recipient.</p> <p>Client variant: None.</p> <p>Returns</p> <p>None.</p> <p>Realm</p> <p>Server and Client variants exist.</p> <p>Example Usage</p> <pre><code>-- Server\nlia.caption.finish(ply)\n\n-- Client\nlia.caption.finish()\n</code></pre>"},{"location":"modules/cards/about/","title":"About","text":"About <p>Name: Cards</p> <p>Description:</p> <p>Adds a full deck of playing cards that can be shuffled and drawn. Card draws sync to all players for simple in-game minigames.</p> Features <ul> <li>Adds a full playing card deck</li> <li>Adds random draws that sync to all players</li> <li>Adds support for simple minigames</li> <li>Adds easy reshuffling of the deck</li> <li>Adds hooks so other modules can use cards</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/cards/changelog/","title":"Changelog","text":""},{"location":"modules/cards/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/cards/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/cards/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Cards module for managing card-related functionality.</p>"},{"location":"modules/cards/hooks/#cardscommandused","title":"CardsCommandUsed","text":"<p>Purpose</p> <p>Called when the cards command is used by a player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who used the cards command.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player executes the <code>cards</code> command - Before the card drawing logic is executed - When the command validation passes</p> <p>Example Usage</p> <pre><code>-- Track cards command usage\nhook.Add(\"CardsCommandUsed\", \"TrackCardsCommandUsage\", function(client)\n    print(client:Name(), \"used the cards command\")\n\n    -- Log to server console\n    local char = client:getChar()\n    if char then\n        local cardsCommandUsage = char:getData(\"cards_command_usage\", 0)\n        char:setData(\"cards_command_usage\", cardsCommandUsage + 1)\n    end\nend)\n\n-- Apply custom effects for cards command\nhook.Add(\"CardsCommandUsed\", \"CardsCommandEffects\", function(client)\n    -- Play sound effect\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 215, 0, 20), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Cards command used!\")\nend)\n\n-- Modify cards command behavior\nhook.Add(\"CardsCommandUsed\", \"ModifyCardsCommandBehavior\", function(client)\n    local char = client:getChar()\n    if char then\n        -- Check if player has special card deck\n        if char:getData(\"special_card_deck\", false) then\n            -- Use special card deck logic\n            local specialCards = {\"Ace of Spades\", \"King of Hearts\", \"Queen of Diamonds\", \"Jack of Clubs\"}\n            local card = table.Random(specialCards)\n            lia.chat.send(client, \"me\", \"draws a special card: \" .. card)\n            return true -- Prevent default behavior\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_card_restricted_area\", false) then\n            client:notify(\"You cannot use cards in this area!\")\n            return false -- Prevent card drawing\n        end\n    end\nend)\n\n-- Log cards command usage\nhook.Add(\"CardsCommandUsed\", \"LogCardsCommandUsage\", function(client)\n    -- Log to server console\n    print(\"CARDS COMMAND:\", client:Name(), \"used cards command at\", os.date())\n\n    -- Log to file if needed\n    file.Append(\"cards_log.txt\", os.date() .. \" - \" .. client:Name() .. \" - Cards command used\\n\")\nend)\n</code></pre>"},{"location":"modules/cards/hooks/#carddrawn","title":"CardDrawn","text":"<p>Purpose</p> <p>Called when a card is successfully drawn by a player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who drew the card.</li> <li><code>card</code> (string): The card that was drawn (e.g., \"Ace of Spades\").</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A card is successfully drawn from the deck - After the card drawing logic completes - When the card result is determined</p> <p>Example Usage</p> <pre><code>-- Track card draws\nhook.Add(\"CardDrawn\", \"TrackCardDraws\", function(client, card)\n    print(client:Name(), \"drew:\", card)\n\n    -- Log to server console\n    local char = client:getChar()\n    if char then\n        local cardDraws = char:getData(\"card_draws\", 0)\n        char:setData(\"card_draws\", cardDraws + 1)\n\n        -- Track specific cards drawn\n        local cardsDrawn = char:getData(\"cards_drawn\", {})\n        table.insert(cardsDrawn, {\n            card = card,\n            timestamp = os.time()\n        })\n        char:setData(\"cards_drawn\", cardsDrawn)\n    end\nend)\n\n-- Apply custom effects for card draws\nhook.Add(\"CardDrawn\", \"CardDrawEffects\", function(client, card)\n    -- Play sound effect based on card type\n    if card:find(\"Ace\") then\n        client:EmitSound(\"buttons/button15.wav\", 75, 100)\n    elseif card:find(\"King\") or card:find(\"Queen\") then\n        client:EmitSound(\"buttons/button14.wav\", 75, 100)\n    else\n        client:EmitSound(\"buttons/button13.wav\", 75, 100)\n    end\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 20), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Card drawn: \" .. card)\nend)\n\n-- Modify card draw behavior\nhook.Add(\"CardDrawn\", \"ModifyCardDrawBehavior\", function(client, card)\n    local char = client:getChar()\n    if char then\n        -- Check for special card combinations\n        local cardsDrawn = char:getData(\"cards_drawn\", {})\n        if #cardsDrawn &gt;= 3 then\n            -- Check for three of a kind\n            local lastThree = {}\n            for i = #cardsDrawn - 2, #cardsDrawn do\n                if cardsDrawn[i] then\n                    local rank = cardsDrawn[i].card:match(\"(%w+)\")\n                    table.insert(lastThree, rank)\n                end\n            end\n\n            if lastThree[1] == lastThree[2] and lastThree[2] == lastThree[3] then\n                client:notify(\"Three of a kind! Bonus points!\")\n                char:setData(\"bonus_points\", (char:getData(\"bonus_points\", 0) + 100))\n            end\n        end\n\n        -- Check for royal flush\n        if card:find(\"Ace\") or card:find(\"King\") or card:find(\"Queen\") or card:find(\"Jack\") then\n            client:notify(\"Royal card drawn! Special effect!\")\n            -- Apply special effect\n            client:ScreenFade(SCREENFADE.IN, Color(255, 215, 0, 50), 1, 0)\n        end\n    end\nend)\n\n-- Track card statistics\nhook.Add(\"CardDrawn\", \"TrackCardStatistics\", function(client, card)\n    local char = client:getChar()\n    if char then\n        -- Track card frequency\n        local cardFrequency = char:getData(\"card_frequency\", {})\n        cardFrequency[card] = (cardFrequency[card] or 0) + 1\n        char:setData(\"card_frequency\", cardFrequency)\n\n        -- Track suit frequency\n        local suit = card:match(\"(%w+)$\")\n        if suit then\n            local suitFrequency = char:getData(\"suit_frequency\", {})\n            suitFrequency[suit] = (suitFrequency[suit] or 0) + 1\n            char:setData(\"suit_frequency\", suitFrequency)\n        end\n\n        -- Track rank frequency\n        local rank = card:match(\"(%w+)\")\n        if rank then\n            local rankFrequency = char:getData(\"rank_frequency\", {})\n            rankFrequency[rank] = (rankFrequency[rank] or 0) + 1\n            char:setData(\"rank_frequency\", rankFrequency)\n        end\n    end\nend)\n\n-- Log card draws\nhook.Add(\"CardDrawn\", \"LogCardDraws\", function(client, card)\n    -- Log to server console\n    print(\"CARD DRAWN:\", client:Name(), \"drew\", card, \"at\", os.date())\n\n    -- Log to file if needed\n    file.Append(\"cards_log.txt\", os.date() .. \" - \" .. client:Name() .. \" - Drew: \" .. card .. \"\\n\")\nend)\n</code></pre>"},{"location":"modules/cards/hooks/#usage-examples","title":"Usage Examples","text":""},{"location":"modules/cards/hooks/#complete-card-system","title":"Complete Card System","text":"<pre><code>-- Track all card-related activity\nhook.Add(\"CardsCommandUsed\", \"TrackAllCardActivity\", function(client)\n    local char = client:getChar()\n    if char then\n        local totalActivity = char:getData(\"total_card_activity\", 0)\n        char:setData(\"total_card_activity\", totalActivity + 1)\n    end\nend)\n\nhook.Add(\"CardDrawn\", \"TrackAllCardActivity\", function(client, card)\n    local char = client:getChar()\n    if char then\n        local totalActivity = char:getData(\"total_card_activity\", 0)\n        char:setData(\"total_card_activity\", totalActivity + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/cards/hooks/#card-based-rewards-system","title":"Card-Based Rewards System","text":"<pre><code>-- Reward system based on cards drawn\nhook.Add(\"CardDrawn\", \"CardRewardSystem\", function(client, card)\n    local char = client:getChar()\n    if char then\n        local rewards = {\n            [\"Ace of Spades\"] = 100,\n            [\"King of Hearts\"] = 50,\n            [\"Queen of Diamonds\"] = 25,\n            [\"Jack of Clubs\"] = 10\n        }\n\n        local reward = rewards[card]\n        if reward then\n            char:setData(\"card_rewards\", (char:getData(\"card_rewards\", 0) + reward))\n            client:notify(\"Card reward: \" .. reward .. \" points!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/cards/hooks/#card-statistics-tracking","title":"Card Statistics Tracking","text":"<pre><code>-- Comprehensive card statistics\nhook.Add(\"CardDrawn\", \"ComprehensiveCardStats\", function(client, card)\n    local char = client:getChar()\n    if char then\n        local stats = char:getData(\"card_stats\", {\n            total_draws = 0,\n            aces_drawn = 0,\n            face_cards_drawn = 0,\n            spades_drawn = 0,\n            hearts_drawn = 0,\n            diamonds_drawn = 0,\n            clubs_drawn = 0\n        })\n\n        stats.total_draws = stats.total_draws + 1\n\n        if card:find(\"Ace\") then\n            stats.aces_drawn = stats.aces_drawn + 1\n        end\n\n        if card:find(\"King\") or card:find(\"Queen\") or card:find(\"Jack\") then\n            stats.face_cards_drawn = stats.face_cards_drawn + 1\n        end\n\n        if card:find(\"Spades\") then\n            stats.spades_drawn = stats.spades_drawn + 1\n        elseif card:find(\"Hearts\") then\n            stats.hearts_drawn = stats.hearts_drawn + 1\n        elseif card:find(\"Diamonds\") then\n            stats.diamonds_drawn = stats.diamonds_drawn + 1\n        elseif card:find(\"Clubs\") then\n            stats.clubs_drawn = stats.clubs_drawn + 1\n        end\n\n        char:setData(\"card_stats\", stats)\n    end\nend)\n</code></pre>"},{"location":"modules/chatmessages/about/","title":"About","text":"About <p>Name: Chat Messages</p> <p>Description:</p> <p>Periodically posts automated advert messages in chat on a timer. Keeps players informed with rotating tips even when staff are offline.</p> Features <ul> <li>Adds periodic server adverts to chat</li> <li>Adds interval control via ChatMessagesInterval</li> <li>Adds localized message support</li> <li>Adds rotating tips for new players</li> <li>Adds toggle to disable adverts per user</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/chatmessages/changelog/","title":"Changelog","text":""},{"location":"modules/chatmessages/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/chatmessages/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/chatmessages/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Chat Messages module for managing automated chat messages.</p>"},{"location":"modules/chatmessages/hooks/#chatmessagestimerstarted","title":"ChatMessagesTimerStarted","text":"<p>Purpose</p> <p>Called when the chat messages timer is started with a specific interval.</p> <p>Parameters</p> <ul> <li><code>interval</code> (number): The interval in seconds between chat messages.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The chat messages module initializes - The timer for automated messages is created - Before any messages are sent</p> <p>Example Usage</p> <pre><code>-- Track when chat messages timer starts\nhook.Add(\"ChatMessagesTimerStarted\", \"TrackChatMessagesTimer\", function(interval)\n    print(\"Chat messages timer started with interval:\", interval, \"seconds\")\n\n    -- Log to server console\n    if SERVER then\n        print(\"Chat messages timer started with interval:\", interval, \"seconds\")\n    end\nend)\n\n-- Modify chat messages behavior based on timer\nhook.Add(\"ChatMessagesTimerStarted\", \"ModifyChatMessagesBehavior\", function(interval)\n    -- Store the interval for later use\n    local char = LocalPlayer():getChar()\n    if char then\n        char:setData(\"chat_messages_interval\", interval)\n    end\n\n    -- Notify player about automated messages\n    LocalPlayer():notify(\"Automated chat messages enabled with \" .. interval .. \" second intervals\")\nend)\n\n-- Apply custom timer modifications\nhook.Add(\"ChatMessagesTimerStarted\", \"CustomTimerModifications\", function(interval)\n    -- Double the interval for certain players\n    local char = LocalPlayer():getChar()\n    if char and char:getData(\"vip_status\", false) then\n        timer.Adjust(\"MessageTimer\", interval * 2, 0, function()\n            -- Custom VIP message handling\n            local messageData = {\"VIP Message 1\", \"VIP Message 2\"}\n            local nextMessageIndex = 1\n            local text = messageData[nextMessageIndex]\n            chat.AddText(Color(255, 215, 0), \"[VIP] \", color_white, text)\n        end)\n    end\nend)\n</code></pre>"},{"location":"modules/chatmessages/hooks/#chatmessagesent","title":"ChatMessageSent","text":"<p>Purpose</p> <p>Called when a chat message is sent by the automated system.</p> <p>Parameters</p> <ul> <li><code>messageIndex</code> (number): The index of the message that was sent.</li> <li><code>text</code> (string): The text content of the message that was sent.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - An automated chat message is displayed - After the message is added to chat - When the message timer fires</p> <p>Example Usage</p> <pre><code>-- Track sent messages\nhook.Add(\"ChatMessageSent\", \"TrackSentMessages\", function(messageIndex, text)\n    local char = LocalPlayer():getChar()\n    if char then\n        local sentMessages = char:getData(\"sent_messages\", 0)\n        char:setData(\"sent_messages\", sentMessages + 1)\n\n        -- Log message details\n        print(\"Message\", messageIndex, \"sent:\", text)\n    end\nend)\n\n-- Apply custom effects to sent messages\nhook.Add(\"ChatMessageSent\", \"CustomMessageEffects\", function(messageIndex, text)\n    -- Play sound effect\n    LocalPlayer():EmitSound(\"buttons/button15.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Automated message sent: \" .. text)\nend)\n\n-- Modify message content\nhook.Add(\"ChatMessageSent\", \"ModifyMessageContent\", function(messageIndex, text)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Add character-specific prefix\n        local charName = char:getName()\n        local modifiedText = \"[\" .. charName .. \"] \" .. text\n\n        -- Send modified message\n        chat.AddText(Color(255, 0, 0), \"[MODIFIED] \", color_white, modifiedText)\n    end\nend)\n\n-- Track message statistics\nhook.Add(\"ChatMessageSent\", \"TrackMessageStatistics\", function(messageIndex, text)\n    local char = LocalPlayer():getChar()\n    if char then\n        local messageStats = char:getData(\"message_statistics\", {})\n        messageStats[messageIndex] = {\n            text = text,\n            timestamp = os.time(),\n            length = string.len(text)\n        }\n        char:setData(\"message_statistics\", messageStats)\n    end\nend)\n</code></pre>"},{"location":"modules/cinematictext/about/","title":"About","text":"About <p>Name: Cinematic Text</p> <p>Description:</p> <p>Adds displays of cinematic splash text overlays, screen darkening with letterbox bars, support for scripted scenes, timed fades for dramatic effect, and customizable text fonts.</p> Features <ul> <li>Adds displays of cinematic splash text overlays</li> <li>Adds screen darkening with letterbox bars</li> <li>Adds support for scripted scenes</li> <li>Adds timed fades for dramatic effect</li> <li>Adds customizable text fonts</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/cinematictext/changelog/","title":"Changelog","text":""},{"location":"modules/cinematictext/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/cinematictext/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/cinematictext/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/cinematictext/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Cinematic Text module for managing cinematic splash text overlays and displays.</p>"},{"location":"modules/cinematictext/hooks/#cinematicdisplayended","title":"CinematicDisplayEnded","text":"<p>Purpose</p> <p>Called when a cinematic text display has finished and is being removed.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The cinematic text display timer expires - The display fades out completely - The splash text panel is removed</p> <p>Example Usage</p> <pre><code>-- Clean up after cinematic display\nhook.Add(\"CinematicDisplayEnded\", \"CleanupCinematicDisplay\", function()\n    -- Stop any background music\n    if IsValid(cinematicMusic) then\n        cinematicMusic:Stop()\n    end\n\n    -- Clear screen effects\n    LocalPlayer():ScreenFade(SCREENFADE.OUT, Color(0, 0, 0, 0), 0.5, 0)\n\n    -- Reset HUD elements\n    if IsValid(cinematicHUD) then\n        cinematicHUD:Remove()\n    end\nend)\n\n-- Track display completion\nhook.Add(\"CinematicDisplayEnded\", \"TrackDisplayCompletion\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local displaysWatched = char:getData(\"cinematic_displays_watched\", 0)\n        char:setData(\"cinematic_displays_watched\", displaysWatched + 1)\n    end\nend)\n\n-- Notify when display ends\nhook.Add(\"CinematicDisplayEnded\", \"NotifyDisplayEnd\", function()\n    LocalPlayer():notify(\"Cinematic display ended!\")\nend)\n</code></pre>"},{"location":"modules/cinematictext/hooks/#cinematicdisplaystart","title":"CinematicDisplayStart","text":"<p>Purpose</p> <p>Called when a cinematic text display starts showing.</p> <p>Parameters</p> <ul> <li><code>text</code> (string): The main text content (can be nil).</li> <li><code>bigText</code> (string): The large text content (can be nil).</li> <li><code>duration</code> (number): The duration in seconds the display will show.</li> <li><code>blackBars</code> (boolean): Whether black bars should be drawn.</li> <li><code>music</code> (boolean): Whether background music should play.</li> <li><code>color</code> (Color): The color of the text.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A cinematic display is received from the server - Before the splash text panel is created - Before any visual effects are applied</p> <p>Example Usage</p> <pre><code>-- Apply custom effects when display starts\nhook.Add(\"CinematicDisplayStart\", \"CustomDisplayEffects\", function(text, bigText, duration, blackBars, music, color)\n    -- Apply screen darkening\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 0, 0, 50), 1, 0)\n\n    -- Create custom HUD overlay\n    local overlay = vgui.Create(\"DPanel\")\n    overlay:SetSize(ScrW(), ScrH())\n    overlay:SetPos(0, 0)\n    overlay.Paint = function(self, w, h)\n        surface.SetDrawColor(0, 0, 0, 100)\n        surface.DrawRect(0, 0, w, h)\n    end\n    overlay:MakePopup()\n\n    -- Store reference for cleanup\n    cinematicHUD = overlay\nend)\n\n-- Track display statistics\nhook.Add(\"CinematicDisplayStart\", \"TrackDisplayStats\", function(text, bigText, duration, blackBars, music, color)\n    local char = LocalPlayer():getChar()\n    if char then\n        local totalDuration = char:getData(\"total_cinematic_duration\", 0)\n        char:setData(\"total_cinematic_duration\", totalDuration + duration)\n\n        -- Track display preferences\n        if blackBars then\n            char:setData(\"black_bars_displays\", char:getData(\"black_bars_displays\", 0) + 1)\n        end\n        if music then\n            char:setData(\"music_displays\", char:getData(\"music_displays\", 0) + 1)\n        end\n    end\nend)\n\n-- Apply custom music\nhook.Add(\"CinematicDisplayStart\", \"CustomMusic\", function(text, bigText, duration, blackBars, music, color)\n    if music then\n        -- Play custom music based on text content\n        local musicFile = \"music/stingers/industrial_suspense2.wav\"\n\n        if text and string.find(string.lower(text), \"warning\") then\n            musicFile = \"music/stingers/warning.wav\"\n        elseif text and string.find(string.lower(text), \"victory\") then\n            musicFile = \"music/stingers/victory.wav\"\n        end\n\n        cinematicMusic = CreateSound(LocalPlayer(), musicFile)\n        cinematicMusic:PlayEx(0, 100)\n        cinematicMusic:ChangeVolume(1, 2)\n    end\nend)\n</code></pre>"},{"location":"modules/cinematictext/hooks/#cinematicmenuopened","title":"CinematicMenuOpened","text":"<p>Purpose</p> <p>Called when the cinematic text menu is opened.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client who opened the menu.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The <code>cinematicmenu</code> command is executed - Before the menu network message is sent to the client</p> <p>Example Usage</p> <pre><code>-- Track menu usage\nhook.Add(\"CinematicMenuOpened\", \"TrackMenuUsage\", function(client)\n    local char = client:getChar()\n    if char then\n        local menuUses = char:getData(\"cinematic_menu_uses\", 0)\n        char:setData(\"cinematic_menu_uses\", menuUses + 1)\n    end\n\n    lia.log.add(client, \"cinematicMenuOpened\")\nend)\n\n-- Apply restrictions\nhook.Add(\"CinematicMenuOpened\", \"ApplyMenuRestrictions\", function(client)\n    -- Check cooldown\n    local lastUse = client:getData(\"last_cinematic_menu\", 0)\n    if os.time() - lastUse &lt; 60 then -- 1 minute cooldown\n        client:notify(\"Please wait before opening the cinematic menu again!\")\n        return false\n    end\n\n    -- Set last use time\n    client:setData(\"last_cinematic_menu\", os.time())\nend)\n\n-- Notify administrators\nhook.Add(\"CinematicMenuOpened\", \"NotifyAdmins\", function(client)\n    for _, admin in player.Iterator() do\n        if admin:IsAdmin() then\n            admin:notify(client:Name() .. \" opened the cinematic menu\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/cinematictext/hooks/#cinematicpanelcreated","title":"CinematicPanelCreated","text":"<p>Purpose</p> <p>Called when the cinematic splash text panel is created.</p> <p>Parameters</p> <ul> <li><code>panel</code> (Panel): The cinematic splash text panel.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The splash text panel is created - Before any visual effects are applied - After <code>CinematicDisplayStart</code> hook</p> <p>Example Usage</p> <pre><code>-- Customize the panel appearance\nhook.Add(\"CinematicPanelCreated\", \"CustomizePanel\", function(panel)\n    -- Add custom styling\n    panel:SetBackgroundColor(Color(0, 0, 0, 0))\n\n    -- Add custom border\n    panel.Paint = function(self, w, h)\n        surface.SetDrawColor(255, 255, 255, 100)\n        surface.DrawOutlinedRect(0, 0, w, h)\n    end\n\n    -- Store reference for later use\n    currentCinematicPanel = panel\nend)\n\n-- Add custom effects to the panel\nhook.Add(\"CinematicPanelCreated\", \"AddPanelEffects\", function(panel)\n    -- Add particle effect\n    local effect = EffectData()\n    effect:SetOrigin(panel:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Add sound effect\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\nend)\n\n-- Track panel creation\nhook.Add(\"CinematicPanelCreated\", \"TrackPanelCreation\", function(panel)\n    local char = LocalPlayer():getChar()\n    if char then\n        local panelsCreated = char:getData(\"cinematic_panels_created\", 0)\n        char:setData(\"cinematic_panels_created\", panelsCreated + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/cinematictext/hooks/#cinematictriggered","title":"CinematicTriggered","text":"<p>Purpose</p> <p>Called when a cinematic display is triggered by a player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who triggered the cinematic.</li> <li><code>text</code> (string): The main text content.</li> <li><code>bigText</code> (string): The large text content.</li> <li><code>duration</code> (number): The duration in seconds.</li> <li><code>blackBars</code> (boolean): Whether black bars should be drawn.</li> <li><code>music</code> (boolean): Whether background music should play.</li> <li><code>color</code> (Color): The color of the text.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player sends a cinematic display request - Before the display is broadcast to all clients - After permission checks pass</p> <p>Example Usage</p> <pre><code>-- Log cinematic triggers\nhook.Add(\"CinematicTriggered\", \"LogCinematicTriggers\", function(client, text, bigText, duration, blackBars, music, color)\n    lia.log.add(client, \"cinematicTriggered\", text, bigText, duration)\n\n    -- Log to external system\n    local data = {\n        sender = client:SteamID(),\n        sender_name = client:Name(),\n        text = text,\n        big_text = bigText,\n        duration = duration,\n        black_bars = blackBars,\n        music = music,\n        color = {r = color.r, g = color.g, b = color.b, a = color.a},\n        timestamp = os.time()\n    }\n\n    http.Post(\"https://your-logging-service.com/cinematic-triggers\", data, function(response)\n        print(\"Cinematic trigger logged to external system\")\n    end)\nend)\n\n-- Track cinematic usage statistics\nhook.Add(\"CinematicTriggered\", \"TrackCinematicStats\", function(client, text, bigText, duration, blackBars, music, color)\n    local char = client:getChar()\n    if char then\n        local triggers = char:getData(\"cinematic_triggers\", 0)\n        char:setData(\"cinematic_triggers\", triggers + 1)\n\n        -- Track total duration\n        local totalDuration = char:getData(\"total_cinematic_duration_created\", 0)\n        char:setData(\"total_cinematic_duration_created\", totalDuration + duration)\n\n        -- Track preferences\n        if blackBars then\n            char:setData(\"black_bars_triggers\", char:getData(\"black_bars_triggers\", 0) + 1)\n        end\n        if music then\n            char:setData(\"music_triggers\", char:getData(\"music_triggers\", 0) + 1)\n        end\n    end\nend)\n\n-- Apply content filtering\nhook.Add(\"CinematicTriggered\", \"FilterCinematicContent\", function(client, text, bigText, duration, blackBars, music, color)\n    -- Check for inappropriate content\n    local filteredWords = {\"spam\", \"scam\", \"hack\"}\n\n    local fullText = (text or \"\") .. \" \" .. (bigText or \"\")\n    for _, word in ipairs(filteredWords) do\n        if string.find(string.lower(fullText), word) then\n            client:notify(\"Your cinematic text contains inappropriate content!\")\n            return false\n        end\n    end\n\n    -- Check duration limits\n    if duration &gt; 30 then\n        client:notify(\"Cinematic duration too long! Maximum 30 seconds allowed.\")\n        return false\n    end\n\n    -- Check for empty content\n    if not text and not bigText then\n        client:notify(\"Cinematic text cannot be empty!\")\n        return false\n    end\nend)\n\n-- Notify administrators of cinematic triggers\nhook.Add(\"CinematicTriggered\", \"NotifyAdmins\", function(client, text, bigText, duration, blackBars, music, color)\n    for _, admin in player.Iterator() do\n        if admin:IsAdmin() then\n            local message = client:Name() .. \" triggered cinematic: \"\n            if text then message = message .. text end\n            if bigText then message = message .. \" (Big: \" .. bigText .. \")\" end\n            admin:notify(message)\n        end\n    end\nend)\n\n-- Award achievements\nhook.Add(\"CinematicTriggered\", \"CinematicAchievements\", function(client, text, bigText, duration, blackBars, music, color)\n    local char = client:getChar()\n    if char then\n        local triggers = char:getData(\"cinematic_triggers\", 0)\n\n        if triggers == 1 then\n            client:notify(\"Achievement: First Cinematic!\")\n        elseif triggers == 10 then\n            client:notify(\"Achievement: Cinematic Director!\")\n        elseif triggers == 50 then\n            client:notify(\"Achievement: Master of Drama!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/climb/about/","title":"About","text":"About <p>Name: Climbing</p> <p>Description:</p> <p>Adds the ability to climb ledges using movement keys, custom climbing animations, and hooks for climb attempts.</p> Features <ul> <li>Adds the ability to climb ledges using movement keys</li> <li>Adds custom climbing animations</li> <li>Adds hooks for climb attempts</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/climb/changelog/","title":"Changelog","text":""},{"location":"modules/climb/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/climb/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/climb/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Climb module for managing player climbing mechanics and ledge climbing.</p>"},{"location":"modules/climb/hooks/#playerbeginclimb","title":"PlayerBeginClimb","text":"<p>Purpose</p> <p>Called when a player begins climbing a ledge.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who is beginning to climb.</li> <li><code>distance</code> (number): The distance to the ledge being climbed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player successfully attempts to climb a ledge - The climb trace detects a valid climbable surface - Before the player's velocity is modified</p> <p>Example Usage</p> <pre><code>-- Track climbing statistics\nhook.Add(\"PlayerBeginClimb\", \"TrackClimbingStats\", function(player, distance)\n    local char = player:getChar()\n    if char then\n        local climbs = char:getData(\"climbs_attempted\", 0)\n        char:setData(\"climbs_attempted\", climbs + 1)\n\n        -- Track distance climbed\n        local totalDistance = char:getData(\"total_climb_distance\", 0)\n        char:setData(\"total_climb_distance\", totalDistance + distance)\n\n        -- Track highest climb\n        local highestClimb = char:getData(\"highest_climb\", 0)\n        if distance &gt; highestClimb then\n            char:setData(\"highest_climb\", distance)\n        end\n    end\nend)\n\n-- Apply climbing effects\nhook.Add(\"PlayerBeginClimb\", \"ApplyClimbingEffects\", function(player, distance)\n    -- Play climbing sound\n    player:EmitSound(\"player/pl_jumpland1.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 10), 0.5, 0)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Log climbing attempts\nhook.Add(\"PlayerBeginClimb\", \"LogClimbingAttempts\", function(player, distance)\n    lia.log.add(player, \"climbBegin\", distance)\n\n    -- Notify nearby players\n    for _, ply in player.Iterator() do\n        if ply ~= player and ply:GetPos():Distance(player:GetPos()) &lt; 200 then\n            ply:notify(player:Name() .. \" is climbing a ledge!\")\n        end\n    end\nend)\n\n-- Apply climbing restrictions\nhook.Add(\"PlayerBeginClimb\", \"ApplyClimbingRestrictions\", function(player, distance)\n    local char = player:getChar()\n    if char then\n        -- Check if player is carrying too much weight\n        local weight = char:getData(\"carried_weight\", 0)\n        if weight &gt; 50 then\n            player:notify(\"You're carrying too much to climb!\")\n            return false\n        end\n\n        -- Check if player is injured\n        if char:getData(\"injured\", false) then\n            player:notify(\"You're too injured to climb!\")\n            return false\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/climb/hooks/#playerclimbattempt","title":"PlayerClimbAttempt","text":"<p>Purpose</p> <p>Called when a player attempts to climb (presses jump while looking at a ledge).</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player attempting to climb.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player presses the jump key - Before any climb detection logic runs - Before <code>PlayerBeginClimb</code> or <code>PlayerFailedClimb</code> hooks</p> <p>Example Usage</p> <pre><code>-- Track climb attempts\nhook.Add(\"PlayerClimbAttempt\", \"TrackClimbAttempts\", function(player)\n    local char = player:getChar()\n    if char then\n        local attempts = char:getData(\"climb_attempts\", 0)\n        char:setData(\"climb_attempts\", attempts + 1)\n\n        -- Track attempt frequency\n        local lastAttempt = char:getData(\"last_climb_attempt\", 0)\n        char:setData(\"last_climb_attempt\", os.time())\n\n        if os.time() - lastAttempt &lt; 1 then\n            char:setData(\"rapid_climb_attempts\", char:getData(\"rapid_climb_attempts\", 0) + 1)\n        end\n    end\nend)\n\n-- Apply attempt restrictions\nhook.Add(\"PlayerClimbAttempt\", \"ApplyAttemptRestrictions\", function(player)\n    local char = player:getChar()\n    if char then\n        -- Check cooldown\n        local lastClimb = char:getData(\"last_climb\", 0)\n        if os.time() - lastClimb &lt; 2 then -- 2 second cooldown\n            player:notify(\"Please wait before attempting to climb again!\")\n            return false\n        end\n\n        -- Check stamina\n        local stamina = char:getData(\"stamina\", 100)\n        if stamina &lt; 20 then\n            player:notify(\"You're too tired to climb!\")\n            return false\n        end\n\n        -- Reduce stamina\n        char:setData(\"stamina\", stamina - 10)\n    end\nend)\n\n-- Log climb attempts\nhook.Add(\"PlayerClimbAttempt\", \"LogClimbAttempts\", function(player)\n    lia.log.add(player, \"climbAttempt\")\nend)\n\n-- Apply attempt effects\nhook.Add(\"PlayerClimbAttempt\", \"ApplyAttemptEffects\", function(player)\n    -- Play attempt sound\n    player:EmitSound(\"player/pl_jump1.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 5), 0.3, 0)\nend)\n</code></pre>"},{"location":"modules/climb/hooks/#playerclimbed","title":"PlayerClimbed","text":"<p>Purpose</p> <p>Called when a player successfully completes a climb.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who successfully climbed.</li> <li><code>distance</code> (number): The distance that was climbed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player successfully climbs a ledge - After the player's velocity has been modified - After <code>PlayerBeginClimb</code> hook</p> <p>Example Usage</p> <pre><code>-- Track successful climbs\nhook.Add(\"PlayerClimbed\", \"TrackSuccessfulClimbs\", function(player, distance)\n    local char = player:getChar()\n    if char then\n        local successfulClimbs = char:getData(\"successful_climbs\", 0)\n        char:setData(\"successful_climbs\", successfulClimbs + 1)\n\n        -- Track total distance climbed\n        local totalDistance = char:getData(\"total_climb_distance\", 0)\n        char:setData(\"total_climb_distance\", totalDistance + distance)\n\n        -- Track climb success rate\n        local attempts = char:getData(\"climb_attempts\", 0)\n        local successRate = (successfulClimbs / attempts) * 100\n        char:setData(\"climb_success_rate\", successRate)\n    end\nend)\n\n-- Apply success effects\nhook.Add(\"PlayerClimbed\", \"ApplySuccessEffects\", function(player, distance)\n    -- Play success sound\n    player:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 1, 0)\n\n    -- Create success particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos() + Vector(0, 0, 50))\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Notify player\n    player:notify(\"Successfully climbed \" .. math.Round(distance) .. \" units!\")\nend)\n\n-- Award climbing achievements\nhook.Add(\"PlayerClimbed\", \"ClimbingAchievements\", function(player, distance)\n    local char = player:getChar()\n    if char then\n        local successfulClimbs = char:getData(\"successful_climbs\", 0)\n\n        if successfulClimbs == 1 then\n            player:notify(\"Achievement: First Climb!\")\n        elseif successfulClimbs == 10 then\n            player:notify(\"Achievement: Climbing Enthusiast!\")\n        elseif successfulClimbs == 50 then\n            player:notify(\"Achievement: Master Climber!\")\n        elseif successfulClimbs == 100 then\n            player:notify(\"Achievement: Climbing Legend!\")\n        end\n\n        -- Check for distance achievements\n        if distance &gt; 100 then\n            player:notify(\"Achievement: High Climber! (\" .. math.Round(distance) .. \" units)\")\n        end\n    end\nend)\n\n-- Log successful climbs\nhook.Add(\"PlayerClimbed\", \"LogSuccessfulClimbs\", function(player, distance)\n    lia.log.add(player, \"climbSuccess\", distance)\n\n    -- Notify nearby players\n    for _, ply in player.Iterator() do\n        if ply ~= player and ply:GetPos():Distance(player:GetPos()) &lt; 300 then\n            ply:notify(player:Name() .. \" successfully climbed a ledge!\")\n        end\n    end\nend)\n\n-- Apply post-climb effects\nhook.Add(\"PlayerClimbed\", \"PostClimbEffects\", function(player, distance)\n    local char = player:getChar()\n    if char then\n        -- Reduce stamina based on distance\n        local stamina = char:getData(\"stamina\", 100)\n        local staminaCost = math.min(distance * 0.1, 20)\n        char:setData(\"stamina\", math.max(0, stamina - staminaCost))\n\n        -- Set last climb time\n        char:setData(\"last_climb\", os.time())\n\n        -- Apply temporary speed boost\n        player:SetWalkSpeed(player:GetWalkSpeed() * 1.1)\n        player:SetRunSpeed(player:GetRunSpeed() * 1.1)\n\n        -- Remove speed boost after 5 seconds\n        timer.Simple(5, function()\n            if IsValid(player) then\n                player:SetWalkSpeed(200)\n                player:SetRunSpeed(400)\n            end\n        end)\n    end\nend)\n</code></pre>"},{"location":"modules/climb/hooks/#playerfailedclimb","title":"PlayerFailedClimb","text":"<p>Purpose</p> <p>Called when a player fails to climb (no valid climbable surface detected).</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who failed to climb.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player attempts to climb but no valid surface is found - The climb trace doesn't detect a climbable ledge - After <code>PlayerClimbAttempt</code> hook</p> <p>Example Usage</p> <pre><code>-- Track failed climb attempts\nhook.Add(\"PlayerFailedClimb\", \"TrackFailedClimbs\", function(player)\n    local char = player:getChar()\n    if char then\n        local failedClimbs = char:getData(\"failed_climbs\", 0)\n        char:setData(\"failed_climbs\", failedClimbs + 1)\n\n        -- Track failure rate\n        local attempts = char:getData(\"climb_attempts\", 0)\n        local failureRate = (failedClimbs / attempts) * 100\n        char:setData(\"climb_failure_rate\", failureRate)\n    end\nend)\n\n-- Apply failure effects\nhook.Add(\"PlayerFailedClimb\", \"ApplyFailureEffects\", function(player)\n    -- Play failure sound\n    player:EmitSound(\"player/pl_jump2.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 5), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"No climbable surface found!\")\nend)\n\n-- Provide climbing hints\nhook.Add(\"PlayerFailedClimb\", \"ProvideClimbingHints\", function(player)\n    local char = player:getChar()\n    if char then\n        local failedClimbs = char:getData(\"failed_climbs\", 0)\n\n        -- Provide hints based on failure count\n        if failedClimbs == 5 then\n            player:notify(\"Tip: Look for ledges that are about 30 units away!\")\n        elseif failedClimbs == 10 then\n            player:notify(\"Tip: Make sure you're looking directly at the ledge!\")\n        elseif failedClimbs == 20 then\n            player:notify(\"Tip: Try jumping while looking at the ledge!\")\n        end\n    end\nend)\n\n-- Log failed climbs\nhook.Add(\"PlayerFailedClimb\", \"LogFailedClimbs\", function(player)\n    lia.log.add(player, \"climbFailed\")\nend)\n\n-- Apply failure penalties\nhook.Add(\"PlayerFailedClimb\", \"ApplyFailurePenalties\", function(player)\n    local char = player:getChar()\n    if char then\n        -- Reduce stamina for failed attempts\n        local stamina = char:getData(\"stamina\", 100)\n        char:setData(\"stamina\", math.max(0, stamina - 5))\n\n        -- Apply temporary movement penalty\n        player:SetWalkSpeed(player:GetWalkSpeed() * 0.9)\n        player:SetRunSpeed(player:GetRunSpeed() * 0.9)\n\n        -- Remove penalty after 3 seconds\n        timer.Simple(3, function()\n            if IsValid(player) then\n                player:SetWalkSpeed(200)\n                player:SetRunSpeed(400)\n            end\n        end)\n    end\nend)\n\n-- Track consecutive failures\nhook.Add(\"PlayerFailedClimb\", \"TrackConsecutiveFailures\", function(player)\n    local char = player:getChar()\n    if char then\n        local consecutiveFailures = char:getData(\"consecutive_climb_failures\", 0)\n        char:setData(\"consecutive_climb_failures\", consecutiveFailures + 1)\n\n        -- Apply cooldown for too many consecutive failures\n        if consecutiveFailures &gt;= 5 then\n            char:setData(\"climb_cooldown\", os.time() + 10) -- 10 second cooldown\n            player:notify(\"Too many failed climb attempts! Please wait 10 seconds.\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/communitycommands/about/","title":"About","text":"About <p>Name: Community Commands</p> <p>Description:</p> <p>Adds chat commands to open community links, easy sharing of workshop and docs, configurable commands via settings, localization for command names, and the ability to add custom URLs.</p> Features <ul> <li>Adds chat commands to open community links</li> <li>Adds easy sharing of workshop and docs</li> <li>Adds configurable commands via settings</li> <li>Adds localization for command names</li> <li>Adds the ability to add custom URLs</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/communitycommands/changelog/","title":"Changelog","text":""},{"location":"modules/communitycommands/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/communitycommands/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/communitycommands/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Community Commands module for managing community URL commands and external link handling.</p>"},{"location":"modules/communitycommands/hooks/#communityurlopened","title":"CommunityURLOpened","text":"<p>Purpose</p> <p>Called when a community URL is opened on the client side.</p> <p>Parameters</p> <ul> <li><code>commandName</code> (string): The name of the command that was executed.</li> <li><code>url</code> (string): The URL that was opened.</li> <li><code>openIngame</code> (boolean): Whether the URL should open in-game or in the external browser.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A community URL command is executed - The URL is about to be opened (either in-game or externally) - After <code>CommunityURLRequest</code> hook on the server</p> <p>Example Usage</p> <pre><code>-- Track URL usage\nhook.Add(\"CommunityURLOpened\", \"TrackURLUsage\", function(commandName, url, openIngame)\n    local char = LocalPlayer():getChar()\n    if char then\n        local urlsOpened = char:getData(\"community_urls_opened\", 0)\n        char:setData(\"community_urls_opened\", urlsOpened + 1)\n\n        -- Track specific command usage\n        local commandUsage = char:getData(\"command_usage\", {})\n        commandUsage[commandName] = (commandUsage[commandName] or 0) + 1\n        char:setData(\"command_usage\", commandUsage)\n\n        -- Track in-game vs external usage\n        if openIngame then\n            char:setData(\"ingame_urls\", char:getData(\"ingame_urls\", 0) + 1)\n        else\n            char:setData(\"external_urls\", char:getData(\"external_urls\", 0) + 1)\n        end\n    end\nend)\n\n-- Apply custom effects when URL opens\nhook.Add(\"CommunityURLOpened\", \"ApplyURLEffects\", function(commandName, url, openIngame)\n    -- Play sound effect\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.5, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Opening \" .. commandName .. \" URL...\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(LocalPlayer():GetPos() + Vector(0, 0, 50))\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Customize in-game browser\nhook.Add(\"CommunityURLOpened\", \"CustomizeInGameBrowser\", function(commandName, url, openIngame)\n    if openIngame then\n        -- Add custom styling to in-game browser\n        timer.Simple(0.1, function()\n            local frames = vgui.GetWorldPanel():GetChildren()\n            for _, frame in ipairs(frames) do\n                if frame:GetName() == \"DFrame\" and frame:GetTitle() == commandName then\n                    -- Customize the frame\n                    frame:SetBackgroundColor(Color(50, 50, 50, 255))\n                    frame:SetTitleColor(Color(255, 255, 255))\n\n                    -- Add custom close button\n                    local closeBtn = frame:Add(\"DButton\")\n                    closeBtn:SetText(\"Close\")\n                    closeBtn:SetPos(frame:GetWide() - 80, 5)\n                    closeBtn:SetSize(70, 25)\n                    closeBtn.DoClick = function()\n                        frame:Close()\n                    end\n                end\n            end\n        end)\n    end\nend)\n\n-- Log URL openings\nhook.Add(\"CommunityURLOpened\", \"LogURLOpenings\", function(commandName, url, openIngame)\n    print(\"Community URL opened: \" .. commandName .. \" -&gt; \" .. url .. \" (In-game: \" .. tostring(openIngame) .. \")\")\nend)\n\n-- Apply URL-specific effects\nhook.Add(\"CommunityURLOpened\", \"ApplyURLSpecificEffects\", function(commandName, url, openIngame)\n    -- Apply different effects based on command\n    if commandName == \"Discord\" then\n        LocalPlayer():EmitSound(\"buttons/button15.wav\", 75, 100)\n        LocalPlayer():ScreenFade(SCREENFADE.IN, Color(114, 137, 218, 10), 1, 0)\n    elseif commandName == \"Rules\" then\n        LocalPlayer():EmitSound(\"buttons/button14.wav\", 75, 100)\n        LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 1, 0)\n    elseif commandName == \"SteamGroup\" then\n        LocalPlayer():EmitSound(\"buttons/button16.wav\", 75, 100)\n        LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 100, 200, 10), 1, 0)\n    end\nend)\n</code></pre>"},{"location":"modules/communitycommands/hooks/#communityurlrequest","title":"CommunityURLRequest","text":"<p>Purpose</p> <p>Called when a community URL command is requested on the server side.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client who requested the URL.</li> <li><code>command</code> (string): The command that was executed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A community URL command is executed - Before the URL is sent to the client - After command validation</p> <p>Example Usage</p> <pre><code>-- Track URL requests\nhook.Add(\"CommunityURLRequest\", \"TrackURLRequests\", function(client, command)\n    local char = client:getChar()\n    if char then\n        local requests = char:getData(\"community_url_requests\", 0)\n        char:setData(\"community_url_requests\", requests + 1)\n\n        -- Track specific command requests\n        local commandRequests = char:getData(\"command_requests\", {})\n        commandRequests[command] = (commandRequests[command] or 0) + 1\n        char:setData(\"command_requests\", commandRequests)\n    end\n\n    lia.log.add(client, \"communityURLRequest\", command)\nend)\n\n-- Apply request restrictions\nhook.Add(\"CommunityURLRequest\", \"ApplyRequestRestrictions\", function(client, command)\n    local char = client:getChar()\n    if char then\n        -- Check cooldown\n        local lastRequest = char:getData(\"last_url_request\", 0)\n        if os.time() - lastRequest &lt; 5 then -- 5 second cooldown\n            client:notify(\"Please wait before using another community command!\")\n            return false\n        end\n\n        -- Check daily limit\n        local today = os.date(\"%Y-%m-%d\")\n        local dailyRequests = char:getData(\"daily_url_requests\", {})\n        if dailyRequests[today] and dailyRequests[today] &gt;= 10 then\n            client:notify(\"Daily community command limit reached!\")\n            return false\n        end\n\n        -- Update counters\n        char:setData(\"last_url_request\", os.time())\n        dailyRequests[today] = (dailyRequests[today] or 0) + 1\n        char:setData(\"daily_url_requests\", dailyRequests)\n    end\nend)\n\n-- Log URL requests for moderation\nhook.Add(\"CommunityURLRequest\", \"LogURLRequests\", function(client, command)\n    -- Log to external system\n    local data = {\n        player = client:SteamID(),\n        player_name = client:Name(),\n        command = command,\n        timestamp = os.time()\n    }\n\n    http.Post(\"https://your-logging-service.com/community-requests\", data, function(response)\n        print(\"Community URL request logged to external system\")\n    end)\n\n    -- Notify administrators\n    for _, admin in player.Iterator() do\n        if admin:IsAdmin() then\n            admin:notify(client:Name() .. \" used community command: \" .. command)\n        end\n    end\nend)\n\n-- Apply command-specific restrictions\nhook.Add(\"CommunityURLRequest\", \"ApplyCommandRestrictions\", function(client, command)\n    local char = client:getChar()\n    if char then\n        -- Check faction-based restrictions\n        local faction = char:getFaction()\n\n        if command == \"Discord\" and faction == \"criminal\" then\n            client:notify(\"Criminals cannot access the Discord server!\")\n            return false\n        end\n\n        if command == \"Rules\" and faction == \"police\" then\n            -- Police get priority access\n            client:notify(\"Accessing official rules...\")\n        end\n\n        -- Check for restricted commands\n        local restrictedCommands = char:getData(\"restricted_commands\", {})\n        if restrictedCommands[command] then\n            client:notify(\"You don't have permission to use this command!\")\n            return false\n        end\n    end\nend)\n\n-- Track command usage patterns\nhook.Add(\"CommunityURLRequest\", \"TrackCommandPatterns\", function(client, command)\n    local char = client:getChar()\n    if char then\n        -- Track command frequency\n        local commandFrequency = char:getData(\"command_frequency\", {})\n        commandFrequency[command] = (commandFrequency[command] or 0) + 1\n        char:setData(\"command_frequency\", commandFrequency)\n\n        -- Track command sequence\n        local commandSequence = char:getData(\"command_sequence\", {})\n        table.insert(commandSequence, command)\n        if #commandSequence &gt; 10 then\n            table.remove(commandSequence, 1)\n        end\n        char:setData(\"command_sequence\", commandSequence)\n\n        -- Detect spam patterns\n        local recentCommands = {}\n        for i = math.max(1, #commandSequence - 5), #commandSequence do\n            table.insert(recentCommands, commandSequence[i])\n        end\n\n        local sameCommandCount = 0\n        for _, cmd in ipairs(recentCommands) do\n            if cmd == command then\n                sameCommandCount = sameCommandCount + 1\n            end\n        end\n\n        if sameCommandCount &gt;= 3 then\n            client:notify(\"Please don't spam community commands!\")\n            return false\n        end\n    end\nend)\n\n-- Award achievements for command usage\nhook.Add(\"CommunityURLRequest\", \"CommandAchievements\", function(client, command)\n    local char = client:getChar()\n    if char then\n        local totalRequests = char:getData(\"community_url_requests\", 0)\n\n        if totalRequests == 1 then\n            client:notify(\"Achievement: First Community Command!\")\n        elseif totalRequests == 10 then\n            client:notify(\"Achievement: Community Explorer!\")\n        elseif totalRequests == 50 then\n            client:notify(\"Achievement: Community Master!\")\n        end\n\n        -- Command-specific achievements\n        local commandRequests = char:getData(\"command_requests\", {})\n        if commandRequests[command] == 1 then\n            client:notify(\"Achievement: First \" .. command .. \" Command!\")\n        elseif commandRequests[command] == 10 then\n            client:notify(\"Achievement: \" .. command .. \" Enthusiast!\")\n        end\n    end\nend)\n\n-- Apply request effects\nhook.Add(\"CommunityURLRequest\", \"ApplyRequestEffects\", function(client, command)\n    -- Play sound effect\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.3, 0)\n\n    -- Notify client\n    client:notify(\"Processing \" .. command .. \" request...\")\nend)\n</code></pre>"},{"location":"modules/corpscid/changelog/","title":"Changelog","text":""},{"location":"modules/corpscid/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/corpseid/about/","title":"About","text":"About <p>Name: Corpse ID</p> <p>Description:</p> <p>Adds the ability to identify corpses after IdentificationTime, use of CorpseMessageFont for 3D2D text, info display above bodies, configurable identification delays, and logs when corpses are identified.</p> Features <ul> <li>Adds the ability to identify corpses after IdentificationTime</li> <li>Adds use of CorpseMessageFont for 3D2D text</li> <li>Adds info display above bodies</li> <li>Adds configurable identification delays</li> <li>Adds logs when corpses are identified</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/corpseid/changelog/","title":"Changelog","text":""},{"location":"modules/corpseid/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/corpseid/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/corpseid/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/corpseid/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Corpse ID module for managing corpse identification functionality.</p>"},{"location":"modules/corpseid/hooks/#corpsecreated","title":"CorpseCreated","text":"<p>Purpose</p> <p>Called when a corpse is created for a player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose corpse was created.</li> <li><code>corpse</code> (Entity): The ragdoll corpse entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player dies and a ragdoll is created - The corpse is set up with player information - Before the corpse becomes available for identification</p> <p>Example Usage</p> <pre><code>-- Track corpse creation\nhook.Add(\"CorpseCreated\", \"TrackCorpseCreation\", function(client, corpse)\n    local char = client:getChar()\n    if char then\n        local corpsesCreated = char:getData(\"corpses_created\", 0)\n        char:setData(\"corpses_created\", corpsesCreated + 1)\n\n        -- Track death location\n        char:setData(\"last_death_location\", client:GetPos())\n        char:setData(\"last_death_time\", os.time())\n    end\n\n    lia.log.add(client, \"corpseCreated\", client:GetPos())\nend)\n\n-- Apply corpse effects\nhook.Add(\"CorpseCreated\", \"CorpseCreationEffects\", function(client, corpse)\n    -- Play death sound\n    client:EmitSound(\"vo/npc/male01/pain08.wav\", 75, 100)\n\n    -- Create death particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Set corpse properties\n    corpse:setNetVar(\"ShowCorpseMessage\", true)\n    corpse:setNetVar(\"player\", client)\n    corpse:setNetVar(\"death_time\", os.time())\nend)\n\n-- Notify nearby players\nhook.Add(\"CorpseCreated\", \"NotifyNearbyPlayers\", function(client, corpse)\n    for _, ply in player.Iterator() do\n        if ply ~= client and ply:GetPos():Distance(client:GetPos()) &lt; 500 then\n            ply:notify(client:Name() .. \" has died nearby!\")\n        end\n    end\nend)\n\n-- Track death statistics\nhook.Add(\"CorpseCreated\", \"TrackDeathStats\", function(client, corpse)\n    local char = client:getChar()\n    if char then\n        local deaths = char:getData(\"total_deaths\", 0)\n        char:setData(\"total_deaths\", deaths + 1)\n\n        -- Track death causes\n        local deathCause = client:GetNWString(\"LastDamageType\", \"unknown\")\n        local deathCauses = char:getData(\"death_causes\", {})\n        deathCauses[deathCause] = (deathCauses[deathCause] or 0) + 1\n        char:setData(\"death_causes\", deathCauses)\n    end\nend)\n</code></pre>"},{"location":"modules/corpseid/hooks/#corpseidentified","title":"CorpseIdentified","text":"<p>Purpose</p> <p>Called when a corpse has been successfully identified.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who identified the corpse.</li> <li><code>targetPlayer</code> (Player): The player whose corpse was identified.</li> <li><code>corpse</code> (Entity): The ragdoll corpse entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player completes the identification process - After the identification time has elapsed - After <code>CorpseIdentifyStarted</code> hook</p> <p>Example Usage</p> <pre><code>-- Track corpse identifications\nhook.Add(\"CorpseIdentified\", \"TrackCorpseIdentifications\", function(client, targetPlayer, corpse)\n    local char = client:getChar()\n    if char then\n        local identifications = char:getData(\"corpse_identifications\", 0)\n        char:setData(\"corpse_identifications\", identifications + 1)\n\n        -- Track identification targets\n        local targetIdentifications = char:getData(\"target_identifications\", {})\n        targetIdentifications[targetPlayer:SteamID()] = (targetIdentifications[targetPlayer:SteamID()] or 0) + 1\n        char:setData(\"target_identifications\", targetIdentifications)\n    end\n\n    lia.log.add(client, \"corpseIdentified\", targetPlayer:Name())\nend)\n\n-- Apply identification effects\nhook.Add(\"CorpseIdentified\", \"IdentificationEffects\", function(client, targetPlayer, corpse)\n    -- Play identification sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 1, 0)\n\n    -- Notify client\n    client:notify(\"Successfully identified \" .. targetPlayer:Name() .. \"'s corpse!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(corpse:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Award identification achievements\nhook.Add(\"CorpseIdentified\", \"IdentificationAchievements\", function(client, targetPlayer, corpse)\n    local char = client:getChar()\n    if char then\n        local identifications = char:getData(\"corpse_identifications\", 0)\n\n        if identifications == 1 then\n            client:notify(\"Achievement: First Identification!\")\n        elseif identifications == 10 then\n            client:notify(\"Achievement: Corpse Detective!\")\n        elseif identifications == 50 then\n            client:notify(\"Achievement: Master Investigator!\")\n        end\n\n        -- Check for specific target achievements\n        local targetIdentifications = char:getData(\"target_identifications\", {})\n        local targetCount = targetIdentifications[targetPlayer:SteamID()] or 0\n\n        if targetCount == 1 then\n            client:notify(\"Achievement: First time identifying \" .. targetPlayer:Name() .. \"!\")\n        end\n    end\nend)\n\n-- Track identification patterns\nhook.Add(\"CorpseIdentified\", \"TrackIdentificationPatterns\", function(client, targetPlayer, corpse)\n    local char = client:getChar()\n    if char then\n        -- Track identification frequency\n        local lastIdentification = char:getData(\"last_identification_time\", 0)\n        char:setData(\"last_identification_time\", os.time())\n\n        -- Track identification speed\n        local identificationStart = char:getData(\"identification_start_time\", 0)\n        if identificationStart &gt; 0 then\n            local identificationTime = os.time() - identificationStart\n            char:setData(\"avg_identification_time\", char:getData(\"avg_identification_time\", 0) + identificationTime)\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/corpseid/hooks/#corpseidentifybegin","title":"CorpseIdentifyBegin","text":"<p>Purpose</p> <p>Called when a player begins the corpse identification process.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is beginning identification.</li> <li><code>entity</code> (Entity): The ragdoll corpse entity being identified.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player chooses to identify a corpse - Before the identification timer starts - After the identification question is answered positively</p> <p>Example Usage</p> <pre><code>-- Track identification attempts\nhook.Add(\"CorpseIdentifyBegin\", \"TrackIdentificationAttempts\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        local identificationAttempts = char:getData(\"identification_attempts\", 0)\n        char:setData(\"identification_attempts\", identificationAttempts + 1)\n\n        -- Set identification start time\n        char:setData(\"identification_start_time\", os.time())\n    end\n\n    lia.log.add(client, \"corpseIdentifyBegin\", entity:GetPos())\nend)\n\n-- Apply identification start effects\nhook.Add(\"CorpseIdentifyBegin\", \"IdentificationStartEffects\", function(client, entity)\n    -- Play start sound\n    client:EmitSound(\"buttons/button15.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.5, 0)\n\n    -- Notify client\n    client:notify(\"Beginning corpse identification...\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(entity:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Apply identification restrictions\nhook.Add(\"CorpseIdentifyBegin\", \"ApplyIdentificationRestrictions\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Check cooldown\n        local lastIdentification = char:getData(\"last_identification_time\", 0)\n        if os.time() - lastIdentification &lt; 10 then -- 10 second cooldown\n            client:notify(\"Please wait before identifying another corpse!\")\n            return false\n        end\n\n        -- Check if already identifying\n        if char:getData(\"currently_identifying\", false) then\n            client:notify(\"You are already identifying a corpse!\")\n            return false\n        end\n\n        -- Set identification status\n        char:setData(\"currently_identifying\", true)\n        char:setData(\"identification_target\", entity:EntIndex())\n    end\nend)\n\n-- Track identification statistics\nhook.Add(\"CorpseIdentifyBegin\", \"TrackIdentificationStats\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Track identification locations\n        local identificationLocations = char:getData(\"identification_locations\", {})\n        table.insert(identificationLocations, {\n            pos = entity:GetPos(),\n            time = os.time()\n        })\n        char:setData(\"identification_locations\", identificationLocations)\n\n        -- Track identification targets\n        local targetPlayer = entity:getNetVar(\"player\")\n        if IsValid(targetPlayer) then\n            local targetIdentifications = char:getData(\"target_identification_attempts\", {})\n            targetIdentifications[targetPlayer:SteamID()] = (targetIdentifications[targetPlayer:SteamID()] or 0) + 1\n            char:setData(\"target_identification_attempts\", targetIdentifications)\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/corpseid/hooks/#corpseidentifydeclined","title":"CorpseIdentifyDeclined","text":"<p>Purpose</p> <p>Called when a player declines to identify a corpse.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who declined identification.</li> <li><code>entity</code> (Entity): The ragdoll corpse entity that was declined.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player chooses not to identify a corpse - After the identification question is answered negatively</p> <p>Example Usage</p> <pre><code>-- Track identification declines\nhook.Add(\"CorpseIdentifyDeclined\", \"TrackIdentificationDeclines\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        local identificationDeclines = char:getData(\"identification_declines\", 0)\n        char:setData(\"identification_declines\", identificationDeclines + 1)\n    end\n\n    lia.log.add(client, \"corpseIdentifyDeclined\", entity:GetPos())\nend)\n\n-- Apply decline effects\nhook.Add(\"CorpseIdentifyDeclined\", \"IdentificationDeclineEffects\", function(client, entity)\n    -- Play decline sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 5), 0.5, 0)\n\n    -- Notify client\n    client:notify(\"Corpse identification declined.\")\nend)\n\n-- Track decline patterns\nhook.Add(\"CorpseIdentifyDeclined\", \"TrackDeclinePatterns\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Track decline frequency\n        local lastDecline = char:getData(\"last_decline_time\", 0)\n        char:setData(\"last_decline_time\", os.time())\n\n        -- Track decline reasons\n        local declineReasons = char:getData(\"decline_reasons\", {})\n        local reason = \"unknown\"\n\n        -- Determine decline reason based on context\n        if entity:GetPos():Distance(client:GetPos()) &gt; 200 then\n            reason = \"too_far\"\n        elseif client:getChar():getData(\"injured\", false) then\n            reason = \"injured\"\n        elseif client:getChar():getData(\"busy\", false) then\n            reason = \"busy\"\n        end\n\n        declineReasons[reason] = (declineReasons[reason] or 0) + 1\n        char:setData(\"decline_reasons\", declineReasons)\n    end\nend)\n\n-- Apply decline restrictions\nhook.Add(\"CorpseIdentifyDeclined\", \"ApplyDeclineRestrictions\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Check decline cooldown\n        local lastDecline = char:getData(\"last_decline_time\", 0)\n        if os.time() - lastDecline &lt; 5 then -- 5 second cooldown\n            client:notify(\"Please wait before declining another identification!\")\n            return false\n        end\n\n        -- Track decline frequency\n        local declineCount = char:getData(\"recent_declines\", 0)\n        char:setData(\"recent_declines\", declineCount + 1)\n\n        -- Reset decline count after 1 minute\n        timer.Simple(60, function()\n            if IsValid(client) and client:getChar() then\n                client:getChar():setData(\"recent_declines\", 0)\n            end\n        end)\n    end\nend)\n</code></pre>"},{"location":"modules/corpseid/hooks/#corpseidentifystarted","title":"CorpseIdentifyStarted","text":"<p>Purpose</p> <p>Called when the corpse identification process starts (timer begins).</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is identifying the corpse.</li> <li><code>targetPlayer</code> (Player): The player whose corpse is being identified.</li> <li><code>corpse</code> (Entity): The ragdoll corpse entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The identification timer starts - After <code>CorpseIdentifyBegin</code> hook - Before the identification process begins</p> <p>Example Usage</p> <pre><code>-- Track identification start\nhook.Add(\"CorpseIdentifyStarted\", \"TrackIdentificationStart\", function(client, targetPlayer, corpse)\n    local char = client:getChar()\n    if char then\n        char:setData(\"identification_start_time\", os.time())\n        char:setData(\"identification_target\", targetPlayer:SteamID())\n    end\n\n    lia.log.add(client, \"corpseIdentifyStarted\", targetPlayer:Name())\nend)\n\n-- Apply identification start effects\nhook.Add(\"CorpseIdentifyStarted\", \"IdentificationStartEffects\", function(client, targetPlayer, corpse)\n    -- Play start sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 255, 10), 1, 0)\n\n    -- Notify client\n    client:notify(\"Identifying \" .. targetPlayer:Name() .. \"'s corpse...\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(corpse:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track identification statistics\nhook.Add(\"CorpseIdentifyStarted\", \"TrackIdentificationStats\", function(client, targetPlayer, corpse)\n    local char = client:getChar()\n    if char then\n        -- Track identification targets\n        local targetIdentifications = char:getData(\"target_identification_starts\", {})\n        targetIdentifications[targetPlayer:SteamID()] = (targetIdentifications[targetPlayer:SteamID()] or 0) + 1\n        char:setData(\"target_identification_starts\", targetIdentifications)\n\n        -- Track identification locations\n        local identificationLocations = char:getData(\"identification_start_locations\", {})\n        table.insert(identificationLocations, {\n            pos = corpse:GetPos(),\n            target = targetPlayer:Name(),\n            time = os.time()\n        })\n        char:setData(\"identification_start_locations\", identificationLocations)\n    end\nend)\n\n-- Apply identification restrictions\nhook.Add(\"CorpseIdentifyStarted\", \"ApplyIdentificationRestrictions\", function(client, targetPlayer, corpse)\n    local char = client:getChar()\n    if char then\n        -- Check if already identifying\n        if char:getData(\"currently_identifying\", false) then\n            client:notify(\"You are already identifying a corpse!\")\n            return false\n        end\n\n        -- Set identification status\n        char:setData(\"currently_identifying\", true)\n        char:setData(\"identification_target\", targetPlayer:SteamID())\n\n        -- Check identification limits\n        local identificationsToday = char:getData(\"identifications_today\", 0)\n        if identificationsToday &gt;= 20 then\n            client:notify(\"Daily identification limit reached!\")\n            return false\n        end\n    end\nend)\n\n-- Notify target player\nhook.Add(\"CorpseIdentifyStarted\", \"NotifyTargetPlayer\", function(client, targetPlayer, corpse)\n    -- Notify target player if they're online\n    if IsValid(targetPlayer) then\n        targetPlayer:notify(client:Name() .. \" is identifying your corpse!\")\n    end\n\n    -- Notify nearby players\n    for _, ply in player.Iterator() do\n        if ply ~= client and ply:GetPos():Distance(corpse:GetPos()) &lt; 300 then\n            ply:notify(client:Name() .. \" is identifying \" .. targetPlayer:Name() .. \"'s corpse!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/cursor/about/","title":"About","text":"About <p>Name: Cursor</p> <p>Description:</p> <p>Adds a toggleable custom cursor for the UI, a purely client-side implementation, improved menu navigation, a hotkey to quickly show or hide the cursor, and compatibility with other menu modules.</p> Features <ul> <li>Adds a toggleable custom cursor for the UI</li> <li>Adds a purely client-side implementation</li> <li>Adds improved menu navigation</li> <li>Adds a hotkey to quickly show or hide the cursor</li> <li>Adds compatibility with other menu modules</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/cursor/changelog/","title":"Changelog","text":""},{"location":"modules/cursor/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/cursor/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/cursor/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Cursor module for managing custom cursor functionality.</p>"},{"location":"modules/cursor/hooks/#cursorthink","title":"CursorThink","text":"<p>Purpose</p> <p>Called every frame when the cursor is active and hovering over a panel.</p> <p>Parameters</p> <ul> <li><code>hoverPanel</code> (Panel): The panel currently being hovered over.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The cursor is active - A panel is being hovered over - Every frame during the Think hook - After <code>PreCursorThink</code> hook</p> <p>Example Usage</p> <pre><code>-- Track cursor hover statistics\nhook.Add(\"CursorThink\", \"TrackCursorHover\", function(hoverPanel)\n    local char = LocalPlayer():getChar()\n    if char then\n        local hoverTime = char:getData(\"cursor_hover_time\", 0)\n        char:setData(\"cursor_hover_time\", hoverTime + FrameTime())\n\n        -- Track hovered panel types\n        local panelType = hoverPanel:GetName() or \"Unknown\"\n        local panelHovers = char:getData(\"panel_hovers\", {})\n        panelHovers[panelType] = (panelHovers[panelType] or 0) + 1\n        char:setData(\"panel_hovers\", panelHovers)\n    end\nend)\n\n-- Apply cursor hover effects\nhook.Add(\"CursorThink\", \"CursorHoverEffects\", function(hoverPanel)\n    -- Apply screen effect based on panel type\n    if hoverPanel:GetName() == \"DButton\" then\n        LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 2), 0.1, 0)\n    elseif hoverPanel:GetName() == \"DTextEntry\" then\n        LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 2), 0.1, 0)\n    end\nend)\n\n-- Customize cursor behavior\nhook.Add(\"CursorThink\", \"CustomizeCursorBehavior\", function(hoverPanel)\n    -- Change cursor based on panel type\n    if hoverPanel:GetName() == \"DButton\" then\n        hoverPanel:SetCursor(\"hand\")\n    elseif hoverPanel:GetName() == \"DTextEntry\" then\n        hoverPanel:SetCursor(\"ibeam\")\n    else\n        hoverPanel:SetCursor(\"blank\")\n    end\nend)\n\n-- Track cursor performance\nhook.Add(\"CursorThink\", \"TrackCursorPerformance\", function(hoverPanel)\n    local char = LocalPlayer():getChar()\n    if char then\n        local frameTime = char:getData(\"cursor_frame_time\", 0)\n        char:setData(\"cursor_frame_time\", frameTime + FrameTime())\n\n        -- Track frame rate\n        local frameCount = char:getData(\"cursor_frame_count\", 0)\n        char:setData(\"cursor_frame_count\", frameCount + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/cursor/hooks/#postrendercursor","title":"PostRenderCursor","text":"<p>Purpose</p> <p>Called after the custom cursor is rendered.</p> <p>Parameters</p> <ul> <li><code>cursorMaterial</code> (string): The material path of the cursor being rendered.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The custom cursor has been rendered - After <code>PreRenderCursor</code> hook - Every frame when the cursor is active</p> <p>Example Usage</p> <pre><code>-- Track cursor rendering\nhook.Add(\"PostRenderCursor\", \"TrackCursorRendering\", function(cursorMaterial)\n    local char = LocalPlayer():getChar()\n    if char then\n        local renderCount = char:getData(\"cursor_render_count\", 0)\n        char:setData(\"cursor_render_count\", renderCount + 1)\n\n        -- Track cursor material usage\n        local materialUsage = char:getData(\"cursor_material_usage\", {})\n        materialUsage[cursorMaterial] = (materialUsage[cursorMaterial] or 0) + 1\n        char:setData(\"cursor_material_usage\", materialUsage)\n    end\nend)\n\n-- Apply post-render effects\nhook.Add(\"PostRenderCursor\", \"PostRenderEffects\", function(cursorMaterial)\n    -- Apply screen effect after cursor render\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 1), 0.1, 0)\n\n    -- Create particle effect at cursor position\n    local cursorPos = gui.MousePos()\n    local effect = EffectData()\n    effect:SetOrigin(Vector(cursorPos.x, cursorPos.y, 0))\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Customize cursor rendering\nhook.Add(\"PostRenderCursor\", \"CustomizeCursorRendering\", function(cursorMaterial)\n    -- Override cursor rendering with custom effects\n    local cursorPos = gui.MousePos()\n\n    -- Draw custom cursor outline\n    surface.SetDrawColor(255, 255, 255, 100)\n    surface.DrawRect(cursorPos.x - 1, cursorPos.y - 1, 3, 3)\n\n    -- Draw custom cursor center\n    surface.SetDrawColor(0, 0, 0, 200)\n    surface.DrawRect(cursorPos.x, cursorPos.y, 1, 1)\nend)\n\n-- Track cursor performance\nhook.Add(\"PostRenderCursor\", \"TrackCursorPerformance\", function(cursorMaterial)\n    local char = LocalPlayer():getChar()\n    if char then\n        local renderTime = char:getData(\"cursor_render_time\", 0)\n        char:setData(\"cursor_render_time\", renderTime + FrameTime())\n\n        -- Track render frequency\n        local renderFrequency = char:getData(\"cursor_render_frequency\", 0)\n        char:setData(\"cursor_render_frequency\", renderFrequency + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/cursor/hooks/#precursorthink","title":"PreCursorThink","text":"<p>Purpose</p> <p>Called before the cursor Think hook processes the hovered panel.</p> <p>Parameters</p> <ul> <li><code>hoverPanel</code> (Panel): The panel currently being hovered over.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The cursor is active - A panel is being hovered over - Before the cursor Think hook processes the panel - Before <code>CursorThink</code> hook</p> <p>Example Usage</p> <pre><code>-- Validate cursor hover\nhook.Add(\"PreCursorThink\", \"ValidateCursorHover\", function(hoverPanel)\n    -- Check if panel is valid\n    if not IsValid(hoverPanel) then\n        return false\n    end\n\n    -- Check if panel is visible\n    if not hoverPanel:IsVisible() then\n        return false\n    end\n\n    -- Check if panel is enabled\n    if hoverPanel.IsEnabled and not hoverPanel:IsEnabled() then\n        return false\n    end\nend)\n\n-- Apply pre-think effects\nhook.Add(\"PreCursorThink\", \"PreThinkEffects\", function(hoverPanel)\n    -- Apply screen effect before processing\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 1), 0.1, 0)\n\n    -- Play hover sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\nend)\n\n-- Track cursor hover patterns\nhook.Add(\"PreCursorThink\", \"TrackCursorPatterns\", function(hoverPanel)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track hover frequency\n        local hoverFrequency = char:getData(\"cursor_hover_frequency\", 0)\n        char:setData(\"cursor_hover_frequency\", hoverFrequency + 1)\n\n        -- Track panel types\n        local panelType = hoverPanel:GetName() or \"Unknown\"\n        local panelTypes = char:getData(\"cursor_panel_types\", {})\n        panelTypes[panelType] = (panelTypes[panelType] or 0) + 1\n        char:setData(\"cursor_panel_types\", panelTypes)\n    end\nend)\n\n-- Apply cursor restrictions\nhook.Add(\"PreCursorThink\", \"ApplyCursorRestrictions\", function(hoverPanel)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if cursor is disabled\n        if char:getData(\"cursor_disabled\", false) then\n            return false\n        end\n\n        -- Check cursor cooldown\n        local lastCursor = char:getData(\"last_cursor_time\", 0)\n        if os.time() - lastCursor &lt; 1 then -- 1 second cooldown\n            return false\n        end\n\n        -- Update last cursor time\n        char:setData(\"last_cursor_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/cursor/hooks/#prerendercursor","title":"PreRenderCursor","text":"<p>Purpose</p> <p>Called before the custom cursor is rendered.</p> <p>Parameters</p> <ul> <li><code>cursorMaterial</code> (string): The material path of the cursor being rendered.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The custom cursor is about to be rendered - Before the cursor material is drawn - Every frame when the cursor is active</p> <p>Example Usage</p> <pre><code>-- Track cursor rendering\nhook.Add(\"PreRenderCursor\", \"TrackCursorRendering\", function(cursorMaterial)\n    local char = LocalPlayer():getChar()\n    if char then\n        local renderCount = char:getData(\"cursor_pre_render_count\", 0)\n        char:setData(\"cursor_pre_render_count\", renderCount + 1)\n\n        -- Track cursor material usage\n        local materialUsage = char:getData(\"cursor_pre_material_usage\", {})\n        materialUsage[cursorMaterial] = (materialUsage[cursorMaterial] or 0) + 1\n        char:setData(\"cursor_pre_material_usage\", materialUsage)\n    end\nend)\n\n-- Apply pre-render effects\nhook.Add(\"PreRenderCursor\", \"PreRenderEffects\", function(cursorMaterial)\n    -- Apply screen effect before cursor render\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 1), 0.1, 0)\n\n    -- Play render sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\nend)\n\n-- Customize cursor material\nhook.Add(\"PreRenderCursor\", \"CustomizeCursorMaterial\", function(cursorMaterial)\n    -- Override cursor material based on context\n    local hoverPanel = vgui.GetHoveredPanel()\n    if IsValid(hoverPanel) then\n        if hoverPanel:GetName() == \"DButton\" then\n            cursorMaterial = \"cursor/hand\"\n        elseif hoverPanel:GetName() == \"DTextEntry\" then\n            cursorMaterial = \"cursor/ibeam\"\n        end\n    end\n\n    -- Apply custom cursor effects\n    local cursorPos = gui.MousePos()\n\n    -- Draw custom cursor background\n    surface.SetDrawColor(0, 0, 0, 100)\n    surface.DrawRect(cursorPos.x - 2, cursorPos.y - 2, 4, 4)\n\n    -- Draw custom cursor border\n    surface.SetDrawColor(255, 255, 255, 200)\n    surface.DrawRect(cursorPos.x - 1, cursorPos.y - 1, 2, 2)\nend)\n\n-- Track cursor performance\nhook.Add(\"PreRenderCursor\", \"TrackCursorPerformance\", function(cursorMaterial)\n    local char = LocalPlayer():getChar()\n    if char then\n        local preRenderTime = char:getData(\"cursor_pre_render_time\", 0)\n        char:setData(\"cursor_pre_render_time\", preRenderTime + FrameTime())\n\n        -- Track render frequency\n        local renderFrequency = char:getData(\"cursor_pre_render_frequency\", 0)\n        char:setData(\"cursor_pre_render_frequency\", renderFrequency + 1)\n    end\nend)\n\n-- Apply cursor restrictions\nhook.Add(\"PreRenderCursor\", \"ApplyCursorRestrictions\", function(cursorMaterial)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if cursor is disabled\n        if char:getData(\"cursor_disabled\", false) then\n            return false\n        end\n\n        -- Check cursor cooldown\n        local lastCursor = char:getData(\"last_cursor_render_time\", 0)\n        if os.time() - lastCursor &lt; 1 then -- 1 second cooldown\n            return false\n        end\n\n        -- Update last cursor render time\n        char:setData(\"last_cursor_render_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/cutscenes/about/","title":"About","text":"About <p>Name: Cutscenes</p> <p>Description:</p> <p>Adds a framework for simple cutscene playback, scenes defined through tables, syncing of camera movement across clients, commands to trigger cutscenes, and the ability for players to skip.</p> Features <ul> <li>Adds a framework for simple cutscene playback</li> <li>Adds scenes defined through tables</li> <li>Adds syncing of camera movement across clients</li> <li>Adds commands to trigger cutscenes</li> <li>Adds the ability for players to skip</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/cutscenes/changelog/","title":"Changelog","text":""},{"location":"modules/cutscenes/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/cutscenes/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/cutscenes/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Cutscenes module for managing cutscene playback and control.</p>"},{"location":"modules/cutscenes/hooks/#cutsceneended","title":"CutsceneEnded","text":"<p>Purpose</p> <p>Called when a cutscene has completely finished playing.</p> <p>Parameters</p> <ul> <li><code>cutsceneID</code> (string): The ID of the cutscene that ended.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A cutscene has finished playing all scenes - The cutscene fade out is complete - The cutscene panel is removed</p> <p>Example Usage</p> <pre><code>-- Track cutscene completion\nhook.Add(\"CutsceneEnded\", \"TrackCutsceneCompletion\", function(cutsceneID)\n    local char = LocalPlayer():getChar()\n    if char then\n        local cutscenesWatched = char:getData(\"cutscenes_watched\", 0)\n        char:setData(\"cutscenes_watched\", cutscenesWatched + 1)\n\n        -- Track specific cutscene\n        local cutsceneWatches = char:getData(\"cutscene_watches\", {})\n        cutsceneWatches[cutsceneID] = (cutsceneWatches[cutsceneID] or 0) + 1\n        char:setData(\"cutscene_watches\", cutsceneWatches)\n    end\nend)\n\n-- Apply cutscene end effects\nhook.Add(\"CutsceneEnded\", \"CutsceneEndEffects\", function(cutsceneID)\n    -- Play end sound\n    LocalPlayer():EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.OUT, Color(0, 0, 0, 0), 1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Cutscene '\" .. cutsceneID .. \"' ended!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(LocalPlayer():GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Clean up cutscene data\nhook.Add(\"CutsceneEnded\", \"CleanupCutsceneData\", function(cutsceneID)\n    -- Clear cutscene state\n    LocalPlayer().scene = nil\n\n    -- Remove cutscene music\n    if lia.cutsceneMusic then\n        lia.cutsceneMusic:Stop()\n        lia.cutsceneMusic = nil\n    end\n\n    -- Clear cutscene variables\n    LocalPlayer():setData(\"current_cutscene\", nil)\n    LocalPlayer():setData(\"cutscene_start_time\", nil)\nend)\n\n-- Award cutscene achievements\nhook.Add(\"CutsceneEnded\", \"CutsceneAchievements\", function(cutsceneID)\n    local char = LocalPlayer():getChar()\n    if char then\n        local cutscenesWatched = char:getData(\"cutscenes_watched\", 0)\n\n        if cutscenesWatched == 1 then\n            LocalPlayer():notify(\"Achievement: First Cutscene!\")\n        elseif cutscenesWatched == 10 then\n            LocalPlayer():notify(\"Achievement: Cutscene Enthusiast!\")\n        elseif cutscenesWatched == 50 then\n            LocalPlayer():notify(\"Achievement: Cutscene Master!\")\n        end\n\n        -- Check for specific cutscene achievements\n        local cutsceneWatches = char:getData(\"cutscene_watches\", {})\n        if cutsceneWatches[cutsceneID] == 1 then\n            LocalPlayer():notify(\"Achievement: First time watching '\" .. cutsceneID .. \"'!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/cutscenes/hooks/#cutscenesceneended","title":"CutsceneSceneEnded","text":"<p>Purpose</p> <p>Called when a specific scene within a cutscene ends.</p> <p>Parameters</p> <ul> <li><code>cutsceneID</code> (string): The ID of the cutscene.</li> <li><code>scene</code> (table): The scene data that ended.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A scene within a cutscene finishes - The scene fade out is complete - Before the next scene starts or cutscene ends</p> <p>Example Usage</p> <pre><code>-- Track scene completion\nhook.Add(\"CutsceneSceneEnded\", \"TrackSceneCompletion\", function(cutsceneID, scene)\n    local char = LocalPlayer():getChar()\n    if char then\n        local scenesWatched = char:getData(\"scenes_watched\", 0)\n        char:setData(\"scenes_watched\", scenesWatched + 1)\n\n        -- Track scene duration\n        local sceneDuration = char:getData(\"total_scene_duration\", 0)\n        char:setData(\"total_scene_duration\", sceneDuration + (scene.duration or 0))\n    end\nend)\n\n-- Apply scene end effects\nhook.Add(\"CutsceneSceneEnded\", \"SceneEndEffects\", function(cutsceneID, scene)\n    -- Play scene end sound\n    LocalPlayer():EmitSound(\"buttons/button15.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 10), 0.5, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Scene ended in cutscene '\" .. cutsceneID .. \"'!\")\nend)\n\n-- Track scene statistics\nhook.Add(\"CutsceneSceneEnded\", \"TrackSceneStats\", function(cutsceneID, scene)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track scene types\n        local sceneTypes = char:getData(\"scene_types\", {})\n        local sceneType = scene.image and \"image\" or \"text\"\n        sceneTypes[sceneType] = (sceneTypes[sceneType] or 0) + 1\n        char:setData(\"scene_types\", sceneTypes)\n\n        -- Track scene durations\n        local sceneDurations = char:getData(\"scene_durations\", {})\n        table.insert(sceneDurations, {\n            cutscene = cutsceneID,\n            duration = scene.duration or 0,\n            time = os.time()\n        })\n        char:setData(\"scene_durations\", sceneDurations)\n    end\nend)\n</code></pre>"},{"location":"modules/cutscenes/hooks/#cutscenescenestarted","title":"CutsceneSceneStarted","text":"<p>Purpose</p> <p>Called when a specific scene within a cutscene starts.</p> <p>Parameters</p> <ul> <li><code>cutsceneID</code> (string): The ID of the cutscene.</li> <li><code>scene</code> (table): The scene data that started.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A scene within a cutscene begins - The scene image is displayed - Before any subtitles are shown</p> <p>Example Usage</p> <pre><code>-- Track scene start\nhook.Add(\"CutsceneSceneStarted\", \"TrackSceneStart\", function(cutsceneID, scene)\n    local char = LocalPlayer():getChar()\n    if char then\n        local scenesStarted = char:getData(\"scenes_started\", 0)\n        char:setData(\"scenes_started\", scenesStarted + 1)\n\n        -- Track scene start time\n        char:setData(\"current_scene_start_time\", os.time())\n    end\nend)\n\n-- Apply scene start effects\nhook.Add(\"CutsceneSceneStarted\", \"SceneStartEffects\", function(cutsceneID, scene)\n    -- Play scene start sound\n    LocalPlayer():EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 0, 0, 50), 1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Scene started in cutscene '\" .. cutsceneID .. \"'!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(LocalPlayer():GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track scene content\nhook.Add(\"CutsceneSceneStarted\", \"TrackSceneContent\", function(cutsceneID, scene)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track scene images\n        if scene.image then\n            local sceneImages = char:getData(\"scene_images\", {})\n            sceneImages[scene.image] = (sceneImages[scene.image] or 0) + 1\n            char:setData(\"scene_images\", sceneImages)\n        end\n\n        -- Track scene sounds\n        if scene.sound then\n            local sceneSounds = char:getData(\"scene_sounds\", {})\n            sceneSounds[scene.sound] = (sceneSounds[scene.sound] or 0) + 1\n            char:setData(\"scene_sounds\", sceneSounds)\n        end\n    end\nend)\n\n-- Apply scene restrictions\nhook.Add(\"CutsceneSceneStarted\", \"ApplySceneRestrictions\", function(cutsceneID, scene)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if cutscenes are disabled\n        if char:getData(\"cutscenes_disabled\", false) then\n            LocalPlayer():notify(\"Cutscenes are disabled!\")\n            return false\n        end\n\n        -- Check scene cooldown\n        local lastScene = char:getData(\"last_scene_time\", 0)\n        if os.time() - lastScene &lt; 5 then -- 5 second cooldown\n            LocalPlayer():notify(\"Please wait before starting another scene!\")\n            return false\n        end\n\n        -- Update last scene time\n        char:setData(\"last_scene_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/cutscenes/hooks/#cutscenestarted","title":"CutsceneStarted","text":"<p>Purpose</p> <p>Called when a cutscene begins playing.</p> <p>Parameters</p> <ul> <li><code>cutsceneID</code> (string): The ID of the cutscene that started.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A cutscene begins playing - The cutscene panel is created - Before any scenes are displayed</p> <p>Example Usage</p> <pre><code>-- Track cutscene start\nhook.Add(\"CutsceneStarted\", \"TrackCutsceneStart\", function(cutsceneID)\n    local char = LocalPlayer():getChar()\n    if char then\n        local cutscenesStarted = char:getData(\"cutscenes_started\", 0)\n        char:setData(\"cutscenes_started\", cutscenesStarted + 1)\n\n        -- Track cutscene start time\n        char:setData(\"current_cutscene_start_time\", os.time())\n        char:setData(\"current_cutscene\", cutsceneID)\n    end\nend)\n\n-- Apply cutscene start effects\nhook.Add(\"CutsceneStarted\", \"CutsceneStartEffects\", function(cutsceneID)\n    -- Play start sound\n    LocalPlayer():EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 0, 0, 100), 1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Cutscene '\" .. cutsceneID .. \"' started!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(LocalPlayer():GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track cutscene statistics\nhook.Add(\"CutsceneStarted\", \"TrackCutsceneStats\", function(cutsceneID)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track cutscene frequency\n        local cutsceneFrequency = char:getData(\"cutscene_frequency\", {})\n        cutsceneFrequency[cutsceneID] = (cutsceneFrequency[cutsceneID] or 0) + 1\n        char:setData(\"cutscene_frequency\", cutsceneFrequency)\n\n        -- Track cutscene start times\n        local cutsceneStartTimes = char:getData(\"cutscene_start_times\", {})\n        table.insert(cutsceneStartTimes, {\n            cutscene = cutsceneID,\n            time = os.time()\n        })\n        char:setData(\"cutscene_start_times\", cutsceneStartTimes)\n    end\nend)\n\n-- Apply cutscene restrictions\nhook.Add(\"CutsceneStarted\", \"ApplyCutsceneRestrictions\", function(cutsceneID)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if cutscenes are disabled\n        if char:getData(\"cutscenes_disabled\", false) then\n            LocalPlayer():notify(\"Cutscenes are disabled!\")\n            return false\n        end\n\n        -- Check cutscene cooldown\n        local lastCutscene = char:getData(\"last_cutscene_time\", 0)\n        if os.time() - lastCutscene &lt; 10 then -- 10 second cooldown\n            LocalPlayer():notify(\"Please wait before starting another cutscene!\")\n            return false\n        end\n\n        -- Update last cutscene time\n        char:setData(\"last_cutscene_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/cutscenes/hooks/#cutscenesubtitlestarted","title":"CutsceneSubtitleStarted","text":"<p>Purpose</p> <p>Called when a subtitle within a cutscene starts displaying.</p> <p>Parameters</p> <ul> <li><code>cutsceneID</code> (string): The ID of the cutscene.</li> <li><code>subtitle</code> (table): The subtitle data that started.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A subtitle begins displaying in a cutscene - The subtitle text is shown - Before the subtitle duration timer starts</p> <p>Example Usage</p> <pre><code>-- Track subtitle start\nhook.Add(\"CutsceneSubtitleStarted\", \"TrackSubtitleStart\", function(cutsceneID, subtitle)\n    local char = LocalPlayer():getChar()\n    if char then\n        local subtitlesStarted = char:getData(\"subtitles_started\", 0)\n        char:setData(\"subtitles_started\", subtitlesStarted + 1)\n\n        -- Track subtitle content\n        local subtitleContent = char:getData(\"subtitle_content\", {})\n        table.insert(subtitleContent, {\n            cutscene = cutsceneID,\n            text = subtitle.text,\n            time = os.time()\n        })\n        char:setData(\"subtitle_content\", subtitleContent)\n    end\nend)\n\n-- Apply subtitle start effects\nhook.Add(\"CutsceneSubtitleStarted\", \"SubtitleStartEffects\", function(cutsceneID, subtitle)\n    -- Play subtitle sound\n    if subtitle.sound then\n        LocalPlayer():EmitSound(subtitle.sound, 75, 100)\n    end\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 5), 0.5, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Subtitle: \" .. subtitle.text)\nend)\n\n-- Track subtitle statistics\nhook.Add(\"CutsceneSubtitleStarted\", \"TrackSubtitleStats\", function(cutsceneID, subtitle)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track subtitle duration\n        local subtitleDuration = char:getData(\"total_subtitle_duration\", 0)\n        char:setData(\"total_subtitle_duration\", subtitleDuration + (subtitle.duration or 0))\n\n        -- Track subtitle colors\n        if subtitle.color then\n            local subtitleColors = char:getData(\"subtitle_colors\", {})\n            local colorKey = subtitle.color.r .. \",\" .. subtitle.color.g .. \",\" .. subtitle.color.b\n            subtitleColors[colorKey] = (subtitleColors[colorKey] or 0) + 1\n            char:setData(\"subtitle_colors\", subtitleColors)\n        end\n\n        -- Track subtitle fonts\n        if subtitle.font then\n            local subtitleFonts = char:getData(\"subtitle_fonts\", {})\n            subtitleFonts[subtitle.font] = (subtitleFonts[subtitle.font] or 0) + 1\n            char:setData(\"subtitle_fonts\", subtitleFonts)\n        end\n    end\nend)\n\n-- Apply subtitle restrictions\nhook.Add(\"CutsceneSubtitleStarted\", \"ApplySubtitleRestrictions\", function(cutsceneID, subtitle)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if subtitles are disabled\n        if char:getData(\"subtitles_disabled\", false) then\n            LocalPlayer():notify(\"Subtitles are disabled!\")\n            return false\n        end\n\n        -- Check subtitle cooldown\n        local lastSubtitle = char:getData(\"last_subtitle_time\", 0)\n        if os.time() - lastSubtitle &lt; 1 then -- 1 second cooldown\n            return false\n        end\n\n        -- Update last subtitle time\n        char:setData(\"last_subtitle_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/damagenumbers/about/","title":"About","text":"About <p>Name: Damage Numbers</p> <p>Description:</p> <p>Adds floating combat text when hitting targets, different colors for damage types, display of damage dealt and received, scaling text based on damage amount, and client option to disable numbers.</p> Features <ul> <li>Adds floating combat text when hitting targets</li> <li>Adds different colors for damage types</li> <li>Adds display of damage dealt and received</li> <li>Adds scaling text based on damage amount</li> <li>Adds client option to disable numbers</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/damagenumbers/changelog/","title":"Changelog","text":""},{"location":"modules/damagenumbers/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/damagenumbers/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/damagenumbers/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/damagenumbers/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Damage Numbers module for managing floating damage text display.</p>"},{"location":"modules/damagenumbers/hooks/#damagenumberadded","title":"DamageNumberAdded","text":"<p>Purpose</p> <p>Called when a damage number is added to the display queue.</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The entity that received damage.</li> <li><code>damage</code> (number): The amount of damage dealt.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A damage number is received from the server - The damage number is added to the display queue - Before the damage number starts displaying</p> <p>Example Usage</p> <pre><code>-- Track damage number display\nhook.Add(\"DamageNumberAdded\", \"TrackDamageNumbers\", function(entity, damage)\n    local char = LocalPlayer():getChar()\n    if char then\n        local damageNumbers = char:getData(\"damage_numbers_seen\", 0)\n        char:setData(\"damage_numbers_seen\", damageNumbers + 1)\n\n        -- Track damage amounts\n        local totalDamage = char:getData(\"total_damage_seen\", 0)\n        char:setData(\"total_damage_seen\", totalDamage + damage)\n\n        -- Track entity types\n        if IsValid(entity) then\n            local entityType = entity:GetClass()\n            local entityDamage = char:getData(\"entity_damage_seen\", {})\n            entityDamage[entityType] = (entityDamage[entityType] or 0) + damage\n            char:setData(\"entity_damage_seen\", entityDamage)\n        end\n    end\nend)\n\n-- Apply damage number effects\nhook.Add(\"DamageNumberAdded\", \"DamageNumberEffects\", function(entity, damage)\n    -- Play damage sound\n    LocalPlayer():EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 5), 0.3, 0)\n\n    -- Create particle effect\n    if IsValid(entity) then\n        local effect = EffectData()\n        effect:SetOrigin(entity:GetPos())\n        effect:SetMagnitude(1)\n        effect:SetScale(1)\n        util.Effect(\"Explosion\", effect)\n    end\nend)\n\n-- Customize damage number display\nhook.Add(\"DamageNumberAdded\", \"CustomizeDamageDisplay\", function(entity, damage)\n    -- Modify damage number based on amount\n    if damage &gt; 100 then\n        -- Large damage - make it more prominent\n        LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.5, 0)\n    elseif damage &gt; 50 then\n        -- Medium damage - normal effect\n        LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 5), 0.3, 0)\n    else\n        -- Small damage - subtle effect\n        LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 3), 0.2, 0)\n    end\nend)\n\n-- Track damage statistics\nhook.Add(\"DamageNumberAdded\", \"TrackDamageStats\", function(entity, damage)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track damage frequency\n        local damageFrequency = char:getData(\"damage_frequency\", 0)\n        char:setData(\"damage_frequency\", damageFrequency + 1)\n\n        -- Track damage patterns\n        local damagePatterns = char:getData(\"damage_patterns\", {})\n        table.insert(damagePatterns, {\n            damage = damage,\n            time = os.time(),\n            entity = IsValid(entity) and entity:GetClass() or \"unknown\"\n        })\n        char:setData(\"damage_patterns\", damagePatterns)\n\n        -- Track damage ranges\n        if damage &gt; 100 then\n            char:setData(\"high_damage_count\", char:getData(\"high_damage_count\", 0) + 1)\n        elseif damage &gt; 50 then\n            char:setData(\"medium_damage_count\", char:getData(\"medium_damage_count\", 0) + 1)\n        else\n            char:setData(\"low_damage_count\", char:getData(\"low_damage_count\", 0) + 1)\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/damagenumbers/hooks/#damagenumberexpired","title":"DamageNumberExpired","text":"<p>Purpose</p> <p>Called when a damage number expires and is removed from the display.</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The entity that the damage number was associated with.</li> <li><code>damage</code> (number): The amount of damage that was displayed.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A damage number's display time expires - The damage number is removed from the display queue - After the damage number has been shown</p> <p>Example Usage</p> <pre><code>-- Track damage number expiration\nhook.Add(\"DamageNumberExpired\", \"TrackDamageExpiration\", function(entity, damage)\n    local char = LocalPlayer():getChar()\n    if char then\n        local damageExpired = char:getData(\"damage_numbers_expired\", 0)\n        char:setData(\"damage_numbers_expired\", damageExpired + 1)\n\n        -- Track damage display duration\n        local totalDisplayTime = char:getData(\"total_damage_display_time\", 0)\n        char:setData(\"total_damage_display_time\", totalDisplayTime + 2) -- Default 2 second display\n    end\nend)\n\n-- Apply damage expiration effects\nhook.Add(\"DamageNumberExpired\", \"DamageExpirationEffects\", function(entity, damage)\n    -- Play expiration sound\n    LocalPlayer():EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.OUT, Color(0, 0, 0, 0), 0.5, 0)\n\n    -- Create particle effect\n    if IsValid(entity) then\n        local effect = EffectData()\n        effect:SetOrigin(entity:GetPos())\n        effect:SetMagnitude(1)\n        effect:SetScale(1)\n        util.Effect(\"Explosion\", effect)\n    end\nend)\n\n-- Track damage display statistics\nhook.Add(\"DamageNumberExpired\", \"TrackDamageDisplayStats\", function(entity, damage)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track damage display patterns\n        local damageDisplayPatterns = char:getData(\"damage_display_patterns\", {})\n        table.insert(damageDisplayPatterns, {\n            damage = damage,\n            entity = IsValid(entity) and entity:GetClass() or \"unknown\",\n            time = os.time()\n        })\n        char:setData(\"damage_display_patterns\", damageDisplayPatterns)\n\n        -- Track damage display frequency\n        local damageDisplayFrequency = char:getData(\"damage_display_frequency\", 0)\n        char:setData(\"damage_display_frequency\", damageDisplayFrequency + 1)\n    end\nend)\n\n-- Clean up damage data\nhook.Add(\"DamageNumberExpired\", \"CleanupDamageData\", function(entity, damage)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Remove expired damage from tracking\n        local activeDamage = char:getData(\"active_damage_numbers\", {})\n        for i = #activeDamage, 1, -1 do\n            if activeDamage[i].damage == damage and activeDamage[i].entity == entity then\n                table.remove(activeDamage, i)\n            end\n        end\n        char:setData(\"active_damage_numbers\", activeDamage)\n    end\nend)\n</code></pre>"},{"location":"modules/damagenumbers/hooks/#damagenumberssent","title":"DamageNumbersSent","text":"<p>Purpose</p> <p>Called when damage numbers are sent from the server to clients.</p> <p>Parameters</p> <ul> <li><code>attacker</code> (Player): The player who dealt the damage.</li> <li><code>target</code> (Player): The player who received the damage.</li> <li><code>damage</code> (number): The amount of damage dealt.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player takes damage from another player - The damage numbers are sent to both players - After the damage calculation is complete</p> <p>Example Usage</p> <pre><code>-- Track damage number sending\nhook.Add(\"DamageNumbersSent\", \"TrackDamageSending\", function(attacker, target, damage)\n    local char = attacker:getChar()\n    if char then\n        local damageDealt = char:getData(\"damage_dealt\", 0)\n        char:setData(\"damage_dealt\", damageDealt + damage)\n\n        -- Track damage targets\n        local damageTargets = char:getData(\"damage_targets\", {})\n        damageTargets[target:SteamID()] = (damageTargets[target:SteamID()] or 0) + damage\n        char:setData(\"damage_targets\", damageTargets)\n    end\n\n    lia.log.add(attacker, \"damageNumbersSent\", target:Name(), damage)\nend)\n\n-- Apply damage sending effects\nhook.Add(\"DamageNumbersSent\", \"DamageSendingEffects\", function(attacker, target, damage)\n    -- Play damage sound for attacker\n    attacker:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect for attacker\n    attacker:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.5, 0)\n\n    -- Apply screen effect for target\n    target:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 10), 0.5, 0)\n\n    -- Notify players\n    attacker:notify(\"Dealt \" .. damage .. \" damage to \" .. target:Name() .. \"!\")\n    target:notify(\"Received \" .. damage .. \" damage from \" .. attacker:Name() .. \"!\")\nend)\n\n-- Track damage statistics\nhook.Add(\"DamageNumbersSent\", \"TrackDamageStats\", function(attacker, target, damage)\n    local char = attacker:getChar()\n    if char then\n        -- Track damage frequency\n        local damageFrequency = char:getData(\"damage_frequency\", 0)\n        char:setData(\"damage_frequency\", damageFrequency + 1)\n\n        -- Track damage amounts\n        local damageAmounts = char:getData(\"damage_amounts\", {})\n        table.insert(damageAmounts, {\n            damage = damage,\n            target = target:Name(),\n            time = os.time()\n        })\n        char:setData(\"damage_amounts\", damageAmounts)\n\n        -- Track damage ranges\n        if damage &gt; 100 then\n            char:setData(\"high_damage_dealt\", char:getData(\"high_damage_dealt\", 0) + 1)\n        elseif damage &gt; 50 then\n            char:setData(\"medium_damage_dealt\", char:getData(\"medium_damage_dealt\", 0) + 1)\n        else\n            char:setData(\"low_damage_dealt\", char:getData(\"low_damage_dealt\", 0) + 1)\n        end\n    end\nend)\n\n-- Apply damage restrictions\nhook.Add(\"DamageNumbersSent\", \"ApplyDamageRestrictions\", function(attacker, target, damage)\n    local char = attacker:getChar()\n    if char then\n        -- Check damage cooldown\n        local lastDamage = char:getData(\"last_damage_time\", 0)\n        if os.time() - lastDamage &lt; 1 then -- 1 second cooldown\n            attacker:notify(\"Please wait before dealing damage again!\")\n            return false\n        end\n\n        -- Check damage limits\n        local damageToday = char:getData(\"damage_today\", 0)\n        if damageToday &gt;= 1000 then\n            attacker:notify(\"Daily damage limit reached!\")\n            return false\n        end\n\n        -- Update counters\n        char:setData(\"last_damage_time\", os.time())\n        char:setData(\"damage_today\", damageToday + damage)\n    end\nend)\n\n-- Award damage achievements\nhook.Add(\"DamageNumbersSent\", \"DamageAchievements\", function(attacker, target, damage)\n    local char = attacker:getChar()\n    if char then\n        local totalDamage = char:getData(\"damage_dealt\", 0)\n\n        if totalDamage &gt;= 1000 then\n            attacker:notify(\"Achievement: Damage Dealer!\")\n        elseif totalDamage &gt;= 5000 then\n            attacker:notify(\"Achievement: Heavy Hitter!\")\n        elseif totalDamage &gt;= 10000 then\n            attacker:notify(\"Achievement: Damage Master!\")\n        end\n\n        -- Check for specific damage achievements\n        if damage &gt;= 100 then\n            attacker:notify(\"Achievement: High Damage Hit!\")\n        elseif damage &gt;= 50 then\n            attacker:notify(\"Achievement: Medium Damage Hit!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/developmenthud/about/","title":"About","text":"About <p>Name: Development HUD</p> <p>Description:</p> <p>Adds a staff-only development HUD, font customization via DevHudFont, a requirement for the CAMI privilege, real-time server performance metrics, and a toggle command to show or hide the HUD.</p> Features <ul> <li>Adds a staff-only development HUD</li> <li>Adds font customization via DevHudFont</li> <li>Adds a requirement for the CAMI privilege</li> <li>Adds real-time server performance metrics</li> <li>Adds a toggle command to show or hide the HUD</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/developmenthud/changelog/","title":"Changelog","text":""},{"location":"modules/developmenthud/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/developmenthud/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/developmenthud/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/developmenthud/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Development HUD module for managing staff-only development interface functionality.</p>"},{"location":"modules/developmenthud/hooks/#developmenthudpaint","title":"DevelopmentHUDPaint","text":"<p>Purpose</p> <p>Called when the development HUD is being painted on the screen.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client whose HUD is being painted.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The development HUD is being rendered - After <code>DevelopmentHUDPrePaint</code> hook - When the HUD drawing is complete</p> <p>Example Usage</p> <pre><code>-- Add custom development HUD elements\nhook.Add(\"DevelopmentHUDPaint\", \"AddCustomDevHUD\", function(client)\n    local char = client:getChar()\n    if char and client:hasPrivilege(\"developmentHUD\") then\n        local x = ScrW() / 5.25\n        local y = ScrH() / 1.04\n\n        -- Add custom information\n        draw.SimpleText(\"| Custom Info: \" .. char:getName() .. \" |\", \"DermaDefault\", x, y, Color(255, 255, 0, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)\n\n        -- Add server uptime\n        local uptime = os.time() - (GetConVar(\"sv_starttime\"):GetInt() or 0)\n        local uptimeText = string.format(\"%02d:%02d:%02d\", math.floor(uptime / 3600), math.floor((uptime % 3600) / 60), uptime % 60)\n        draw.SimpleText(\"| Uptime: \" .. uptimeText .. \" |\", \"DermaDefault\", x, y + 20, Color(0, 255, 0, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)\n    end\nend)\n\n-- Track HUD painting\nhook.Add(\"DevelopmentHUDPaint\", \"TrackHUDPainting\", function(client)\n    local char = client:getChar()\n    if char then\n        local hudPaints = char:getData(\"dev_hud_paints\", 0)\n        char:setData(\"dev_hud_paints\", hudPaints + 1)\n    end\nend)\n\n-- Apply HUD effects\nhook.Add(\"DevelopmentHUDPaint\", \"HUDPaintEffects\", function(client)\n    -- Add subtle glow effect\n    local x = ScrW() / 5.25\n    local y = ScrH() / 1.12\n\n    surface.SetDrawColor(255, 255, 255, 10)\n    surface.DrawRect(x - 5, y - 5, 200, 20)\nend)\n</code></pre>"},{"location":"modules/developmenthud/hooks/#developmenthudprepaint","title":"DevelopmentHUDPrePaint","text":"<p>Purpose</p> <p>Called before the development HUD is painted on the screen.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The client whose HUD is about to be painted.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - The development HUD is about to be rendered - Before any HUD drawing begins - Before <code>DevelopmentHUDPaint</code> hook</p> <p>Example Usage</p> <pre><code>-- Prepare HUD data\nhook.Add(\"DevelopmentHUDPrePaint\", \"PrepareHUDData\", function(client)\n    local char = client:getChar()\n    if char and client:hasPrivilege(\"developmentHUD\") then\n        -- Cache frequently used data\n        char:setData(\"cached_pos\", client:GetPos())\n        char:setData(\"cached_ang\", client:GetAngles())\n        char:setData(\"cached_health\", client:Health())\n        char:setData(\"cached_armor\", client:Armor())\n    end\nend)\n\n-- Validate HUD access\nhook.Add(\"DevelopmentHUDPrePaint\", \"ValidateHUDAccess\", function(client)\n    local char = client:getChar()\n    if not char then\n        return false\n    end\n\n    -- Check if HUD is disabled\n    if char:getData(\"dev_hud_disabled\", false) then\n        return false\n    end\n\n    -- Check cooldown\n    local lastPaint = char:getData(\"last_hud_paint_time\", 0)\n    if os.time() - lastPaint &lt; 1 then -- 1 second cooldown\n        return false\n    end\n\n    -- Update last paint time\n    char:setData(\"last_hud_paint_time\", os.time())\nend)\n\n-- Track HUD preparation\nhook.Add(\"DevelopmentHUDPrePaint\", \"TrackHUDPreparation\", function(client)\n    local char = client:getChar()\n    if char then\n        local hudPreparations = char:getData(\"dev_hud_preparations\", 0)\n        char:setData(\"dev_hud_preparations\", hudPreparations + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/developmentserver/about/","title":"About","text":"About <p>Name: Development Server</p> <p>Description:</p> <p>Adds a development server mode for testing, the ability to run special development functions, a toggle via configuration, an environment flag for dev commands, and logging of executed dev actions.</p> Features <ul> <li>Adds a development server mode for testing</li> <li>Adds the ability to run special development functions</li> <li>Adds a toggle via configuration</li> <li>Adds an environment flag for dev commands</li> <li>Adds logging of executed dev actions</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/developmentserver/changelog/","title":"Changelog","text":""},{"location":"modules/developmentserver/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/developmentserver/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/developmentserver/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Development Server module for managing development server mode functionality.</p>"},{"location":"modules/developmentserver/hooks/#devserverauthorized","title":"DevServerAuthorized","text":"<p>Purpose</p> <p>Called when a player is authorized to access the development server.</p> <p>Parameters</p> <ul> <li><code>steamid64</code> (string): The Steam ID 64 of the authorized player.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player connects to the development server - The player's Steam ID is found in the authorized developers list - After <code>DevServerUnauthorized</code> hook check</p> <p>Example Usage</p> <pre><code>-- Track development server authorization\nhook.Add(\"DevServerAuthorized\", \"TrackDevServerAuth\", function(steamid64)\n    lia.log.add(nil, \"devServerAuthorized\", steamid64)\n\n    -- Notify all players\n    for _, ply in player.Iterator() do\n        if ply:SteamID64() == steamid64 then\n            ply:notify(\"Welcome to the development server!\")\n        end\n    end\nend)\n\n-- Apply authorization effects\nhook.Add(\"DevServerAuthorized\", \"DevServerAuthEffects\", function(steamid64)\n    -- Find the authorized player\n    for _, ply in player.Iterator() do\n        if ply:SteamID64() == steamid64 then\n            -- Play authorization sound\n            ply:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n            -- Apply screen effect\n            ply:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.5, 0)\n\n            -- Give development tools\n            ply:Give(\"weapon_crowbar\")\n            ply:Give(\"weapon_physcannon\")\n        end\n    end\nend)\n\n-- Track authorization statistics\nhook.Add(\"DevServerAuthorized\", \"TrackDevServerAuthStats\", function(steamid64)\n    -- Track total authorizations\n    local totalAuths = lia.data.get(\"dev_server_authorizations\", 0)\n    lia.data.set(\"dev_server_authorizations\", totalAuths + 1)\n\n    -- Track unique authorizations\n    local uniqueAuths = lia.data.get(\"dev_server_unique_auths\", {})\n    uniqueAuths[steamid64] = (uniqueAuths[steamid64] or 0) + 1\n    lia.data.set(\"dev_server_unique_auths\", uniqueAuths)\nend)\n</code></pre>"},{"location":"modules/developmentserver/hooks/#devservermodeactivated","title":"DevServerModeActivated","text":"<p>Purpose</p> <p>Called when development server mode is activated.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The development server mode is enabled - The server starts in development mode - After <code>DevServerModeDeactivated</code> hook check</p> <p>Example Usage</p> <pre><code>-- Track development mode activation\nhook.Add(\"DevServerModeActivated\", \"TrackDevModeActivation\", function()\n    lia.log.add(nil, \"devServerModeActivated\")\n\n    -- Notify all players\n    for _, ply in player.Iterator() do\n        ply:notify(\"Development server mode activated!\")\n    end\n\n    -- Print server message\n    print(\"Development server mode is now active!\")\nend)\n\n-- Apply development mode effects\nhook.Add(\"DevServerModeActivated\", \"DevModeActivationEffects\", function()\n    -- Enable development features\n    RunConsoleCommand(\"sv_cheats\", \"1\")\n    RunConsoleCommand(\"sv_allowcslua\", \"1\")\n\n    -- Set development server settings\n    RunConsoleCommand(\"sv_gravity\", \"600\")\n    RunConsoleCommand(\"sv_friction\", \"4\")\n\n    -- Create development entities\n    local devSpawn = ents.Create(\"info_player_start\")\n    devSpawn:SetPos(Vector(0, 0, 0))\n    devSpawn:Spawn()\nend)\n\n-- Track activation statistics\nhook.Add(\"DevServerModeActivated\", \"TrackDevModeActivationStats\", function()\n    -- Track activation count\n    local activations = lia.data.get(\"dev_mode_activations\", 0)\n    lia.data.set(\"dev_mode_activations\", activations + 1)\n\n    -- Track activation time\n    lia.data.set(\"dev_mode_activation_time\", os.time())\nend)\n</code></pre>"},{"location":"modules/developmentserver/hooks/#devservermodedeactivated","title":"DevServerModeDeactivated","text":"<p>Purpose</p> <p>Called when development server mode is deactivated.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The development server mode is disabled - The server switches to production mode - After <code>DevServerModeActivated</code> hook check</p> <p>Example Usage</p> <pre><code>-- Track development mode deactivation\nhook.Add(\"DevServerModeDeactivated\", \"TrackDevModeDeactivation\", function()\n    lia.log.add(nil, \"devServerModeDeactivated\")\n\n    -- Notify all players\n    for _, ply in player.Iterator() do\n        ply:notify(\"Development server mode deactivated!\")\n    end\n\n    -- Print server message\n    print(\"Development server mode is now inactive!\")\nend)\n\n-- Apply development mode deactivation effects\nhook.Add(\"DevServerModeDeactivated\", \"DevModeDeactivationEffects\", function()\n    -- Disable development features\n    RunConsoleCommand(\"sv_cheats\", \"0\")\n    RunConsoleCommand(\"sv_allowcslua\", \"0\")\n\n    -- Reset server settings\n    RunConsoleCommand(\"sv_gravity\", \"600\")\n    RunConsoleCommand(\"sv_friction\", \"4\")\n\n    -- Clean up development entities\n    for _, ent in pairs(ents.FindByClass(\"info_player_start\")) do\n        if ent:GetPos() == Vector(0, 0, 0) then\n            ent:Remove()\n        end\n    end\nend)\n\n-- Track deactivation statistics\nhook.Add(\"DevServerModeDeactivated\", \"TrackDevModeDeactivationStats\", function()\n    -- Track deactivation count\n    local deactivations = lia.data.get(\"dev_mode_deactivations\", 0)\n    lia.data.set(\"dev_mode_deactivations\", deactivations + 1)\n\n    -- Track deactivation time\n    lia.data.set(\"dev_mode_deactivation_time\", os.time())\nend)\n</code></pre>"},{"location":"modules/developmentserver/hooks/#devserverunauthorized","title":"DevServerUnauthorized","text":"<p>Purpose</p> <p>Called when a player is unauthorized to access the development server.</p> <p>Parameters</p> <ul> <li><code>steamid64</code> (string): The Steam ID 64 of the unauthorized player.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player connects to the development server - The player's Steam ID is not found in the authorized developers list - Before <code>DevServerAuthorized</code> hook check</p> <p>Example Usage</p> <pre><code>-- Track development server unauthorized access\nhook.Add(\"DevServerUnauthorized\", \"TrackDevServerUnauth\", function(steamid64)\n    lia.log.add(nil, \"devServerUnauthorized\", steamid64)\n\n    -- Notify unauthorized player\n    for _, ply in player.Iterator() do\n        if ply:SteamID64() == steamid64 then\n            ply:notify(\"You are not authorized to access the development server!\")\n        end\n    end\nend)\n\n-- Apply unauthorized effects\nhook.Add(\"DevServerUnauthorized\", \"DevServerUnauthEffects\", function(steamid64)\n    -- Find the unauthorized player\n    for _, ply in player.Iterator() do\n        if ply:SteamID64() == steamid64 then\n            -- Play unauthorized sound\n            ply:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n            -- Apply screen effect\n            ply:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 20), 1, 0)\n\n            -- Kick player after delay\n            timer.Simple(3, function()\n                if IsValid(ply) then\n                    ply:Kick(\"Unauthorized access to development server\")\n                end\n            end)\n        end\n    end\nend)\n\n-- Track unauthorized access statistics\nhook.Add(\"DevServerUnauthorized\", \"TrackDevServerUnauthStats\", function(steamid64)\n    -- Track total unauthorized attempts\n    local totalUnauths = lia.data.get(\"dev_server_unauthorized_attempts\", 0)\n    lia.data.set(\"dev_server_unauthorized_attempts\", totalUnauths + 1)\n\n    -- Track unique unauthorized attempts\n    local uniqueUnauths = lia.data.get(\"dev_server_unique_unauths\", {})\n    uniqueUnauths[steamid64] = (uniqueUnauths[steamid64] or 0) + 1\n    lia.data.set(\"dev_server_unique_unauths\", uniqueUnauths)\nend)\n</code></pre>"},{"location":"modules/donator/about/","title":"About","text":"About <p>Name: Donator</p> <p>Description:</p> <p>Adds libraries to manage donor perks, tracking for donor ranks and perks, configurable perks by tier, and commands to adjust character slots.</p> Features <ul> <li>Adds libraries to manage donor perks</li> <li>Adds tracking for donor ranks and perks</li> <li>Adds configurable perks by tier</li> <li>Adds commands to adjust character slots</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/donator/changelog/","title":"Changelog","text":""},{"location":"modules/donator/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency:</li> <li><code>GetAdditionalCharSlots()</code> \u2192 <code>getAdditionalCharSlots()</code></li> <li><code>SetAdditionalCharSlots()</code> \u2192 <code>setAdditionalCharSlots()</code></li> <li><code>GiveAdditionalCharSlots()</code> \u2192 <code>giveAdditionalCharSlots()</code></li> </ul>"},{"location":"modules/donator/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/donator/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/donator/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Donator module for managing donor perks and benefits.</p>"},{"location":"modules/donator/hooks/#donatoradditionalslotsgiven","title":"DonatorAdditionalSlotsGiven","text":"<p>Purpose</p> <p>Called when additional character slots are given to a donator.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who received the additional slots.</li> <li><code>addValue</code> (number): The number of additional slots given.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Additional character slots are given to a player - The <code>GiveAdditionalCharSlots</code> function is called - After <code>DonatorAdditionalSlotsSet</code> hook</p> <p>Example Usage</p> <pre><code>-- Track additional slots given\nhook.Add(\"DonatorAdditionalSlotsGiven\", \"TrackAdditionalSlotsGiven\", function(player, addValue)\n    local char = player:getChar()\n    if char then\n        local slotsGiven = char:getData(\"additional_slots_given\", 0)\n        char:setData(\"additional_slots_given\", slotsGiven + addValue)\n    end\n\n    lia.log.add(player, \"additionalSlotsGiven\", addValue)\nend)\n\n-- Apply additional slots effects\nhook.Add(\"DonatorAdditionalSlotsGiven\", \"AdditionalSlotsEffects\", function(player, addValue)\n    -- Play success sound\n    player:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"You received \" .. addValue .. \" additional character slots!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track additional slots statistics\nhook.Add(\"DonatorAdditionalSlotsGiven\", \"TrackAdditionalSlotsStats\", function(player, addValue)\n    local char = player:getChar()\n    if char then\n        -- Track total slots given\n        local totalSlotsGiven = char:getData(\"total_slots_given\", 0)\n        char:setData(\"total_slots_given\", totalSlotsGiven + addValue)\n\n        -- Track slots given patterns\n        local slotsPatterns = char:getData(\"slots_given_patterns\", {})\n        table.insert(slotsPatterns, {\n            amount = addValue,\n            time = os.time()\n        })\n        char:setData(\"slots_given_patterns\", slotsPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/donator/hooks/#donatoradditionalslotsset","title":"DonatorAdditionalSlotsSet","text":"<p>Purpose</p> <p>Called when additional character slots are set for a donator.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose slots are being set.</li> <li><code>value</code> (number): The new number of additional slots.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Additional character slots are set for a player - The <code>SetAdditionalCharSlots</code> function is called - Before <code>DonatorAdditionalSlotsGiven</code> hook</p> <p>Example Usage</p> <pre><code>-- Track additional slots set\nhook.Add(\"DonatorAdditionalSlotsSet\", \"TrackAdditionalSlotsSet\", function(player, value)\n    local char = player:getChar()\n    if char then\n        local slotsSet = char:getData(\"additional_slots_set\", 0)\n        char:setData(\"additional_slots_set\", slotsSet + 1)\n    end\n\n    lia.log.add(player, \"additionalSlotsSet\", value)\nend)\n\n-- Apply additional slots set effects\nhook.Add(\"DonatorAdditionalSlotsSet\", \"AdditionalSlotsSetEffects\", function(player, value)\n    -- Play set sound\n    player:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 10), 0.3, 0)\n\n    -- Notify player\n    player:notify(\"Your additional character slots have been set to \" .. value .. \"!\")\nend)\n\n-- Track additional slots set statistics\nhook.Add(\"DonatorAdditionalSlotsSet\", \"TrackAdditionalSlotsSetStats\", function(player, value)\n    local char = player:getChar()\n    if char then\n        -- Track slots set frequency\n        local slotsSetFrequency = char:getData(\"slots_set_frequency\", 0)\n        char:setData(\"slots_set_frequency\", slotsSetFrequency + 1)\n\n        -- Track slots set patterns\n        local slotsSetPatterns = char:getData(\"slots_set_patterns\", {})\n        table.insert(slotsSetPatterns, {\n            value = value,\n            time = os.time()\n        })\n        char:setData(\"slots_set_patterns\", slotsSetPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/donator/hooks/#donatorflagsgiven","title":"DonatorFlagsGiven","text":"<p>Purpose</p> <p>Called when donator flags are given to a player.</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player who received the flags.</li> <li><code>flags</code> (string): The flags that were given.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Donator flags are given to a player - The <code>lia_giveflags</code> command is executed - After the flags are applied to the character</p> <p>Example Usage</p> <pre><code>-- Track donator flags given\nhook.Add(\"DonatorFlagsGiven\", \"TrackDonatorFlagsGiven\", function(target, flags)\n    local char = target:getChar()\n    if char then\n        local flagsGiven = char:getData(\"donator_flags_given\", 0)\n        char:setData(\"donator_flags_given\", flagsGiven + 1)\n\n        -- Track specific flags\n        local specificFlags = char:getData(\"donator_specific_flags\", {})\n        specificFlags[flags] = (specificFlags[flags] or 0) + 1\n        char:setData(\"donator_specific_flags\", specificFlags)\n    end\n\n    lia.log.add(target, \"donatorFlagsGiven\", flags)\nend)\n\n-- Apply donator flags effects\nhook.Add(\"DonatorFlagsGiven\", \"DonatorFlagsEffects\", function(target, flags)\n    -- Play success sound\n    target:EmitSound(\"buttons/button15.wav\", 75, 100)\n\n    -- Apply screen effect\n    target:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    target:notify(\"You received donator flags: \" .. flags .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(target:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track donator flags statistics\nhook.Add(\"DonatorFlagsGiven\", \"TrackDonatorFlagsStats\", function(target, flags)\n    local char = target:getChar()\n    if char then\n        -- Track flags given frequency\n        local flagsGivenFrequency = char:getData(\"donator_flags_given_frequency\", 0)\n        char:setData(\"donator_flags_given_frequency\", flagsGivenFrequency + 1)\n\n        -- Track flags given patterns\n        local flagsPatterns = char:getData(\"donator_flags_patterns\", {})\n        table.insert(flagsPatterns, {\n            flags = flags,\n            time = os.time()\n        })\n        char:setData(\"donator_flags_patterns\", flagsPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/donator/hooks/#donatorflagsgranted","title":"DonatorFlagsGranted","text":"<p>Purpose</p> <p>Called when donator flags are granted to a player based on their usergroup.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who received the flags.</li> <li><code>group</code> (string): The donator group that granted the flags.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player loads a character - The player's usergroup matches a donator group - After the flags are applied to the character</p> <p>Example Usage</p> <pre><code>-- Track donator flags granted\nhook.Add(\"DonatorFlagsGranted\", \"TrackDonatorFlagsGranted\", function(client, group)\n    local char = client:getChar()\n    if char then\n        local flagsGranted = char:getData(\"donator_flags_granted\", 0)\n        char:setData(\"donator_flags_granted\", flagsGranted + 1)\n\n        -- Track donator group\n        char:setData(\"donator_group\", group)\n    end\n\n    lia.log.add(client, \"donatorFlagsGranted\", group)\nend)\n\n-- Apply donator flags granted effects\nhook.Add(\"DonatorFlagsGranted\", \"DonatorFlagsGrantedEffects\", function(client, group)\n    -- Play granted sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Donator flags granted for group: \" .. group .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track donator flags granted statistics\nhook.Add(\"DonatorFlagsGranted\", \"TrackDonatorFlagsGrantedStats\", function(client, group)\n    local char = client:getChar()\n    if char then\n        -- Track flags granted frequency\n        local flagsGrantedFrequency = char:getData(\"donator_flags_granted_frequency\", 0)\n        char:setData(\"donator_flags_granted_frequency\", flagsGrantedFrequency + 1)\n\n        -- Track donator group patterns\n        local groupPatterns = char:getData(\"donator_group_patterns\", {})\n        groupPatterns[group] = (groupPatterns[group] or 0) + 1\n        char:setData(\"donator_group_patterns\", groupPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/donator/hooks/#donatoritemgiven","title":"DonatorItemGiven","text":"<p>Purpose</p> <p>Called when a donator item is given to a player.</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player who received the item.</li> <li><code>uniqueID</code> (string): The unique ID of the item that was given.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A donator item is given to a player - The <code>lia_giveitem</code> command is executed - After the item is added to the player's inventory</p> <p>Example Usage</p> <pre><code>-- Track donator item given\nhook.Add(\"DonatorItemGiven\", \"TrackDonatorItemGiven\", function(target, uniqueID)\n    local char = target:getChar()\n    if char then\n        local itemsGiven = char:getData(\"donator_items_given\", 0)\n        char:setData(\"donator_items_given\", itemsGiven + 1)\n\n        -- Track specific items\n        local specificItems = char:getData(\"donator_specific_items\", {})\n        specificItems[uniqueID] = (specificItems[uniqueID] or 0) + 1\n        char:setData(\"donator_specific_items\", specificItems)\n    end\n\n    lia.log.add(target, \"donatorItemGiven\", uniqueID)\nend)\n\n-- Apply donator item effects\nhook.Add(\"DonatorItemGiven\", \"DonatorItemEffects\", function(target, uniqueID)\n    -- Play success sound\n    target:EmitSound(\"items/item_pickup.wav\", 75, 100)\n\n    -- Apply screen effect\n    target:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    target:notify(\"You received a donator item: \" .. uniqueID .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(target:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track donator item statistics\nhook.Add(\"DonatorItemGiven\", \"TrackDonatorItemStats\", function(target, uniqueID)\n    local char = target:getChar()\n    if char then\n        -- Track items given frequency\n        local itemsGivenFrequency = char:getData(\"donator_items_given_frequency\", 0)\n        char:setData(\"donator_items_given_frequency\", itemsGivenFrequency + 1)\n\n        -- Track items given patterns\n        local itemsPatterns = char:getData(\"donator_items_patterns\", {})\n        table.insert(itemsPatterns, {\n            item = uniqueID,\n            time = os.time()\n        })\n        char:setData(\"donator_items_patterns\", itemsPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/donator/hooks/#donatormoneygiven","title":"DonatorMoneyGiven","text":"<p>Purpose</p> <p>Called when donator money is given to a player.</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player who received the money.</li> <li><code>amount</code> (number): The amount of money that was given.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Donator money is given to a player - The <code>lia_givemoney</code> command is executed - After the money is added to the player's character</p> <p>Example Usage</p> <pre><code>-- Track donator money given\nhook.Add(\"DonatorMoneyGiven\", \"TrackDonatorMoneyGiven\", function(target, amount)\n    local char = target:getChar()\n    if char then\n        local moneyGiven = char:getData(\"donator_money_given\", 0)\n        char:setData(\"donator_money_given\", moneyGiven + amount)\n    end\n\n    lia.log.add(target, \"donatorMoneyGiven\", amount)\nend)\n\n-- Apply donator money effects\nhook.Add(\"DonatorMoneyGiven\", \"DonatorMoneyEffects\", function(target, amount)\n    -- Play success sound\n    target:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    target:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    target:notify(\"You received donator money: \" .. lia.currency.get(amount) .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(target:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track donator money statistics\nhook.Add(\"DonatorMoneyGiven\", \"TrackDonatorMoneyStats\", function(target, amount)\n    local char = target:getChar()\n    if char then\n        -- Track money given frequency\n        local moneyGivenFrequency = char:getData(\"donator_money_given_frequency\", 0)\n        char:setData(\"donator_money_given_frequency\", moneyGivenFrequency + 1)\n\n        -- Track money given patterns\n        local moneyPatterns = char:getData(\"donator_money_patterns\", {})\n        table.insert(moneyPatterns, {\n            amount = amount,\n            time = os.time()\n        })\n        char:setData(\"donator_money_patterns\", moneyPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/donator/hooks/#donatorslotsadded","title":"DonatorSlotsAdded","text":"<p>Purpose</p> <p>Called when character slots are added to a donator.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who received the slots.</li> <li><code>current</code> (number): The current number of slots after addition.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Character slots are added to a player - The <code>AddOverrideCharSlots</code> function is called - After the slots are updated</p> <p>Example Usage</p> <pre><code>-- Track donator slots added\nhook.Add(\"DonatorSlotsAdded\", \"TrackDonatorSlotsAdded\", function(player, current)\n    local char = player:getChar()\n    if char then\n        local slotsAdded = char:getData(\"donator_slots_added\", 0)\n        char:setData(\"donator_slots_added\", slotsAdded + 1)\n    end\n\n    lia.log.add(player, \"donatorSlotsAdded\", current)\nend)\n\n-- Apply donator slots added effects\nhook.Add(\"DonatorSlotsAdded\", \"DonatorSlotsAddedEffects\", function(player, current)\n    -- Play success sound\n    player:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"Character slots added! Total: \" .. current .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track donator slots added statistics\nhook.Add(\"DonatorSlotsAdded\", \"TrackDonatorSlotsAddedStats\", function(player, current)\n    local char = player:getChar()\n    if char then\n        -- Track slots added frequency\n        local slotsAddedFrequency = char:getData(\"donator_slots_added_frequency\", 0)\n        char:setData(\"donator_slots_added_frequency\", slotsAddedFrequency + 1)\n\n        -- Track slots added patterns\n        local slotsPatterns = char:getData(\"donator_slots_added_patterns\", {})\n        table.insert(slotsPatterns, {\n            current = current,\n            time = os.time()\n        })\n        char:setData(\"donator_slots_added_patterns\", slotsPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/donator/hooks/#donatorslotsset","title":"DonatorSlotsSet","text":"<p>Purpose</p> <p>Called when character slots are set for a donator.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose slots are being set.</li> <li><code>value</code> (number): The new number of character slots.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Character slots are set for a player - The <code>OverrideCharSlots</code> function is called - After the slots are updated</p> <p>Example Usage</p> <pre><code>-- Track donator slots set\nhook.Add(\"DonatorSlotsSet\", \"TrackDonatorSlotsSet\", function(player, value)\n    local char = player:getChar()\n    if char then\n        local slotsSet = char:getData(\"donator_slots_set\", 0)\n        char:setData(\"donator_slots_set\", slotsSet + 1)\n    end\n\n    lia.log.add(player, \"donatorSlotsSet\", value)\nend)\n\n-- Apply donator slots set effects\nhook.Add(\"DonatorSlotsSet\", \"DonatorSlotsSetEffects\", function(player, value)\n    -- Play set sound\n    player:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 15), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"Character slots set to: \" .. value .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track donator slots set statistics\nhook.Add(\"DonatorSlotsSet\", \"TrackDonatorSlotsSetStats\", function(player, value)\n    local char = player:getChar()\n    if char then\n        -- Track slots set frequency\n        local slotsSetFrequency = char:getData(\"donator_slots_set_frequency\", 0)\n        char:setData(\"donator_slots_set_frequency\", slotsSetFrequency + 1)\n\n        -- Track slots set patterns\n        local slotsPatterns = char:getData(\"donator_slots_set_patterns\", {})\n        table.insert(slotsPatterns, {\n            value = value,\n            time = os.time()\n        })\n        char:setData(\"donator_slots_set_patterns\", slotsPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/donator/hooks/#donatorslotssubtracted","title":"DonatorSlotsSubtracted","text":"<p>Purpose</p> <p>Called when character slots are subtracted from a donator.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who lost the slots.</li> <li><code>current</code> (number): The current number of slots after subtraction.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Character slots are subtracted from a player - The <code>SubtractOverrideCharSlots</code> function is called - After the slots are updated</p> <p>Example Usage</p> <pre><code>-- Track donator slots subtracted\nhook.Add(\"DonatorSlotsSubtracted\", \"TrackDonatorSlotsSubtracted\", function(player, current)\n    local char = player:getChar()\n    if char then\n        local slotsSubtracted = char:getData(\"donator_slots_subtracted\", 0)\n        char:setData(\"donator_slots_subtracted\", slotsSubtracted + 1)\n    end\n\n    lia.log.add(player, \"donatorSlotsSubtracted\", current)\nend)\n\n-- Apply donator slots subtracted effects\nhook.Add(\"DonatorSlotsSubtracted\", \"DonatorSlotsSubtractedEffects\", function(player, current)\n    -- Play subtraction sound\n    player:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"Character slots subtracted! Total: \" .. current .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track donator slots subtracted statistics\nhook.Add(\"DonatorSlotsSubtracted\", \"TrackDonatorSlotsSubtractedStats\", function(player, current)\n    local char = player:getChar()\n    if char then\n        -- Track slots subtracted frequency\n        local slotsSubtractedFrequency = char:getData(\"donator_slots_subtracted_frequency\", 0)\n        char:setData(\"donator_slots_subtracted_frequency\", slotsSubtractedFrequency + 1)\n\n        -- Track slots subtracted patterns\n        local slotsPatterns = char:getData(\"donator_slots_subtracted_patterns\", {})\n        table.insert(slotsPatterns, {\n            current = current,\n            time = os.time()\n        })\n        char:setData(\"donator_slots_subtracted_patterns\", slotsPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/donator/hooks/#donatorspawn","title":"DonatorSpawn","text":"<p>Purpose</p> <p>Called when a donator spawns with override slots.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who spawned.</li> <li><code>currentSlots</code> (number): The current number of override slots.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A donator player spawns - The player has override slots set - After the player spawn process</p> <p>Example Usage</p> <pre><code>-- Track donator spawn\nhook.Add(\"DonatorSpawn\", \"TrackDonatorSpawn\", function(client, currentSlots)\n    local char = client:getChar()\n    if char then\n        local donatorSpawns = char:getData(\"donator_spawns\", 0)\n        char:setData(\"donator_spawns\", donatorSpawns + 1)\n    end\n\n    lia.log.add(client, \"donatorSpawn\", currentSlots)\nend)\n\n-- Apply donator spawn effects\nhook.Add(\"DonatorSpawn\", \"DonatorSpawnEffects\", function(client, currentSlots)\n    -- Play spawn sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Welcome back, donator! Override slots: \" .. currentSlots .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track donator spawn statistics\nhook.Add(\"DonatorSpawn\", \"TrackDonatorSpawnStats\", function(client, currentSlots)\n    local char = client:getChar()\n    if char then\n        -- Track spawn frequency\n        local spawnFrequency = char:getData(\"donator_spawn_frequency\", 0)\n        char:setData(\"donator_spawn_frequency\", spawnFrequency + 1)\n\n        -- Track spawn patterns\n        local spawnPatterns = char:getData(\"donator_spawn_patterns\", {})\n        table.insert(spawnPatterns, {\n            slots = currentSlots,\n            time = os.time()\n        })\n        char:setData(\"donator_spawn_patterns\", spawnPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/doorkick/about/","title":"About","text":"About <p>Name: Door Kick</p> <p>Description:</p> <p>Adds the ability to kick doors open with an animation, logging of door kick events, and a fun breach mechanic with physics force to fling doors open.</p> Features <ul> <li>Adds the ability to kick doors open with an animation</li> <li>Adds logging of door kick events</li> <li>Adds a fun breach mechanic</li> <li>Adds physics force to fling doors open</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/doorkick/changelog/","title":"Changelog","text":""},{"location":"modules/doorkick/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/doorkick/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/doorkick/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/doorkick/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Door Kick module for managing door kicking functionality.</p>"},{"location":"modules/doorkick/hooks/#doorkickedopen","title":"DoorKickedOpen","text":"<p>Purpose</p> <p>Called when a door has been successfully kicked open.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who kicked the door.</li> <li><code>door</code> (Entity): The door entity that was kicked open.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A door has been successfully kicked open - The kick animation and unlock sequence completes - After <code>DoorKickStarted</code> hook</p> <p>Example Usage</p> <pre><code>-- Track door kick success\nhook.Add(\"DoorKickedOpen\", \"TrackDoorKickSuccess\", function(client, door)\n    local char = client:getChar()\n    if char then\n        local doorKicks = char:getData(\"door_kicks\", 0)\n        char:setData(\"door_kicks\", doorKicks + 1)\n\n        -- Track door types\n        local doorTypes = char:getData(\"door_kick_types\", {})\n        local doorClass = door:GetClass()\n        doorTypes[doorClass] = (doorTypes[doorClass] or 0) + 1\n        char:setData(\"door_kick_types\", doorTypes)\n    end\n\n    lia.log.add(client, \"doorKickedOpen\", door)\nend)\n\n-- Apply door kick success effects\nhook.Add(\"DoorKickedOpen\", \"DoorKickSuccessEffects\", function(client, door)\n    -- Play success sound\n    client:EmitSound(\"doors/door_metal_thin_open1.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Door kicked open successfully!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(door:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track door kick success statistics\nhook.Add(\"DoorKickedOpen\", \"TrackDoorKickSuccessStats\", function(client, door)\n    local char = client:getChar()\n    if char then\n        -- Track success frequency\n        local successFrequency = char:getData(\"door_kick_success_frequency\", 0)\n        char:setData(\"door_kick_success_frequency\", successFrequency + 1)\n\n        -- Track success patterns\n        local successPatterns = char:getData(\"door_kick_success_patterns\", {})\n        table.insert(successPatterns, {\n            door = door:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"door_kick_success_patterns\", successPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/doorkick/hooks/#doorkickfailed","title":"DoorKickFailed","text":"<p>Purpose</p> <p>Called when a door kick attempt fails.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who attempted to kick the door.</li> <li><code>door</code> (Entity): The door entity that was attempted to be kicked.</li> <li><code>reason</code> (string): The reason for the failure (\"disabled\", \"weak\", \"cannotKick\", \"tooClose\", \"tooFar\", \"invalid\").</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A door kick attempt fails - The player doesn't meet the requirements - Before <code>DoorKickStarted</code> hook</p> <p>Example Usage</p> <pre><code>-- Track door kick failures\nhook.Add(\"DoorKickFailed\", \"TrackDoorKickFailures\", function(client, door, reason)\n    local char = client:getChar()\n    if char then\n        local doorKickFailures = char:getData(\"door_kick_failures\", 0)\n        char:setData(\"door_kick_failures\", doorKickFailures + 1)\n\n        -- Track failure reasons\n        local failureReasons = char:getData(\"door_kick_failure_reasons\", {})\n        failureReasons[reason] = (failureReasons[reason] or 0) + 1\n        char:setData(\"door_kick_failure_reasons\", failureReasons)\n    end\n\n    lia.log.add(client, \"doorKickFailed\", door, reason)\nend)\n\n-- Apply door kick failure effects\nhook.Add(\"DoorKickFailed\", \"DoorKickFailureEffects\", function(client, door, reason)\n    -- Play failure sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player based on reason\n    local messages = {\n        disabled = \"Door kicking is disabled!\",\n        weak = \"You are too weak to kick this door!\",\n        cannotKick = \"You cannot kick this door!\",\n        tooClose = \"You are too close to kick the door!\",\n        tooFar = \"You are too far from the door!\",\n        invalid = \"Invalid door target!\"\n    }\n\n    client:notify(messages[reason] or \"Door kick failed!\")\nend)\n\n-- Track door kick failure statistics\nhook.Add(\"DoorKickFailed\", \"TrackDoorKickFailureStats\", function(client, door, reason)\n    local char = client:getChar()\n    if char then\n        -- Track failure frequency\n        local failureFrequency = char:getData(\"door_kick_failure_frequency\", 0)\n        char:setData(\"door_kick_failure_frequency\", failureFrequency + 1)\n\n        -- Track failure patterns\n        local failurePatterns = char:getData(\"door_kick_failure_patterns\", {})\n        table.insert(failurePatterns, {\n            door = door:GetClass(),\n            reason = reason,\n            time = os.time()\n        })\n        char:setData(\"door_kick_failure_patterns\", failurePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/doorkick/hooks/#doorkickstarted","title":"DoorKickStarted","text":"<p>Purpose</p> <p>Called when a door kick attempt is started.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is starting to kick the door.</li> <li><code>door</code> (Entity): The door entity being kicked.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A door kick attempt is started - The player meets the requirements - Before the kick animation begins</p> <p>Example Usage</p> <pre><code>-- Track door kick attempts\nhook.Add(\"DoorKickStarted\", \"TrackDoorKickAttempts\", function(client, door)\n    local char = client:getChar()\n    if char then\n        local doorKickAttempts = char:getData(\"door_kick_attempts\", 0)\n        char:setData(\"door_kick_attempts\", doorKickAttempts + 1)\n    end\n\n    lia.log.add(client, \"doorKickStarted\", door)\nend)\n\n-- Apply door kick start effects\nhook.Add(\"DoorKickStarted\", \"DoorKickStartEffects\", function(client, door)\n    -- Play start sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Starting to kick the door...\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(door:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track door kick start statistics\nhook.Add(\"DoorKickStarted\", \"TrackDoorKickStartStats\", function(client, door)\n    local char = client:getChar()\n    if char then\n        -- Track start frequency\n        local startFrequency = char:getData(\"door_kick_start_frequency\", 0)\n        char:setData(\"door_kick_start_frequency\", startFrequency + 1)\n\n        -- Track start patterns\n        local startPatterns = char:getData(\"door_kick_start_patterns\", {})\n        table.insert(startPatterns, {\n            door = door:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"door_kick_start_patterns\", startPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/enhanceddeath/about/","title":"About","text":"About <p>Name: Enhanced Death</p> <p>Description:</p> <p>Adds respawning of players at hospitals, a medical recovery system, support for multiple hospital spawns, configurable respawn delays, and integration with death logs.</p> Features <ul> <li>Adds respawning of players at hospitals</li> <li>Adds a medical recovery system</li> <li>Adds support for multiple hospital spawns</li> <li>Adds configurable respawn delays</li> <li>Adds integration with death logs</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/enhanceddeath/changelog/","title":"Changelog","text":""},{"location":"modules/enhanceddeath/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/enhanceddeath/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/enhanceddeath/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Enhanced Death module for managing hospital respawn and death functionality.</p>"},{"location":"modules/enhanceddeath/hooks/#hospitaldeathflagged","title":"HospitalDeathFlagged","text":"<p>Purpose</p> <p>Called when a player's death is flagged for hospital respawn.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose death was flagged.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player dies - The hospital system is enabled - The death is flagged for hospital respawn</p> <p>Example Usage</p> <pre><code>-- Track hospital death flagging\nhook.Add(\"HospitalDeathFlagged\", \"TrackHospitalDeathFlagging\", function(client)\n    local char = client:getChar()\n    if char then\n        local hospitalDeaths = char:getData(\"hospital_deaths\", 0)\n        char:setData(\"hospital_deaths\", hospitalDeaths + 1)\n    end\n\n    lia.log.add(client, \"hospitalDeathFlagged\")\nend)\n\n-- Apply hospital death flagging effects\nhook.Add(\"HospitalDeathFlagged\", \"HospitalDeathFlaggingEffects\", function(client)\n    -- Play death sound\n    client:EmitSound(\"vo/npc/male01/pain08.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 25), 1, 0)\n\n    -- Notify player\n    client:notify(\"You have been flagged for hospital respawn!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track hospital death flagging statistics\nhook.Add(\"HospitalDeathFlagged\", \"TrackHospitalDeathFlaggingStats\", function(client)\n    local char = client:getChar()\n    if char then\n        -- Track flagging frequency\n        local flaggingFrequency = char:getData(\"hospital_death_flagging_frequency\", 0)\n        char:setData(\"hospital_death_flagging_frequency\", flaggingFrequency + 1)\n\n        -- Track flagging patterns\n        local flaggingPatterns = char:getData(\"hospital_death_flagging_patterns\", {})\n        table.insert(flaggingPatterns, {\n            time = os.time()\n        })\n        char:setData(\"hospital_death_flagging_patterns\", flaggingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/enhanceddeath/hooks/#hospitalmoneylost","title":"HospitalMoneyLost","text":"<p>Purpose</p> <p>Called when a player loses money due to hospital death.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who lost money.</li> <li><code>moneyLoss</code> (number): The amount of money lost.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player respawns at a hospital - Money loss is enabled - The money is deducted from the player's character</p> <p>Example Usage</p> <pre><code>-- Track hospital money loss\nhook.Add(\"HospitalMoneyLost\", \"TrackHospitalMoneyLoss\", function(client, moneyLoss)\n    local char = client:getChar()\n    if char then\n        local totalMoneyLost = char:getData(\"hospital_money_lost\", 0)\n        char:setData(\"hospital_money_lost\", totalMoneyLost + moneyLoss)\n    end\n\n    lia.log.add(client, \"hospitalMoneyLost\", moneyLoss)\nend)\n\n-- Apply hospital money loss effects\nhook.Add(\"HospitalMoneyLost\", \"HospitalMoneyLossEffects\", function(client, moneyLoss)\n    -- Play money loss sound\n    client:EmitSound(\"ui/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"You lost \" .. lia.currency.get(moneyLoss) .. \" due to hospital fees!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track hospital money loss statistics\nhook.Add(\"HospitalMoneyLost\", \"TrackHospitalMoneyLossStats\", function(client, moneyLoss)\n    local char = client:getChar()\n    if char then\n        -- Track money loss frequency\n        local moneyLossFrequency = char:getData(\"hospital_money_loss_frequency\", 0)\n        char:setData(\"hospital_money_loss_frequency\", moneyLossFrequency + 1)\n\n        -- Track money loss patterns\n        local moneyLossPatterns = char:getData(\"hospital_money_loss_patterns\", {})\n        table.insert(moneyLossPatterns, {\n            amount = moneyLoss,\n            time = os.time()\n        })\n        char:setData(\"hospital_money_loss_patterns\", moneyLossPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/enhanceddeath/hooks/#hospitalrespawned","title":"HospitalRespawned","text":"<p>Purpose</p> <p>Called when a player respawns at a hospital.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who respawned.</li> <li><code>respawnLocation</code> (Vector): The location where the player respawned.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player respawns at a hospital - The respawn location is set - After the hospital death flag is cleared</p> <p>Example Usage</p> <pre><code>-- Track hospital respawns\nhook.Add(\"HospitalRespawned\", \"TrackHospitalRespawns\", function(client, respawnLocation)\n    local char = client:getChar()\n    if char then\n        local hospitalRespawns = char:getData(\"hospital_respawns\", 0)\n        char:setData(\"hospital_respawns\", hospitalRespawns + 1)\n    end\n\n    lia.log.add(client, \"hospitalRespawned\", respawnLocation)\nend)\n\n-- Apply hospital respawn effects\nhook.Add(\"HospitalRespawned\", \"HospitalRespawnEffects\", function(client, respawnLocation)\n    -- Play respawn sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"You have respawned at the hospital!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(respawnLocation)\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track hospital respawn statistics\nhook.Add(\"HospitalRespawned\", \"TrackHospitalRespawnStats\", function(client, respawnLocation)\n    local char = client:getChar()\n    if char then\n        -- Track respawn frequency\n        local respawnFrequency = char:getData(\"hospital_respawn_frequency\", 0)\n        char:setData(\"hospital_respawn_frequency\", respawnFrequency + 1)\n\n        -- Track respawn patterns\n        local respawnPatterns = char:getData(\"hospital_respawn_patterns\", {})\n        table.insert(respawnPatterns, {\n            location = respawnLocation,\n            time = os.time()\n        })\n        char:setData(\"hospital_respawn_patterns\", respawnPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/extendeddescriptions/about/","title":"About","text":"About <p>Name: Extended Descriptions</p> <p>Description:</p> <p>Adds support for long item descriptions, localization for multiple languages, better RP text display, automatic line wrapping, and fallback to short descriptions.</p> Features <ul> <li>Adds support for long item descriptions</li> <li>Adds localization for multiple languages</li> <li>Adds better RP text display</li> <li>Adds automatic line wrapping</li> <li>Adds fallback to short descriptions</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/extendeddescriptions/changelog/","title":"Changelog","text":""},{"location":"modules/extendeddescriptions/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/extendeddescriptions/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/extendeddescriptions/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/extendeddescriptions/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Extended Descriptions module for managing detailed item descriptions and editing functionality.</p>"},{"location":"modules/extendeddescriptions/hooks/#extendeddescriptionclosed","title":"ExtendedDescriptionClosed","text":"<p>Purpose</p> <p>Called when an extended description window is closed.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who closed the description.</li> <li><code>descText</code> (string): The description text that was displayed.</li> <li><code>descURL</code> (string): The URL that was displayed.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - An extended description window is closed - The player closes the description interface - After <code>ExtendedDescriptionOpened</code> hook</p> <p>Example Usage</p> <pre><code>-- Track extended description closures\nhook.Add(\"ExtendedDescriptionClosed\", \"TrackExtendedDescriptionClosures\", function(player, descText, descURL)\n    local char = player:getChar()\n    if char then\n        local descriptionClosures = char:getData(\"extended_description_closures\", 0)\n        char:setData(\"extended_description_closures\", descriptionClosures + 1)\n    end\nend)\n\n-- Apply extended description closure effects\nhook.Add(\"ExtendedDescriptionClosed\", \"ExtendedDescriptionClosureEffects\", function(player, descText, descURL)\n    -- Play closure sound\n    player:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 5), 0.2, 0)\n\n    -- Notify player\n    player:notify(\"Extended description closed!\")\nend)\n\n-- Track extended description closure statistics\nhook.Add(\"ExtendedDescriptionClosed\", \"TrackExtendedDescriptionClosureStats\", function(player, descText, descURL)\n    local char = player:getChar()\n    if char then\n        -- Track closure frequency\n        local closureFrequency = char:getData(\"extended_description_closure_frequency\", 0)\n        char:setData(\"extended_description_closure_frequency\", closureFrequency + 1)\n\n        -- Track closure patterns\n        local closurePatterns = char:getData(\"extended_description_closure_patterns\", {})\n        table.insert(closurePatterns, {\n            text = descText,\n            url = descURL,\n            time = os.time()\n        })\n        char:setData(\"extended_description_closure_patterns\", closurePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/extendeddescriptions/hooks/#extendeddescriptioneditclosed","title":"ExtendedDescriptionEditClosed","text":"<p>Purpose</p> <p>Called when an extended description edit window is closed.</p> <p>Parameters</p> <ul> <li><code>steamName</code> (string): The Steam name of the player who closed the edit window.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - An extended description edit window is closed - The player closes the edit interface - After <code>ExtendedDescriptionEditOpened</code> hook</p> <p>Example Usage</p> <pre><code>-- Track extended description edit closures\nhook.Add(\"ExtendedDescriptionEditClosed\", \"TrackExtendedDescriptionEditClosures\", function(steamName)\n    local char = LocalPlayer():getChar()\n    if char then\n        local editClosures = char:getData(\"extended_description_edit_closures\", 0)\n        char:setData(\"extended_description_edit_closures\", editClosures + 1)\n    end\nend)\n\n-- Apply extended description edit closure effects\nhook.Add(\"ExtendedDescriptionEditClosed\", \"ExtendedDescriptionEditClosureEffects\", function(steamName)\n    -- Play closure sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 5), 0.2, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Extended description edit closed!\")\nend)\n\n-- Track extended description edit closure statistics\nhook.Add(\"ExtendedDescriptionEditClosed\", \"TrackExtendedDescriptionEditClosureStats\", function(steamName)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track edit closure frequency\n        local editClosureFrequency = char:getData(\"extended_description_edit_closure_frequency\", 0)\n        char:setData(\"extended_description_edit_closure_frequency\", editClosureFrequency + 1)\n\n        -- Track edit closure patterns\n        local editClosurePatterns = char:getData(\"extended_description_edit_closure_patterns\", {})\n        table.insert(editClosurePatterns, {\n            steamName = steamName,\n            time = os.time()\n        })\n        char:setData(\"extended_description_edit_closure_patterns\", editClosurePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/extendeddescriptions/hooks/#extendeddescriptioneditopened","title":"ExtendedDescriptionEditOpened","text":"<p>Purpose</p> <p>Called when an extended description edit window is opened.</p> <p>Parameters</p> <ul> <li><code>frame</code> (Panel): The edit frame that was opened.</li> <li><code>steamName</code> (string): The Steam name of the player who opened the edit window.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - An extended description edit window is opened - The player opens the edit interface - Before <code>ExtendedDescriptionEditClosed</code> hook</p> <p>Example Usage</p> <pre><code>-- Track extended description edit openings\nhook.Add(\"ExtendedDescriptionEditOpened\", \"TrackExtendedDescriptionEditOpenings\", function(frame, steamName)\n    local char = LocalPlayer():getChar()\n    if char then\n        local editOpenings = char:getData(\"extended_description_edit_openings\", 0)\n        char:setData(\"extended_description_edit_openings\", editOpenings + 1)\n    end\nend)\n\n-- Apply extended description edit opening effects\nhook.Add(\"ExtendedDescriptionEditOpened\", \"ExtendedDescriptionEditOpeningEffects\", function(frame, steamName)\n    -- Play opening sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Extended description edit opened!\")\nend)\n\n-- Track extended description edit opening statistics\nhook.Add(\"ExtendedDescriptionEditOpened\", \"TrackExtendedDescriptionEditOpeningStats\", function(frame, steamName)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track edit opening frequency\n        local editOpeningFrequency = char:getData(\"extended_description_edit_opening_frequency\", 0)\n        char:setData(\"extended_description_edit_opening_frequency\", editOpeningFrequency + 1)\n\n        -- Track edit opening patterns\n        local editOpeningPatterns = char:getData(\"extended_description_edit_opening_patterns\", {})\n        table.insert(editOpeningPatterns, {\n            steamName = steamName,\n            time = os.time()\n        })\n        char:setData(\"extended_description_edit_opening_patterns\", editOpeningPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/extendeddescriptions/hooks/#extendeddescriptioneditsubmitted","title":"ExtendedDescriptionEditSubmitted","text":"<p>Purpose</p> <p>Called when an extended description edit is submitted.</p> <p>Parameters</p> <ul> <li><code>steamName</code> (string): The Steam name of the player who submitted the edit.</li> <li><code>urlEntry</code> (string): The URL that was entered.</li> <li><code>textEntry</code> (string): The text that was entered.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - An extended description edit is submitted - The player saves their changes - Before <code>ExtendedDescriptionEditClosed</code> hook</p> <p>Example Usage</p> <pre><code>-- Track extended description edit submissions\nhook.Add(\"ExtendedDescriptionEditSubmitted\", \"TrackExtendedDescriptionEditSubmissions\", function(steamName, urlEntry, textEntry)\n    local char = LocalPlayer():getChar()\n    if char then\n        local editSubmissions = char:getData(\"extended_description_edit_submissions\", 0)\n        char:setData(\"extended_description_edit_submissions\", editSubmissions + 1)\n    end\nend)\n\n-- Apply extended description edit submission effects\nhook.Add(\"ExtendedDescriptionEditSubmitted\", \"ExtendedDescriptionEditSubmissionEffects\", function(steamName, urlEntry, textEntry)\n    -- Play submission sound\n    LocalPlayer():EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.5, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Extended description edit submitted!\")\nend)\n\n-- Track extended description edit submission statistics\nhook.Add(\"ExtendedDescriptionEditSubmitted\", \"TrackExtendedDescriptionEditSubmissionStats\", function(steamName, urlEntry, textEntry)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track edit submission frequency\n        local editSubmissionFrequency = char:getData(\"extended_description_edit_submission_frequency\", 0)\n        char:setData(\"extended_description_edit_submission_frequency\", editSubmissionFrequency + 1)\n\n        -- Track edit submission patterns\n        local editSubmissionPatterns = char:getData(\"extended_description_edit_submission_patterns\", {})\n        table.insert(editSubmissionPatterns, {\n            steamName = steamName,\n            url = urlEntry,\n            text = textEntry,\n            time = os.time()\n        })\n        char:setData(\"extended_description_edit_submission_patterns\", editSubmissionPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/extendeddescriptions/hooks/#extendeddescriptionopened","title":"ExtendedDescriptionOpened","text":"<p>Purpose</p> <p>Called when an extended description window is opened.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who opened the description.</li> <li><code>frame</code> (Panel): The description frame that was opened.</li> <li><code>descText</code> (string): The description text being displayed.</li> <li><code>descURL</code> (string): The URL being displayed.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - An extended description window is opened - The player opens the description interface - Before <code>ExtendedDescriptionClosed</code> hook</p> <p>Example Usage</p> <pre><code>-- Track extended description openings\nhook.Add(\"ExtendedDescriptionOpened\", \"TrackExtendedDescriptionOpenings\", function(player, frame, descText, descURL)\n    local char = player:getChar()\n    if char then\n        local descriptionOpenings = char:getData(\"extended_description_openings\", 0)\n        char:setData(\"extended_description_openings\", descriptionOpenings + 1)\n    end\nend)\n\n-- Apply extended description opening effects\nhook.Add(\"ExtendedDescriptionOpened\", \"ExtendedDescriptionOpeningEffects\", function(player, frame, descText, descURL)\n    -- Play opening sound\n    player:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    player:notify(\"Extended description opened!\")\nend)\n\n-- Track extended description opening statistics\nhook.Add(\"ExtendedDescriptionOpened\", \"TrackExtendedDescriptionOpeningStats\", function(player, frame, descText, descURL)\n    local char = player:getChar()\n    if char then\n        -- Track opening frequency\n        local openingFrequency = char:getData(\"extended_description_opening_frequency\", 0)\n        char:setData(\"extended_description_opening_frequency\", openingFrequency + 1)\n\n        -- Track opening patterns\n        local openingPatterns = char:getData(\"extended_description_opening_patterns\", {})\n        table.insert(openingPatterns, {\n            text = descText,\n            url = descURL,\n            time = os.time()\n        })\n        char:setData(\"extended_description_opening_patterns\", openingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/extendeddescriptions/hooks/#extendeddescriptionupdated","title":"ExtendedDescriptionUpdated","text":"<p>Purpose</p> <p>Called when an extended description is updated.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose description was updated.</li> <li><code>textEntryURL</code> (string): The URL that was updated.</li> <li><code>text</code> (string): The text that was updated.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An extended description is updated - The description data is saved to the character - After <code>PreExtendedDescriptionUpdate</code> hook</p> <p>Example Usage</p> <pre><code>-- Track extended description updates\nhook.Add(\"ExtendedDescriptionUpdated\", \"TrackExtendedDescriptionUpdates\", function(client, textEntryURL, text)\n    local char = client:getChar()\n    if char then\n        local descriptionUpdates = char:getData(\"extended_description_updates\", 0)\n        char:setData(\"extended_description_updates\", descriptionUpdates + 1)\n    end\n\n    lia.log.add(client, \"extendedDescriptionUpdated\", textEntryURL, text)\nend)\n\n-- Apply extended description update effects\nhook.Add(\"ExtendedDescriptionUpdated\", \"ExtendedDescriptionUpdateEffects\", function(client, textEntryURL, text)\n    -- Play update sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Extended description updated!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track extended description update statistics\nhook.Add(\"ExtendedDescriptionUpdated\", \"TrackExtendedDescriptionUpdateStats\", function(client, textEntryURL, text)\n    local char = client:getChar()\n    if char then\n        -- Track update frequency\n        local updateFrequency = char:getData(\"extended_description_update_frequency\", 0)\n        char:setData(\"extended_description_update_frequency\", updateFrequency + 1)\n\n        -- Track update patterns\n        local updatePatterns = char:getData(\"extended_description_update_patterns\", {})\n        table.insert(updatePatterns, {\n            url = textEntryURL,\n            text = text,\n            time = os.time()\n        })\n        char:setData(\"extended_description_update_patterns\", updatePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/extendeddescriptions/hooks/#preextendeddescriptionupdate","title":"PreExtendedDescriptionUpdate","text":"<p>Purpose</p> <p>Called before an extended description is updated.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose description is about to be updated.</li> <li><code>textEntryURL</code> (string): The URL that will be updated.</li> <li><code>text</code> (string): The text that will be updated.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An extended description is about to be updated - Before the description data is saved - Before <code>ExtendedDescriptionUpdated</code> hook</p> <p>Example Usage</p> <pre><code>-- Validate extended description update\nhook.Add(\"PreExtendedDescriptionUpdate\", \"ValidateExtendedDescriptionUpdate\", function(client, textEntryURL, text)\n    local char = client:getChar()\n    if char then\n        -- Check if description updates are disabled\n        if char:getData(\"extended_description_updates_disabled\", false) then\n            client:notify(\"Extended description updates are disabled!\")\n            return false\n        end\n\n        -- Check update cooldown\n        local lastUpdate = char:getData(\"last_extended_description_update_time\", 0)\n        if os.time() - lastUpdate &lt; 5 then -- 5 second cooldown\n            client:notify(\"Please wait before updating your description again!\")\n            return false\n        end\n\n        -- Update last update time\n        char:setData(\"last_extended_description_update_time\", os.time())\n    end\nend)\n\n-- Track extended description update attempts\nhook.Add(\"PreExtendedDescriptionUpdate\", \"TrackExtendedDescriptionUpdateAttempts\", function(client, textEntryURL, text)\n    local char = client:getChar()\n    if char then\n        local updateAttempts = char:getData(\"extended_description_update_attempts\", 0)\n        char:setData(\"extended_description_update_attempts\", updateAttempts + 1)\n    end\nend)\n\n-- Apply pre-update effects\nhook.Add(\"PreExtendedDescriptionUpdate\", \"PreExtendedDescriptionUpdateEffects\", function(client, textEntryURL, text)\n    -- Play pre-update sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Updating extended description...\")\nend)\n</code></pre>"},{"location":"modules/firstpersoneffects/about/","title":"About","text":"About <p>Name: First Person Effects</p> <p>Description:</p> <p>Adds head bob and view sway, camera motion synced to actions, a realistic first-person feel, and adjustable intensity via config.</p> Features <ul> <li>Adds head bob and view sway</li> <li>Adds camera motion synced to actions</li> <li>Adds a realistic first-person feel</li> <li>Adds adjustable intensity via config</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/firstpersoneffects/changelog/","title":"Changelog","text":""},{"location":"modules/firstpersoneffects/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/firstpersoneffects/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/firstpersoneffects/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/firstpersoneffects/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the First Person Effects module for managing head bob and view sway functionality.</p>"},{"location":"modules/firstpersoneffects/hooks/#firstpersoneffectsupdated","title":"FirstPersonEffectsUpdated","text":"<p>Purpose</p> <p>Called when first person effects are updated with new position and angle values.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose effects are being updated.</li> <li><code>currentPos</code> (Vector): The current position offset.</li> <li><code>currentAng</code> (Angle): The current angle offset.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - First person effects are updated - After <code>PostFirstPersonEffects</code> hook - When the effects calculation is complete</p> <p>Example Usage</p> <pre><code>-- Track first person effects updates\nhook.Add(\"FirstPersonEffectsUpdated\", \"TrackFirstPersonEffectsUpdates\", function(player, currentPos, currentAng)\n    local char = player:getChar()\n    if char then\n        local effectsUpdates = char:getData(\"first_person_effects_updates\", 0)\n        char:setData(\"first_person_effects_updates\", effectsUpdates + 1)\n    end\nend)\n\n-- Apply first person effects update effects\nhook.Add(\"FirstPersonEffectsUpdated\", \"FirstPersonEffectsUpdateEffects\", function(player, currentPos, currentAng)\n    -- Play update sound\n    player:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    player:notify(\"First person effects updated!\")\nend)\n\n-- Track first person effects update statistics\nhook.Add(\"FirstPersonEffectsUpdated\", \"TrackFirstPersonEffectsUpdateStats\", function(player, currentPos, currentAng)\n    local char = player:getChar()\n    if char then\n        -- Track update frequency\n        local updateFrequency = char:getData(\"first_person_effects_update_frequency\", 0)\n        char:setData(\"first_person_effects_update_frequency\", updateFrequency + 1)\n\n        -- Track update patterns\n        local updatePatterns = char:getData(\"first_person_effects_update_patterns\", {})\n        table.insert(updatePatterns, {\n            pos = currentPos,\n            ang = currentAng,\n            time = os.time()\n        })\n        char:setData(\"first_person_effects_update_patterns\", updatePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/firstpersoneffects/hooks/#postfirstpersoneffects","title":"PostFirstPersonEffects","text":"<p>Purpose</p> <p>Called after first person effects have been calculated.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose effects are being calculated.</li> <li><code>currentPos</code> (Vector): The current position offset.</li> <li><code>currentAng</code> (Angle): The current angle offset.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - First person effects have been calculated - After <code>PreFirstPersonEffects</code> hook - Before <code>FirstPersonEffectsUpdated</code> hook</p> <p>Example Usage</p> <pre><code>-- Track first person effects completion\nhook.Add(\"PostFirstPersonEffects\", \"TrackFirstPersonEffectsCompletion\", function(player, currentPos, currentAng)\n    local char = player:getChar()\n    if char then\n        local effectsCompletions = char:getData(\"first_person_effects_completions\", 0)\n        char:setData(\"first_person_effects_completions\", effectsCompletions + 1)\n    end\nend)\n\n-- Apply first person effects completion effects\nhook.Add(\"PostFirstPersonEffects\", \"FirstPersonEffectsCompletionEffects\", function(player, currentPos, currentAng)\n    -- Play completion sound\n    player:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    player:notify(\"First person effects calculated!\")\nend)\n\n-- Track first person effects completion statistics\nhook.Add(\"PostFirstPersonEffects\", \"TrackFirstPersonEffectsCompletionStats\", function(player, currentPos, currentAng)\n    local char = player:getChar()\n    if char then\n        -- Track completion frequency\n        local completionFrequency = char:getData(\"first_person_effects_completion_frequency\", 0)\n        char:setData(\"first_person_effects_completion_frequency\", completionFrequency + 1)\n\n        -- Track completion patterns\n        local completionPatterns = char:getData(\"first_person_effects_completion_patterns\", {})\n        table.insert(completionPatterns, {\n            pos = currentPos,\n            ang = currentAng,\n            time = os.time()\n        })\n        char:setData(\"first_person_effects_completion_patterns\", completionPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/firstpersoneffects/hooks/#prefirstpersoneffects","title":"PreFirstPersonEffects","text":"<p>Purpose</p> <p>Called before first person effects are calculated.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose effects are about to be calculated.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - First person effects are about to be calculated - Before any effect calculations begin - Before <code>PostFirstPersonEffects</code> hook</p> <p>Example Usage</p> <pre><code>-- Track first person effects preparation\nhook.Add(\"PreFirstPersonEffects\", \"TrackFirstPersonEffectsPreparation\", function(player)\n    local char = player:getChar()\n    if char then\n        local effectsPreparations = char:getData(\"first_person_effects_preparations\", 0)\n        char:setData(\"first_person_effects_preparations\", effectsPreparations + 1)\n    end\nend)\n\n-- Apply first person effects preparation effects\nhook.Add(\"PreFirstPersonEffects\", \"FirstPersonEffectsPreparationEffects\", function(player)\n    -- Play preparation sound\n    player:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    player:notify(\"Calculating first person effects...\")\nend)\n\n-- Track first person effects preparation statistics\nhook.Add(\"PreFirstPersonEffects\", \"TrackFirstPersonEffectsPreparationStats\", function(player)\n    local char = player:getChar()\n    if char then\n        -- Track preparation frequency\n        local preparationFrequency = char:getData(\"first_person_effects_preparation_frequency\", 0)\n        char:setData(\"first_person_effects_preparation_frequency\", preparationFrequency + 1)\n\n        -- Track preparation patterns\n        local preparationPatterns = char:getData(\"first_person_effects_preparation_patterns\", {})\n        table.insert(preparationPatterns, {\n            time = os.time()\n        })\n        char:setData(\"first_person_effects_preparation_patterns\", preparationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/firstpersoneffects/hooks/#shouldusefirstpersoneffects","title":"ShouldUseFirstPersonEffects","text":"<p>Purpose</p> <p>Called to determine if first person effects should be used for a player.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player to check.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - First person effects are about to be calculated - Before any effect calculations begin - Before <code>PreFirstPersonEffects</code> hook</p> <p>Example Usage</p> <pre><code>-- Control first person effects usage\nhook.Add(\"ShouldUseFirstPersonEffects\", \"ControlFirstPersonEffectsUsage\", function(player)\n    local char = player:getChar()\n    if char then\n        -- Check if effects are disabled\n        if char:getData(\"first_person_effects_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if player:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if player:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check if player is crouching\n        if player:KeyDown(IN_DUCK) then\n            return false\n        end\n\n        -- Check if player is sprinting\n        if player:KeyDown(IN_SPEED) then\n            return false\n        end\n    end\n\n    return true\nend)\n\n-- Track first person effects usage checks\nhook.Add(\"ShouldUseFirstPersonEffects\", \"TrackFirstPersonEffectsUsageChecks\", function(player)\n    local char = player:getChar()\n    if char then\n        local usageChecks = char:getData(\"first_person_effects_usage_checks\", 0)\n        char:setData(\"first_person_effects_usage_checks\", usageChecks + 1)\n    end\nend)\n\n-- Apply first person effects usage check effects\nhook.Add(\"ShouldUseFirstPersonEffects\", \"FirstPersonEffectsUsageCheckEffects\", function(player)\n    local char = player:getChar()\n    if char then\n        -- Check if effects are disabled\n        if char:getData(\"first_person_effects_disabled\", false) then\n            player:notify(\"First person effects are disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/flashlight/about/","title":"About","text":"About <p>Name: Flashlight</p> <p>Description:</p> <p>Adds a serious flashlight with dynamic light, darkening of surroundings when turned off, adjustable brightness, and keybind toggle support.</p> Features <ul> <li>Adds a serious flashlight with dynamic light</li> <li>Adds darkening of surroundings when turned off</li> <li>Adds adjustable brightness</li> <li>Adds keybind toggle support</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/flashlight/changelog/","title":"Changelog","text":""},{"location":"modules/flashlight/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/flashlight/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/flashlight/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Flashlight module for managing flashlight functionality.</p>"},{"location":"modules/flashlight/hooks/#canplayertoggleflashlight","title":"CanPlayerToggleFlashlight","text":"<p>Purpose</p> <p>Called to determine if a player can toggle their flashlight.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to toggle the flashlight.</li> <li><code>isEnabled</code> (boolean): Whether the flashlight is being turned on or off.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player attempts to toggle their flashlight - After <code>PrePlayerToggleFlashlight</code> hook - Before the flashlight is actually toggled</p> <p>Example Usage</p> <pre><code>-- Control flashlight usage\nhook.Add(\"CanPlayerToggleFlashlight\", \"ControlFlashlightUsage\", function(client, isEnabled)\n    local char = client:getChar()\n    if char then\n        -- Check if flashlight is disabled\n        if char:getData(\"flashlight_disabled\", false) then\n            client:notify(\"Flashlight is disabled!\")\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            client:notify(\"Flashlight not allowed in this area!\")\n            return false\n        end\n\n        -- Check if player is handcuffed\n        if client:IsHandcuffed() then\n            client:notify(\"Cannot use flashlight while handcuffed!\")\n            return false\n        end\n\n        -- Check cooldown\n        local lastToggle = char:getData(\"last_flashlight_toggle_time\", 0)\n        if os.time() - lastToggle &lt; 2 then -- 2 second cooldown\n            client:notify(\"Please wait before toggling flashlight again!\")\n            return false\n        end\n\n        -- Update last toggle time\n        char:setData(\"last_flashlight_toggle_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track flashlight usage attempts\nhook.Add(\"CanPlayerToggleFlashlight\", \"TrackFlashlightUsageAttempts\", function(client, isEnabled)\n    local char = client:getChar()\n    if char then\n        local usageAttempts = char:getData(\"flashlight_usage_attempts\", 0)\n        char:setData(\"flashlight_usage_attempts\", usageAttempts + 1)\n    end\nend)\n\n-- Apply flashlight usage check effects\nhook.Add(\"CanPlayerToggleFlashlight\", \"FlashlightUsageCheckEffects\", function(client, isEnabled)\n    local char = client:getChar()\n    if char then\n        -- Check if flashlight is disabled\n        if char:getData(\"flashlight_disabled\", false) then\n            client:notify(\"Flashlight is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/flashlight/hooks/#playertoggleflashlight","title":"PlayerToggleFlashlight","text":"<p>Purpose</p> <p>Called when a player's flashlight is toggled.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose flashlight was toggled.</li> <li><code>isEnabled</code> (boolean): Whether the flashlight was turned on or off.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's flashlight is successfully toggled - After <code>CanPlayerToggleFlashlight</code> hook - After the flashlight state is changed</p> <p>Example Usage</p> <pre><code>-- Track flashlight toggles\nhook.Add(\"PlayerToggleFlashlight\", \"TrackFlashlightToggles\", function(client, isEnabled)\n    local char = client:getChar()\n    if char then\n        local flashlightToggles = char:getData(\"flashlight_toggles\", 0)\n        char:setData(\"flashlight_toggles\", flashlightToggles + 1)\n\n        -- Track toggle patterns\n        local togglePatterns = char:getData(\"flashlight_toggle_patterns\", {})\n        table.insert(togglePatterns, {\n            enabled = isEnabled,\n            time = os.time()\n        })\n        char:setData(\"flashlight_toggle_patterns\", togglePatterns)\n    end\n\n    lia.log.add(client, \"flashlightToggled\", isEnabled)\nend)\n\n-- Apply flashlight toggle effects\nhook.Add(\"PlayerToggleFlashlight\", \"FlashlightToggleEffects\", function(client, isEnabled)\n    -- Play toggle sound\n    client:EmitSound(isEnabled and \"buttons/button24.wav\" or \"buttons/button10.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    local status = isEnabled and \"on\" or \"off\"\n    client:notify(\"Flashlight turned \" .. status .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track flashlight toggle statistics\nhook.Add(\"PlayerToggleFlashlight\", \"TrackFlashlightToggleStats\", function(client, isEnabled)\n    local char = client:getChar()\n    if char then\n        -- Track toggle frequency\n        local toggleFrequency = char:getData(\"flashlight_toggle_frequency\", 0)\n        char:setData(\"flashlight_toggle_frequency\", toggleFrequency + 1)\n\n        -- Track toggle patterns\n        local togglePatterns = char:getData(\"flashlight_toggle_patterns\", {})\n        table.insert(togglePatterns, {\n            enabled = isEnabled,\n            time = os.time()\n        })\n        char:setData(\"flashlight_toggle_patterns\", togglePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/flashlight/hooks/#preplayertoggleflashlight","title":"PrePlayerToggleFlashlight","text":"<p>Purpose</p> <p>Called before a player's flashlight is toggled.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to toggle the flashlight.</li> <li><code>isEnabled</code> (boolean): Whether the flashlight is being turned on or off.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player attempts to toggle their flashlight - Before <code>CanPlayerToggleFlashlight</code> hook - Before any flashlight validation</p> <p>Example Usage</p> <pre><code>-- Track flashlight toggle attempts\nhook.Add(\"PrePlayerToggleFlashlight\", \"TrackFlashlightToggleAttempts\", function(client, isEnabled)\n    local char = client:getChar()\n    if char then\n        local toggleAttempts = char:getData(\"flashlight_toggle_attempts\", 0)\n        char:setData(\"flashlight_toggle_attempts\", toggleAttempts + 1)\n    end\nend)\n\n-- Apply pre-toggle effects\nhook.Add(\"PrePlayerToggleFlashlight\", \"PreFlashlightToggleEffects\", function(client, isEnabled)\n    -- Play pre-toggle sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    local status = isEnabled and \"on\" or \"off\"\n    client:notify(\"Attempting to turn flashlight \" .. status .. \"...\")\nend)\n\n-- Track pre-toggle statistics\nhook.Add(\"PrePlayerToggleFlashlight\", \"TrackPreFlashlightToggleStats\", function(client, isEnabled)\n    local char = client:getChar()\n    if char then\n        -- Track pre-toggle frequency\n        local preToggleFrequency = char:getData(\"flashlight_pre_toggle_frequency\", 0)\n        char:setData(\"flashlight_pre_toggle_frequency\", preToggleFrequency + 1)\n\n        -- Track pre-toggle patterns\n        local preTogglePatterns = char:getData(\"flashlight_pre_toggle_patterns\", {})\n        table.insert(preTogglePatterns, {\n            enabled = isEnabled,\n            time = os.time()\n        })\n        char:setData(\"flashlight_pre_toggle_patterns\", preTogglePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/freelook/about/","title":"About","text":"About <p>Name: Free Look</p> <p>Description:</p> <p>Adds the ability to look around without turning the body, a toggle key similar to EFT, movement direction preservation, and adjustable sensitivity while freelooking.</p> Features <ul> <li>Adds the ability to look around without turning the body</li> <li>Adds a toggle key similar to EFT</li> <li>Adds movement direction preservation</li> <li>Adds adjustable sensitivity while freelooking</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/freelook/changelog/","title":"Changelog","text":""},{"location":"modules/freelook/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/freelook/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/freelook/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Free Look module for managing freelook functionality.</p>"},{"location":"modules/freelook/hooks/#freelooktoggled","title":"FreelookToggled","text":"<p>Purpose</p> <p>Called when freelook is toggled on or off.</p> <p>Parameters</p> <ul> <li><code>enabled</code> (boolean): Whether freelook is being enabled or disabled.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Freelook is toggled on or off - After <code>PreFreelookToggle</code> hook - When the freelook state changes</p> <p>Example Usage</p> <pre><code>-- Track freelook toggles\nhook.Add(\"FreelookToggled\", \"TrackFreelookToggles\", function(enabled)\n    local char = LocalPlayer():getChar()\n    if char then\n        local freelookToggles = char:getData(\"freelook_toggles\", 0)\n        char:setData(\"freelook_toggles\", freelookToggles + 1)\n\n        -- Track toggle patterns\n        local togglePatterns = char:getData(\"freelook_toggle_patterns\", {})\n        table.insert(togglePatterns, {\n            enabled = enabled,\n            time = os.time()\n        })\n        char:setData(\"freelook_toggle_patterns\", togglePatterns)\n    end\nend)\n\n-- Apply freelook toggle effects\nhook.Add(\"FreelookToggled\", \"FreelookToggleEffects\", function(enabled)\n    -- Play toggle sound\n    LocalPlayer():EmitSound(enabled and \"buttons/button24.wav\" or \"buttons/button10.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    local status = enabled and \"on\" or \"off\"\n    LocalPlayer():notify(\"Freelook turned \" .. status .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(LocalPlayer():GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track freelook toggle statistics\nhook.Add(\"FreelookToggled\", \"TrackFreelookToggleStats\", function(enabled)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track toggle frequency\n        local toggleFrequency = char:getData(\"freelook_toggle_frequency\", 0)\n        char:setData(\"freelook_toggle_frequency\", toggleFrequency + 1)\n\n        -- Track toggle patterns\n        local togglePatterns = char:getData(\"freelook_toggle_patterns\", {})\n        table.insert(togglePatterns, {\n            enabled = enabled,\n            time = os.time()\n        })\n        char:setData(\"freelook_toggle_patterns\", togglePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/freelook/hooks/#prefreelooktoggle","title":"PreFreelookToggle","text":"<p>Purpose</p> <p>Called before freelook is toggled on or off.</p> <p>Parameters</p> <ul> <li><code>enabled</code> (boolean): Whether freelook is being enabled or disabled.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Freelook is about to be toggled - Before the freelook state changes - Before <code>FreelookToggled</code> hook</p> <p>Example Usage</p> <pre><code>-- Control freelook toggling\nhook.Add(\"PreFreelookToggle\", \"ControlFreelookToggling\", function(enabled)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if freelook is disabled\n        if char:getData(\"freelook_disabled\", false) then\n            LocalPlayer():notify(\"Freelook is disabled!\")\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if LocalPlayer():InVehicle() then\n            LocalPlayer():notify(\"Cannot use freelook in a vehicle!\")\n            return false\n        end\n\n        -- Check if player is in water\n        if LocalPlayer():WaterLevel() &gt;= 2 then\n            LocalPlayer():notify(\"Cannot use freelook underwater!\")\n            return false\n        end\n\n        -- Check cooldown\n        local lastToggle = char:getData(\"last_freelook_toggle_time\", 0)\n        if os.time() - lastToggle &lt; 1 then -- 1 second cooldown\n            LocalPlayer():notify(\"Please wait before toggling freelook again!\")\n            return false\n        end\n\n        -- Update last toggle time\n        char:setData(\"last_freelook_toggle_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track freelook toggle attempts\nhook.Add(\"PreFreelookToggle\", \"TrackFreelookToggleAttempts\", function(enabled)\n    local char = LocalPlayer():getChar()\n    if char then\n        local toggleAttempts = char:getData(\"freelook_toggle_attempts\", 0)\n        char:setData(\"freelook_toggle_attempts\", toggleAttempts + 1)\n    end\nend)\n\n-- Apply pre-toggle effects\nhook.Add(\"PreFreelookToggle\", \"PreFreelookToggleEffects\", function(enabled)\n    -- Play pre-toggle sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    local status = enabled and \"on\" or \"off\"\n    LocalPlayer():notify(\"Attempting to turn freelook \" .. status .. \"...\")\nend)\n</code></pre>"},{"location":"modules/freelook/hooks/#shouldusefreelook","title":"ShouldUseFreelook","text":"<p>Purpose</p> <p>Called to determine if freelook should be used for a player.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player to check.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Freelook input is being processed - Before any freelook calculations - Before <code>PreFreelookToggle</code> hook</p> <p>Example Usage</p> <pre><code>-- Control freelook usage\nhook.Add(\"ShouldUseFreelook\", \"ControlFreelookUsage\", function(player)\n    local char = player:getChar()\n    if char then\n        -- Check if freelook is disabled\n        if char:getData(\"freelook_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if player:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if player:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check if player is crouching\n        if player:KeyDown(IN_DUCK) then\n            return false\n        end\n\n        -- Check if player is sprinting\n        if player:KeyDown(IN_SPEED) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n    end\n\n    return true\nend)\n\n-- Track freelook usage checks\nhook.Add(\"ShouldUseFreelook\", \"TrackFreelookUsageChecks\", function(player)\n    local char = player:getChar()\n    if char then\n        local usageChecks = char:getData(\"freelook_usage_checks\", 0)\n        char:setData(\"freelook_usage_checks\", usageChecks + 1)\n    end\nend)\n\n-- Apply freelook usage check effects\nhook.Add(\"ShouldUseFreelook\", \"FreelookUsageCheckEffects\", function(player)\n    local char = player:getChar()\n    if char then\n        -- Check if freelook is disabled\n        if char:getData(\"freelook_disabled\", false) then\n            player:notify(\"Freelook is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/about/","title":"About","text":"About <p>Name: Gamemaster Points</p> <p>Description:</p> <p>Adds teleport points for game masters, quick navigation across large maps, saving of locations for reuse, a command to list saved points, and sharing of points with other staff.</p> Features <ul> <li>Adds teleport points for game masters</li> <li>Adds quick navigation across large maps</li> <li>Adds saving of locations for reuse</li> <li>Adds a command to list saved points</li> <li>Adds sharing of points with other staff</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/gamemasterpoints/changelog/","title":"Changelog","text":""},{"location":"modules/gamemasterpoints/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Updated: Client library functions and optimizations</li> </ul>"},{"location":"modules/gamemasterpoints/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/gamemasterpoints/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/gamemasterpoints/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Gamemaster Points module for managing teleport points functionality.</p>"},{"location":"modules/gamemasterpoints/hooks/#gamemasteraddpoint","title":"GamemasterAddPoint","text":"<p>Purpose</p> <p>Called when a gamemaster point is added.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who added the point.</li> <li><code>name</code> (string): The name of the point.</li> <li><code>pos</code> (Vector): The position of the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A gamemaster point is successfully added - After <code>GamemasterPreAddPoint</code> hook - After the point is saved to data</p> <p>Example Usage</p> <pre><code>-- Track gamemaster point additions\nhook.Add(\"GamemasterAddPoint\", \"TrackGamemasterPointAdditions\", function(client, name, pos)\n    local char = client:getChar()\n    if char then\n        local pointAdditions = char:getData(\"gamemaster_point_additions\", 0)\n        char:setData(\"gamemaster_point_additions\", pointAdditions + 1)\n\n        -- Track point names\n        local pointNames = char:getData(\"gamemaster_point_names\", {})\n        pointNames[name] = (pointNames[name] or 0) + 1\n        char:setData(\"gamemaster_point_names\", pointNames)\n    end\n\n    lia.log.add(client, \"gamemasterPointAdded\", name, pos)\nend)\n\n-- Apply gamemaster point addition effects\nhook.Add(\"GamemasterAddPoint\", \"GamemasterPointAdditionEffects\", function(client, name, pos)\n    -- Play addition sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Gamemaster point added: \" .. name .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(pos)\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track gamemaster point addition statistics\nhook.Add(\"GamemasterAddPoint\", \"TrackGamemasterPointAdditionStats\", function(client, name, pos)\n    local char = client:getChar()\n    if char then\n        -- Track addition frequency\n        local additionFrequency = char:getData(\"gamemaster_point_addition_frequency\", 0)\n        char:setData(\"gamemaster_point_addition_frequency\", additionFrequency + 1)\n\n        -- Track addition patterns\n        local additionPatterns = char:getData(\"gamemaster_point_addition_patterns\", {})\n        table.insert(additionPatterns, {\n            name = name,\n            pos = pos,\n            time = os.time()\n        })\n        char:setData(\"gamemaster_point_addition_patterns\", additionPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemastermovetopoint","title":"GamemasterMoveToPoint","text":"<p>Purpose</p> <p>Called when a player moves to a gamemaster point.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who moved to the point.</li> <li><code>properName</code> (string): The proper name of the point.</li> <li><code>pos</code> (Vector): The position of the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player successfully moves to a gamemaster point - After <code>GamemasterPreMoveToPoint</code> hook - After the player is teleported</p> <p>Example Usage</p> <pre><code>-- Track gamemaster point movements\nhook.Add(\"GamemasterMoveToPoint\", \"TrackGamemasterPointMovements\", function(client, properName, pos)\n    local char = client:getChar()\n    if char then\n        local pointMovements = char:getData(\"gamemaster_point_movements\", 0)\n        char:setData(\"gamemaster_point_movements\", pointMovements + 1)\n\n        -- Track movement destinations\n        local movementDestinations = char:getData(\"gamemaster_movement_destinations\", {})\n        movementDestinations[properName] = (movementDestinations[properName] or 0) + 1\n        char:setData(\"gamemaster_movement_destinations\", movementDestinations)\n    end\n\n    lia.log.add(client, \"gamemasterMovedToPoint\", properName, pos)\nend)\n\n-- Apply gamemaster point movement effects\nhook.Add(\"GamemasterMoveToPoint\", \"GamemasterPointMovementEffects\", function(client, properName, pos)\n    -- Play movement sound\n    client:EmitSound(\"buttons/button15.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Moved to gamemaster point: \" .. properName .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(pos)\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track gamemaster point movement statistics\nhook.Add(\"GamemasterMoveToPoint\", \"TrackGamemasterPointMovementStats\", function(client, properName, pos)\n    local char = client:getChar()\n    if char then\n        -- Track movement frequency\n        local movementFrequency = char:getData(\"gamemaster_point_movement_frequency\", 0)\n        char:setData(\"gamemaster_point_movement_frequency\", movementFrequency + 1)\n\n        -- Track movement patterns\n        local movementPatterns = char:getData(\"gamemaster_point_movement_patterns\", {})\n        table.insert(movementPatterns, {\n            name = properName,\n            pos = pos,\n            time = os.time()\n        })\n        char:setData(\"gamemaster_point_movement_patterns\", movementPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemasterpreaddpoint","title":"GamemasterPreAddPoint","text":"<p>Purpose</p> <p>Called before a gamemaster point is added.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to add the point.</li> <li><code>name</code> (string): The name of the point.</li> <li><code>pos</code> (Vector): The position of the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A gamemaster point is about to be added - Before <code>GamemasterAddPoint</code> hook - Before any validation</p> <p>Example Usage</p> <pre><code>-- Validate gamemaster point addition\nhook.Add(\"GamemasterPreAddPoint\", \"ValidateGamemasterPointAddition\", function(client, name, pos)\n    local char = client:getChar()\n    if char then\n        -- Check if point addition is disabled\n        if char:getData(\"gamemaster_point_addition_disabled\", false) then\n            client:notify(\"Gamemaster point addition is disabled!\")\n            return false\n        end\n\n        -- Check if point name already exists\n        local existingPoints = lia.data.get(\"TPPoints\", {})\n        for _, point in pairs(existingPoints) do\n            if point.name == name then\n                client:notify(\"A point with this name already exists!\")\n                return false\n            end\n        end\n\n        -- Check cooldown\n        local lastAddition = char:getData(\"last_gamemaster_point_addition_time\", 0)\n        if os.time() - lastAddition &lt; 5 then -- 5 second cooldown\n            client:notify(\"Please wait before adding another point!\")\n            return false\n        end\n\n        -- Update last addition time\n        char:setData(\"last_gamemaster_point_addition_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track gamemaster point addition attempts\nhook.Add(\"GamemasterPreAddPoint\", \"TrackGamemasterPointAdditionAttempts\", function(client, name, pos)\n    local char = client:getChar()\n    if char then\n        local additionAttempts = char:getData(\"gamemaster_point_addition_attempts\", 0)\n        char:setData(\"gamemaster_point_addition_attempts\", additionAttempts + 1)\n    end\nend)\n\n-- Apply pre-addition effects\nhook.Add(\"GamemasterPreAddPoint\", \"PreGamemasterPointAdditionEffects\", function(client, name, pos)\n    -- Play pre-addition sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Adding gamemaster point: \" .. name .. \"...\")\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemasterpremovetopoint","title":"GamemasterPreMoveToPoint","text":"<p>Purpose</p> <p>Called before a player moves to a gamemaster point.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to move to the point.</li> <li><code>name</code> (string): The name of the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player is about to move to a gamemaster point - Before <code>GamemasterMoveToPoint</code> hook - Before any validation</p> <p>Example Usage</p> <pre><code>-- Validate gamemaster point movement\nhook.Add(\"GamemasterPreMoveToPoint\", \"ValidateGamemasterPointMovement\", function(client, name)\n    local char = client:getChar()\n    if char then\n        -- Check if point movement is disabled\n        if char:getData(\"gamemaster_point_movement_disabled\", false) then\n            client:notify(\"Gamemaster point movement is disabled!\")\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            client:notify(\"Cannot use gamemaster points in this area!\")\n            return false\n        end\n\n        -- Check cooldown\n        local lastMovement = char:getData(\"last_gamemaster_point_movement_time\", 0)\n        if os.time() - lastMovement &lt; 3 then -- 3 second cooldown\n            client:notify(\"Please wait before moving to another point!\")\n            return false\n        end\n\n        -- Update last movement time\n        char:setData(\"last_gamemaster_point_movement_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track gamemaster point movement attempts\nhook.Add(\"GamemasterPreMoveToPoint\", \"TrackGamemasterPointMovementAttempts\", function(client, name)\n    local char = client:getChar()\n    if char then\n        local movementAttempts = char:getData(\"gamemaster_point_movement_attempts\", 0)\n        char:setData(\"gamemaster_point_movement_attempts\", movementAttempts + 1)\n    end\nend)\n\n-- Apply pre-movement effects\nhook.Add(\"GamemasterPreMoveToPoint\", \"PreGamemasterPointMovementEffects\", function(client, name)\n    -- Play pre-movement sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Moving to gamemaster point: \" .. name .. \"...\")\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemasterpreremovepoint","title":"GamemasterPreRemovePoint","text":"<p>Purpose</p> <p>Called before a gamemaster point is removed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to remove the point.</li> <li><code>name</code> (string): The name of the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A gamemaster point is about to be removed - Before <code>GamemasterRemovePoint</code> hook - Before any validation</p> <p>Example Usage</p> <pre><code>-- Validate gamemaster point removal\nhook.Add(\"GamemasterPreRemovePoint\", \"ValidateGamemasterPointRemoval\", function(client, name)\n    local char = client:getChar()\n    if char then\n        -- Check if point removal is disabled\n        if char:getData(\"gamemaster_point_removal_disabled\", false) then\n            client:notify(\"Gamemaster point removal is disabled!\")\n            return false\n        end\n\n        -- Check cooldown\n        local lastRemoval = char:getData(\"last_gamemaster_point_removal_time\", 0)\n        if os.time() - lastRemoval &lt; 2 then -- 2 second cooldown\n            client:notify(\"Please wait before removing another point!\")\n            return false\n        end\n\n        -- Update last removal time\n        char:setData(\"last_gamemaster_point_removal_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track gamemaster point removal attempts\nhook.Add(\"GamemasterPreRemovePoint\", \"TrackGamemasterPointRemovalAttempts\", function(client, name)\n    local char = client:getChar()\n    if char then\n        local removalAttempts = char:getData(\"gamemaster_point_removal_attempts\", 0)\n        char:setData(\"gamemaster_point_removal_attempts\", removalAttempts + 1)\n    end\nend)\n\n-- Apply pre-removal effects\nhook.Add(\"GamemasterPreRemovePoint\", \"PreGamemasterPointRemovalEffects\", function(client, name)\n    -- Play pre-removal sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Removing gamemaster point: \" .. name .. \"...\")\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemasterprerenamepoint","title":"GamemasterPreRenamePoint","text":"<p>Purpose</p> <p>Called before a gamemaster point is renamed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to rename the point.</li> <li><code>name</code> (string): The current name of the point.</li> <li><code>newName</code> (string): The new name for the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A gamemaster point is about to be renamed - Before <code>GamemasterRenamePoint</code> hook - Before any validation</p> <p>Example Usage</p> <pre><code>-- Validate gamemaster point renaming\nhook.Add(\"GamemasterPreRenamePoint\", \"ValidateGamemasterPointRenaming\", function(client, name, newName)\n    local char = client:getChar()\n    if char then\n        -- Check if point renaming is disabled\n        if char:getData(\"gamemaster_point_renaming_disabled\", false) then\n            client:notify(\"Gamemaster point renaming is disabled!\")\n            return false\n        end\n\n        -- Check if new name already exists\n        local existingPoints = lia.data.get(\"TPPoints\", {})\n        for _, point in pairs(existingPoints) do\n            if point.name == newName then\n                client:notify(\"A point with this name already exists!\")\n                return false\n            end\n        end\n\n        -- Check cooldown\n        local lastRename = char:getData(\"last_gamemaster_point_rename_time\", 0)\n        if os.time() - lastRename &lt; 2 then -- 2 second cooldown\n            client:notify(\"Please wait before renaming another point!\")\n            return false\n        end\n\n        -- Update last rename time\n        char:setData(\"last_gamemaster_point_rename_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track gamemaster point renaming attempts\nhook.Add(\"GamemasterPreRenamePoint\", \"TrackGamemasterPointRenamingAttempts\", function(client, name, newName)\n    local char = client:getChar()\n    if char then\n        local renamingAttempts = char:getData(\"gamemaster_point_renaming_attempts\", 0)\n        char:setData(\"gamemaster_point_renaming_attempts\", renamingAttempts + 1)\n    end\nend)\n\n-- Apply pre-renaming effects\nhook.Add(\"GamemasterPreRenamePoint\", \"PreGamemasterPointRenamingEffects\", function(client, name, newName)\n    -- Play pre-renaming sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Renaming gamemaster point: \" .. name .. \" to \" .. newName .. \"...\")\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemasterpreupdateeffect","title":"GamemasterPreUpdateEffect","text":"<p>Purpose</p> <p>Called before a gamemaster point's effect is updated.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to update the effect.</li> <li><code>name</code> (string): The name of the point.</li> <li><code>newEffect</code> (string): The new effect for the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A gamemaster point's effect is about to be updated - Before <code>GamemasterUpdateEffect</code> hook - Before any validation</p> <p>Example Usage</p> <pre><code>-- Validate gamemaster point effect update\nhook.Add(\"GamemasterPreUpdateEffect\", \"ValidateGamemasterPointEffectUpdate\", function(client, name, newEffect)\n    local char = client:getChar()\n    if char then\n        -- Check if effect updates are disabled\n        if char:getData(\"gamemaster_point_effect_updates_disabled\", false) then\n            client:notify(\"Gamemaster point effect updates are disabled!\")\n            return false\n        end\n\n        -- Check cooldown\n        local lastEffectUpdate = char:getData(\"last_gamemaster_point_effect_update_time\", 0)\n        if os.time() - lastEffectUpdate &lt; 1 then -- 1 second cooldown\n            client:notify(\"Please wait before updating another effect!\")\n            return false\n        end\n\n        -- Update last effect update time\n        char:setData(\"last_gamemaster_point_effect_update_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track gamemaster point effect update attempts\nhook.Add(\"GamemasterPreUpdateEffect\", \"TrackGamemasterPointEffectUpdateAttempts\", function(client, name, newEffect)\n    local char = client:getChar()\n    if char then\n        local effectUpdateAttempts = char:getData(\"gamemaster_point_effect_update_attempts\", 0)\n        char:setData(\"gamemaster_point_effect_update_attempts\", effectUpdateAttempts + 1)\n    end\nend)\n\n-- Apply pre-effect update effects\nhook.Add(\"GamemasterPreUpdateEffect\", \"PreGamemasterPointEffectUpdateEffects\", function(client, name, newEffect)\n    -- Play pre-effect update sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Updating gamemaster point effect: \" .. name .. \"...\")\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemasterpreupdatesound","title":"GamemasterPreUpdateSound","text":"<p>Purpose</p> <p>Called before a gamemaster point's sound is updated.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to update the sound.</li> <li><code>name</code> (string): The name of the point.</li> <li><code>newSound</code> (string): The new sound for the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A gamemaster point's sound is about to be updated - Before <code>GamemasterUpdateSound</code> hook - Before any validation</p> <p>Example Usage</p> <pre><code>-- Validate gamemaster point sound update\nhook.Add(\"GamemasterPreUpdateSound\", \"ValidateGamemasterPointSoundUpdate\", function(client, name, newSound)\n    local char = client:getChar()\n    if char then\n        -- Check if sound updates are disabled\n        if char:getData(\"gamemaster_point_sound_updates_disabled\", false) then\n            client:notify(\"Gamemaster point sound updates are disabled!\")\n            return false\n        end\n\n        -- Check cooldown\n        local lastSoundUpdate = char:getData(\"last_gamemaster_point_sound_update_time\", 0)\n        if os.time() - lastSoundUpdate &lt; 1 then -- 1 second cooldown\n            client:notify(\"Please wait before updating another sound!\")\n            return false\n        end\n\n        -- Update last sound update time\n        char:setData(\"last_gamemaster_point_sound_update_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track gamemaster point sound update attempts\nhook.Add(\"GamemasterPreUpdateSound\", \"TrackGamemasterPointSoundUpdateAttempts\", function(client, name, newSound)\n    local char = client:getChar()\n    if char then\n        local soundUpdateAttempts = char:getData(\"gamemaster_point_sound_update_attempts\", 0)\n        char:setData(\"gamemaster_point_sound_update_attempts\", soundUpdateAttempts + 1)\n    end\nend)\n\n-- Apply pre-sound update effects\nhook.Add(\"GamemasterPreUpdateSound\", \"PreGamemasterPointSoundUpdateEffects\", function(client, name, newSound)\n    -- Play pre-sound update sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Updating gamemaster point sound: \" .. name .. \"...\")\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemasterremovepoint","title":"GamemasterRemovePoint","text":"<p>Purpose</p> <p>Called when a gamemaster point is removed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who removed the point.</li> <li><code>properName</code> (string): The proper name of the point that was removed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A gamemaster point is successfully removed - After <code>GamemasterPreRemovePoint</code> hook - After the point is removed from data</p> <p>Example Usage</p> <pre><code>-- Track gamemaster point removals\nhook.Add(\"GamemasterRemovePoint\", \"TrackGamemasterPointRemovals\", function(client, properName)\n    local char = client:getChar()\n    if char then\n        local pointRemovals = char:getData(\"gamemaster_point_removals\", 0)\n        char:setData(\"gamemaster_point_removals\", pointRemovals + 1)\n    end\n\n    lia.log.add(client, \"gamemasterPointRemoved\", properName)\nend)\n\n-- Apply gamemaster point removal effects\nhook.Add(\"GamemasterRemovePoint\", \"GamemasterPointRemovalEffects\", function(client, properName)\n    -- Play removal sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Gamemaster point removed: \" .. properName .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track gamemaster point removal statistics\nhook.Add(\"GamemasterRemovePoint\", \"TrackGamemasterPointRemovalStats\", function(client, properName)\n    local char = client:getChar()\n    if char then\n        -- Track removal frequency\n        local removalFrequency = char:getData(\"gamemaster_point_removal_frequency\", 0)\n        char:setData(\"gamemaster_point_removal_frequency\", removalFrequency + 1)\n\n        -- Track removal patterns\n        local removalPatterns = char:getData(\"gamemaster_point_removal_patterns\", {})\n        table.insert(removalPatterns, {\n            name = properName,\n            time = os.time()\n        })\n        char:setData(\"gamemaster_point_removal_patterns\", removalPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemasterrenamepoint","title":"GamemasterRenamePoint","text":"<p>Purpose</p> <p>Called when a gamemaster point is renamed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who renamed the point.</li> <li><code>oldName</code> (string): The old name of the point.</li> <li><code>newName</code> (string): The new name of the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A gamemaster point is successfully renamed - After <code>GamemasterPreRenamePoint</code> hook - After the point name is updated in data</p> <p>Example Usage</p> <pre><code>-- Track gamemaster point renames\nhook.Add(\"GamemasterRenamePoint\", \"TrackGamemasterPointRenames\", function(client, oldName, newName)\n    local char = client:getChar()\n    if char then\n        local pointRenames = char:getData(\"gamemaster_point_renames\", 0)\n        char:setData(\"gamemaster_point_renames\", pointRenames + 1)\n    end\n\n    lia.log.add(client, \"gamemasterPointRenamed\", oldName, newName)\nend)\n\n-- Apply gamemaster point rename effects\nhook.Add(\"GamemasterRenamePoint\", \"GamemasterPointRenameEffects\", function(client, oldName, newName)\n    -- Play rename sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Gamemaster point renamed: \" .. oldName .. \" to \" .. newName .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track gamemaster point rename statistics\nhook.Add(\"GamemasterRenamePoint\", \"TrackGamemasterPointRenameStats\", function(client, oldName, newName)\n    local char = client:getChar()\n    if char then\n        -- Track rename frequency\n        local renameFrequency = char:getData(\"gamemaster_point_rename_frequency\", 0)\n        char:setData(\"gamemaster_point_rename_frequency\", renameFrequency + 1)\n\n        -- Track rename patterns\n        local renamePatterns = char:getData(\"gamemaster_point_rename_patterns\", {})\n        table.insert(renamePatterns, {\n            oldName = oldName,\n            newName = newName,\n            time = os.time()\n        })\n        char:setData(\"gamemaster_point_rename_patterns\", renamePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemasterupdateeffect","title":"GamemasterUpdateEffect","text":"<p>Purpose</p> <p>Called when a gamemaster point's effect is updated.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who updated the effect.</li> <li><code>name</code> (string): The name of the point.</li> <li><code>newEffect</code> (string): The new effect for the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A gamemaster point's effect is successfully updated - After <code>GamemasterPreUpdateEffect</code> hook - After the effect is saved to data</p> <p>Example Usage</p> <pre><code>-- Track gamemaster point effect updates\nhook.Add(\"GamemasterUpdateEffect\", \"TrackGamemasterPointEffectUpdates\", function(client, name, newEffect)\n    local char = client:getChar()\n    if char then\n        local effectUpdates = char:getData(\"gamemaster_point_effect_updates\", 0)\n        char:setData(\"gamemaster_point_effect_updates\", effectUpdates + 1)\n    end\n\n    lia.log.add(client, \"gamemasterPointEffectUpdated\", name, newEffect)\nend)\n\n-- Apply gamemaster point effect update effects\nhook.Add(\"GamemasterUpdateEffect\", \"GamemasterPointEffectUpdateEffects\", function(client, name, newEffect)\n    -- Play effect update sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Gamemaster point effect updated: \" .. name .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track gamemaster point effect update statistics\nhook.Add(\"GamemasterUpdateEffect\", \"TrackGamemasterPointEffectUpdateStats\", function(client, name, newEffect)\n    local char = client:getChar()\n    if char then\n        -- Track effect update frequency\n        local effectUpdateFrequency = char:getData(\"gamemaster_point_effect_update_frequency\", 0)\n        char:setData(\"gamemaster_point_effect_update_frequency\", effectUpdateFrequency + 1)\n\n        -- Track effect update patterns\n        local effectUpdatePatterns = char:getData(\"gamemaster_point_effect_update_patterns\", {})\n        table.insert(effectUpdatePatterns, {\n            name = name,\n            effect = newEffect,\n            time = os.time()\n        })\n        char:setData(\"gamemaster_point_effect_update_patterns\", effectUpdatePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/gamemasterpoints/hooks/#gamemasterupdatesound","title":"GamemasterUpdateSound","text":"<p>Purpose</p> <p>Called when a gamemaster point's sound is updated.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who updated the sound.</li> <li><code>name</code> (string): The name of the point.</li> <li><code>newSound</code> (string): The new sound for the point.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A gamemaster point's sound is successfully updated - After <code>GamemasterPreUpdateSound</code> hook - After the sound is saved to data</p> <p>Example Usage</p> <pre><code>-- Track gamemaster point sound updates\nhook.Add(\"GamemasterUpdateSound\", \"TrackGamemasterPointSoundUpdates\", function(client, name, newSound)\n    local char = client:getChar()\n    if char then\n        local soundUpdates = char:getData(\"gamemaster_point_sound_updates\", 0)\n        char:setData(\"gamemaster_point_sound_updates\", soundUpdates + 1)\n    end\n\n    lia.log.add(client, \"gamemasterPointSoundUpdated\", name, newSound)\nend)\n\n-- Apply gamemaster point sound update effects\nhook.Add(\"GamemasterUpdateSound\", \"GamemasterPointSoundUpdateEffects\", function(client, name, newSound)\n    -- Play sound update sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Gamemaster point sound updated: \" .. name .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track gamemaster point sound update statistics\nhook.Add(\"GamemasterUpdateSound\", \"TrackGamemasterPointSoundUpdateStats\", function(client, name, newSound)\n    local char = client:getChar()\n    if char then\n        -- Track sound update frequency\n        local soundUpdateFrequency = char:getData(\"gamemaster_point_sound_update_frequency\", 0)\n        char:setData(\"gamemaster_point_sound_update_frequency\", soundUpdateFrequency + 1)\n\n        -- Track sound update patterns\n        local soundUpdatePatterns = char:getData(\"gamemaster_point_sound_update_patterns\", {})\n        table.insert(soundUpdatePatterns, {\n            name = name,\n            sound = newSound,\n            time = os.time()\n        })\n        char:setData(\"gamemaster_point_sound_update_patterns\", soundUpdatePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/hud_extras/about/","title":"About","text":"About <p>Name: HUD Extras</p> <p>Description:</p> <p>Adds extra HUD elements like an FPS counter, fonts configurable with FPSHudFont, hooks so other modules can extend, performance stats display, and toggles for individual HUD elements.</p> Features <ul> <li>Adds extra HUD elements like an FPS counter</li> <li>Adds fonts configurable with FPSHudFont</li> <li>Adds hooks so other modules can extend</li> <li>Adds performance stats display</li> <li>Adds toggles for individual HUD elements</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/hud_extras/changelog/","title":"Changelog","text":""},{"location":"modules/hud_extras/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated blur effect to use network variables (<code>getNetVar</code>) instead of local variables (<code>getLocalVar</code>) for better synchronization</li> </ul>"},{"location":"modules/hud_extras/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/hud_extras/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/hud_extras/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the HUD Extras module for managing additional HUD elements and effects.</p>"},{"location":"modules/hud_extras/hooks/#adjustbluramount","title":"AdjustBlurAmount","text":"<p>Purpose</p> <p>Called to adjust the blur amount for HUD effects.</p> <p>Parameters</p> <ul> <li><code>blurGoal</code> (number): The current blur goal value.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - HUD blur effects are being calculated - Before the blur is applied to the screen - During the blur rendering process</p> <p>Example Usage</p> <pre><code>-- Adjust blur amount based on player state\nhook.Add(\"AdjustBlurAmount\", \"AdjustBlurBasedOnPlayerState\", function(blurGoal)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Increase blur if player is injured\n        if LocalPlayer():Health() &lt; 50 then\n            return blurGoal + 20\n        end\n\n        -- Increase blur if player is drunk\n        if char:getData(\"drunk\", false) then\n            return blurGoal + 30\n        end\n\n        -- Increase blur if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return blurGoal + 10\n        end\n    end\n\n    return blurGoal\nend)\n\n-- Track blur adjustments\nhook.Add(\"AdjustBlurAmount\", \"TrackBlurAdjustments\", function(blurGoal)\n    local char = LocalPlayer():getChar()\n    if char then\n        local blurAdjustments = char:getData(\"blur_adjustments\", 0)\n        char:setData(\"blur_adjustments\", blurAdjustments + 1)\n    end\nend)\n\n-- Apply blur adjustment effects\nhook.Add(\"AdjustBlurAmount\", \"BlurAdjustmentEffects\", function(blurGoal)\n    -- Play blur adjustment sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.1, 0)\nend)\n</code></pre>"},{"location":"modules/hud_extras/hooks/#hudextraspostdrawblur","title":"HUDExtrasPostDrawBlur","text":"<p>Purpose</p> <p>Called after blur effects are drawn on the HUD.</p> <p>Parameters</p> <ul> <li><code>blurValue</code> (number): The blur value that was applied.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Blur effects have been drawn on the HUD - After <code>HUDExtrasPreDrawBlur</code> hook - When blur rendering is complete</p> <p>Example Usage</p> <pre><code>-- Track blur drawing completion\nhook.Add(\"HUDExtrasPostDrawBlur\", \"TrackBlurDrawingCompletion\", function(blurValue)\n    local char = LocalPlayer():getChar()\n    if char then\n        local blurDrawings = char:getData(\"blur_drawings\", 0)\n        char:setData(\"blur_drawings\", blurDrawings + 1)\n    end\nend)\n\n-- Apply post-blur drawing effects\nhook.Add(\"HUDExtrasPostDrawBlur\", \"PostBlurDrawingEffects\", function(blurValue)\n    -- Play completion sound\n    LocalPlayer():EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Blur effect applied!\")\nend)\n\n-- Track blur drawing statistics\nhook.Add(\"HUDExtrasPostDrawBlur\", \"TrackBlurDrawingStats\", function(blurValue)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track drawing frequency\n        local drawingFrequency = char:getData(\"blur_drawing_frequency\", 0)\n        char:setData(\"blur_drawing_frequency\", drawingFrequency + 1)\n\n        -- Track drawing patterns\n        local drawingPatterns = char:getData(\"blur_drawing_patterns\", {})\n        table.insert(drawingPatterns, {\n            value = blurValue,\n            time = os.time()\n        })\n        char:setData(\"blur_drawing_patterns\", drawingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/hud_extras/hooks/#hudextraspostdrawfps","title":"HUDExtrasPostDrawFPS","text":"<p>Purpose</p> <p>Called after FPS counter is drawn on the HUD.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - FPS counter has been drawn on the HUD - After <code>HUDExtrasPreDrawFPS</code> hook - When FPS rendering is complete</p> <p>Example Usage</p> <pre><code>-- Track FPS drawing completion\nhook.Add(\"HUDExtrasPostDrawFPS\", \"TrackFPSDrawingCompletion\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local fpsDrawings = char:getData(\"fps_drawings\", 0)\n        char:setData(\"fps_drawings\", fpsDrawings + 1)\n    end\nend)\n\n-- Apply post-FPS drawing effects\nhook.Add(\"HUDExtrasPostDrawFPS\", \"PostFPSDrawingEffects\", function()\n    -- Play completion sound\n    LocalPlayer():EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"FPS counter drawn!\")\nend)\n\n-- Track FPS drawing statistics\nhook.Add(\"HUDExtrasPostDrawFPS\", \"TrackFPSDrawingStats\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track drawing frequency\n        local drawingFrequency = char:getData(\"fps_drawing_frequency\", 0)\n        char:setData(\"fps_drawing_frequency\", drawingFrequency + 1)\n\n        -- Track drawing patterns\n        local drawingPatterns = char:getData(\"fps_drawing_patterns\", {})\n        table.insert(drawingPatterns, {\n            time = os.time()\n        })\n        char:setData(\"fps_drawing_patterns\", drawingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/hud_extras/hooks/#hudextraspostdrawvignette","title":"HUDExtrasPostDrawVignette","text":"<p>Purpose</p> <p>Called after vignette effects are drawn on the HUD.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Vignette effects have been drawn on the HUD - After <code>HUDExtrasPreDrawVignette</code> hook - When vignette rendering is complete</p> <p>Example Usage</p> <pre><code>-- Track vignette drawing completion\nhook.Add(\"HUDExtrasPostDrawVignette\", \"TrackVignetteDrawingCompletion\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local vignetteDrawings = char:getData(\"vignette_drawings\", 0)\n        char:setData(\"vignette_drawings\", vignetteDrawings + 1)\n    end\nend)\n\n-- Apply post-vignette drawing effects\nhook.Add(\"HUDExtrasPostDrawVignette\", \"PostVignetteDrawingEffects\", function()\n    -- Play completion sound\n    LocalPlayer():EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Vignette effect drawn!\")\nend)\n\n-- Track vignette drawing statistics\nhook.Add(\"HUDExtrasPostDrawVignette\", \"TrackVignetteDrawingStats\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track drawing frequency\n        local drawingFrequency = char:getData(\"vignette_drawing_frequency\", 0)\n        char:setData(\"vignette_drawing_frequency\", drawingFrequency + 1)\n\n        -- Track drawing patterns\n        local drawingPatterns = char:getData(\"vignette_drawing_patterns\", {})\n        table.insert(drawingPatterns, {\n            time = os.time()\n        })\n        char:setData(\"vignette_drawing_patterns\", drawingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/hud_extras/hooks/#hudextraspostdrawwatermark","title":"HUDExtrasPostDrawWatermark","text":"<p>Purpose</p> <p>Called after watermark is drawn on the HUD.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Watermark has been drawn on the HUD - After <code>HUDExtrasPreDrawWatermark</code> hook - When watermark rendering is complete</p> <p>Example Usage</p> <pre><code>-- Track watermark drawing completion\nhook.Add(\"HUDExtrasPostDrawWatermark\", \"TrackWatermarkDrawingCompletion\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local watermarkDrawings = char:getData(\"watermark_drawings\", 0)\n        char:setData(\"watermark_drawings\", watermarkDrawings + 1)\n    end\nend)\n\n-- Apply post-watermark drawing effects\nhook.Add(\"HUDExtrasPostDrawWatermark\", \"PostWatermarkDrawingEffects\", function()\n    -- Play completion sound\n    LocalPlayer():EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Watermark drawn!\")\nend)\n\n-- Track watermark drawing statistics\nhook.Add(\"HUDExtrasPostDrawWatermark\", \"TrackWatermarkDrawingStats\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track drawing frequency\n        local drawingFrequency = char:getData(\"watermark_drawing_frequency\", 0)\n        char:setData(\"watermark_drawing_frequency\", drawingFrequency + 1)\n\n        -- Track drawing patterns\n        local drawingPatterns = char:getData(\"watermark_drawing_patterns\", {})\n        table.insert(drawingPatterns, {\n            time = os.time()\n        })\n        char:setData(\"watermark_drawing_patterns\", drawingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/hud_extras/hooks/#hudextraspredrawblur","title":"HUDExtrasPreDrawBlur","text":"<p>Purpose</p> <p>Called before blur effects are drawn on the HUD.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Blur effects are about to be drawn on the HUD - Before any blur rendering begins - Before <code>HUDExtrasPostDrawBlur</code> hook</p> <p>Example Usage</p> <pre><code>-- Track blur drawing preparation\nhook.Add(\"HUDExtrasPreDrawBlur\", \"TrackBlurDrawingPreparation\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local blurPreparations = char:getData(\"blur_preparations\", 0)\n        char:setData(\"blur_preparations\", blurPreparations + 1)\n    end\nend)\n\n-- Apply pre-blur drawing effects\nhook.Add(\"HUDExtrasPreDrawBlur\", \"PreBlurDrawingEffects\", function()\n    -- Play preparation sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Preparing blur effect...\")\nend)\n\n-- Track blur drawing preparation statistics\nhook.Add(\"HUDExtrasPreDrawBlur\", \"TrackBlurDrawingPreparationStats\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track preparation frequency\n        local preparationFrequency = char:getData(\"blur_preparation_frequency\", 0)\n        char:setData(\"blur_preparation_frequency\", preparationFrequency + 1)\n\n        -- Track preparation patterns\n        local preparationPatterns = char:getData(\"blur_preparation_patterns\", {})\n        table.insert(preparationPatterns, {\n            time = os.time()\n        })\n        char:setData(\"blur_preparation_patterns\", preparationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/hud_extras/hooks/#hudextraspredrawfps","title":"HUDExtrasPreDrawFPS","text":"<p>Purpose</p> <p>Called before FPS counter is drawn on the HUD.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - FPS counter is about to be drawn on the HUD - Before any FPS rendering begins - Before <code>HUDExtrasPostDrawFPS</code> hook</p> <p>Example Usage</p> <pre><code>-- Track FPS drawing preparation\nhook.Add(\"HUDExtrasPreDrawFPS\", \"TrackFPSDrawingPreparation\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local fpsPreparations = char:getData(\"fps_preparations\", 0)\n        char:setData(\"fps_preparations\", fpsPreparations + 1)\n    end\nend)\n\n-- Apply pre-FPS drawing effects\nhook.Add(\"HUDExtrasPreDrawFPS\", \"PreFPSDrawingEffects\", function()\n    -- Play preparation sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Preparing FPS counter...\")\nend)\n\n-- Track FPS drawing preparation statistics\nhook.Add(\"HUDExtrasPreDrawFPS\", \"TrackFPSDrawingPreparationStats\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track preparation frequency\n        local preparationFrequency = char:getData(\"fps_preparation_frequency\", 0)\n        char:setData(\"fps_preparation_frequency\", preparationFrequency + 1)\n\n        -- Track preparation patterns\n        local preparationPatterns = char:getData(\"fps_preparation_patterns\", {})\n        table.insert(preparationPatterns, {\n            time = os.time()\n        })\n        char:setData(\"fps_preparation_patterns\", preparationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/hud_extras/hooks/#hudextraspredrawvignette","title":"HUDExtrasPreDrawVignette","text":"<p>Purpose</p> <p>Called before vignette effects are drawn on the HUD.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Vignette effects are about to be drawn on the HUD - Before any vignette rendering begins - Before <code>HUDExtrasPostDrawVignette</code> hook</p> <p>Example Usage</p> <pre><code>-- Track vignette drawing preparation\nhook.Add(\"HUDExtrasPreDrawVignette\", \"TrackVignetteDrawingPreparation\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local vignettePreparations = char:getData(\"vignette_preparations\", 0)\n        char:setData(\"vignette_preparations\", vignettePreparations + 1)\n    end\nend)\n\n-- Apply pre-vignette drawing effects\nhook.Add(\"HUDExtrasPreDrawVignette\", \"PreVignetteDrawingEffects\", function()\n    -- Play preparation sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Preparing vignette effect...\")\nend)\n\n-- Track vignette drawing preparation statistics\nhook.Add(\"HUDExtrasPreDrawVignette\", \"TrackVignetteDrawingPreparationStats\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track preparation frequency\n        local preparationFrequency = char:getData(\"vignette_preparation_frequency\", 0)\n        char:setData(\"vignette_preparation_frequency\", preparationFrequency + 1)\n\n        -- Track preparation patterns\n        local preparationPatterns = char:getData(\"vignette_preparation_patterns\", {})\n        table.insert(preparationPatterns, {\n            time = os.time()\n        })\n        char:setData(\"vignette_preparation_patterns\", preparationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/hud_extras/hooks/#hudextraspredrawwatermark","title":"HUDExtrasPreDrawWatermark","text":"<p>Purpose</p> <p>Called before watermark is drawn on the HUD.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Watermark is about to be drawn on the HUD - Before any watermark rendering begins - Before <code>HUDExtrasPostDrawWatermark</code> hook</p> <p>Example Usage</p> <pre><code>-- Track watermark drawing preparation\nhook.Add(\"HUDExtrasPreDrawWatermark\", \"TrackWatermarkDrawingPreparation\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local watermarkPreparations = char:getData(\"watermark_preparations\", 0)\n        char:setData(\"watermark_preparations\", watermarkPreparations + 1)\n    end\nend)\n\n-- Apply pre-watermark drawing effects\nhook.Add(\"HUDExtrasPreDrawWatermark\", \"PreWatermarkDrawingEffects\", function()\n    -- Play preparation sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Preparing watermark...\")\nend)\n\n-- Track watermark drawing preparation statistics\nhook.Add(\"HUDExtrasPreDrawWatermark\", \"TrackWatermarkDrawingPreparationStats\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track preparation frequency\n        local preparationFrequency = char:getData(\"watermark_preparation_frequency\", 0)\n        char:setData(\"watermark_preparation_frequency\", preparationFrequency + 1)\n\n        -- Track preparation patterns\n        local preparationPatterns = char:getData(\"watermark_preparation_patterns\", {})\n        table.insert(preparationPatterns, {\n            time = os.time()\n        })\n        char:setData(\"watermark_preparation_patterns\", preparationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/hud_extras/hooks/#shoulddrawblur","title":"ShouldDrawBlur","text":"<p>Purpose</p> <p>Called to determine if blur effects should be drawn.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - HUD blur effects are being checked - Before any blur rendering - During the blur drawing process</p> <p>Example Usage</p> <pre><code>-- Control blur drawing\nhook.Add(\"ShouldDrawBlur\", \"ControlBlurDrawing\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if blur is disabled\n        if char:getData(\"blur_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if LocalPlayer():InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if LocalPlayer():WaterLevel() &gt;= 2 then\n            return false\n        end\n    end\n\n    return true\nend)\n\n-- Track blur drawing checks\nhook.Add(\"ShouldDrawBlur\", \"TrackBlurDrawingChecks\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local blurChecks = char:getData(\"blur_checks\", 0)\n        char:setData(\"blur_checks\", blurChecks + 1)\n    end\nend)\n\n-- Apply blur drawing check effects\nhook.Add(\"ShouldDrawBlur\", \"BlurDrawingCheckEffects\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if blur is disabled\n        if char:getData(\"blur_disabled\", false) then\n            LocalPlayer():notify(\"Blur is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/hud_extras/hooks/#shoulddrawwatermark","title":"ShouldDrawWatermark","text":"<p>Purpose</p> <p>Called to determine if watermark should be drawn.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - HUD watermark is being checked - Before any watermark rendering - During the watermark drawing process</p> <p>Example Usage</p> <pre><code>-- Control watermark drawing\nhook.Add(\"ShouldDrawWatermark\", \"ControlWatermarkDrawing\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if watermark is disabled\n        if char:getData(\"watermark_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if LocalPlayer():InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if LocalPlayer():WaterLevel() &gt;= 2 then\n            return false\n        end\n    end\n\n    return true\nend)\n\n-- Track watermark drawing checks\nhook.Add(\"ShouldDrawWatermark\", \"TrackWatermarkDrawingChecks\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        local watermarkChecks = char:getData(\"watermark_checks\", 0)\n        char:setData(\"watermark_checks\", watermarkChecks + 1)\n    end\nend)\n\n-- Apply watermark drawing check effects\nhook.Add(\"ShouldDrawWatermark\", \"WatermarkDrawingCheckEffects\", function()\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if watermark is disabled\n        if char:getData(\"watermark_disabled\", false) then\n            LocalPlayer():notify(\"Watermark is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/instakill/about/","title":"About","text":"About <p>Name: Instakill</p> <p>Description:</p> <p>Adds instant kill on headshots, lethality configurable per weapon, extra tension to combat, and integration with damage numbers.</p> Features <ul> <li>Adds instant kill on headshots</li> <li>Adds lethality configurable per weapon</li> <li>Adds extra tension to combat</li> <li>Adds integration with damage numbers</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/instakill/changelog/","title":"Changelog","text":""},{"location":"modules/instakill/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/instakill/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/instakill/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Instakill module for managing instant kill functionality.</p>"},{"location":"modules/instakill/hooks/#playerinstantkilled","title":"PlayerInstantKilled","text":"<p>Purpose</p> <p>Called when a player is instant killed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who was instant killed.</li> <li><code>dmgInfo</code> (CTakeDamageInfo): The damage information that caused the instant kill.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player is instant killed by a headshot - After <code>PlayerPreInstantKill</code> hook - After the damage is applied</p> <p>Example Usage</p> <pre><code>-- Track instant kills\nhook.Add(\"PlayerInstantKilled\", \"TrackInstantKills\", function(client, dmgInfo)\n    local char = client:getChar()\n    if char then\n        local instantKills = char:getData(\"instant_kills\", 0)\n        char:setData(\"instant_kills\", instantKills + 1)\n\n        -- Track instant kill patterns\n        local instantKillPatterns = char:getData(\"instant_kill_patterns\", {})\n        table.insert(instantKillPatterns, {\n            attacker = dmgInfo:GetAttacker(),\n            weapon = dmgInfo:GetInflictor(),\n            time = os.time()\n        })\n        char:setData(\"instant_kill_patterns\", instantKillPatterns)\n    end\n\n    lia.log.add(client, \"instantKilled\", dmgInfo:GetAttacker())\nend)\n\n-- Apply instant kill effects\nhook.Add(\"PlayerInstantKilled\", \"InstantKillEffects\", function(client, dmgInfo)\n    -- Play instant kill sound\n    client:EmitSound(\"vo/npc/male01/pain08.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 25), 1, 0)\n\n    -- Notify player\n    client:notify(\"You were instant killed!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track instant kill statistics\nhook.Add(\"PlayerInstantKilled\", \"TrackInstantKillStats\", function(client, dmgInfo)\n    local char = client:getChar()\n    if char then\n        -- Track instant kill frequency\n        local instantKillFrequency = char:getData(\"instant_kill_frequency\", 0)\n        char:setData(\"instant_kill_frequency\", instantKillFrequency + 1)\n\n        -- Track instant kill patterns\n        local instantKillPatterns = char:getData(\"instant_kill_patterns\", {})\n        table.insert(instantKillPatterns, {\n            attacker = dmgInfo:GetAttacker(),\n            weapon = dmgInfo:GetInflictor(),\n            time = os.time()\n        })\n        char:setData(\"instant_kill_patterns\", instantKillPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/instakill/hooks/#playerpreinstantkill","title":"PlayerPreInstantKill","text":"<p>Purpose</p> <p>Called before a player is instant killed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is about to be instant killed.</li> <li><code>dmgInfo</code> (CTakeDamageInfo): The damage information that will cause the instant kill.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player is about to be instant killed by a headshot - Before <code>PlayerInstantKilled</code> hook - Before the damage is applied</p> <p>Example Usage</p> <pre><code>-- Track instant kill attempts\nhook.Add(\"PlayerPreInstantKill\", \"TrackInstantKillAttempts\", function(client, dmgInfo)\n    local char = client:getChar()\n    if char then\n        local instantKillAttempts = char:getData(\"instant_kill_attempts\", 0)\n        char:setData(\"instant_kill_attempts\", instantKillAttempts + 1)\n    end\nend)\n\n-- Apply pre-instant kill effects\nhook.Add(\"PlayerPreInstantKill\", \"PreInstantKillEffects\", function(client, dmgInfo)\n    -- Play pre-instant kill sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"You are about to be instant killed!\")\nend)\n\n-- Track pre-instant kill statistics\nhook.Add(\"PlayerPreInstantKill\", \"TrackPreInstantKillStats\", function(client, dmgInfo)\n    local char = client:getChar()\n    if char then\n        -- Track pre-instant kill frequency\n        local preInstantKillFrequency = char:getData(\"pre_instant_kill_frequency\", 0)\n        char:setData(\"pre_instant_kill_frequency\", preInstantKillFrequency + 1)\n\n        -- Track pre-instant kill patterns\n        local preInstantKillPatterns = char:getData(\"pre_instant_kill_patterns\", {})\n        table.insert(preInstantKillPatterns, {\n            attacker = dmgInfo:GetAttacker(),\n            weapon = dmgInfo:GetInflictor(),\n            time = os.time()\n        })\n        char:setData(\"pre_instant_kill_patterns\", preInstantKillPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/instakill/hooks/#shouldinstantkill","title":"ShouldInstantKill","text":"<p>Purpose</p> <p>Called to determine if a player should be instant killed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who might be instant killed.</li> <li><code>dmgInfo</code> (CTakeDamageInfo): The damage information that might cause the instant kill.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player takes headshot damage - Before <code>PlayerPreInstantKill</code> hook - Before any instant kill validation</p> <p>Example Usage</p> <pre><code>-- Control instant kill usage\nhook.Add(\"ShouldInstantKill\", \"ControlInstantKillUsage\", function(client, dmgInfo)\n    local char = client:getChar()\n    if char then\n        -- Check if instant kill is disabled\n        if char:getData(\"instant_kill_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if client:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if client:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check if player is handcuffed\n        if client:IsHandcuffed() then\n            return false\n        end\n\n        -- Check cooldown\n        local lastInstantKill = char:getData(\"last_instant_kill_time\", 0)\n        if os.time() - lastInstantKill &lt; 5 then -- 5 second cooldown\n            return false\n        end\n\n        -- Update last instant kill time\n        char:setData(\"last_instant_kill_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track instant kill usage checks\nhook.Add(\"ShouldInstantKill\", \"TrackInstantKillUsageChecks\", function(client, dmgInfo)\n    local char = client:getChar()\n    if char then\n        local usageChecks = char:getData(\"instant_kill_usage_checks\", 0)\n        char:setData(\"instant_kill_usage_checks\", usageChecks + 1)\n    end\nend)\n\n-- Apply instant kill usage check effects\nhook.Add(\"ShouldInstantKill\", \"InstantKillUsageCheckEffects\", function(client, dmgInfo)\n    local char = client:getChar()\n    if char then\n        -- Check if instant kill is disabled\n        if char:getData(\"instant_kill_disabled\", false) then\n            client:notify(\"Instant kill is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/joinleavemessages/about/","title":"About","text":"About <p>Name: Join Leave Messages</p> <p>Description:</p> <p>Adds announcements when players join, notifications on disconnect, improved community awareness, relay of messages to Discord, and per-player toggle to hide messages.</p> Features <ul> <li>Adds announcements when players join</li> <li>Adds notifications on disconnect</li> <li>Adds improved community awareness</li> <li>Adds relay of messages to Discord</li> <li>Adds per-player toggle to hide messages</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/joinleavemessages/changelog/","title":"Changelog","text":""},{"location":"modules/joinleavemessages/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/joinleavemessages/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/joinleavemessages/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Join Leave Messages module for managing player join and leave announcements.</p>"},{"location":"modules/joinleavemessages/hooks/#joinleavemessagesent","title":"JoinLeaveMessageSent","text":"<p>Purpose</p> <p>Called when a join or leave message is sent to players.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who joined or left.</li> <li><code>isJoin</code> (boolean): Whether this is a join message (true) or leave message (false).</li> <li><code>message</code> (string): The message that was sent.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A join or leave message is sent to all players - After <code>PreJoinLeaveMessageSent</code> hook - After the message is displayed</p> <p>Example Usage</p> <pre><code>-- Track join/leave messages\nhook.Add(\"JoinLeaveMessageSent\", \"TrackJoinLeaveMessages\", function(client, isJoin, message)\n    local char = client:getChar()\n    if char then\n        local messageType = isJoin and \"join\" or \"leave\"\n        local messageCount = char:getData(\"join_leave_messages_\" .. messageType, 0)\n        char:setData(\"join_leave_messages_\" .. messageType, messageCount + 1)\n    end\n\n    lia.log.add(client, \"joinLeaveMessageSent\", isJoin, message)\nend)\n\n-- Apply join/leave message effects\nhook.Add(\"JoinLeaveMessageSent\", \"JoinLeaveMessageEffects\", function(client, isJoin, message)\n    -- Play message sound\n    client:EmitSound(isJoin and \"buttons/button14.wav\" or \"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, isJoin and Color(0, 255, 0, 15) or Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    local status = isJoin and \"joined\" or \"left\"\n    client:notify(\"Player \" .. status .. \" message sent!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track join/leave message statistics\nhook.Add(\"JoinLeaveMessageSent\", \"TrackJoinLeaveMessageStats\", function(client, isJoin, message)\n    local char = client:getChar()\n    if char then\n        -- Track message frequency\n        local messageFrequency = char:getData(\"join_leave_message_frequency\", 0)\n        char:setData(\"join_leave_message_frequency\", messageFrequency + 1)\n\n        -- Track message patterns\n        local messagePatterns = char:getData(\"join_leave_message_patterns\", {})\n        table.insert(messagePatterns, {\n            isJoin = isJoin,\n            message = message,\n            time = os.time()\n        })\n        char:setData(\"join_leave_message_patterns\", messagePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/joinleavemessages/hooks/#prejoinleavemessagesent","title":"PreJoinLeaveMessageSent","text":"<p>Purpose</p> <p>Called before a join or leave message is sent to players.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who joined or left.</li> <li><code>isJoin</code> (boolean): Whether this is a join message (true) or leave message (false).</li> <li><code>message</code> (string): The message that will be sent.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A join or leave message is about to be sent - Before <code>JoinLeaveMessageSent</code> hook - Before any message validation</p> <p>Example Usage</p> <pre><code>-- Validate join/leave messages\nhook.Add(\"PreJoinLeaveMessageSent\", \"ValidateJoinLeaveMessages\", function(client, isJoin, message)\n    local char = client:getChar()\n    if char then\n        -- Check if messages are disabled\n        if char:getData(\"join_leave_messages_disabled\", false) then\n            client:notify(\"Join/leave messages are disabled!\")\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            client:notify(\"Cannot send join/leave messages in this area!\")\n            return false\n        end\n\n        -- Check cooldown\n        local lastMessage = char:getData(\"last_join_leave_message_time\", 0)\n        if os.time() - lastMessage &lt; 1 then -- 1 second cooldown\n            client:notify(\"Please wait before sending another message!\")\n            return false\n        end\n\n        -- Update last message time\n        char:setData(\"last_join_leave_message_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track join/leave message attempts\nhook.Add(\"PreJoinLeaveMessageSent\", \"TrackJoinLeaveMessageAttempts\", function(client, isJoin, message)\n    local char = client:getChar()\n    if char then\n        local messageAttempts = char:getData(\"join_leave_message_attempts\", 0)\n        char:setData(\"join_leave_message_attempts\", messageAttempts + 1)\n    end\nend)\n\n-- Apply pre-message effects\nhook.Add(\"PreJoinLeaveMessageSent\", \"PreJoinLeaveMessageEffects\", function(client, isJoin, message)\n    -- Play pre-message sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    local status = isJoin and \"join\" or \"leave\"\n    client:notify(\"Sending \" .. status .. \" message...\")\nend)\n</code></pre>"},{"location":"modules/loadmessages/about/","title":"About","text":"About <p>Name: Load Messages</p> <p>Description:</p> <p>Adds faction-based load messages, execution when players first load a character, customizable message text, color-coded formatting options, and per-faction enable toggles.</p> Features <ul> <li>Adds faction-based load messages</li> <li>Adds execution when players first load a character</li> <li>Adds customizable message text</li> <li>Adds color-coded formatting options</li> <li>Adds per-faction enable toggles</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/loadmessages/changelog/","title":"Changelog","text":""},{"location":"modules/loadmessages/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/loadmessages/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/loadmessages/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Load Messages module for managing faction-based load messages.</p>"},{"location":"modules/loadmessages/hooks/#loadmessagemissing","title":"LoadMessageMissing","text":"<p>Purpose</p> <p>Called when a load message is missing for a player's faction.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who loaded a character but has no faction message.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player loads a character - No faction message is found for their team - After <code>PreLoadMessage</code> hook would have been called</p> <p>Example Usage</p> <pre><code>-- Track missing load messages\nhook.Add(\"LoadMessageMissing\", \"TrackMissingLoadMessages\", function(client)\n    local char = client:getChar()\n    if char then\n        local missingMessages = char:getData(\"missing_load_messages\", 0)\n        char:setData(\"missing_load_messages\", missingMessages + 1)\n    end\n\n    lia.log.add(client, \"loadMessageMissing\")\nend)\n\n-- Apply missing load message effects\nhook.Add(\"LoadMessageMissing\", \"MissingLoadMessageEffects\", function(client)\n    -- Play missing message sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"No load message found for your faction!\")\nend)\n\n-- Track missing load message statistics\nhook.Add(\"LoadMessageMissing\", \"TrackMissingLoadMessageStats\", function(client)\n    local char = client:getChar()\n    if char then\n        -- Track missing frequency\n        local missingFrequency = char:getData(\"load_message_missing_frequency\", 0)\n        char:setData(\"load_message_missing_frequency\", missingFrequency + 1)\n\n        -- Track missing patterns\n        local missingPatterns = char:getData(\"load_message_missing_patterns\", {})\n        table.insert(missingPatterns, {\n            faction = client:Team(),\n            time = os.time()\n        })\n        char:setData(\"load_message_missing_patterns\", missingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/loadmessages/hooks/#loadmessagesent","title":"LoadMessageSent","text":"<p>Purpose</p> <p>Called when a load message is sent to a player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who received the load message.</li> <li><code>data</code> (table): The load message data containing the message content.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A load message is sent to a player - After <code>PreLoadMessage</code> hook - Before <code>PostLoadMessage</code> hook</p> <p>Example Usage</p> <pre><code>-- Track load message sends\nhook.Add(\"LoadMessageSent\", \"TrackLoadMessageSends\", function(client, data)\n    local char = client:getChar()\n    if char then\n        local messageSends = char:getData(\"load_message_sends\", 0)\n        char:setData(\"load_message_sends\", messageSends + 1)\n    end\n\n    lia.log.add(client, \"loadMessageSent\", data)\nend)\n\n-- Apply load message send effects\nhook.Add(\"LoadMessageSent\", \"LoadMessageSendEffects\", function(client, data)\n    -- Play send sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Load message sent!\")\nend)\n\n-- Track load message send statistics\nhook.Add(\"LoadMessageSent\", \"TrackLoadMessageSendStats\", function(client, data)\n    local char = client:getChar()\n    if char then\n        -- Track send frequency\n        local sendFrequency = char:getData(\"load_message_send_frequency\", 0)\n        char:setData(\"load_message_send_frequency\", sendFrequency + 1)\n\n        -- Track send patterns\n        local sendPatterns = char:getData(\"load_message_send_patterns\", {})\n        table.insert(sendPatterns, {\n            data = data,\n            time = os.time()\n        })\n        char:setData(\"load_message_send_patterns\", sendPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/loadmessages/hooks/#postloadmessage","title":"PostLoadMessage","text":"<p>Purpose</p> <p>Called after a load message is processed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who received the load message.</li> <li><code>data</code> (table): The load message data containing the message content.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A load message is fully processed - After <code>LoadMessageSent</code> hook - When the message display is complete</p> <p>Example Usage</p> <pre><code>-- Track load message completion\nhook.Add(\"PostLoadMessage\", \"TrackLoadMessageCompletion\", function(client, data)\n    local char = client:getChar()\n    if char then\n        local messageCompletions = char:getData(\"load_message_completions\", 0)\n        char:setData(\"load_message_completions\", messageCompletions + 1)\n    end\n\n    lia.log.add(client, \"loadMessageCompleted\", data)\nend)\n\n-- Apply post load message effects\nhook.Add(\"PostLoadMessage\", \"PostLoadMessageEffects\", function(client, data)\n    -- Play completion sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Load message processing complete!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track post load message statistics\nhook.Add(\"PostLoadMessage\", \"TrackPostLoadMessageStats\", function(client, data)\n    local char = client:getChar()\n    if char then\n        -- Track completion frequency\n        local completionFrequency = char:getData(\"load_message_completion_frequency\", 0)\n        char:setData(\"load_message_completion_frequency\", completionFrequency + 1)\n\n        -- Track completion patterns\n        local completionPatterns = char:getData(\"load_message_completion_patterns\", {})\n        table.insert(completionPatterns, {\n            data = data,\n            time = os.time()\n        })\n        char:setData(\"load_message_completion_patterns\", completionPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/loadmessages/hooks/#preloadmessage","title":"PreLoadMessage","text":"<p>Purpose</p> <p>Called before a load message is processed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who will receive the load message.</li> <li><code>data</code> (table): The load message data containing the message content.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A load message is about to be processed - Before <code>LoadMessageSent</code> hook - When the message data is ready</p> <p>Example Usage</p> <pre><code>-- Track load message preparation\nhook.Add(\"PreLoadMessage\", \"TrackLoadMessagePreparation\", function(client, data)\n    local char = client:getChar()\n    if char then\n        local messagePreparations = char:getData(\"load_message_preparations\", 0)\n        char:setData(\"load_message_preparations\", messagePreparations + 1)\n    end\n\n    lia.log.add(client, \"loadMessagePrepared\", data)\nend)\n\n-- Apply pre load message effects\nhook.Add(\"PreLoadMessage\", \"PreLoadMessageEffects\", function(client, data)\n    -- Play preparation sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Preparing load message...\")\nend)\n\n-- Track pre load message statistics\nhook.Add(\"PreLoadMessage\", \"TrackPreLoadMessageStats\", function(client, data)\n    local char = client:getChar()\n    if char then\n        -- Track preparation frequency\n        local preparationFrequency = char:getData(\"load_message_preparation_frequency\", 0)\n        char:setData(\"load_message_preparation_frequency\", preparationFrequency + 1)\n\n        -- Track preparation patterns\n        local preparationPatterns = char:getData(\"load_message_preparation_patterns\", {})\n        table.insert(preparationPatterns, {\n            data = data,\n            time = os.time()\n        })\n        char:setData(\"load_message_preparation_patterns\", preparationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/loyalism/about/","title":"About","text":"About <p>Name: Loyalism</p> <p>Description:</p> <p>Adds a loyalty tier system for players, the /partytier command access, permission control through flags, automatic tier progression, and customizable rewards per tier.</p> Features <ul> <li>Adds a loyalty tier system for players</li> <li>Adds the /partytier command access</li> <li>Adds permission control through flags</li> <li>Adds automatic tier progression</li> <li>Adds customizable rewards per tier</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/loyalism/changelog/","title":"Changelog","text":""},{"location":"modules/loyalism/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/loyalism/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/loyalism/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Loyalism module for managing loyalty tier system functionality.</p>"},{"location":"modules/loyalism/hooks/#partytierapplying","title":"PartyTierApplying","text":"<p>Purpose</p> <p>Called when a party tier is being applied to a player.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose tier is being applied.</li> <li><code>tier</code> (number): The tier number being applied.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A party tier is being applied to a player - After <code>PreUpdatePartyTiers</code> hook - Before <code>PartyTierUpdated</code> hook</p> <p>Example Usage</p> <pre><code>-- Track party tier applications\nhook.Add(\"PartyTierApplying\", \"TrackPartyTierApplications\", function(player, tier)\n    local char = player:getChar()\n    if char then\n        local tierApplications = char:getData(\"party_tier_applications\", 0)\n        char:setData(\"party_tier_applications\", tierApplications + 1)\n    end\n\n    lia.log.add(player, \"partyTierApplying\", tier)\nend)\n\n-- Apply party tier application effects\nhook.Add(\"PartyTierApplying\", \"PartyTierApplicationEffects\", function(player, tier)\n    -- Play application sound\n    player:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    player:notify(\"Applying party tier: \" .. tier .. \"!\")\nend)\n\n-- Track party tier application statistics\nhook.Add(\"PartyTierApplying\", \"TrackPartyTierApplicationStats\", function(player, tier)\n    local char = player:getChar()\n    if char then\n        -- Track application frequency\n        local applicationFrequency = char:getData(\"party_tier_application_frequency\", 0)\n        char:setData(\"party_tier_application_frequency\", applicationFrequency + 1)\n\n        -- Track application patterns\n        local applicationPatterns = char:getData(\"party_tier_application_patterns\", {})\n        table.insert(applicationPatterns, {\n            tier = tier,\n            time = os.time()\n        })\n        char:setData(\"party_tier_application_patterns\", applicationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/loyalism/hooks/#partytiernocharacter","title":"PartyTierNoCharacter","text":"<p>Purpose</p> <p>Called when a player has no character during party tier update.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who has no character.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player has no character during party tier update - After <code>PreUpdatePartyTiers</code> hook - When the character check fails</p> <p>Example Usage</p> <pre><code>-- Track party tier no character cases\nhook.Add(\"PartyTierNoCharacter\", \"TrackPartyTierNoCharacter\", function(player)\n    local noCharacterCases = player:getData(\"party_tier_no_character_cases\", 0)\n    player:setData(\"party_tier_no_character_cases\", noCharacterCases + 1)\n\n    lia.log.add(player, \"partyTierNoCharacter\")\nend)\n\n-- Apply party tier no character effects\nhook.Add(\"PartyTierNoCharacter\", \"PartyTierNoCharacterEffects\", function(player)\n    -- Play no character sound\n    player:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 10), 0.3, 0)\n\n    -- Notify player\n    player:notify(\"No character found for party tier update!\")\nend)\n\n-- Track party tier no character statistics\nhook.Add(\"PartyTierNoCharacter\", \"TrackPartyTierNoCharacterStats\", function(player)\n    -- Track no character frequency\n    local noCharacterFrequency = player:getData(\"party_tier_no_character_frequency\", 0)\n    player:setData(\"party_tier_no_character_frequency\", noCharacterFrequency + 1)\n\n    -- Track no character patterns\n    local noCharacterPatterns = player:getData(\"party_tier_no_character_patterns\", {})\n    table.insert(noCharacterPatterns, {\n        time = os.time()\n    })\n    player:setData(\"party_tier_no_character_patterns\", noCharacterPatterns)\nend)\n</code></pre>"},{"location":"modules/loyalism/hooks/#partytierupdated","title":"PartyTierUpdated","text":"<p>Purpose</p> <p>Called when a party tier is updated for a player.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose tier was updated.</li> <li><code>tier</code> (number): The tier number that was set.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A party tier is updated for a player - After <code>PartyTierApplying</code> hook - When the tier is successfully set</p> <p>Example Usage</p> <pre><code>-- Track party tier updates\nhook.Add(\"PartyTierUpdated\", \"TrackPartyTierUpdates\", function(player, tier)\n    local char = player:getChar()\n    if char then\n        local tierUpdates = char:getData(\"party_tier_updates\", 0)\n        char:setData(\"party_tier_updates\", tierUpdates + 1)\n    end\n\n    lia.log.add(player, \"partyTierUpdated\", tier)\nend)\n\n-- Apply party tier update effects\nhook.Add(\"PartyTierUpdated\", \"PartyTierUpdateEffects\", function(player, tier)\n    -- Play update sound\n    player:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"Party tier updated to: \" .. tier .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track party tier update statistics\nhook.Add(\"PartyTierUpdated\", \"TrackPartyTierUpdateStats\", function(player, tier)\n    local char = player:getChar()\n    if char then\n        -- Track update frequency\n        local updateFrequency = char:getData(\"party_tier_update_frequency\", 0)\n        char:setData(\"party_tier_update_frequency\", updateFrequency + 1)\n\n        -- Track update patterns\n        local updatePatterns = char:getData(\"party_tier_update_patterns\", {})\n        table.insert(updatePatterns, {\n            tier = tier,\n            time = os.time()\n        })\n        char:setData(\"party_tier_update_patterns\", updatePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/loyalism/hooks/#postupdatepartytiers","title":"PostUpdatePartyTiers","text":"<p>Purpose</p> <p>Called after all party tiers have been updated.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - All party tiers have been updated - After <code>PartyTierUpdated</code> hook for all players - When the update cycle is complete</p> <p>Example Usage</p> <pre><code>-- Track party tier update completion\nhook.Add(\"PostUpdatePartyTiers\", \"TrackPartyTierUpdateCompletion\", function()\n    -- Track completion\n    local completions = lia.data.get(\"party_tier_update_completions\", 0)\n    lia.data.set(\"party_tier_update_completions\", completions + 1)\n\n    lia.log.add(nil, \"partyTierUpdateCompleted\")\nend)\n\n-- Apply post update party tiers effects\nhook.Add(\"PostUpdatePartyTiers\", \"PostUpdatePartyTiersEffects\", function()\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Party tier update cycle completed!\")\n    end\nend)\n\n-- Track post update party tiers statistics\nhook.Add(\"PostUpdatePartyTiers\", \"TrackPostUpdatePartyTiersStats\", function()\n    -- Track completion frequency\n    local completionFrequency = lia.data.get(\"party_tier_update_completion_frequency\", 0)\n    lia.data.set(\"party_tier_update_completion_frequency\", completionFrequency + 1)\n\n    -- Track completion patterns\n    local completionPatterns = lia.data.get(\"party_tier_update_completion_patterns\", {})\n    table.insert(completionPatterns, {\n        time = os.time()\n    })\n    lia.data.set(\"party_tier_update_completion_patterns\", completionPatterns)\nend)\n</code></pre>"},{"location":"modules/loyalism/hooks/#preupdatepartytiers","title":"PreUpdatePartyTiers","text":"<p>Purpose</p> <p>Called before party tiers are updated.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Party tiers are about to be updated - Before <code>PartyTierApplying</code> hook - When the update cycle begins</p> <p>Example Usage</p> <pre><code>-- Track party tier update preparation\nhook.Add(\"PreUpdatePartyTiers\", \"TrackPartyTierUpdatePreparation\", function()\n    -- Track preparation\n    local preparations = lia.data.get(\"party_tier_update_preparations\", 0)\n    lia.data.set(\"party_tier_update_preparations\", preparations + 1)\n\n    lia.log.add(nil, \"partyTierUpdatePrepared\")\nend)\n\n-- Apply pre update party tiers effects\nhook.Add(\"PreUpdatePartyTiers\", \"PreUpdatePartyTiersEffects\", function()\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Preparing party tier update...\")\n    end\nend)\n\n-- Track pre update party tiers statistics\nhook.Add(\"PreUpdatePartyTiers\", \"TrackPreUpdatePartyTiersStats\", function()\n    -- Track preparation frequency\n    local preparationFrequency = lia.data.get(\"party_tier_update_preparation_frequency\", 0)\n    lia.data.set(\"party_tier_update_preparation_frequency\", preparationFrequency + 1)\n\n    -- Track preparation patterns\n    local preparationPatterns = lia.data.get(\"party_tier_update_preparation_patterns\", {})\n    table.insert(preparationPatterns, {\n        time = os.time()\n    })\n    lia.data.set(\"party_tier_update_preparation_patterns\", preparationPatterns)\nend)\n</code></pre>"},{"location":"modules/mapcleaner/about/","title":"About","text":"About <p>Name: Map Cleaner</p> <p>Description:</p> <p>Adds periodic cleaning of map debris, a configurable interval, reduced server lag, a whitelist for protected entities, and manual cleanup commands.</p> Features <ul> <li>Adds periodic cleaning of map debris</li> <li>Adds a configurable interval</li> <li>Adds reduced server lag</li> <li>Adds a whitelist for protected entities</li> <li>Adds manual cleanup commands</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/mapcleaner/changelog/","title":"Changelog","text":""},{"location":"modules/mapcleaner/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/mapcleaner/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/mapcleaner/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Map Cleaner module for managing periodic map cleanup functionality.</p>"},{"location":"modules/mapcleaner/hooks/#itemcleanupentityremoved","title":"ItemCleanupEntityRemoved","text":"<p>Purpose</p> <p>Called when an item entity is removed during cleanup.</p> <p>Parameters</p> <ul> <li><code>item</code> (Entity): The item entity that was removed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An item entity is removed during cleanup - During <code>PreItemCleanup</code> hook execution - When the item is being deleted</p> <p>Example Usage</p> <pre><code>-- Track item cleanup entity removals\nhook.Add(\"ItemCleanupEntityRemoved\", \"TrackItemCleanupEntityRemovals\", function(item)\n    -- Track removal\n    local removals = lia.data.get(\"item_cleanup_entity_removals\", 0)\n    lia.data.set(\"item_cleanup_entity_removals\", removals + 1)\n\n    lia.log.add(nil, \"itemCleanupEntityRemoved\", item)\nend)\n\n-- Apply item cleanup entity removal effects\nhook.Add(\"ItemCleanupEntityRemoved\", \"ItemCleanupEntityRemovalEffects\", function(item)\n    -- Create removal effect\n    local effect = EffectData()\n    effect:SetOrigin(item:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play removal sound\n    item:EmitSound(\"buttons/button16.wav\", 75, 100)\nend)\n\n-- Track item cleanup entity removal statistics\nhook.Add(\"ItemCleanupEntityRemoved\", \"TrackItemCleanupEntityRemovalStats\", function(item)\n    -- Track removal frequency\n    local removalFrequency = lia.data.get(\"item_cleanup_entity_removal_frequency\", 0)\n    lia.data.set(\"item_cleanup_entity_removal_frequency\", removalFrequency + 1)\n\n    -- Track removal patterns\n    local removalPatterns = lia.data.get(\"item_cleanup_entity_removal_patterns\", {})\n    table.insert(removalPatterns, {\n        class = item:GetClass(),\n        time = os.time()\n    })\n    lia.data.set(\"item_cleanup_entity_removal_patterns\", removalPatterns)\nend)\n</code></pre>"},{"location":"modules/mapcleaner/hooks/#mapcleanupentityremoved","title":"MapCleanupEntityRemoved","text":"<p>Purpose</p> <p>Called when a map entity is removed during cleanup.</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The map entity that was removed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A map entity is removed during cleanup - During <code>PreMapCleanup</code> hook execution - When the entity is being deleted</p> <p>Example Usage</p> <pre><code>-- Track map cleanup entity removals\nhook.Add(\"MapCleanupEntityRemoved\", \"TrackMapCleanupEntityRemovals\", function(entity)\n    -- Track removal\n    local removals = lia.data.get(\"map_cleanup_entity_removals\", 0)\n    lia.data.set(\"map_cleanup_entity_removals\", removals + 1)\n\n    lia.log.add(nil, \"mapCleanupEntityRemoved\", entity)\nend)\n\n-- Apply map cleanup entity removal effects\nhook.Add(\"MapCleanupEntityRemoved\", \"MapCleanupEntityRemovalEffects\", function(entity)\n    -- Create removal effect\n    local effect = EffectData()\n    effect:SetOrigin(entity:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play removal sound\n    entity:EmitSound(\"buttons/button16.wav\", 75, 100)\nend)\n\n-- Track map cleanup entity removal statistics\nhook.Add(\"MapCleanupEntityRemoved\", \"TrackMapCleanupEntityRemovalStats\", function(entity)\n    -- Track removal frequency\n    local removalFrequency = lia.data.get(\"map_cleanup_entity_removal_frequency\", 0)\n    lia.data.set(\"map_cleanup_entity_removal_frequency\", removalFrequency + 1)\n\n    -- Track removal patterns\n    local removalPatterns = lia.data.get(\"map_cleanup_entity_removal_patterns\", {})\n    table.insert(removalPatterns, {\n        class = entity:GetClass(),\n        time = os.time()\n    })\n    lia.data.set(\"map_cleanup_entity_removal_patterns\", removalPatterns)\nend)\n</code></pre>"},{"location":"modules/mapcleaner/hooks/#postitemcleanup","title":"PostItemCleanup","text":"<p>Purpose</p> <p>Called after item cleanup is complete.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Item cleanup is complete - After all items have been removed - When the cleanup cycle ends</p> <p>Example Usage</p> <pre><code>-- Track item cleanup completion\nhook.Add(\"PostItemCleanup\", \"TrackItemCleanupCompletion\", function()\n    -- Track completion\n    local completions = lia.data.get(\"item_cleanup_completions\", 0)\n    lia.data.set(\"item_cleanup_completions\", completions + 1)\n\n    lia.log.add(nil, \"itemCleanupCompleted\")\nend)\n\n-- Apply post item cleanup effects\nhook.Add(\"PostItemCleanup\", \"PostItemCleanupEffects\", function()\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Item cleanup completed!\")\n    end\nend)\n\n-- Track post item cleanup statistics\nhook.Add(\"PostItemCleanup\", \"TrackPostItemCleanupStats\", function()\n    -- Track completion frequency\n    local completionFrequency = lia.data.get(\"item_cleanup_completion_frequency\", 0)\n    lia.data.set(\"item_cleanup_completion_frequency\", completionFrequency + 1)\n\n    -- Track completion patterns\n    local completionPatterns = lia.data.get(\"item_cleanup_completion_patterns\", {})\n    table.insert(completionPatterns, {\n        time = os.time()\n    })\n    lia.data.set(\"item_cleanup_completion_patterns\", completionPatterns)\nend)\n</code></pre>"},{"location":"modules/mapcleaner/hooks/#postitemcleanupwarning","title":"PostItemCleanupWarning","text":"<p>Purpose</p> <p>Called after item cleanup warning is sent.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Item cleanup warning is sent to all players - After <code>PreItemCleanupWarning</code> hook - When the warning cycle ends</p> <p>Example Usage</p> <pre><code>-- Track item cleanup warning completion\nhook.Add(\"PostItemCleanupWarning\", \"TrackItemCleanupWarningCompletion\", function()\n    -- Track completion\n    local completions = lia.data.get(\"item_cleanup_warning_completions\", 0)\n    lia.data.set(\"item_cleanup_warning_completions\", completions + 1)\n\n    lia.log.add(nil, \"itemCleanupWarningCompleted\")\nend)\n\n-- Apply post item cleanup warning effects\nhook.Add(\"PostItemCleanupWarning\", \"PostItemCleanupWarningEffects\", function()\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Item cleanup warning sent!\")\n    end\nend)\n\n-- Track post item cleanup warning statistics\nhook.Add(\"PostItemCleanupWarning\", \"TrackPostItemCleanupWarningStats\", function()\n    -- Track completion frequency\n    local completionFrequency = lia.data.get(\"item_cleanup_warning_completion_frequency\", 0)\n    lia.data.set(\"item_cleanup_warning_completion_frequency\", completionFrequency + 1)\n\n    -- Track completion patterns\n    local completionPatterns = lia.data.get(\"item_cleanup_warning_completion_patterns\", {})\n    table.insert(completionPatterns, {\n        time = os.time()\n    })\n    lia.data.set(\"item_cleanup_warning_completion_patterns\", completionPatterns)\nend)\n</code></pre>"},{"location":"modules/mapcleaner/hooks/#postmapcleanup","title":"PostMapCleanup","text":"<p>Purpose</p> <p>Called after map cleanup is complete.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Map cleanup is complete - After all map entities have been removed - When the cleanup cycle ends</p> <p>Example Usage</p> <pre><code>-- Track map cleanup completion\nhook.Add(\"PostMapCleanup\", \"TrackMapCleanupCompletion\", function()\n    -- Track completion\n    local completions = lia.data.get(\"map_cleanup_completions\", 0)\n    lia.data.set(\"map_cleanup_completions\", completions + 1)\n\n    lia.log.add(nil, \"mapCleanupCompleted\")\nend)\n\n-- Apply post map cleanup effects\nhook.Add(\"PostMapCleanup\", \"PostMapCleanupEffects\", function()\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Map cleanup completed!\")\n    end\nend)\n\n-- Track post map cleanup statistics\nhook.Add(\"PostMapCleanup\", \"TrackPostMapCleanupStats\", function()\n    -- Track completion frequency\n    local completionFrequency = lia.data.get(\"map_cleanup_completion_frequency\", 0)\n    lia.data.set(\"map_cleanup_completion_frequency\", completionFrequency + 1)\n\n    -- Track completion patterns\n    local completionPatterns = lia.data.get(\"map_cleanup_completion_patterns\", {})\n    table.insert(completionPatterns, {\n        time = os.time()\n    })\n    lia.data.set(\"map_cleanup_completion_patterns\", completionPatterns)\nend)\n</code></pre>"},{"location":"modules/mapcleaner/hooks/#postmapcleanupwarning","title":"PostMapCleanupWarning","text":"<p>Purpose</p> <p>Called after map cleanup warning is sent.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Map cleanup warning is sent to all players - After <code>PreMapCleanupWarning</code> hook - When the warning cycle ends</p> <p>Example Usage</p> <pre><code>-- Track map cleanup warning completion\nhook.Add(\"PostMapCleanupWarning\", \"TrackMapCleanupWarningCompletion\", function()\n    -- Track completion\n    local completions = lia.data.get(\"map_cleanup_warning_completions\", 0)\n    lia.data.set(\"map_cleanup_warning_completions\", completions + 1)\n\n    lia.log.add(nil, \"mapCleanupWarningCompleted\")\nend)\n\n-- Apply post map cleanup warning effects\nhook.Add(\"PostMapCleanupWarning\", \"PostMapCleanupWarningEffects\", function()\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Map cleanup warning sent!\")\n    end\nend)\n\n-- Track post map cleanup warning statistics\nhook.Add(\"PostMapCleanupWarning\", \"TrackPostMapCleanupWarningStats\", function()\n    -- Track completion frequency\n    local completionFrequency = lia.data.get(\"map_cleanup_warning_completion_frequency\", 0)\n    lia.data.set(\"map_cleanup_warning_completion_frequency\", completionFrequency + 1)\n\n    -- Track completion patterns\n    local completionPatterns = lia.data.get(\"map_cleanup_warning_completion_patterns\", {})\n    table.insert(completionPatterns, {\n        time = os.time()\n    })\n    lia.data.set(\"map_cleanup_warning_completion_patterns\", completionPatterns)\nend)\n</code></pre>"},{"location":"modules/mapcleaner/hooks/#preitemcleanup","title":"PreItemCleanup","text":"<p>Purpose</p> <p>Called before item cleanup begins.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Item cleanup is about to begin - Before items are removed - When the cleanup cycle starts</p> <p>Example Usage</p> <pre><code>-- Track item cleanup preparation\nhook.Add(\"PreItemCleanup\", \"TrackItemCleanupPreparation\", function()\n    -- Track preparation\n    local preparations = lia.data.get(\"item_cleanup_preparations\", 0)\n    lia.data.set(\"item_cleanup_preparations\", preparations + 1)\n\n    lia.log.add(nil, \"itemCleanupPrepared\")\nend)\n\n-- Apply pre item cleanup effects\nhook.Add(\"PreItemCleanup\", \"PreItemCleanupEffects\", function()\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Preparing item cleanup...\")\n    end\nend)\n\n-- Track pre item cleanup statistics\nhook.Add(\"PreItemCleanup\", \"TrackPreItemCleanupStats\", function()\n    -- Track preparation frequency\n    local preparationFrequency = lia.data.get(\"item_cleanup_preparation_frequency\", 0)\n    lia.data.set(\"item_cleanup_preparation_frequency\", preparationFrequency + 1)\n\n    -- Track preparation patterns\n    local preparationPatterns = lia.data.get(\"item_cleanup_preparation_patterns\", {})\n    table.insert(preparationPatterns, {\n        time = os.time()\n    })\n    lia.data.set(\"item_cleanup_preparation_patterns\", preparationPatterns)\nend)\n</code></pre>"},{"location":"modules/mapcleaner/hooks/#preitemcleanupwarning","title":"PreItemCleanupWarning","text":"<p>Purpose</p> <p>Called before item cleanup warning is sent.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Item cleanup warning is about to be sent - Before players are notified - When the warning cycle starts</p> <p>Example Usage</p> <pre><code>-- Track item cleanup warning preparation\nhook.Add(\"PreItemCleanupWarning\", \"TrackItemCleanupWarningPreparation\", function()\n    -- Track preparation\n    local preparations = lia.data.get(\"item_cleanup_warning_preparations\", 0)\n    lia.data.set(\"item_cleanup_warning_preparations\", preparations + 1)\n\n    lia.log.add(nil, \"itemCleanupWarningPrepared\")\nend)\n\n-- Apply pre item cleanup warning effects\nhook.Add(\"PreItemCleanupWarning\", \"PreItemCleanupWarningEffects\", function()\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Preparing item cleanup warning...\")\n    end\nend)\n\n-- Track pre item cleanup warning statistics\nhook.Add(\"PreItemCleanupWarning\", \"TrackPreItemCleanupWarningStats\", function()\n    -- Track preparation frequency\n    local preparationFrequency = lia.data.get(\"item_cleanup_warning_preparation_frequency\", 0)\n    lia.data.set(\"item_cleanup_warning_preparation_frequency\", preparationFrequency + 1)\n\n    -- Track preparation patterns\n    local preparationPatterns = lia.data.get(\"item_cleanup_warning_preparation_patterns\", {})\n    table.insert(preparationPatterns, {\n        time = os.time()\n    })\n    lia.data.set(\"item_cleanup_warning_preparation_patterns\", preparationPatterns)\nend)\n</code></pre>"},{"location":"modules/mapcleaner/hooks/#premapcleanup","title":"PreMapCleanup","text":"<p>Purpose</p> <p>Called before map cleanup begins.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Map cleanup is about to begin - Before map entities are removed - When the cleanup cycle starts</p> <p>Example Usage</p> <pre><code>-- Track map cleanup preparation\nhook.Add(\"PreMapCleanup\", \"TrackMapCleanupPreparation\", function()\n    -- Track preparation\n    local preparations = lia.data.get(\"map_cleanup_preparations\", 0)\n    lia.data.set(\"map_cleanup_preparations\", preparations + 1)\n\n    lia.log.add(nil, \"mapCleanupPrepared\")\nend)\n\n-- Apply pre map cleanup effects\nhook.Add(\"PreMapCleanup\", \"PreMapCleanupEffects\", function()\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Preparing map cleanup...\")\n    end\nend)\n\n-- Track pre map cleanup statistics\nhook.Add(\"PreMapCleanup\", \"TrackPreMapCleanupStats\", function()\n    -- Track preparation frequency\n    local preparationFrequency = lia.data.get(\"map_cleanup_preparation_frequency\", 0)\n    lia.data.set(\"map_cleanup_preparation_frequency\", preparationFrequency + 1)\n\n    -- Track preparation patterns\n    local preparationPatterns = lia.data.get(\"map_cleanup_preparation_patterns\", {})\n    table.insert(preparationPatterns, {\n        time = os.time()\n    })\n    lia.data.set(\"map_cleanup_preparation_patterns\", preparationPatterns)\nend)\n</code></pre>"},{"location":"modules/mapcleaner/hooks/#premapcleanupwarning","title":"PreMapCleanupWarning","text":"<p>Purpose</p> <p>Called before map cleanup warning is sent.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Map cleanup warning is about to be sent - Before players are notified - When the warning cycle starts</p> <p>Example Usage</p> <pre><code>-- Track map cleanup warning preparation\nhook.Add(\"PreMapCleanupWarning\", \"TrackMapCleanupWarningPreparation\", function()\n    -- Track preparation\n    local preparations = lia.data.get(\"map_cleanup_warning_preparations\", 0)\n    lia.data.set(\"map_cleanup_warning_preparations\", preparations + 1)\n\n    lia.log.add(nil, \"mapCleanupWarningPrepared\")\nend)\n\n-- Apply pre map cleanup warning effects\nhook.Add(\"PreMapCleanupWarning\", \"PreMapCleanupWarningEffects\", function()\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Preparing map cleanup warning...\")\n    end\nend)\n\n-- Track pre map cleanup warning statistics\nhook.Add(\"PreMapCleanupWarning\", \"TrackPreMapCleanupWarningStats\", function()\n    -- Track preparation frequency\n    local preparationFrequency = lia.data.get(\"map_cleanup_warning_preparation_frequency\", 0)\n    lia.data.set(\"map_cleanup_warning_preparation_frequency\", preparationFrequency + 1)\n\n    -- Track preparation patterns\n    local preparationPatterns = lia.data.get(\"map_cleanup_warning_preparation_patterns\", {})\n    table.insert(preparationPatterns, {\n        time = os.time()\n    })\n    lia.data.set(\"map_cleanup_warning_preparation_patterns\", preparationPatterns)\nend)\n</code></pre>"},{"location":"modules/modelpay/about/","title":"About","text":"About <p>Name: Model Pay</p> <p>Description:</p> <p>Adds payment to characters based on model, custom wage definitions, integration into the economy, config to exclude certain models, and logs of wages issued.</p> Features <ul> <li>Adds payment to characters based on model</li> <li>Adds custom wage definitions</li> <li>Adds integration into the economy</li> <li>Adds config to exclude certain models</li> <li>Adds logs of wages issued</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/modelpay/changelog/","title":"Changelog","text":""},{"location":"modules/modelpay/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/modelpay/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/modelpay/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Model Pay module for managing model-based payment functionality.</p>"},{"location":"modules/modelpay/hooks/#createsalarytimer","title":"CreateSalaryTimer","text":"<p>Purpose</p> <p>Called when a salary timer is created for a player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player for whom the salary timer is created.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A salary timer is created for a player - When a player's model changes to an eligible model - During model change processing</p> <p>Example Usage</p> <pre><code>-- Track salary timer creation\nhook.Add(\"CreateSalaryTimer\", \"TrackSalaryTimerCreation\", function(client)\n    local char = client:getChar()\n    if char then\n        local timerCreations = char:getData(\"salary_timer_creations\", 0)\n        char:setData(\"salary_timer_creations\", timerCreations + 1)\n    end\n\n    lia.log.add(client, \"salaryTimerCreated\")\nend)\n\n-- Apply salary timer creation effects\nhook.Add(\"CreateSalaryTimer\", \"SalaryTimerCreationEffects\", function(client)\n    -- Play creation sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Salary timer created!\")\nend)\n\n-- Track salary timer creation statistics\nhook.Add(\"CreateSalaryTimer\", \"TrackSalaryTimerCreationStats\", function(client)\n    local char = client:getChar()\n    if char then\n        -- Track creation frequency\n        local creationFrequency = char:getData(\"salary_timer_creation_frequency\", 0)\n        char:setData(\"salary_timer_creation_frequency\", creationFrequency + 1)\n\n        -- Track creation patterns\n        local creationPatterns = char:getData(\"salary_timer_creation_patterns\", {})\n        table.insert(creationPatterns, {\n            time = os.time()\n        })\n        char:setData(\"salary_timer_creation_patterns\", creationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modelpay/hooks/#modelpaymodelchecked","title":"ModelPayModelChecked","text":"<p>Purpose</p> <p>Called when a player's model is checked for payment eligibility.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose model is being checked.</li> <li><code>playerModel</code> (string): The player's model string.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's model is checked for payment eligibility - During salary amount calculation - When the model validation begins</p> <p>Example Usage</p> <pre><code>-- Track model checks\nhook.Add(\"ModelPayModelChecked\", \"TrackModelChecks\", function(client, playerModel)\n    local char = client:getChar()\n    if char then\n        local modelChecks = char:getData(\"model_checks\", 0)\n        char:setData(\"model_checks\", modelChecks + 1)\n    end\n\n    lia.log.add(client, \"modelChecked\", playerModel)\nend)\n\n-- Apply model check effects\nhook.Add(\"ModelPayModelChecked\", \"ModelCheckEffects\", function(client, playerModel)\n    -- Play check sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Model checked: \" .. playerModel .. \"!\")\nend)\n\n-- Track model check statistics\nhook.Add(\"ModelPayModelChecked\", \"TrackModelCheckStats\", function(client, playerModel)\n    local char = client:getChar()\n    if char then\n        -- Track check frequency\n        local checkFrequency = char:getData(\"model_check_frequency\", 0)\n        char:setData(\"model_check_frequency\", checkFrequency + 1)\n\n        -- Track check patterns\n        local checkPatterns = char:getData(\"model_check_patterns\", {})\n        table.insert(checkPatterns, {\n            model = playerModel,\n            time = os.time()\n        })\n        char:setData(\"model_check_patterns\", checkPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modelpay/hooks/#modelpaymodeleligible","title":"ModelPayModelEligible","text":"<p>Purpose</p> <p>Called when a player's model is eligible for payment.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose model is eligible.</li> <li><code>newModel</code> (string): The new model that is eligible.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's model is eligible for payment - When a player changes to an eligible model - During model change processing</p> <p>Example Usage</p> <pre><code>-- Track model eligibility\nhook.Add(\"ModelPayModelEligible\", \"TrackModelEligibility\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        local modelEligibility = char:getData(\"model_eligibility\", 0)\n        char:setData(\"model_eligibility\", modelEligibility + 1)\n    end\n\n    lia.log.add(client, \"modelEligible\", newModel)\nend)\n\n-- Apply model eligibility effects\nhook.Add(\"ModelPayModelEligible\", \"ModelEligibilityEffects\", function(client, newModel)\n    -- Play eligibility sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Model eligible for payment: \" .. newModel .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track model eligibility statistics\nhook.Add(\"ModelPayModelEligible\", \"TrackModelEligibilityStats\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        -- Track eligibility frequency\n        local eligibilityFrequency = char:getData(\"model_eligibility_frequency\", 0)\n        char:setData(\"model_eligibility_frequency\", eligibilityFrequency + 1)\n\n        -- Track eligibility patterns\n        local eligibilityPatterns = char:getData(\"model_eligibility_patterns\", {})\n        table.insert(eligibilityPatterns, {\n            model = newModel,\n            time = os.time()\n        })\n        char:setData(\"model_eligibility_patterns\", eligibilityPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modelpay/hooks/#modelpaymodelineligible","title":"ModelPayModelIneligible","text":"<p>Purpose</p> <p>Called when a player's model is not eligible for payment.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose model is not eligible.</li> <li><code>newModel</code> (string): The new model that is not eligible.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's model is not eligible for payment - When a player changes to an ineligible model - During model change processing</p> <p>Example Usage</p> <pre><code>-- Track model ineligibility\nhook.Add(\"ModelPayModelIneligible\", \"TrackModelIneligibility\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        local modelIneligibility = char:getData(\"model_ineligibility\", 0)\n        char:setData(\"model_ineligibility\", modelIneligibility + 1)\n    end\n\n    lia.log.add(client, \"modelIneligible\", newModel)\nend)\n\n-- Apply model ineligibility effects\nhook.Add(\"ModelPayModelIneligible\", \"ModelIneligibilityEffects\", function(client, newModel)\n    -- Play ineligibility sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Model not eligible for payment: \" .. newModel .. \"!\")\nend)\n\n-- Track model ineligibility statistics\nhook.Add(\"ModelPayModelIneligible\", \"TrackModelIneligibilityStats\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        -- Track ineligibility frequency\n        local ineligibilityFrequency = char:getData(\"model_ineligibility_frequency\", 0)\n        char:setData(\"model_ineligibility_frequency\", ineligibilityFrequency + 1)\n\n        -- Track ineligibility patterns\n        local ineligibilityPatterns = char:getData(\"model_ineligibility_patterns\", {})\n        table.insert(ineligibilityPatterns, {\n            model = newModel,\n            time = os.time()\n        })\n        char:setData(\"model_ineligibility_patterns\", ineligibilityPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modelpay/hooks/#modelpaymodelmatched","title":"ModelPayModelMatched","text":"<p>Purpose</p> <p>Called when a player's model matches a payment model.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose model matched.</li> <li><code>model</code> (string): The model that matched.</li> <li><code>pay</code> (number): The payment amount.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's model matches a payment model - During salary amount calculation - When a match is found</p> <p>Example Usage</p> <pre><code>-- Track model matches\nhook.Add(\"ModelPayModelMatched\", \"TrackModelMatches\", function(client, model, pay)\n    local char = client:getChar()\n    if char then\n        local modelMatches = char:getData(\"model_matches\", 0)\n        char:setData(\"model_matches\", modelMatches + 1)\n    end\n\n    lia.log.add(client, \"modelMatched\", model, pay)\nend)\n\n-- Apply model match effects\nhook.Add(\"ModelPayModelMatched\", \"ModelMatchEffects\", function(client, model, pay)\n    -- Play match sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Model matched! Payment: \" .. pay .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track model match statistics\nhook.Add(\"ModelPayModelMatched\", \"TrackModelMatchStats\", function(client, model, pay)\n    local char = client:getChar()\n    if char then\n        -- Track match frequency\n        local matchFrequency = char:getData(\"model_match_frequency\", 0)\n        char:setData(\"model_match_frequency\", matchFrequency + 1)\n\n        -- Track match patterns\n        local matchPatterns = char:getData(\"model_match_patterns\", {})\n        table.insert(matchPatterns, {\n            model = model,\n            pay = pay,\n            time = os.time()\n        })\n        char:setData(\"model_match_patterns\", matchPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modelpay/hooks/#modelpaymodelnotmatched","title":"ModelPayModelNotMatched","text":"<p>Purpose</p> <p>Called when a player's model does not match any payment model.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose model did not match.</li> <li><code>playerModel</code> (string): The player's model string.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's model does not match any payment model - During salary amount calculation - When no match is found</p> <p>Example Usage</p> <pre><code>-- Track model non-matches\nhook.Add(\"ModelPayModelNotMatched\", \"TrackModelNonMatches\", function(client, playerModel)\n    local char = client:getChar()\n    if char then\n        local modelNonMatches = char:getData(\"model_non_matches\", 0)\n        char:setData(\"model_non_matches\", modelNonMatches + 1)\n    end\n\n    lia.log.add(client, \"modelNotMatched\", playerModel)\nend)\n\n-- Apply model non-match effects\nhook.Add(\"ModelPayModelNotMatched\", \"ModelNonMatchEffects\", function(client, playerModel)\n    -- Play non-match sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Model not matched: \" .. playerModel .. \"!\")\nend)\n\n-- Track model non-match statistics\nhook.Add(\"ModelPayModelNotMatched\", \"TrackModelNonMatchStats\", function(client, playerModel)\n    local char = client:getChar()\n    if char then\n        -- Track non-match frequency\n        local nonMatchFrequency = char:getData(\"model_non_match_frequency\", 0)\n        char:setData(\"model_non_match_frequency\", nonMatchFrequency + 1)\n\n        -- Track non-match patterns\n        local nonMatchPatterns = char:getData(\"model_non_match_patterns\", {})\n        table.insert(nonMatchPatterns, {\n            model = playerModel,\n            time = os.time()\n        })\n        char:setData(\"model_non_match_patterns\", nonMatchPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modelpay/hooks/#modelpaysalarydetermined","title":"ModelPaySalaryDetermined","text":"<p>Purpose</p> <p>Called when a salary amount is determined for a player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player for whom the salary is determined.</li> <li><code>pay</code> (number): The determined salary amount.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A salary amount is determined for a player - After model matching or non-matching - When the salary calculation is complete</p> <p>Example Usage</p> <pre><code>-- Track salary determination\nhook.Add(\"ModelPaySalaryDetermined\", \"TrackSalaryDetermination\", function(client, pay)\n    local char = client:getChar()\n    if char then\n        local salaryDeterminations = char:getData(\"salary_determinations\", 0)\n        char:setData(\"salary_determinations\", salaryDeterminations + 1)\n    end\n\n    lia.log.add(client, \"salaryDetermined\", pay)\nend)\n\n-- Apply salary determination effects\nhook.Add(\"ModelPaySalaryDetermined\", \"SalaryDeterminationEffects\", function(client, pay)\n    -- Play determination sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Salary determined: \" .. pay .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track salary determination statistics\nhook.Add(\"ModelPaySalaryDetermined\", \"TrackSalaryDeterminationStats\", function(client, pay)\n    local char = client:getChar()\n    if char then\n        -- Track determination frequency\n        local determinationFrequency = char:getData(\"salary_determination_frequency\", 0)\n        char:setData(\"salary_determination_frequency\", determinationFrequency + 1)\n\n        -- Track determination patterns\n        local determinationPatterns = char:getData(\"salary_determination_patterns\", {})\n        table.insert(determinationPatterns, {\n            pay = pay,\n            time = os.time()\n        })\n        char:setData(\"salary_determination_patterns\", determinationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modeltweaker/about/","title":"About","text":"About <p>Name: Model Tweaker</p> <p>Description:</p> <p>Adds an entity to tweak prop models, adjustments for scale and rotation, easy UI controls, saving of tweaked props between restarts, and undo support for recent tweaks.</p> Features <ul> <li>Adds an entity to tweak prop models</li> <li>Adds adjustments for scale and rotation</li> <li>Adds easy UI controls</li> <li>Adds saving of tweaked props between restarts</li> <li>Adds undo support for recent tweaks</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/modeltweaker/changelog/","title":"Changelog","text":""},{"location":"modules/modeltweaker/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/modeltweaker/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/modeltweaker/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/modeltweaker/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Model Tweaker module for managing wardrobe model change functionality.</p>"},{"location":"modules/modeltweaker/hooks/#postwardrobemodelchange","title":"PostWardrobeModelChange","text":"<p>Purpose</p> <p>Called after a wardrobe model change is complete.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose model was changed.</li> <li><code>newModel</code> (string): The new model that was set.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A wardrobe model change is complete - After <code>WardrobeModelChanged</code> hook - When the model change process is finished</p> <p>Example Usage</p> <pre><code>-- Track wardrobe model change completion\nhook.Add(\"PostWardrobeModelChange\", \"TrackWardrobeModelChangeCompletion\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        local changeCompletions = char:getData(\"wardrobe_model_change_completions\", 0)\n        char:setData(\"wardrobe_model_change_completions\", changeCompletions + 1)\n    end\n\n    lia.log.add(client, \"wardrobeModelChangeCompleted\", newModel)\nend)\n\n-- Apply post wardrobe model change effects\nhook.Add(\"PostWardrobeModelChange\", \"PostWardrobeModelChangeEffects\", function(client, newModel)\n    -- Play completion sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Wardrobe model change completed: \" .. newModel .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track post wardrobe model change statistics\nhook.Add(\"PostWardrobeModelChange\", \"TrackPostWardrobeModelChangeStats\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        -- Track completion frequency\n        local completionFrequency = char:getData(\"wardrobe_model_change_completion_frequency\", 0)\n        char:setData(\"wardrobe_model_change_completion_frequency\", completionFrequency + 1)\n\n        -- Track completion patterns\n        local completionPatterns = char:getData(\"wardrobe_model_change_completion_patterns\", {})\n        table.insert(completionPatterns, {\n            model = newModel,\n            time = os.time()\n        })\n        char:setData(\"wardrobe_model_change_completion_patterns\", completionPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modeltweaker/hooks/#prewardrobemodelchange","title":"PreWardrobeModelChange","text":"<p>Purpose</p> <p>Called before a wardrobe model change begins.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose model will be changed.</li> <li><code>newModel</code> (string): The new model that will be set.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A wardrobe model change is about to begin - Before <code>WardrobeModelChanged</code> hook - When the model change process starts</p> <p>Example Usage</p> <pre><code>-- Track wardrobe model change preparation\nhook.Add(\"PreWardrobeModelChange\", \"TrackWardrobeModelChangePreparation\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        local changePreparations = char:getData(\"wardrobe_model_change_preparations\", 0)\n        char:setData(\"wardrobe_model_change_preparations\", changePreparations + 1)\n    end\n\n    lia.log.add(client, \"wardrobeModelChangePrepared\", newModel)\nend)\n\n-- Apply pre wardrobe model change effects\nhook.Add(\"PreWardrobeModelChange\", \"PreWardrobeModelChangeEffects\", function(client, newModel)\n    -- Play preparation sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Preparing wardrobe model change: \" .. newModel .. \"!\")\nend)\n\n-- Track pre wardrobe model change statistics\nhook.Add(\"PreWardrobeModelChange\", \"TrackPreWardrobeModelChangeStats\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        -- Track preparation frequency\n        local preparationFrequency = char:getData(\"wardrobe_model_change_preparation_frequency\", 0)\n        char:setData(\"wardrobe_model_change_preparation_frequency\", preparationFrequency + 1)\n\n        -- Track preparation patterns\n        local preparationPatterns = char:getData(\"wardrobe_model_change_preparation_patterns\", {})\n        table.insert(preparationPatterns, {\n            model = newModel,\n            time = os.time()\n        })\n        char:setData(\"wardrobe_model_change_preparation_patterns\", preparationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modeltweaker/hooks/#wardrobemodelchanged","title":"WardrobeModelChanged","text":"<p>Purpose</p> <p>Called when a wardrobe model is successfully changed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose model was changed.</li> <li><code>newModel</code> (string): The new model that was set.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A wardrobe model is successfully changed - After <code>PreWardrobeModelChange</code> hook - Before <code>PostWardrobeModelChange</code> hook</p> <p>Example Usage</p> <pre><code>-- Track wardrobe model changes\nhook.Add(\"WardrobeModelChanged\", \"TrackWardrobeModelChanges\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        local modelChanges = char:getData(\"wardrobe_model_changes\", 0)\n        char:setData(\"wardrobe_model_changes\", modelChanges + 1)\n    end\n\n    lia.log.add(client, \"wardrobeModelChanged\", newModel)\nend)\n\n-- Apply wardrobe model change effects\nhook.Add(\"WardrobeModelChanged\", \"WardrobeModelChangeEffects\", function(client, newModel)\n    -- Play change sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Wardrobe model changed to: \" .. newModel .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track wardrobe model change statistics\nhook.Add(\"WardrobeModelChanged\", \"TrackWardrobeModelChangeStats\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        -- Track change frequency\n        local changeFrequency = char:getData(\"wardrobe_model_change_frequency\", 0)\n        char:setData(\"wardrobe_model_change_frequency\", changeFrequency + 1)\n\n        -- Track change patterns\n        local changePatterns = char:getData(\"wardrobe_model_change_patterns\", {})\n        table.insert(changePatterns, {\n            model = newModel,\n            time = os.time()\n        })\n        char:setData(\"wardrobe_model_change_patterns\", changePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modeltweaker/hooks/#wardrobemodelchangerequested","title":"WardrobeModelChangeRequested","text":"<p>Purpose</p> <p>Called when a wardrobe model change is requested.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player requesting the model change.</li> <li><code>newModel</code> (string): The new model being requested.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A wardrobe model change is requested - Before any validation - When the request is received</p> <p>Example Usage</p> <pre><code>-- Track wardrobe model change requests\nhook.Add(\"WardrobeModelChangeRequested\", \"TrackWardrobeModelChangeRequests\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        local changeRequests = char:getData(\"wardrobe_model_change_requests\", 0)\n        char:setData(\"wardrobe_model_change_requests\", changeRequests + 1)\n    end\n\n    lia.log.add(client, \"wardrobeModelChangeRequested\", newModel)\nend)\n\n-- Apply wardrobe model change request effects\nhook.Add(\"WardrobeModelChangeRequested\", \"WardrobeModelChangeRequestEffects\", function(client, newModel)\n    -- Play request sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Wardrobe model change requested: \" .. newModel .. \"!\")\nend)\n\n-- Track wardrobe model change request statistics\nhook.Add(\"WardrobeModelChangeRequested\", \"TrackWardrobeModelChangeRequestStats\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        -- Track request frequency\n        local requestFrequency = char:getData(\"wardrobe_model_change_request_frequency\", 0)\n        char:setData(\"wardrobe_model_change_request_frequency\", requestFrequency + 1)\n\n        -- Track request patterns\n        local requestPatterns = char:getData(\"wardrobe_model_change_request_patterns\", {})\n        table.insert(requestPatterns, {\n            model = newModel,\n            time = os.time()\n        })\n        char:setData(\"wardrobe_model_change_request_patterns\", requestPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/modeltweaker/hooks/#wardrobemodelinvalid","title":"WardrobeModelInvalid","text":"<p>Purpose</p> <p>Called when a wardrobe model change request is invalid.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose model change request was invalid.</li> <li><code>newModel</code> (string): The invalid model that was requested.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A wardrobe model change request is invalid - When the model validation fails - When the request is rejected</p> <p>Example Usage</p> <pre><code>-- Track wardrobe model invalid requests\nhook.Add(\"WardrobeModelInvalid\", \"TrackWardrobeModelInvalidRequests\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        local invalidRequests = char:getData(\"wardrobe_model_invalid_requests\", 0)\n        char:setData(\"wardrobe_model_invalid_requests\", invalidRequests + 1)\n    end\n\n    lia.log.add(client, \"wardrobeModelInvalid\", newModel)\nend)\n\n-- Apply wardrobe model invalid effects\nhook.Add(\"WardrobeModelInvalid\", \"WardrobeModelInvalidEffects\", function(client, newModel)\n    -- Play invalid sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Invalid wardrobe model: \" .. newModel .. \"!\")\nend)\n\n-- Track wardrobe model invalid statistics\nhook.Add(\"WardrobeModelInvalid\", \"TrackWardrobeModelInvalidStats\", function(client, newModel)\n    local char = client:getChar()\n    if char then\n        -- Track invalid frequency\n        local invalidFrequency = char:getData(\"wardrobe_model_invalid_frequency\", 0)\n        char:setData(\"wardrobe_model_invalid_frequency\", invalidFrequency + 1)\n\n        -- Track invalid patterns\n        local invalidPatterns = char:getData(\"wardrobe_model_invalid_patterns\", {})\n        table.insert(invalidPatterns, {\n            model = newModel,\n            time = os.time()\n        })\n        char:setData(\"wardrobe_model_invalid_patterns\", invalidPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/npcdrop/about/","title":"About","text":"About <p>Name: NPC Drop</p> <p>Description:</p> <p>Adds NPCs that drop items on death, DropTable to define probabilities, encouragement for looting, editable drop tables per NPC type, and weighted chances for rare items.</p> Features <ul> <li>Adds NPCs that drop items on death</li> <li>Adds DropTable to define probabilities</li> <li>Adds encouragement for looting</li> <li>Adds editable drop tables per NPC type</li> <li>Adds weighted chances for rare items</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/npcdrop/changelog/","title":"Changelog","text":""},{"location":"modules/npcdrop/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/npcdrop/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/npcdrop/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the NPC Drop module for managing NPC item drop functionality.</p>"},{"location":"modules/npcdrop/hooks/#npcdropcheck","title":"NPCDropCheck","text":"<p>Purpose</p> <p>Called when an NPC drop check is performed.</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The NPC entity being checked for drops.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC is killed - Before any drop table checks - When the drop process begins</p> <p>Example Usage</p> <pre><code>-- Track NPC drop checks\nhook.Add(\"NPCDropCheck\", \"TrackNPCDropChecks\", function(ent)\n    -- Track check\n    local checks = lia.data.get(\"npc_drop_checks\", 0)\n    lia.data.set(\"npc_drop_checks\", checks + 1)\n\n    lia.log.add(nil, \"npcDropCheck\", ent)\nend)\n\n-- Apply NPC drop check effects\nhook.Add(\"NPCDropCheck\", \"NPCDropCheckEffects\", function(ent)\n    -- Create check effect\n    local effect = EffectData()\n    effect:SetOrigin(ent:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play check sound\n    ent:EmitSound(\"ui/buttonclick.wav\", 75, 100)\nend)\n\n-- Track NPC drop check statistics\nhook.Add(\"NPCDropCheck\", \"TrackNPCDropCheckStats\", function(ent)\n    -- Track check frequency\n    local checkFrequency = lia.data.get(\"npc_drop_check_frequency\", 0)\n    lia.data.set(\"npc_drop_check_frequency\", checkFrequency + 1)\n\n    -- Track check patterns\n    local checkPatterns = lia.data.get(\"npc_drop_check_patterns\", {})\n    table.insert(checkPatterns, {\n        class = ent:GetClass(),\n        time = os.time()\n    })\n    lia.data.set(\"npc_drop_check_patterns\", checkPatterns)\nend)\n</code></pre>"},{"location":"modules/npcdrop/hooks/#npcdropfailed","title":"NPCDropFailed","text":"<p>Purpose</p> <p>Called when an NPC drop attempt fails.</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The NPC entity that failed to drop items.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC drop attempt fails - When no item is selected from the drop table - After <code>NPCDropRoll</code> hook</p> <p>Example Usage</p> <pre><code>-- Track NPC drop failures\nhook.Add(\"NPCDropFailed\", \"TrackNPCDropFailures\", function(ent)\n    -- Track failure\n    local failures = lia.data.get(\"npc_drop_failures\", 0)\n    lia.data.set(\"npc_drop_failures\", failures + 1)\n\n    lia.log.add(nil, \"npcDropFailed\", ent)\nend)\n\n-- Apply NPC drop failure effects\nhook.Add(\"NPCDropFailed\", \"NPCDropFailureEffects\", function(ent)\n    -- Create failure effect\n    local effect = EffectData()\n    effect:SetOrigin(ent:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play failure sound\n    ent:EmitSound(\"buttons/button16.wav\", 75, 100)\nend)\n\n-- Track NPC drop failure statistics\nhook.Add(\"NPCDropFailed\", \"TrackNPCDropFailureStats\", function(ent)\n    -- Track failure frequency\n    local failureFrequency = lia.data.get(\"npc_drop_failure_frequency\", 0)\n    lia.data.set(\"npc_drop_failure_frequency\", failureFrequency + 1)\n\n    -- Track failure patterns\n    local failurePatterns = lia.data.get(\"npc_drop_failure_patterns\", {})\n    table.insert(failurePatterns, {\n        class = ent:GetClass(),\n        time = os.time()\n    })\n    lia.data.set(\"npc_drop_failure_patterns\", failurePatterns)\nend)\n</code></pre>"},{"location":"modules/npcdrop/hooks/#npcdropnoitems","title":"NPCDropNoItems","text":"<p>Purpose</p> <p>Called when an NPC has no items in its drop table.</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The NPC entity that has no items.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC has no items in its drop table - When the total weight is 0 or less - After <code>NPCDropNoTable</code> hook</p> <p>Example Usage</p> <pre><code>-- Track NPC drop no items\nhook.Add(\"NPCDropNoItems\", \"TrackNPCDropNoItems\", function(ent)\n    -- Track no items\n    local noItems = lia.data.get(\"npc_drop_no_items\", 0)\n    lia.data.set(\"npc_drop_no_items\", noItems + 1)\n\n    lia.log.add(nil, \"npcDropNoItems\", ent)\nend)\n\n-- Apply NPC drop no items effects\nhook.Add(\"NPCDropNoItems\", \"NPCDropNoItemsEffects\", function(ent)\n    -- Create no items effect\n    local effect = EffectData()\n    effect:SetOrigin(ent:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play no items sound\n    ent:EmitSound(\"buttons/button16.wav\", 75, 100)\nend)\n\n-- Track NPC drop no items statistics\nhook.Add(\"NPCDropNoItems\", \"TrackNPCDropNoItemsStats\", function(ent)\n    -- Track no items frequency\n    local noItemsFrequency = lia.data.get(\"npc_drop_no_items_frequency\", 0)\n    lia.data.set(\"npc_drop_no_items_frequency\", noItemsFrequency + 1)\n\n    -- Track no items patterns\n    local noItemsPatterns = lia.data.get(\"npc_drop_no_items_patterns\", {})\n    table.insert(noItemsPatterns, {\n        class = ent:GetClass(),\n        time = os.time()\n    })\n    lia.data.set(\"npc_drop_no_items_patterns\", noItemsPatterns)\nend)\n</code></pre>"},{"location":"modules/npcdrop/hooks/#npcdropnotable","title":"NPCDropNoTable","text":"<p>Purpose</p> <p>Called when an NPC has no drop table.</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The NPC entity that has no drop table.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC has no drop table - When the drop table is not found - After <code>NPCDropCheck</code> hook</p> <p>Example Usage</p> <pre><code>-- Track NPC drop no table\nhook.Add(\"NPCDropNoTable\", \"TrackNPCDropNoTable\", function(ent)\n    -- Track no table\n    local noTable = lia.data.get(\"npc_drop_no_table\", 0)\n    lia.data.set(\"npc_drop_no_table\", noTable + 1)\n\n    lia.log.add(nil, \"npcDropNoTable\", ent)\nend)\n\n-- Apply NPC drop no table effects\nhook.Add(\"NPCDropNoTable\", \"NPCDropNoTableEffects\", function(ent)\n    -- Create no table effect\n    local effect = EffectData()\n    effect:SetOrigin(ent:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play no table sound\n    ent:EmitSound(\"buttons/button16.wav\", 75, 100)\nend)\n\n-- Track NPC drop no table statistics\nhook.Add(\"NPCDropNoTable\", \"TrackNPCDropNoTableStats\", function(ent)\n    -- Track no table frequency\n    local noTableFrequency = lia.data.get(\"npc_drop_no_table_frequency\", 0)\n    lia.data.set(\"npc_drop_no_table_frequency\", noTableFrequency + 1)\n\n    -- Track no table patterns\n    local noTablePatterns = lia.data.get(\"npc_drop_no_table_patterns\", {})\n    table.insert(noTablePatterns, {\n        class = ent:GetClass(),\n        time = os.time()\n    })\n    lia.data.set(\"npc_drop_no_table_patterns\", noTablePatterns)\nend)\n</code></pre>"},{"location":"modules/npcdrop/hooks/#npcdroppeditem","title":"NPCDroppedItem","text":"<p>Purpose</p> <p>Called when an NPC drops an item.</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The NPC entity that dropped the item.</li> <li><code>itemName</code> (string): The name of the item that was dropped.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC successfully drops an item - After <code>NPCDropRoll</code> hook - When the item is spawned</p> <p>Example Usage</p> <pre><code>-- Track NPC dropped items\nhook.Add(\"NPCDroppedItem\", \"TrackNPCDroppedItems\", function(ent, itemName)\n    -- Track dropped item\n    local droppedItems = lia.data.get(\"npc_dropped_items\", 0)\n    lia.data.set(\"npc_dropped_items\", droppedItems + 1)\n\n    lia.log.add(nil, \"npcDroppedItem\", ent, itemName)\nend)\n\n-- Apply NPC dropped item effects\nhook.Add(\"NPCDroppedItem\", \"NPCDroppedItemEffects\", function(ent, itemName)\n    -- Create dropped item effect\n    local effect = EffectData()\n    effect:SetOrigin(ent:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play dropped item sound\n    ent:EmitSound(\"buttons/button14.wav\", 75, 100)\nend)\n\n-- Track NPC dropped item statistics\nhook.Add(\"NPCDroppedItem\", \"TrackNPCDroppedItemStats\", function(ent, itemName)\n    -- Track dropped item frequency\n    local droppedItemFrequency = lia.data.get(\"npc_dropped_item_frequency\", 0)\n    lia.data.set(\"npc_dropped_item_frequency\", droppedItemFrequency + 1)\n\n    -- Track dropped item patterns\n    local droppedItemPatterns = lia.data.get(\"npc_dropped_item_patterns\", {})\n    table.insert(droppedItemPatterns, {\n        class = ent:GetClass(),\n        item = itemName,\n        time = os.time()\n    })\n    lia.data.set(\"npc_dropped_item_patterns\", droppedItemPatterns)\nend)\n</code></pre>"},{"location":"modules/npcdrop/hooks/#npcdroproll","title":"NPCDropRoll","text":"<p>Purpose</p> <p>Called when an NPC drop roll is made.</p> <p>Parameters</p> <ul> <li><code>ent</code> (Entity): The NPC entity being rolled for drops.</li> <li><code>choice</code> (number): The random choice value.</li> <li><code>totalWeight</code> (number): The total weight of all items.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC drop roll is made - After <code>NPCDropNoItems</code> hook - Before <code>NPCDroppedItem</code> hook</p> <p>Example Usage</p> <pre><code>-- Track NPC drop rolls\nhook.Add(\"NPCDropRoll\", \"TrackNPCDropRolls\", function(ent, choice, totalWeight)\n    -- Track roll\n    local rolls = lia.data.get(\"npc_drop_rolls\", 0)\n    lia.data.set(\"npc_drop_rolls\", rolls + 1)\n\n    lia.log.add(nil, \"npcDropRoll\", ent, choice, totalWeight)\nend)\n\n-- Apply NPC drop roll effects\nhook.Add(\"NPCDropRoll\", \"NPCDropRollEffects\", function(ent, choice, totalWeight)\n    -- Create roll effect\n    local effect = EffectData()\n    effect:SetOrigin(ent:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play roll sound\n    ent:EmitSound(\"ui/buttonclick.wav\", 75, 100)\nend)\n\n-- Track NPC drop roll statistics\nhook.Add(\"NPCDropRoll\", \"TrackNPCDropRollStats\", function(ent, choice, totalWeight)\n    -- Track roll frequency\n    local rollFrequency = lia.data.get(\"npc_drop_roll_frequency\", 0)\n    lia.data.set(\"npc_drop_roll_frequency\", rollFrequency + 1)\n\n    -- Track roll patterns\n    local rollPatterns = lia.data.get(\"npc_drop_roll_patterns\", {})\n    table.insert(rollPatterns, {\n        class = ent:GetClass(),\n        choice = choice,\n        totalWeight = totalWeight,\n        time = os.time()\n    })\n    lia.data.set(\"npc_drop_roll_patterns\", rollPatterns)\nend)\n</code></pre>"},{"location":"modules/npcspawner/about/","title":"About","text":"About <p>Name: NPC Spawner</p> <p>Description:</p> <p>Adds automatic NPC spawns at points, the ability for admins to force spawns, logging of spawn actions, and configuration for spawn intervals.</p> Features <ul> <li>Adds automatic NPC spawns at points</li> <li>Adds the ability for admins to force spawns</li> <li>Adds logging of spawn actions</li> <li>Adds configuration for spawn intervals</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/npcspawner/changelog/","title":"Changelog","text":""},{"location":"modules/npcspawner/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/npcspawner/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/npcspawner/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the NPC Spawner module for managing automatic NPC spawning functionality.</p>"},{"location":"modules/npcspawner/hooks/#cannpcspawn","title":"CanNPCSpawn","text":"<p>Purpose</p> <p>Called to determine if an NPC can spawn in a zone.</p> <p>Parameters</p> <ul> <li><code>zone</code> (table): The spawn zone data.</li> <li><code>npcType</code> (string): The NPC type to spawn.</li> <li><code>group</code> (string): The spawn group.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC is about to spawn - Before <code>PreNPCSpawn</code> hook - When the spawn validation begins</p> <p>Example Usage</p> <pre><code>-- Control NPC spawning\nhook.Add(\"CanNPCSpawn\", \"ControlNPCSpawning\", function(zone, npcType, group)\n    -- Check if NPC spawning is disabled\n    if lia.data.get(\"npc_spawning_disabled\", false) then\n        return false\n    end\n\n    -- Check if zone is restricted\n    if zone.restricted then\n        return false\n    end\n\n    -- Check if NPC type is allowed\n    local allowedTypes = lia.data.get(\"allowed_npc_types\", {})\n    if not table.HasValue(allowedTypes, npcType) then\n        return false\n    end\n\n    return true\nend)\n\n-- Track NPC spawn checks\nhook.Add(\"CanNPCSpawn\", \"TrackNPCSpawnChecks\", function(zone, npcType, group)\n    -- Track check\n    local checks = lia.data.get(\"npc_spawn_checks\", 0)\n    lia.data.set(\"npc_spawn_checks\", checks + 1)\n\n    lia.log.add(nil, \"npcSpawnCheck\", zone, npcType, group)\nend)\n\n-- Apply NPC spawn check effects\nhook.Add(\"CanNPCSpawn\", \"NPCSpawnCheckEffects\", function(zone, npcType, group)\n    -- Create check effect\n    local effect = EffectData()\n    effect:SetOrigin(zone.pos)\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n</code></pre>"},{"location":"modules/npcspawner/hooks/#onnpcforcespawn","title":"OnNPCForceSpawn","text":"<p>Purpose</p> <p>Called when an NPC is force spawned by an admin.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The admin who force spawned the NPC.</li> <li><code>selectedSpawner</code> (string): The selected spawner.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An admin force spawns an NPC - During admin command execution - When the force spawn is initiated</p> <p>Example Usage</p> <pre><code>-- Track NPC force spawns\nhook.Add(\"OnNPCForceSpawn\", \"TrackNPCForceSpawns\", function(client, selectedSpawner)\n    local char = client:getChar()\n    if char then\n        local forceSpawns = char:getData(\"npc_force_spawns\", 0)\n        char:setData(\"npc_force_spawns\", forceSpawns + 1)\n    end\n\n    lia.log.add(client, \"npcForceSpawned\", selectedSpawner)\nend)\n\n-- Apply NPC force spawn effects\nhook.Add(\"OnNPCForceSpawn\", \"NPCForceSpawnEffects\", function(client, selectedSpawner)\n    -- Play force spawn sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"NPC force spawned: \" .. selectedSpawner .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track NPC force spawn statistics\nhook.Add(\"OnNPCForceSpawn\", \"TrackNPCForceSpawnStats\", function(client, selectedSpawner)\n    local char = client:getChar()\n    if char then\n        -- Track force spawn frequency\n        local forceSpawnFrequency = char:getData(\"npc_force_spawn_frequency\", 0)\n        char:setData(\"npc_force_spawn_frequency\", forceSpawnFrequency + 1)\n\n        -- Track force spawn patterns\n        local forceSpawnPatterns = char:getData(\"npc_force_spawn_patterns\", {})\n        table.insert(forceSpawnPatterns, {\n            spawner = selectedSpawner,\n            time = os.time()\n        })\n        char:setData(\"npc_force_spawn_patterns\", forceSpawnPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/npcspawner/hooks/#onnpcgroupspawned","title":"OnNPCGroupSpawned","text":"<p>Purpose</p> <p>Called when a group of NPCs is spawned.</p> <p>Parameters</p> <ul> <li><code>zone</code> (table): The spawn zone data.</li> <li><code>group</code> (string): The spawn group.</li> <li><code>spawned</code> (number): The number of NPCs spawned.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A group of NPCs is spawned - After <code>PostProcessNPCZone</code> hook - When the group spawn is complete</p> <p>Example Usage</p> <pre><code>-- Track NPC group spawns\nhook.Add(\"OnNPCGroupSpawned\", \"TrackNPCGroupSpawns\", function(zone, group, spawned)\n    -- Track group spawn\n    local groupSpawns = lia.data.get(\"npc_group_spawns\", 0)\n    lia.data.set(\"npc_group_spawns\", groupSpawns + 1)\n\n    lia.log.add(nil, \"npcGroupSpawned\", zone, group, spawned)\nend)\n\n-- Apply NPC group spawn effects\nhook.Add(\"OnNPCGroupSpawned\", \"NPCGroupSpawnEffects\", function(zone, group, spawned)\n    -- Create group spawn effect\n    local effect = EffectData()\n    effect:SetOrigin(zone.pos)\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"NPC group spawned: \" .. group .. \" (\" .. spawned .. \" NPCs)!\")\n    end\nend)\n\n-- Track NPC group spawn statistics\nhook.Add(\"OnNPCGroupSpawned\", \"TrackNPCGroupSpawnStats\", function(zone, group, spawned)\n    -- Track group spawn frequency\n    local groupSpawnFrequency = lia.data.get(\"npc_group_spawn_frequency\", 0)\n    lia.data.set(\"npc_group_spawn_frequency\", groupSpawnFrequency + 1)\n\n    -- Track group spawn patterns\n    local groupSpawnPatterns = lia.data.get(\"npc_group_spawn_patterns\", {})\n    table.insert(groupSpawnPatterns, {\n        group = group,\n        spawned = spawned,\n        time = os.time()\n    })\n    lia.data.set(\"npc_group_spawn_patterns\", groupSpawnPatterns)\nend)\n</code></pre>"},{"location":"modules/npcspawner/hooks/#onnpcspawned","title":"OnNPCSpawned","text":"<p>Purpose</p> <p>Called when an NPC is spawned.</p> <p>Parameters</p> <ul> <li><code>npc</code> (Entity): The spawned NPC entity.</li> <li><code>zone</code> (table): The spawn zone data.</li> <li><code>group</code> (string): The spawn group.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC is successfully spawned - After <code>PreNPCSpawn</code> hook - Before <code>PostNPCSpawn</code> hook</p> <p>Example Usage</p> <pre><code>-- Track NPC spawns\nhook.Add(\"OnNPCSpawned\", \"TrackNPCSpawns\", function(npc, zone, group)\n    -- Track spawn\n    local spawns = lia.data.get(\"npc_spawns\", 0)\n    lia.data.set(\"npc_spawns\", spawns + 1)\n\n    lia.log.add(nil, \"npcSpawned\", npc, zone, group)\nend)\n\n-- Apply NPC spawn effects\nhook.Add(\"OnNPCSpawned\", \"NPCSpawnEffects\", function(npc, zone, group)\n    -- Create spawn effect\n    local effect = EffectData()\n    effect:SetOrigin(npc:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play spawn sound\n    npc:EmitSound(\"ui/buttonclick.wav\", 75, 100)\nend)\n\n-- Track NPC spawn statistics\nhook.Add(\"OnNPCSpawned\", \"TrackNPCSpawnStats\", function(npc, zone, group)\n    -- Track spawn frequency\n    local spawnFrequency = lia.data.get(\"npc_spawn_frequency\", 0)\n    lia.data.set(\"npc_spawn_frequency\", spawnFrequency + 1)\n\n    -- Track spawn patterns\n    local spawnPatterns = lia.data.get(\"npc_spawn_patterns\", {})\n    table.insert(spawnPatterns, {\n        class = npc:GetClass(),\n        group = group,\n        time = os.time()\n    })\n    lia.data.set(\"npc_spawn_patterns\", spawnPatterns)\nend)\n</code></pre>"},{"location":"modules/npcspawner/hooks/#postnpcspawn","title":"PostNPCSpawn","text":"<p>Purpose</p> <p>Called after an NPC is spawned.</p> <p>Parameters</p> <ul> <li><code>npc</code> (Entity): The spawned NPC entity.</li> <li><code>zone</code> (table): The spawn zone data.</li> <li><code>group</code> (string): The spawn group.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC spawn is complete - After <code>OnNPCSpawned</code> hook - When the spawn process is finished</p> <p>Example Usage</p> <pre><code>-- Track NPC spawn completion\nhook.Add(\"PostNPCSpawn\", \"TrackNPCSpawnCompletion\", function(npc, zone, group)\n    -- Track completion\n    local completions = lia.data.get(\"npc_spawn_completions\", 0)\n    lia.data.set(\"npc_spawn_completions\", completions + 1)\n\n    lia.log.add(nil, \"npcSpawnCompleted\", npc, zone, group)\nend)\n\n-- Apply post NPC spawn effects\nhook.Add(\"PostNPCSpawn\", \"PostNPCSpawnEffects\", function(npc, zone, group)\n    -- Create completion effect\n    local effect = EffectData()\n    effect:SetOrigin(npc:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play completion sound\n    npc:EmitSound(\"buttons/button14.wav\", 75, 100)\nend)\n\n-- Track post NPC spawn statistics\nhook.Add(\"PostNPCSpawn\", \"TrackPostNPCSpawnStats\", function(npc, zone, group)\n    -- Track completion frequency\n    local completionFrequency = lia.data.get(\"npc_spawn_completion_frequency\", 0)\n    lia.data.set(\"npc_spawn_completion_frequency\", completionFrequency + 1)\n\n    -- Track completion patterns\n    local completionPatterns = lia.data.get(\"npc_spawn_completion_patterns\", {})\n    table.insert(completionPatterns, {\n        class = npc:GetClass(),\n        group = group,\n        time = os.time()\n    })\n    lia.data.set(\"npc_spawn_completion_patterns\", completionPatterns)\nend)\n</code></pre>"},{"location":"modules/npcspawner/hooks/#postnpcspawncycle","title":"PostNPCSpawnCycle","text":"<p>Purpose</p> <p>Called after an NPC spawn cycle is complete.</p> <p>Parameters</p> <ul> <li><code>zones</code> (table): The zones that were processed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC spawn cycle is complete - After all zones have been processed - When the cycle ends</p> <p>Example Usage</p> <pre><code>-- Track NPC spawn cycle completion\nhook.Add(\"PostNPCSpawnCycle\", \"TrackNPCSpawnCycleCompletion\", function(zones)\n    -- Track completion\n    local completions = lia.data.get(\"npc_spawn_cycle_completions\", 0)\n    lia.data.set(\"npc_spawn_cycle_completions\", completions + 1)\n\n    lia.log.add(nil, \"npcSpawnCycleCompleted\", zones)\nend)\n\n-- Apply post NPC spawn cycle effects\nhook.Add(\"PostNPCSpawnCycle\", \"PostNPCSpawnCycleEffects\", function(zones)\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"NPC spawn cycle completed!\")\n    end\nend)\n\n-- Track post NPC spawn cycle statistics\nhook.Add(\"PostNPCSpawnCycle\", \"TrackPostNPCSpawnCycleStats\", function(zones)\n    -- Track completion frequency\n    local completionFrequency = lia.data.get(\"npc_spawn_cycle_completion_frequency\", 0)\n    lia.data.set(\"npc_spawn_cycle_completion_frequency\", completionFrequency + 1)\n\n    -- Track completion patterns\n    local completionPatterns = lia.data.get(\"npc_spawn_cycle_completion_patterns\", {})\n    table.insert(completionPatterns, {\n        zones = zones,\n        time = os.time()\n    })\n    lia.data.set(\"npc_spawn_cycle_completion_patterns\", completionPatterns)\nend)\n</code></pre>"},{"location":"modules/npcspawner/hooks/#postprocessnpczone","title":"PostProcessNPCZone","text":"<p>Purpose</p> <p>Called after an NPC zone is processed.</p> <p>Parameters</p> <ul> <li><code>zone</code> (table): The spawn zone data.</li> <li><code>group</code> (string): The spawn group.</li> <li><code>spawned</code> (number): The number of NPCs spawned.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC zone is processed - After <code>PreProcessNPCZone</code> hook - When the zone processing is complete</p> <p>Example Usage</p> <pre><code>-- Track NPC zone processing completion\nhook.Add(\"PostProcessNPCZone\", \"TrackNPCZoneProcessingCompletion\", function(zone, group, spawned)\n    -- Track completion\n    local completions = lia.data.get(\"npc_zone_processing_completions\", 0)\n    lia.data.set(\"npc_zone_processing_completions\", completions + 1)\n\n    lia.log.add(nil, \"npcZoneProcessingCompleted\", zone, group, spawned)\nend)\n\n-- Apply post process NPC zone effects\nhook.Add(\"PostProcessNPCZone\", \"PostProcessNPCZoneEffects\", function(zone, group, spawned)\n    -- Create completion effect\n    local effect = EffectData()\n    effect:SetOrigin(zone.pos)\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"NPC zone processed: \" .. group .. \" (\" .. spawned .. \" NPCs)!\")\n    end\nend)\n\n-- Track post process NPC zone statistics\nhook.Add(\"PostProcessNPCZone\", \"TrackPostProcessNPCZoneStats\", function(zone, group, spawned)\n    -- Track completion frequency\n    local completionFrequency = lia.data.get(\"npc_zone_processing_completion_frequency\", 0)\n    lia.data.set(\"npc_zone_processing_completion_frequency\", completionFrequency + 1)\n\n    -- Track completion patterns\n    local completionPatterns = lia.data.get(\"npc_zone_processing_completion_patterns\", {})\n    table.insert(completionPatterns, {\n        group = group,\n        spawned = spawned,\n        time = os.time()\n    })\n    lia.data.set(\"npc_zone_processing_completion_patterns\", completionPatterns)\nend)\n</code></pre>"},{"location":"modules/npcspawner/hooks/#prenpcspawn","title":"PreNPCSpawn","text":"<p>Purpose</p> <p>Called before an NPC is spawned.</p> <p>Parameters</p> <ul> <li><code>zone</code> (table): The spawn zone data.</li> <li><code>npcType</code> (string): The NPC type to spawn.</li> <li><code>group</code> (string): The spawn group.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC is about to spawn - After <code>CanNPCSpawn</code> hook - Before <code>OnNPCSpawned</code> hook</p> <p>Example Usage</p> <pre><code>-- Track NPC spawn preparation\nhook.Add(\"PreNPCSpawn\", \"TrackNPCSpawnPreparation\", function(zone, npcType, group)\n    -- Track preparation\n    local preparations = lia.data.get(\"npc_spawn_preparations\", 0)\n    lia.data.set(\"npc_spawn_preparations\", preparations + 1)\n\n    lia.log.add(nil, \"npcSpawnPrepared\", zone, npcType, group)\nend)\n\n-- Apply pre NPC spawn effects\nhook.Add(\"PreNPCSpawn\", \"PreNPCSpawnEffects\", function(zone, npcType, group)\n    -- Create preparation effect\n    local effect = EffectData()\n    effect:SetOrigin(zone.pos)\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Preparing NPC spawn: \" .. npcType .. \"!\")\n    end\nend)\n\n-- Track pre NPC spawn statistics\nhook.Add(\"PreNPCSpawn\", \"TrackPreNPCSpawnStats\", function(zone, npcType, group)\n    -- Track preparation frequency\n    local preparationFrequency = lia.data.get(\"npc_spawn_preparation_frequency\", 0)\n    lia.data.set(\"npc_spawn_preparation_frequency\", preparationFrequency + 1)\n\n    -- Track preparation patterns\n    local preparationPatterns = lia.data.get(\"npc_spawn_preparation_patterns\", {})\n    table.insert(preparationPatterns, {\n        npcType = npcType,\n        group = group,\n        time = os.time()\n    })\n    lia.data.set(\"npc_spawn_preparation_patterns\", preparationPatterns)\nend)\n</code></pre>"},{"location":"modules/npcspawner/hooks/#prenpcspawncycle","title":"PreNPCSpawnCycle","text":"<p>Purpose</p> <p>Called before an NPC spawn cycle begins.</p> <p>Parameters</p> <ul> <li><code>zones</code> (table): The zones that will be processed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC spawn cycle is about to begin - Before any zones are processed - When the cycle starts</p> <p>Example Usage</p> <pre><code>-- Track NPC spawn cycle preparation\nhook.Add(\"PreNPCSpawnCycle\", \"TrackNPCSpawnCyclePreparation\", function(zones)\n    -- Track preparation\n    local preparations = lia.data.get(\"npc_spawn_cycle_preparations\", 0)\n    lia.data.set(\"npc_spawn_cycle_preparations\", preparations + 1)\n\n    lia.log.add(nil, \"npcSpawnCyclePrepared\", zones)\nend)\n\n-- Apply pre NPC spawn cycle effects\nhook.Add(\"PreNPCSpawnCycle\", \"PreNPCSpawnCycleEffects\", function(zones)\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Preparing NPC spawn cycle...\")\n    end\nend)\n\n-- Track pre NPC spawn cycle statistics\nhook.Add(\"PreNPCSpawnCycle\", \"TrackPreNPCSpawnCycleStats\", function(zones)\n    -- Track preparation frequency\n    local preparationFrequency = lia.data.get(\"npc_spawn_cycle_preparation_frequency\", 0)\n    lia.data.set(\"npc_spawn_cycle_preparation_frequency\", preparationFrequency + 1)\n\n    -- Track preparation patterns\n    local preparationPatterns = lia.data.get(\"npc_spawn_cycle_preparation_patterns\", {})\n    table.insert(preparationPatterns, {\n        zones = zones,\n        time = os.time()\n    })\n    lia.data.set(\"npc_spawn_cycle_preparation_patterns\", preparationPatterns)\nend)\n</code></pre>"},{"location":"modules/npcspawner/hooks/#preprocessnpczone","title":"PreProcessNPCZone","text":"<p>Purpose</p> <p>Called before an NPC zone is processed.</p> <p>Parameters</p> <ul> <li><code>zone</code> (table): The spawn zone data.</li> <li><code>group</code> (string): The spawn group.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An NPC zone is about to be processed - Before any NPCs are spawned - When the zone processing begins</p> <p>Example Usage</p> <pre><code>-- Track NPC zone processing preparation\nhook.Add(\"PreProcessNPCZone\", \"TrackNPCZoneProcessingPreparation\", function(zone, group)\n    -- Track preparation\n    local preparations = lia.data.get(\"npc_zone_processing_preparations\", 0)\n    lia.data.set(\"npc_zone_processing_preparations\", preparations + 1)\n\n    lia.log.add(nil, \"npcZoneProcessingPrepared\", zone, group)\nend)\n\n-- Apply pre process NPC zone effects\nhook.Add(\"PreProcessNPCZone\", \"PreProcessNPCZoneEffects\", function(zone, group)\n    -- Create preparation effect\n    local effect = EffectData()\n    effect:SetOrigin(zone.pos)\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Notify all players\n    for _, client in player.Iterator() do\n        client:notify(\"Preparing NPC zone processing: \" .. group .. \"!\")\n    end\nend)\n\n-- Track pre process NPC zone statistics\nhook.Add(\"PreProcessNPCZone\", \"TrackPreProcessNPCZoneStats\", function(zone, group)\n    -- Track preparation frequency\n    local preparationFrequency = lia.data.get(\"npc_zone_processing_preparation_frequency\", 0)\n    lia.data.set(\"npc_zone_processing_preparation_frequency\", preparationFrequency + 1)\n\n    -- Track preparation patterns\n    local preparationPatterns = lia.data.get(\"npc_zone_processing_preparation_patterns\", {})\n    table.insert(preparationPatterns, {\n        group = group,\n        time = os.time()\n    })\n    lia.data.set(\"npc_zone_processing_preparation_patterns\", preparationPatterns)\nend)\n</code></pre>"},{"location":"modules/permaremove/about/","title":"About","text":"About <p>Name: Perma Remove</p> <p>Description:</p> <p>Adds ability to permanently delete map entities, logging for each removed entity, an admin-only command, confirmation prompts before removal, and restore list to undo mistakes.</p> Features <ul> <li>Adds ability to permanently delete map entities</li> <li>Adds logging for each removed entity</li> <li>Adds an admin-only command</li> <li>Adds confirmation prompts before removal</li> <li>Adds restore list to undo mistakes</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/permaremove/changelog/","title":"Changelog","text":""},{"location":"modules/permaremove/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/permaremove/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/permaremove/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Perma Remove module for managing permanent entity removal functionality.</p>"},{"location":"modules/permaremove/hooks/#canpermaremoveentity","title":"CanPermaRemoveEntity","text":"<p>Purpose</p> <p>Called to determine if an entity can be permanently removed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to remove the entity.</li> <li><code>entity</code> (Entity): The entity being removed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player attempts to permanently remove an entity - Before <code>OnPermaRemoveEntity</code> hook - When the removal validation begins</p> <p>Example Usage</p> <pre><code>-- Control perma remove entity\nhook.Add(\"CanPermaRemoveEntity\", \"ControlPermaRemoveEntity\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Check if perma remove is disabled\n        if char:getData(\"perma_remove_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if entity is protected\n        if entity:getData(\"protected\", false) then\n            return false\n        end\n\n        -- Check if entity is important\n        if entity:getData(\"important\", false) then\n            return false\n        end\n\n        -- Check cooldown\n        local lastPermaRemove = char:getData(\"last_perma_remove_time\", 0)\n        if os.time() - lastPermaRemove &lt; 5 then -- 5 second cooldown\n            return false\n        end\n\n        -- Update last perma remove time\n        char:setData(\"last_perma_remove_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track perma remove entity attempts\nhook.Add(\"CanPermaRemoveEntity\", \"TrackPermaRemoveEntityAttempts\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        local removeAttempts = char:getData(\"perma_remove_attempts\", 0)\n        char:setData(\"perma_remove_attempts\", removeAttempts + 1)\n    end\n\n    lia.log.add(client, \"permaRemoveEntityAttempted\", entity)\nend)\n\n-- Apply perma remove entity check effects\nhook.Add(\"CanPermaRemoveEntity\", \"PermaRemoveEntityCheckEffects\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Check if perma remove is disabled\n        if char:getData(\"perma_remove_disabled\", false) then\n            client:notify(\"Perma remove is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/permaremove/hooks/#onpermaremoveentity","title":"OnPermaRemoveEntity","text":"<p>Purpose</p> <p>Called when an entity is permanently removed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who removed the entity.</li> <li><code>entity</code> (Entity): The entity that was removed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - An entity is permanently removed - After <code>CanPermaRemoveEntity</code> hook - When the removal is complete</p> <p>Example Usage</p> <pre><code>-- Track perma remove entity\nhook.Add(\"OnPermaRemoveEntity\", \"TrackPermaRemoveEntity\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        local removeCount = char:getData(\"perma_remove_count\", 0)\n        char:setData(\"perma_remove_count\", removeCount + 1)\n    end\n\n    lia.log.add(client, \"permaRemoveEntity\", entity)\nend)\n\n-- Apply perma remove entity effects\nhook.Add(\"OnPermaRemoveEntity\", \"PermaRemoveEntityEffects\", function(client, entity)\n    -- Play removal sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Entity permanently removed!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(entity:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track perma remove entity statistics\nhook.Add(\"OnPermaRemoveEntity\", \"TrackPermaRemoveEntityStats\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Track removal frequency\n        local removalFrequency = char:getData(\"perma_remove_frequency\", 0)\n        char:setData(\"perma_remove_frequency\", removalFrequency + 1)\n\n        -- Track removal patterns\n        local removalPatterns = char:getData(\"perma_remove_patterns\", {})\n        table.insert(removalPatterns, {\n            class = entity:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"perma_remove_patterns\", removalPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/permaremove/hooks/#onpermaremoveloaded","title":"OnPermaRemoveLoaded","text":"<p>Purpose</p> <p>Called when a perma remove entity is loaded from data.</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The entity that was loaded for removal.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A perma remove entity is loaded from data - During data loading process - When the entity is restored for removal</p> <p>Example Usage</p> <pre><code>-- Track perma remove loaded\nhook.Add(\"OnPermaRemoveLoaded\", \"TrackPermaRemoveLoaded\", function(entity)\n    -- Track loaded\n    local loaded = lia.data.get(\"perma_remove_loaded\", 0)\n    lia.data.set(\"perma_remove_loaded\", loaded + 1)\n\n    lia.log.add(nil, \"permaRemoveLoaded\", entity)\nend)\n\n-- Apply perma remove loaded effects\nhook.Add(\"OnPermaRemoveLoaded\", \"PermaRemoveLoadedEffects\", function(entity)\n    -- Create loaded effect\n    local effect = EffectData()\n    effect:SetOrigin(entity:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Play loaded sound\n    entity:EmitSound(\"ui/buttonclick.wav\", 75, 100)\nend)\n\n-- Track perma remove loaded statistics\nhook.Add(\"OnPermaRemoveLoaded\", \"TrackPermaRemoveLoadedStats\", function(entity)\n    -- Track loaded frequency\n    local loadedFrequency = lia.data.get(\"perma_remove_loaded_frequency\", 0)\n    lia.data.set(\"perma_remove_loaded_frequency\", loadedFrequency + 1)\n\n    -- Track loaded patterns\n    local loadedPatterns = lia.data.get(\"perma_remove_loaded_patterns\", {})\n    table.insert(loadedPatterns, {\n        class = entity:GetClass(),\n        time = os.time()\n    })\n    lia.data.set(\"perma_remove_loaded_patterns\", loadedPatterns)\nend)\n</code></pre>"},{"location":"modules/radio/about/","title":"About","text":"About <p>Name: Radio</p> <p>Description:</p> <p>Adds a radio chat channel for players, font configuration via RadioFont, workshop models for radios, frequency channels for groups, and handheld radio items.</p> Features <ul> <li>Adds a radio chat channel for players</li> <li>Adds font configuration via RadioFont</li> <li>Adds workshop models for radios</li> <li>Adds frequency channels for groups</li> <li>Adds handheld radio items</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/radio/changelog/","title":"Changelog","text":""},{"location":"modules/radio/changelog/#version-13","title":"Version 1.3","text":"<ul> <li>Updated: Shared library functions and language files for all supported languages (English, French, German, Italian, Portuguese, Spanish)</li> <li>Changed: Configuration and shared library optimizations</li> </ul>"},{"location":"modules/radio/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/radio/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/radio/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/radio/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Radio module for managing radio communication functionality.</p>"},{"location":"modules/radio/hooks/#canhearradio","title":"CanHearRadio","text":"<p>Purpose</p> <p>Called to determine if a player can hear radio communication.</p> <p>Parameters</p> <ul> <li><code>listener</code> (Player): The player who would hear the radio.</li> <li><code>speaker</code> (Player): The player who is speaking on radio.</li> <li><code>freq</code> (string): The radio frequency.</li> <li><code>channel</code> (number): The radio channel.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player attempts to hear radio communication - During radio chat processing - When the hearing validation begins</p> <p>Example Usage</p> <pre><code>-- Control radio hearing\nhook.Add(\"CanHearRadio\", \"ControlRadioHearing\", function(listener, speaker, freq, channel)\n    local char = listener:getChar()\n    if char then\n        -- Check if radio hearing is disabled\n        if char:getData(\"radio_hearing_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if listener:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if listener:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check if player is handcuffed\n        if listener:IsHandcuffed() then\n            return false\n        end\n\n        -- Check cooldown\n        local lastRadioHear = char:getData(\"last_radio_hear_time\", 0)\n        if os.time() - lastRadioHear &lt; 1 then -- 1 second cooldown\n            return false\n        end\n\n        -- Update last radio hear time\n        char:setData(\"last_radio_hear_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track radio hearing attempts\nhook.Add(\"CanHearRadio\", \"TrackRadioHearingAttempts\", function(listener, speaker, freq, channel)\n    local char = listener:getChar()\n    if char then\n        local hearingAttempts = char:getData(\"radio_hearing_attempts\", 0)\n        char:setData(\"radio_hearing_attempts\", hearingAttempts + 1)\n    end\n\n    lia.log.add(listener, \"radioHearingAttempted\", speaker, freq, channel)\nend)\n\n-- Apply radio hearing check effects\nhook.Add(\"CanHearRadio\", \"RadioHearingCheckEffects\", function(listener, speaker, freq, channel)\n    local char = listener:getChar()\n    if char then\n        -- Check if radio hearing is disabled\n        if char:getData(\"radio_hearing_disabled\", false) then\n            listener:notify(\"Radio hearing is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/radio/hooks/#canuseradio","title":"CanUseRadio","text":"<p>Purpose</p> <p>Called to determine if a player can use radio communication.</p> <p>Parameters</p> <ul> <li><code>speaker</code> (Player): The player attempting to use radio.</li> <li><code>freq</code> (string): The radio frequency.</li> <li><code>channel</code> (number): The radio channel.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player attempts to use radio communication - During radio chat processing - When the usage validation begins</p> <p>Example Usage</p> <pre><code>-- Control radio usage\nhook.Add(\"CanUseRadio\", \"ControlRadioUsage\", function(speaker, freq, channel)\n    local char = speaker:getChar()\n    if char then\n        -- Check if radio usage is disabled\n        if char:getData(\"radio_usage_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if speaker:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if speaker:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check if player is handcuffed\n        if speaker:IsHandcuffed() then\n            return false\n        end\n\n        -- Check cooldown\n        local lastRadioUse = char:getData(\"last_radio_use_time\", 0)\n        if os.time() - lastRadioUse &lt; 1 then -- 1 second cooldown\n            return false\n        end\n\n        -- Update last radio use time\n        char:setData(\"last_radio_use_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track radio usage attempts\nhook.Add(\"CanUseRadio\", \"TrackRadioUsageAttempts\", function(speaker, freq, channel)\n    local char = speaker:getChar()\n    if char then\n        local usageAttempts = char:getData(\"radio_usage_attempts\", 0)\n        char:setData(\"radio_usage_attempts\", usageAttempts + 1)\n    end\n\n    lia.log.add(speaker, \"radioUsageAttempted\", freq, channel)\nend)\n\n-- Apply radio usage check effects\nhook.Add(\"CanUseRadio\", \"RadioUsageCheckEffects\", function(speaker, freq, channel)\n    local char = speaker:getChar()\n    if char then\n        -- Check if radio usage is disabled\n        if char:getData(\"radio_usage_disabled\", false) then\n            speaker:notify(\"Radio usage is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/radio/hooks/#onradiodisabled","title":"OnRadioDisabled","text":"<p>Purpose</p> <p>Called when a radio is disabled.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose radio was disabled.</li> <li><code>item</code> (Item): The radio item that was disabled.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A radio is disabled - During radio item processing - When the radio is turned off</p> <p>Example Usage</p> <pre><code>-- Track radio disabled\nhook.Add(\"OnRadioDisabled\", \"TrackRadioDisabled\", function(client, item)\n    local char = client:getChar()\n    if char then\n        local radioDisabled = char:getData(\"radio_disabled\", 0)\n        char:setData(\"radio_disabled\", radioDisabled + 1)\n    end\n\n    lia.log.add(client, \"radioDisabled\", item)\nend)\n\n-- Apply radio disabled effects\nhook.Add(\"OnRadioDisabled\", \"RadioDisabledEffects\", function(client, item)\n    -- Play disabled sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Radio disabled!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track radio disabled statistics\nhook.Add(\"OnRadioDisabled\", \"TrackRadioDisabledStats\", function(client, item)\n    local char = client:getChar()\n    if char then\n        -- Track disabled frequency\n        local disabledFrequency = char:getData(\"radio_disabled_frequency\", 0)\n        char:setData(\"radio_disabled_frequency\", disabledFrequency + 1)\n\n        -- Track disabled patterns\n        local disabledPatterns = char:getData(\"radio_disabled_patterns\", {})\n        table.insert(disabledPatterns, {\n            item = item:getID(),\n            time = os.time()\n        })\n        char:setData(\"radio_disabled_patterns\", disabledPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/radio/hooks/#onradioenabled","title":"OnRadioEnabled","text":"<p>Purpose</p> <p>Called when a radio is enabled.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose radio was enabled.</li> <li><code>item</code> (Item): The radio item that was enabled.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A radio is enabled - During radio item processing - When the radio is turned on</p> <p>Example Usage</p> <pre><code>-- Track radio enabled\nhook.Add(\"OnRadioEnabled\", \"TrackRadioEnabled\", function(client, item)\n    local char = client:getChar()\n    if char then\n        local radioEnabled = char:getData(\"radio_enabled\", 0)\n        char:setData(\"radio_enabled\", radioEnabled + 1)\n    end\n\n    lia.log.add(client, \"radioEnabled\", item)\nend)\n\n-- Apply radio enabled effects\nhook.Add(\"OnRadioEnabled\", \"RadioEnabledEffects\", function(client, item)\n    -- Play enabled sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Radio enabled!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track radio enabled statistics\nhook.Add(\"OnRadioEnabled\", \"TrackRadioEnabledStats\", function(client, item)\n    local char = client:getChar()\n    if char then\n        -- Track enabled frequency\n        local enabledFrequency = char:getData(\"radio_enabled_frequency\", 0)\n        char:setData(\"radio_enabled_frequency\", enabledFrequency + 1)\n\n        -- Track enabled patterns\n        local enabledPatterns = char:getData(\"radio_enabled_patterns\", {})\n        table.insert(enabledPatterns, {\n            item = item:getID(),\n            time = os.time()\n        })\n        char:setData(\"radio_enabled_patterns\", enabledPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/radio/hooks/#onradiofrequencychanged","title":"OnRadioFrequencyChanged","text":"<p>Purpose</p> <p>Called when a radio frequency is changed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose radio frequency was changed.</li> <li><code>item</code> (Item): The radio item whose frequency was changed.</li> <li><code>freq</code> (string): The new frequency.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A radio frequency is changed - During radio item processing - When the frequency is updated</p> <p>Example Usage</p> <pre><code>-- Track radio frequency changes\nhook.Add(\"OnRadioFrequencyChanged\", \"TrackRadioFrequencyChanges\", function(client, item, freq)\n    local char = client:getChar()\n    if char then\n        local frequencyChanges = char:getData(\"radio_frequency_changes\", 0)\n        char:setData(\"radio_frequency_changes\", frequencyChanges + 1)\n    end\n\n    lia.log.add(client, \"radioFrequencyChanged\", item, freq)\nend)\n\n-- Apply radio frequency change effects\nhook.Add(\"OnRadioFrequencyChanged\", \"RadioFrequencyChangeEffects\", function(client, item, freq)\n    -- Play frequency change sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Radio frequency changed to: \" .. freq .. \"!\")\nend)\n\n-- Track radio frequency change statistics\nhook.Add(\"OnRadioFrequencyChanged\", \"TrackRadioFrequencyChangeStats\", function(client, item, freq)\n    local char = client:getChar()\n    if char then\n        -- Track frequency change frequency\n        local frequencyChangeFrequency = char:getData(\"radio_frequency_change_frequency\", 0)\n        char:setData(\"radio_frequency_change_frequency\", frequencyChangeFrequency + 1)\n\n        -- Track frequency change patterns\n        local frequencyChangePatterns = char:getData(\"radio_frequency_change_patterns\", {})\n        table.insert(frequencyChangePatterns, {\n            item = item:getID(),\n            freq = freq,\n            time = os.time()\n        })\n        char:setData(\"radio_frequency_change_patterns\", frequencyChangePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/radio/hooks/#onradiosabotaged","title":"OnRadioSabotaged","text":"<p>Purpose</p> <p>Called when a radio is sabotaged.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose radio was sabotaged.</li> <li><code>item</code> (Item): The radio item that was sabotaged.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A radio is sabotaged - During radio item processing - When the radio is damaged</p> <p>Example Usage</p> <pre><code>-- Track radio sabotaged\nhook.Add(\"OnRadioSabotaged\", \"TrackRadioSabotaged\", function(client, item)\n    local char = client:getChar()\n    if char then\n        local radioSabotaged = char:getData(\"radio_sabotaged\", 0)\n        char:setData(\"radio_sabotaged\", radioSabotaged + 1)\n    end\n\n    lia.log.add(client, \"radioSabotaged\", item)\nend)\n\n-- Apply radio sabotaged effects\nhook.Add(\"OnRadioSabotaged\", \"RadioSabotagedEffects\", function(client, item)\n    -- Play sabotaged sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Radio sabotaged!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track radio sabotaged statistics\nhook.Add(\"OnRadioSabotaged\", \"TrackRadioSabotagedStats\", function(client, item)\n    local char = client:getChar()\n    if char then\n        -- Track sabotaged frequency\n        local sabotagedFrequency = char:getData(\"radio_sabotaged_frequency\", 0)\n        char:setData(\"radio_sabotaged_frequency\", sabotagedFrequency + 1)\n\n        -- Track sabotaged patterns\n        local sabotagedPatterns = char:getData(\"radio_sabotaged_patterns\", {})\n        table.insert(sabotagedPatterns, {\n            item = item:getID(),\n            time = os.time()\n        })\n        char:setData(\"radio_sabotaged_patterns\", sabotagedPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/radio/hooks/#playerfinishradio","title":"PlayerFinishRadio","text":"<p>Purpose</p> <p>Called when a player finishes using radio.</p> <p>Parameters</p> <ul> <li><code>listener</code> (Player): The player who finished using radio.</li> <li><code>freq</code> (string): The radio frequency.</li> <li><code>channel</code> (number): The radio channel.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player finishes using radio - After radio communication ends - When the radio session is complete</p> <p>Example Usage</p> <pre><code>-- Track player finish radio\nhook.Add(\"PlayerFinishRadio\", \"TrackPlayerFinishRadio\", function(listener, freq, channel)\n    local char = listener:getChar()\n    if char then\n        local finishRadio = char:getData(\"finish_radio\", 0)\n        char:setData(\"finish_radio\", finishRadio + 1)\n    end\n\n    lia.log.add(listener, \"playerFinishRadio\", freq, channel)\nend)\n\n-- Apply player finish radio effects\nhook.Add(\"PlayerFinishRadio\", \"PlayerFinishRadioEffects\", function(listener, freq, channel)\n    -- Play finish sound\n    listener:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    listener:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    listener:notify(\"Radio session finished!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(listener:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track player finish radio statistics\nhook.Add(\"PlayerFinishRadio\", \"TrackPlayerFinishRadioStats\", function(listener, freq, channel)\n    local char = listener:getChar()\n    if char then\n        -- Track finish frequency\n        local finishFrequency = char:getData(\"finish_radio_frequency\", 0)\n        char:setData(\"finish_radio_frequency\", finishFrequency + 1)\n\n        -- Track finish patterns\n        local finishPatterns = char:getData(\"finish_radio_patterns\", {})\n        table.insert(finishPatterns, {\n            freq = freq,\n            channel = channel,\n            time = os.time()\n        })\n        char:setData(\"finish_radio_patterns\", finishPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/radio/hooks/#playerstartradio","title":"PlayerStartRadio","text":"<p>Purpose</p> <p>Called when a player starts using radio.</p> <p>Parameters</p> <ul> <li><code>speaker</code> (Player): The player who started using radio.</li> <li><code>freq</code> (string): The radio frequency.</li> <li><code>channel</code> (number): The radio channel.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player starts using radio - Before radio communication begins - When the radio session starts</p> <p>Example Usage</p> <pre><code>-- Track player start radio\nhook.Add(\"PlayerStartRadio\", \"TrackPlayerStartRadio\", function(speaker, freq, channel)\n    local char = speaker:getChar()\n    if char then\n        local startRadio = char:getData(\"start_radio\", 0)\n        char:setData(\"start_radio\", startRadio + 1)\n    end\n\n    lia.log.add(speaker, \"playerStartRadio\", freq, channel)\nend)\n\n-- Apply player start radio effects\nhook.Add(\"PlayerStartRadio\", \"PlayerStartRadioEffects\", function(speaker, freq, channel)\n    -- Play start sound\n    speaker:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    speaker:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    speaker:notify(\"Radio session started!\")\nend)\n\n-- Track player start radio statistics\nhook.Add(\"PlayerStartRadio\", \"TrackPlayerStartRadioStats\", function(speaker, freq, channel)\n    local char = speaker:getChar()\n    if char then\n        -- Track start frequency\n        local startFrequency = char:getData(\"start_radio_frequency\", 0)\n        char:setData(\"start_radio_frequency\", startFrequency + 1)\n\n        -- Track start patterns\n        local startPatterns = char:getData(\"start_radio_patterns\", {})\n        table.insert(startPatterns, {\n            freq = freq,\n            channel = channel,\n            time = os.time()\n        })\n        char:setData(\"start_radio_patterns\", startPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/radio/hooks/#shouldradiobeep","title":"ShouldRadioBeep","text":"<p>Purpose</p> <p>Called to determine if a radio should beep.</p> <p>Parameters</p> <ul> <li><code>listener</code> (Player): The player who would hear the beep.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A radio beep is about to be played - During radio communication - When the beep validation begins</p> <p>Example Usage</p> <pre><code>-- Control radio beep\nhook.Add(\"ShouldRadioBeep\", \"ControlRadioBeep\", function(listener)\n    local char = listener:getChar()\n    if char then\n        -- Check if radio beep is disabled\n        if char:getData(\"radio_beep_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if listener:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if listener:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check cooldown\n        local lastRadioBeep = char:getData(\"last_radio_beep_time\", 0)\n        if os.time() - lastRadioBeep &lt; 0.5 then -- 0.5 second cooldown\n            return false\n        end\n\n        -- Update last radio beep time\n        char:setData(\"last_radio_beep_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track radio beep checks\nhook.Add(\"ShouldRadioBeep\", \"TrackRadioBeepChecks\", function(listener)\n    local char = listener:getChar()\n    if char then\n        local beepChecks = char:getData(\"radio_beep_checks\", 0)\n        char:setData(\"radio_beep_checks\", beepChecks + 1)\n    end\n\n    lia.log.add(listener, \"radioBeepChecked\")\nend)\n\n-- Apply radio beep check effects\nhook.Add(\"ShouldRadioBeep\", \"RadioBeepCheckEffects\", function(listener)\n    local char = listener:getChar()\n    if char then\n        -- Check if radio beep is disabled\n        if char:getData(\"radio_beep_disabled\", false) then\n            listener:notify(\"Radio beep is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/raisedweapons/about/","title":"About","text":"About <p>Name: Raised Weapons</p> <p>Description:</p> <p>Adds auto-lowering of weapons when running, a raise delay set by WeaponRaiseSpeed, prevention of accidental fire, a toggle to keep weapons lowered, and compatibility with melee weapons.</p> Features <ul> <li>Adds auto-lowering of weapons when running</li> <li>Adds a raise delay set by WeaponRaiseSpeed</li> <li>Adds prevention of accidental fire</li> <li>Adds a toggle to keep weapons lowered</li> <li>Adds compatibility with melee weapons</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/raisedweapons/changelog/","title":"Changelog","text":""},{"location":"modules/raisedweapons/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/raisedweapons/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/raisedweapons/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/raisedweapons/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Raised Weapons module for managing weapon raising and lowering functionality.</p>"},{"location":"modules/raisedweapons/hooks/#onweaponlowered","title":"OnWeaponLowered","text":"<p>Purpose</p> <p>Called when a weapon is lowered.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose weapon was lowered.</li> <li><code>weapon</code> (Weapon): The weapon that was lowered.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A weapon is lowered - After <code>PlayerWeaponRaisedChanged</code> hook - When the weapon state changes to lowered</p> <p>Example Usage</p> <pre><code>-- Track weapon lowered\nhook.Add(\"OnWeaponLowered\", \"TrackWeaponLowered\", function(player, weapon)\n    local char = player:getChar()\n    if char then\n        local weaponLowered = char:getData(\"weapon_lowered\", 0)\n        char:setData(\"weapon_lowered\", weaponLowered + 1)\n    end\n\n    lia.log.add(player, \"weaponLowered\", weapon)\nend)\n\n-- Apply weapon lowered effects\nhook.Add(\"OnWeaponLowered\", \"WeaponLoweredEffects\", function(player, weapon)\n    -- Play lowered sound\n    player:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"Weapon lowered!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track weapon lowered statistics\nhook.Add(\"OnWeaponLowered\", \"TrackWeaponLoweredStats\", function(player, weapon)\n    local char = player:getChar()\n    if char then\n        -- Track lowered frequency\n        local loweredFrequency = char:getData(\"weapon_lowered_frequency\", 0)\n        char:setData(\"weapon_lowered_frequency\", loweredFrequency + 1)\n\n        -- Track lowered patterns\n        local loweredPatterns = char:getData(\"weapon_lowered_patterns\", {})\n        table.insert(loweredPatterns, {\n            weapon = weapon:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"weapon_lowered_patterns\", loweredPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/raisedweapons/hooks/#onweaponraised","title":"OnWeaponRaised","text":"<p>Purpose</p> <p>Called when a weapon is raised.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose weapon was raised.</li> <li><code>weapon</code> (Weapon): The weapon that was raised.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A weapon is raised - After <code>PlayerWeaponRaisedChanged</code> hook - When the weapon state changes to raised</p> <p>Example Usage</p> <pre><code>-- Track weapon raised\nhook.Add(\"OnWeaponRaised\", \"TrackWeaponRaised\", function(player, weapon)\n    local char = player:getChar()\n    if char then\n        local weaponRaised = char:getData(\"weapon_raised\", 0)\n        char:setData(\"weapon_raised\", weaponRaised + 1)\n    end\n\n    lia.log.add(player, \"weaponRaised\", weapon)\nend)\n\n-- Apply weapon raised effects\nhook.Add(\"OnWeaponRaised\", \"WeaponRaisedEffects\", function(player, weapon)\n    -- Play raised sound\n    player:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"Weapon raised!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track weapon raised statistics\nhook.Add(\"OnWeaponRaised\", \"TrackWeaponRaisedStats\", function(player, weapon)\n    local char = player:getChar()\n    if char then\n        -- Track raised frequency\n        local raisedFrequency = char:getData(\"weapon_raised_frequency\", 0)\n        char:setData(\"weapon_raised_frequency\", raisedFrequency + 1)\n\n        -- Track raised patterns\n        local raisedPatterns = char:getData(\"weapon_raised_patterns\", {})\n        table.insert(raisedPatterns, {\n            weapon = weapon:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"weapon_raised_patterns\", raisedPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/raisedweapons/hooks/#overrideweaponraisespeed","title":"OverrideWeaponRaiseSpeed","text":"<p>Purpose</p> <p>Called to override the weapon raise speed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose weapon raise speed is being set.</li> <li><code>raiseSpeed</code> (number): The current raise speed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A weapon raise speed is being set - During weapon raising/lowering - When the speed calculation begins</p> <p>Example Usage</p> <pre><code>-- Override weapon raise speed\nhook.Add(\"OverrideWeaponRaiseSpeed\", \"OverrideWeaponRaiseSpeed\", function(client, raiseSpeed)\n    local char = client:getChar()\n    if char then\n        -- Check if player has speed modifier\n        local speedModifier = char:getData(\"weapon_raise_speed_modifier\", 1)\n        if speedModifier ~= 1 then\n            return raiseSpeed * speedModifier\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return raiseSpeed * 0.5 -- Slower in restricted areas\n        end\n\n        -- Check if player is in water\n        if client:WaterLevel() &gt;= 2 then\n            return raiseSpeed * 0.75 -- Slower in water\n        end\n\n        -- Check if player is handcuffed\n        if client:IsHandcuffed() then\n            return raiseSpeed * 0.25 -- Much slower when handcuffed\n        end\n    end\n\n    return raiseSpeed\nend)\n\n-- Track weapon raise speed overrides\nhook.Add(\"OverrideWeaponRaiseSpeed\", \"TrackWeaponRaiseSpeedOverrides\", function(client, raiseSpeed)\n    local char = client:getChar()\n    if char then\n        local speedOverrides = char:getData(\"weapon_raise_speed_overrides\", 0)\n        char:setData(\"weapon_raise_speed_overrides\", speedOverrides + 1)\n    end\n\n    lia.log.add(client, \"weaponRaiseSpeedOverridden\", raiseSpeed)\nend)\n\n-- Apply weapon raise speed override effects\nhook.Add(\"OverrideWeaponRaiseSpeed\", \"WeaponRaiseSpeedOverrideEffects\", function(client, raiseSpeed)\n    -- Play speed override sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.1, 0)\n\n    -- Notify player\n    client:notify(\"Weapon raise speed overridden!\")\nend)\n</code></pre>"},{"location":"modules/raisedweapons/hooks/#playerweaponraisedchanged","title":"PlayerWeaponRaisedChanged","text":"<p>Purpose</p> <p>Called when a player's weapon raised state changes.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose weapon state changed.</li> <li><code>state</code> (boolean): The new raised state.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's weapon raised state changes - After <code>setWepRaised</code> is called - When the state is updated</p> <p>Example Usage</p> <pre><code>-- Track weapon raised state changes\nhook.Add(\"PlayerWeaponRaisedChanged\", \"TrackWeaponRaisedStateChanges\", function(player, state)\n    local char = player:getChar()\n    if char then\n        local stateChanges = char:getData(\"weapon_raised_state_changes\", 0)\n        char:setData(\"weapon_raised_state_changes\", stateChanges + 1)\n    end\n\n    lia.log.add(player, \"weaponRaisedStateChanged\", state)\nend)\n\n-- Apply weapon raised state change effects\nhook.Add(\"PlayerWeaponRaisedChanged\", \"WeaponRaisedStateChangeEffects\", function(player, state)\n    -- Play state change sound\n    player:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    local color = state and Color(0, 255, 0, 10) or Color(255, 0, 0, 10)\n    player:ScreenFade(SCREENFADE.IN, color, 0.3, 0)\n\n    -- Notify player\n    local status = state and \"raised\" or \"lowered\"\n    player:notify(\"Weapon \" .. status .. \"!\")\nend)\n\n-- Track weapon raised state change statistics\nhook.Add(\"PlayerWeaponRaisedChanged\", \"TrackWeaponRaisedStateChangeStats\", function(player, state)\n    local char = player:getChar()\n    if char then\n        -- Track state change frequency\n        local stateChangeFrequency = char:getData(\"weapon_raised_state_change_frequency\", 0)\n        char:setData(\"weapon_raised_state_change_frequency\", stateChangeFrequency + 1)\n\n        -- Track state change patterns\n        local stateChangePatterns = char:getData(\"weapon_raised_state_change_patterns\", {})\n        table.insert(stateChangePatterns, {\n            state = state,\n            time = os.time()\n        })\n        char:setData(\"weapon_raised_state_change_patterns\", stateChangePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/raisedweapons/hooks/#shouldweaponberaised","title":"ShouldWeaponBeRaised","text":"<p>Purpose</p> <p>Called to determine if a weapon should be raised.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose weapon is being checked.</li> <li><code>weapon</code> (Weapon): The weapon being checked.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A weapon raise state is being checked - During <code>isWepRaised</code> calls - When the state validation begins</p> <p>Example Usage</p> <pre><code>-- Control weapon raising\nhook.Add(\"ShouldWeaponBeRaised\", \"ControlWeaponRaising\", function(player, weapon)\n    local char = player:getChar()\n    if char then\n        -- Check if weapon raising is disabled\n        if char:getData(\"weapon_raising_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if player:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if player:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check if player is handcuffed\n        if player:IsHandcuffed() then\n            return false\n        end\n\n        -- Check if weapon is restricted\n        if weapon:getData(\"restricted\", false) then\n            return false\n        end\n    end\n\n    return nil -- Let default logic handle it\nend)\n\n-- Track weapon raising checks\nhook.Add(\"ShouldWeaponBeRaised\", \"TrackWeaponRaisingChecks\", function(player, weapon)\n    local char = player:getChar()\n    if char then\n        local raisingChecks = char:getData(\"weapon_raising_checks\", 0)\n        char:setData(\"weapon_raising_checks\", raisingChecks + 1)\n    end\n\n    lia.log.add(player, \"weaponRaisingChecked\", weapon)\nend)\n\n-- Apply weapon raising check effects\nhook.Add(\"ShouldWeaponBeRaised\", \"WeaponRaisingCheckEffects\", function(player, weapon)\n    local char = player:getChar()\n    if char then\n        -- Check if weapon raising is disabled\n        if char:getData(\"weapon_raising_disabled\", false) then\n            player:notify(\"Weapon raising is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/raisedweapons/hooks/#weaponholstercancelled","title":"WeaponHolsterCancelled","text":"<p>Purpose</p> <p>Called when a weapon holster is cancelled.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose weapon holster was cancelled.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A weapon holster is cancelled - During weapon holster processing - When the holster is interrupted</p> <p>Example Usage</p> <pre><code>-- Track weapon holster cancellations\nhook.Add(\"WeaponHolsterCancelled\", \"TrackWeaponHolsterCancellations\", function(client)\n    local char = client:getChar()\n    if char then\n        local holsterCancellations = char:getData(\"weapon_holster_cancellations\", 0)\n        char:setData(\"weapon_holster_cancellations\", holsterCancellations + 1)\n    end\n\n    lia.log.add(client, \"weaponHolsterCancelled\")\nend)\n\n-- Apply weapon holster cancellation effects\nhook.Add(\"WeaponHolsterCancelled\", \"WeaponHolsterCancellationEffects\", function(client)\n    -- Play cancellation sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Weapon holster cancelled!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track weapon holster cancellation statistics\nhook.Add(\"WeaponHolsterCancelled\", \"TrackWeaponHolsterCancellationStats\", function(client)\n    local char = client:getChar()\n    if char then\n        -- Track cancellation frequency\n        local cancellationFrequency = char:getData(\"weapon_holster_cancellation_frequency\", 0)\n        char:setData(\"weapon_holster_cancellation_frequency\", cancellationFrequency + 1)\n\n        -- Track cancellation patterns\n        local cancellationPatterns = char:getData(\"weapon_holster_cancellation_patterns\", {})\n        table.insert(cancellationPatterns, {\n            time = os.time()\n        })\n        char:setData(\"weapon_holster_cancellation_patterns\", cancellationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/raisedweapons/hooks/#weaponholsterscheduled","title":"WeaponHolsterScheduled","text":"<p>Purpose</p> <p>Called when a weapon holster is scheduled.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose weapon holster is scheduled.</li> <li><code>raiseSpeed</code> (number): The raise speed for the holster.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A weapon holster is scheduled - During weapon holster processing - When the holster is planned</p> <p>Example Usage</p> <pre><code>-- Track weapon holster scheduling\nhook.Add(\"WeaponHolsterScheduled\", \"TrackWeaponHolsterScheduling\", function(client, raiseSpeed)\n    local char = client:getChar()\n    if char then\n        local holsterScheduling = char:getData(\"weapon_holster_scheduling\", 0)\n        char:setData(\"weapon_holster_scheduling\", holsterScheduling + 1)\n    end\n\n    lia.log.add(client, \"weaponHolsterScheduled\", raiseSpeed)\nend)\n\n-- Apply weapon holster scheduling effects\nhook.Add(\"WeaponHolsterScheduled\", \"WeaponHolsterSchedulingEffects\", function(client, raiseSpeed)\n    -- Play scheduling sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Weapon holster scheduled!\")\nend)\n\n-- Track weapon holster scheduling statistics\nhook.Add(\"WeaponHolsterScheduled\", \"TrackWeaponHolsterSchedulingStats\", function(client, raiseSpeed)\n    local char = client:getChar()\n    if char then\n        -- Track scheduling frequency\n        local schedulingFrequency = char:getData(\"weapon_holster_scheduling_frequency\", 0)\n        char:setData(\"weapon_holster_scheduling_frequency\", schedulingFrequency + 1)\n\n        -- Track scheduling patterns\n        local schedulingPatterns = char:getData(\"weapon_holster_scheduling_patterns\", {})\n        table.insert(schedulingPatterns, {\n            raiseSpeed = raiseSpeed,\n            time = os.time()\n        })\n        char:setData(\"weapon_holster_scheduling_patterns\", schedulingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/raisedweapons/hooks/#weaponraisescheduled","title":"WeaponRaiseScheduled","text":"<p>Purpose</p> <p>Called when a weapon raise is scheduled.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose weapon raise is scheduled.</li> <li><code>newWeapon</code> (Weapon): The new weapon being raised.</li> <li><code>raiseSpeed</code> (number): The raise speed for the weapon.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A weapon raise is scheduled - During weapon raising processing - When the raise is planned</p> <p>Example Usage</p> <pre><code>-- Track weapon raise scheduling\nhook.Add(\"WeaponRaiseScheduled\", \"TrackWeaponRaiseScheduling\", function(client, newWeapon, raiseSpeed)\n    local char = client:getChar()\n    if char then\n        local raiseScheduling = char:getData(\"weapon_raise_scheduling\", 0)\n        char:setData(\"weapon_raise_scheduling\", raiseScheduling + 1)\n    end\n\n    lia.log.add(client, \"weaponRaiseScheduled\", newWeapon, raiseSpeed)\nend)\n\n-- Apply weapon raise scheduling effects\nhook.Add(\"WeaponRaiseScheduled\", \"WeaponRaiseSchedulingEffects\", function(client, newWeapon, raiseSpeed)\n    -- Play scheduling sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Weapon raise scheduled!\")\nend)\n\n-- Track weapon raise scheduling statistics\nhook.Add(\"WeaponRaiseScheduled\", \"TrackWeaponRaiseSchedulingStats\", function(client, newWeapon, raiseSpeed)\n    local char = client:getChar()\n    if char then\n        -- Track scheduling frequency\n        local schedulingFrequency = char:getData(\"weapon_raise_scheduling_frequency\", 0)\n        char:setData(\"weapon_raise_scheduling_frequency\", schedulingFrequency + 1)\n\n        -- Track scheduling patterns\n        local schedulingPatterns = char:getData(\"weapon_raise_scheduling_patterns\", {})\n        table.insert(schedulingPatterns, {\n            weapon = newWeapon:GetClass(),\n            raiseSpeed = raiseSpeed,\n            time = os.time()\n        })\n        char:setData(\"weapon_raise_scheduling_patterns\", schedulingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/realisticview/about/","title":"About","text":"About <p>Name: Realistic View</p> <p>Description:</p> <p>Adds a first-person view that shows the full body, immersive camera transitions, compatibility with animations, smooth leaning animations, and optional third-person override.</p> Features <ul> <li>Adds a first-person view that shows the full body</li> <li>Adds immersive camera transitions</li> <li>Adds compatibility with animations</li> <li>Adds smooth leaning animations</li> <li>Adds optional third-person override</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/realisticview/changelog/","title":"Changelog","text":""},{"location":"modules/realisticview/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/realisticview/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/realisticview/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/realisticview/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Realistic View module for managing first-person view functionality.</p>"},{"location":"modules/realisticview/hooks/#realisticviewupdated","title":"RealisticViewUpdated","text":"<p>Purpose</p> <p>Called when realistic view is updated with new values.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose view is being updated.</li> <li><code>view</code> (table): The view table containing origin, angles, fov, and drawviewer.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Realistic view is updated with new values - Before view calculations - When the view data is ready</p> <p>Example Usage</p> <pre><code>-- Track realistic view updates\nhook.Add(\"RealisticViewUpdated\", \"TrackRealisticViewUpdates\", function(client, view)\n    local char = client:getChar()\n    if char then\n        local viewUpdates = char:getData(\"realistic_view_updates\", 0)\n        char:setData(\"realistic_view_updates\", viewUpdates + 1)\n    end\nend)\n\n-- Apply realistic view update effects\nhook.Add(\"RealisticViewUpdated\", \"RealisticViewUpdateEffects\", function(client, view)\n    -- Play update sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Realistic view updated!\")\nend)\n\n-- Track realistic view update statistics\nhook.Add(\"RealisticViewUpdated\", \"TrackRealisticViewUpdateStats\", function(client, view)\n    local char = client:getChar()\n    if char then\n        -- Track update frequency\n        local updateFrequency = char:getData(\"realistic_view_update_frequency\", 0)\n        char:setData(\"realistic_view_update_frequency\", updateFrequency + 1)\n\n        -- Track update patterns\n        local updatePatterns = char:getData(\"realistic_view_update_patterns\", {})\n        table.insert(updatePatterns, {\n            origin = view.origin,\n            angles = view.angles,\n            fov = view.fov,\n            time = os.time()\n        })\n        char:setData(\"realistic_view_update_patterns\", updatePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/realisticview/hooks/#shoulduserealisticview","title":"ShouldUseRealisticView","text":"<p>Purpose</p> <p>Called to determine if realistic view should be used for a player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player to check.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Realistic view is being checked - Before any view calculations - Before <code>RealisticViewUpdated</code> hook</p> <p>Example Usage</p> <pre><code>-- Control realistic view usage\nhook.Add(\"ShouldUseRealisticView\", \"ControlRealisticViewUsage\", function(client)\n    local char = client:getChar()\n    if char then\n        -- Check if realistic view is disabled\n        if char:getData(\"realistic_view_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if client:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if client:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check if player is crouching\n        if client:KeyDown(IN_DUCK) then\n            return false\n        end\n\n        -- Check if player is sprinting\n        if client:KeyDown(IN_SPEED) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n    end\n\n    return true\nend)\n\n-- Track realistic view usage checks\nhook.Add(\"ShouldUseRealisticView\", \"TrackRealisticViewUsageChecks\", function(client)\n    local char = client:getChar()\n    if char then\n        local usageChecks = char:getData(\"realistic_view_usage_checks\", 0)\n        char:setData(\"realistic_view_usage_checks\", usageChecks + 1)\n    end\nend)\n\n-- Apply realistic view usage check effects\nhook.Add(\"ShouldUseRealisticView\", \"RealisticViewUsageCheckEffects\", function(client)\n    local char = client:getChar()\n    if char then\n        -- Check if realistic view is disabled\n        if char:getData(\"realistic_view_disabled\", false) then\n            client:notify(\"Realistic view is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/realisticview/hooks/#realisticviewcalcview","title":"RealisticViewCalcView","text":"<p>Purpose</p> <p>Called when realistic view calculations are complete and the final view data is ready.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose view is being calculated.</li> <li><code>view</code> (table): The final view table containing origin, angles, fov, and drawviewer.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - Realistic view calculations are complete - After <code>RealisticViewUpdated</code> hook - Before the view is returned to the game engine - When all view modifications are finished</p> <p>Example Usage</p> <pre><code>-- Apply final view modifications\nhook.Add(\"RealisticViewCalcView\", \"FinalViewModifications\", function(client, view)\n    local char = client:getChar()\n    if char then\n        -- Apply character-specific view modifications\n        local viewModifier = char:getData(\"view_modifier\", 1)\n        view.fov = view.fov * viewModifier\n\n        -- Apply head movement restrictions\n        local headMovement = char:getData(\"head_movement_restricted\", false)\n        if headMovement then\n            view.angles.p = math.Clamp(view.angles.p, -30, 30)\n            view.angles.y = math.Clamp(view.angles.y, -45, 45)\n        end\n    end\nend)\n\n-- Track realistic view calculations\nhook.Add(\"RealisticViewCalcView\", \"TrackRealisticViewCalculations\", function(client, view)\n    local char = client:getChar()\n    if char then\n        local calculations = char:getData(\"realistic_view_calculations\", 0)\n        char:setData(\"realistic_view_calculations\", calculations + 1)\n\n        -- Log view data for debugging\n        print(\"Realistic view calculated for\", client:Name(), \"at\", view.origin)\n    end\nend)\n\n-- Apply realistic view effects\nhook.Add(\"RealisticViewCalcView\", \"RealisticViewEffects\", function(client, view)\n    -- Apply screen shake based on movement\n    local velocity = client:GetVelocity()\n    local shake = math.min(velocity:Length() / 100, 5)\n    if shake &gt; 0.1 then\n        view.angles.p = view.angles.p + math.sin(RealTime() * 10) * shake\n        view.angles.y = view.angles.y + math.cos(RealTime() * 8) * shake\n    end\n\n    -- Apply breathing effect\n    local breathing = math.sin(RealTime() * 2) * 0.5\n    view.origin = view.origin + Vector(0, 0, breathing)\nend)\n</code></pre>"},{"location":"modules/rumour/about/","title":"About","text":"About <p>Name: Anonymous Rumors</p> <p>Description:</p> <p>Adds an anonymous rumour chat command, hiding of the sender's identity, encouragement for roleplay intrigue, a cooldown to prevent spam, and admin logging of rumour messages.</p> Features <ul> <li>Adds an anonymous rumour chat command</li> <li>Adds hiding of the sender's identity</li> <li>Adds encouragement for roleplay intrigue</li> <li>Adds a cooldown to prevent spam</li> <li>Adds admin logging of rumour messages</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/rumour/changelog/","title":"Changelog","text":""},{"location":"modules/rumour/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/rumour/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/rumour/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Rumour module for managing anonymous rumour functionality.</p>"},{"location":"modules/rumour/hooks/#cansendrumour","title":"CanSendRumour","text":"<p>Purpose</p> <p>Called to determine if a player can send a rumour.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to send the rumour.</li> <li><code>rumourMessage</code> (string): The rumour message being sent.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player attempts to send a rumour - Before <code>RumourValidationFailed</code> hook - Before any rumour validation</p> <p>Example Usage</p> <pre><code>-- Control rumour sending\nhook.Add(\"CanSendRumour\", \"ControlRumourSending\", function(client, rumourMessage)\n    local char = client:getChar()\n    if char then\n        -- Check if rumour sending is disabled\n        if char:getData(\"rumour_sending_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if client:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if client:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check if player is handcuffed\n        if client:IsHandcuffed() then\n            return false\n        end\n\n        -- Check cooldown\n        local lastRumour = char:getData(\"last_rumour_time\", 0)\n        if os.time() - lastRumour &lt; 5 then -- 5 second cooldown\n            return false\n        end\n\n        -- Update last rumour time\n        char:setData(\"last_rumour_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track rumour sending attempts\nhook.Add(\"CanSendRumour\", \"TrackRumourSendingAttempts\", function(client, rumourMessage)\n    local char = client:getChar()\n    if char then\n        local sendingAttempts = char:getData(\"rumour_sending_attempts\", 0)\n        char:setData(\"rumour_sending_attempts\", sendingAttempts + 1)\n    end\nend)\n\n-- Apply rumour sending check effects\nhook.Add(\"CanSendRumour\", \"RumourSendingCheckEffects\", function(client, rumourMessage)\n    local char = client:getChar()\n    if char then\n        -- Check if rumour sending is disabled\n        if char:getData(\"rumour_sending_disabled\", false) then\n            client:notify(\"Rumour sending is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/rumour/hooks/#prerumourcommand","title":"PreRumourCommand","text":"<p>Purpose</p> <p>Called before a rumour command is processed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player executing the rumour command.</li> <li><code>arguments</code> (table): The command arguments.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A rumour command is about to be processed - Before any rumour validation - Before <code>RumourFactionDisallowed</code> hook</p> <p>Example Usage</p> <pre><code>-- Track rumour command attempts\nhook.Add(\"PreRumourCommand\", \"TrackRumourCommandAttempts\", function(client, arguments)\n    local char = client:getChar()\n    if char then\n        local commandAttempts = char:getData(\"rumour_command_attempts\", 0)\n        char:setData(\"rumour_command_attempts\", commandAttempts + 1)\n    end\nend)\n\n-- Apply pre-rumour command effects\nhook.Add(\"PreRumourCommand\", \"PreRumourCommandEffects\", function(client, arguments)\n    -- Play command sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Processing rumour command...\")\nend)\n\n-- Track pre-rumour command statistics\nhook.Add(\"PreRumourCommand\", \"TrackPreRumourCommandStats\", function(client, arguments)\n    local char = client:getChar()\n    if char then\n        -- Track command frequency\n        local commandFrequency = char:getData(\"rumour_command_frequency\", 0)\n        char:setData(\"rumour_command_frequency\", commandFrequency + 1)\n\n        -- Track command patterns\n        local commandPatterns = char:getData(\"rumour_command_patterns\", {})\n        table.insert(commandPatterns, {\n            arguments = arguments,\n            time = os.time()\n        })\n        char:setData(\"rumour_command_patterns\", commandPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/rumour/hooks/#rumourattempt","title":"RumourAttempt","text":"<p>Purpose</p> <p>Called when a rumour attempt is made.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to send the rumour.</li> <li><code>rumourMessage</code> (string): The rumour message being sent.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A rumour attempt is made - After <code>CanSendRumour</code> hook - Before <code>RumourRevealRoll</code> hook</p> <p>Example Usage</p> <pre><code>-- Track rumour attempts\nhook.Add(\"RumourAttempt\", \"TrackRumourAttempts\", function(client, rumourMessage)\n    local char = client:getChar()\n    if char then\n        local rumourAttempts = char:getData(\"rumour_attempts\", 0)\n        char:setData(\"rumour_attempts\", rumourAttempts + 1)\n    end\n\n    lia.log.add(client, \"rumourAttempt\", rumourMessage)\nend)\n\n-- Apply rumour attempt effects\nhook.Add(\"RumourAttempt\", \"RumourAttemptEffects\", function(client, rumourMessage)\n    -- Play attempt sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Rumour attempt made!\")\nend)\n\n-- Track rumour attempt statistics\nhook.Add(\"RumourAttempt\", \"TrackRumourAttemptStats\", function(client, rumourMessage)\n    local char = client:getChar()\n    if char then\n        -- Track attempt frequency\n        local attemptFrequency = char:getData(\"rumour_attempt_frequency\", 0)\n        char:setData(\"rumour_attempt_frequency\", attemptFrequency + 1)\n\n        -- Track attempt patterns\n        local attemptPatterns = char:getData(\"rumour_attempt_patterns\", {})\n        table.insert(attemptPatterns, {\n            message = rumourMessage,\n            time = os.time()\n        })\n        char:setData(\"rumour_attempt_patterns\", attemptPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/rumour/hooks/#rumourfactiondisallowed","title":"RumourFactionDisallowed","text":"<p>Purpose</p> <p>Called when a rumour is disallowed due to faction restrictions.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose rumour was disallowed.</li> <li><code>faction</code> (table): The faction that disallowed the rumour.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A rumour is disallowed due to faction restrictions - After <code>PreRumourCommand</code> hook - When the faction check fails</p> <p>Example Usage</p> <pre><code>-- Track rumour faction disallowances\nhook.Add(\"RumourFactionDisallowed\", \"TrackRumourFactionDisallowances\", function(client, faction)\n    local char = client:getChar()\n    if char then\n        local factionDisallowances = char:getData(\"rumour_faction_disallowances\", 0)\n        char:setData(\"rumour_faction_disallowances\", factionDisallowances + 1)\n    end\n\n    lia.log.add(client, \"rumourFactionDisallowed\", faction)\nend)\n\n-- Apply rumour faction disallowance effects\nhook.Add(\"RumourFactionDisallowed\", \"RumourFactionDisallowanceEffects\", function(client, faction)\n    -- Play disallowance sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Rumour disallowed by faction!\")\nend)\n\n-- Track rumour faction disallowance statistics\nhook.Add(\"RumourFactionDisallowed\", \"TrackRumourFactionDisallowanceStats\", function(client, faction)\n    local char = client:getChar()\n    if char then\n        -- Track disallowance frequency\n        local disallowanceFrequency = char:getData(\"rumour_faction_disallowance_frequency\", 0)\n        char:setData(\"rumour_faction_disallowance_frequency\", disallowanceFrequency + 1)\n\n        -- Track disallowance patterns\n        local disallowancePatterns = char:getData(\"rumour_faction_disallowance_patterns\", {})\n        table.insert(disallowancePatterns, {\n            faction = faction,\n            time = os.time()\n        })\n        char:setData(\"rumour_faction_disallowance_patterns\", disallowancePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/rumour/hooks/#rumournomessage","title":"RumourNoMessage","text":"<p>Purpose</p> <p>Called when a rumour command is executed without a message.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who executed the command without a message.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A rumour command is executed without a message - After <code>PreRumourCommand</code> hook - When the message validation fails</p> <p>Example Usage</p> <pre><code>-- Track rumour no message attempts\nhook.Add(\"RumourNoMessage\", \"TrackRumourNoMessageAttempts\", function(client)\n    local char = client:getChar()\n    if char then\n        local noMessageAttempts = char:getData(\"rumour_no_message_attempts\", 0)\n        char:setData(\"rumour_no_message_attempts\", noMessageAttempts + 1)\n    end\n\n    lia.log.add(client, \"rumourNoMessage\")\nend)\n\n-- Apply rumour no message effects\nhook.Add(\"RumourNoMessage\", \"RumourNoMessageEffects\", function(client)\n    -- Play no message sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"No rumour message provided!\")\nend)\n\n-- Track rumour no message statistics\nhook.Add(\"RumourNoMessage\", \"TrackRumourNoMessageStats\", function(client)\n    local char = client:getChar()\n    if char then\n        -- Track no message frequency\n        local noMessageFrequency = char:getData(\"rumour_no_message_frequency\", 0)\n        char:setData(\"rumour_no_message_frequency\", noMessageFrequency + 1)\n\n        -- Track no message patterns\n        local noMessagePatterns = char:getData(\"rumour_no_message_patterns\", {})\n        table.insert(noMessagePatterns, {\n            time = os.time()\n        })\n        char:setData(\"rumour_no_message_patterns\", noMessagePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/rumour/hooks/#rumourrevealed","title":"RumourRevealed","text":"<p>Purpose</p> <p>Called when a rumour is revealed to police.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose rumour was revealed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A rumour is revealed to police - After <code>RumourRevealRoll</code> hook - When the reveal roll succeeds</p> <p>Example Usage</p> <pre><code>-- Track rumour revelations\nhook.Add(\"RumourRevealed\", \"TrackRumourRevelations\", function(client)\n    local char = client:getChar()\n    if char then\n        local rumourRevelations = char:getData(\"rumour_revelations\", 0)\n        char:setData(\"rumour_revelations\", rumourRevelations + 1)\n    end\n\n    lia.log.add(client, \"rumourRevealed\")\nend)\n\n-- Apply rumour revelation effects\nhook.Add(\"RumourRevealed\", \"RumourRevelationEffects\", function(client)\n    -- Play revelation sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Your rumour has been revealed to police!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track rumour revelation statistics\nhook.Add(\"RumourRevealed\", \"TrackRumourRevelationStats\", function(client)\n    local char = client:getChar()\n    if char then\n        -- Track revelation frequency\n        local revelationFrequency = char:getData(\"rumour_revelation_frequency\", 0)\n        char:setData(\"rumour_revelation_frequency\", revelationFrequency + 1)\n\n        -- Track revelation patterns\n        local revelationPatterns = char:getData(\"rumour_revelation_patterns\", {})\n        table.insert(revelationPatterns, {\n            time = os.time()\n        })\n        char:setData(\"rumour_revelation_patterns\", revelationPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/rumour/hooks/#rumourrevealroll","title":"RumourRevealRoll","text":"<p>Purpose</p> <p>Called when a rumour reveal roll is made.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose rumour is being rolled.</li> <li><code>revealChance</code> (number): The chance of revelation.</li> <li><code>revealMath</code> (boolean): Whether the roll succeeded.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A rumour reveal roll is made - After <code>RumourAttempt</code> hook - Before <code>RumourRevealed</code> hook</p> <p>Example Usage</p> <pre><code>-- Track rumour reveal rolls\nhook.Add(\"RumourRevealRoll\", \"TrackRumourRevealRolls\", function(client, revealChance, revealMath)\n    local char = client:getChar()\n    if char then\n        local revealRolls = char:getData(\"rumour_reveal_rolls\", 0)\n        char:setData(\"rumour_reveal_rolls\", revealRolls + 1)\n    end\n\n    lia.log.add(client, \"rumourRevealRoll\", revealChance, revealMath)\nend)\n\n-- Apply rumour reveal roll effects\nhook.Add(\"RumourRevealRoll\", \"RumourRevealRollEffects\", function(client, revealChance, revealMath)\n    -- Play roll sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    local result = revealMath and \"succeeded\" or \"failed\"\n    client:notify(\"Rumour reveal roll \" .. result .. \"!\")\nend)\n\n-- Track rumour reveal roll statistics\nhook.Add(\"RumourRevealRoll\", \"TrackRumourRevealRollStats\", function(client, revealChance, revealMath)\n    local char = client:getChar()\n    if char then\n        -- Track roll frequency\n        local rollFrequency = char:getData(\"rumour_reveal_roll_frequency\", 0)\n        char:setData(\"rumour_reveal_roll_frequency\", rollFrequency + 1)\n\n        -- Track roll patterns\n        local rollPatterns = char:getData(\"rumour_reveal_roll_patterns\", {})\n        table.insert(rollPatterns, {\n            chance = revealChance,\n            success = revealMath,\n            time = os.time()\n        })\n        char:setData(\"rumour_reveal_roll_patterns\", rollPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/rumour/hooks/#rumoursent","title":"RumourSent","text":"<p>Purpose</p> <p>Called when a rumour is sent.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who sent the rumour.</li> <li><code>rumourMessage</code> (string): The rumour message that was sent.</li> <li><code>revealMath</code> (boolean): Whether the rumour was revealed to police.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A rumour is successfully sent - After <code>RumourRevealed</code> hook - When the rumour is delivered to players</p> <p>Example Usage</p> <pre><code>-- Track rumour sends\nhook.Add(\"RumourSent\", \"TrackRumourSends\", function(client, rumourMessage, revealMath)\n    local char = client:getChar()\n    if char then\n        local rumourSends = char:getData(\"rumour_sends\", 0)\n        char:setData(\"rumour_sends\", rumourSends + 1)\n    end\n\n    lia.log.add(client, \"rumourSent\", rumourMessage, revealMath)\nend)\n\n-- Apply rumour send effects\nhook.Add(\"RumourSent\", \"RumourSendEffects\", function(client, rumourMessage, revealMath)\n    -- Play send sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    local status = revealMath and \"revealed\" or \"hidden\"\n    client:notify(\"Rumour sent! Status: \" .. status .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track rumour send statistics\nhook.Add(\"RumourSent\", \"TrackRumourSendStats\", function(client, rumourMessage, revealMath)\n    local char = client:getChar()\n    if char then\n        -- Track send frequency\n        local sendFrequency = char:getData(\"rumour_send_frequency\", 0)\n        char:setData(\"rumour_send_frequency\", sendFrequency + 1)\n\n        -- Track send patterns\n        local sendPatterns = char:getData(\"rumour_send_patterns\", {})\n        table.insert(sendPatterns, {\n            message = rumourMessage,\n            revealed = revealMath,\n            time = os.time()\n        })\n        char:setData(\"rumour_send_patterns\", sendPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/rumour/hooks/#rumourvalidationfailed","title":"RumourValidationFailed","text":"<p>Purpose</p> <p>Called when rumour validation fails.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose rumour validation failed.</li> <li><code>rumourMessage</code> (string): The rumour message that failed validation.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Rumour validation fails - After <code>CanSendRumour</code> hook - When the rumour is rejected</p> <p>Example Usage</p> <pre><code>-- Track rumour validation failures\nhook.Add(\"RumourValidationFailed\", \"TrackRumourValidationFailures\", function(client, rumourMessage)\n    local char = client:getChar()\n    if char then\n        local validationFailures = char:getData(\"rumour_validation_failures\", 0)\n        char:setData(\"rumour_validation_failures\", validationFailures + 1)\n    end\n\n    lia.log.add(client, \"rumourValidationFailed\", rumourMessage)\nend)\n\n-- Apply rumour validation failure effects\nhook.Add(\"RumourValidationFailed\", \"RumourValidationFailureEffects\", function(client, rumourMessage)\n    -- Play failure sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Rumour validation failed!\")\nend)\n\n-- Track rumour validation failure statistics\nhook.Add(\"RumourValidationFailed\", \"TrackRumourValidationFailureStats\", function(client, rumourMessage)\n    local char = client:getChar()\n    if char then\n        -- Track failure frequency\n        local failureFrequency = char:getData(\"rumour_validation_failure_frequency\", 0)\n        char:setData(\"rumour_validation_failure_frequency\", failureFrequency + 1)\n\n        -- Track failure patterns\n        local failurePatterns = char:getData(\"rumour_validation_failure_patterns\", {})\n        table.insert(failurePatterns, {\n            message = rumourMessage,\n            time = os.time()\n        })\n        char:setData(\"rumour_validation_failure_patterns\", failurePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/shootlock/about/","title":"About","text":"About <p>Name: Shoot Lock</p> <p>Description:</p> <p>Adds the ability to shoot door locks to open them, a quick breach alternative, a loud action that may alert others, and chance-based lock destruction.</p> Features <ul> <li>Adds the ability to shoot door locks to open them</li> <li>Adds a quick breach alternative</li> <li>Adds a loud action that may alert others</li> <li>Adds chance-based lock destruction</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/shootlock/changelog/","title":"Changelog","text":""},{"location":"modules/shootlock/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/shootlock/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/shootlock/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/shootlock/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Shoot Lock module for managing door lock shooting functionality.</p>"},{"location":"modules/shootlock/hooks/#canplayerbustlock","title":"CanPlayerBustLock","text":"<p>Purpose</p> <p>Called to determine if a player can bust a lock by shooting it.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to bust the lock.</li> <li><code>entity</code> (Entity): The door entity being shot.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player attempts to bust a lock by shooting it - Before <code>LockShotBreach</code> hook - Before any lock busting validation</p> <p>Example Usage</p> <pre><code>-- Control lock busting\nhook.Add(\"CanPlayerBustLock\", \"ControlLockBusting\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Check if lock busting is disabled\n        if char:getData(\"lock_busting_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if client:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if client:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check if player is handcuffed\n        if client:IsHandcuffed() then\n            return false\n        end\n\n        -- Check cooldown\n        local lastLockBust = char:getData(\"last_lock_bust_time\", 0)\n        if os.time() - lastLockBust &lt; 3 then -- 3 second cooldown\n            return false\n        end\n\n        -- Update last lock bust time\n        char:setData(\"last_lock_bust_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track lock busting attempts\nhook.Add(\"CanPlayerBustLock\", \"TrackLockBustingAttempts\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        local bustingAttempts = char:getData(\"lock_busting_attempts\", 0)\n        char:setData(\"lock_busting_attempts\", bustingAttempts + 1)\n    end\nend)\n\n-- Apply lock busting check effects\nhook.Add(\"CanPlayerBustLock\", \"LockBustingCheckEffects\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Check if lock busting is disabled\n        if char:getData(\"lock_busting_disabled\", false) then\n            client:notify(\"Lock busting is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/shootlock/hooks/#lockshotattempt","title":"LockShotAttempt","text":"<p>Purpose</p> <p>Called when a lock shot attempt is made.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player attempting to shoot the lock.</li> <li><code>entity</code> (Entity): The door entity being shot.</li> <li><code>dmgInfo</code> (CTakeDamageInfo): The damage information.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player attempts to shoot a door lock - Before <code>CanPlayerBustLock</code> hook - When the shot is detected</p> <p>Example Usage</p> <pre><code>-- Track lock shot attempts\nhook.Add(\"LockShotAttempt\", \"TrackLockShotAttempts\", function(client, entity, dmgInfo)\n    local char = client:getChar()\n    if char then\n        local shotAttempts = char:getData(\"lock_shot_attempts\", 0)\n        char:setData(\"lock_shot_attempts\", shotAttempts + 1)\n    end\n\n    lia.log.add(client, \"lockShotAttempt\", entity)\nend)\n\n-- Apply lock shot attempt effects\nhook.Add(\"LockShotAttempt\", \"LockShotAttemptEffects\", function(client, entity, dmgInfo)\n    -- Play attempt sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Lock shot attempt made!\")\nend)\n\n-- Track lock shot attempt statistics\nhook.Add(\"LockShotAttempt\", \"TrackLockShotAttemptStats\", function(client, entity, dmgInfo)\n    local char = client:getChar()\n    if char then\n        -- Track attempt frequency\n        local attemptFrequency = char:getData(\"lock_shot_attempt_frequency\", 0)\n        char:setData(\"lock_shot_attempt_frequency\", attemptFrequency + 1)\n\n        -- Track attempt patterns\n        local attemptPatterns = char:getData(\"lock_shot_attempt_patterns\", {})\n        table.insert(attemptPatterns, {\n            entity = entity:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"lock_shot_attempt_patterns\", attemptPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/shootlock/hooks/#lockshotbreach","title":"LockShotBreach","text":"<p>Purpose</p> <p>Called when a lock is successfully breached by shooting.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who breached the lock.</li> <li><code>entity</code> (Entity): The door entity that was breached.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A lock is successfully breached by shooting - After <code>CanPlayerBustLock</code> hook - When the door is unlocked</p> <p>Example Usage</p> <pre><code>-- Track lock shot breaches\nhook.Add(\"LockShotBreach\", \"TrackLockShotBreaches\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        local shotBreaches = char:getData(\"lock_shot_breaches\", 0)\n        char:setData(\"lock_shot_breaches\", shotBreaches + 1)\n    end\n\n    lia.log.add(client, \"lockShotBreach\", entity)\nend)\n\n-- Apply lock shot breach effects\nhook.Add(\"LockShotBreach\", \"LockShotBreachEffects\", function(client, entity)\n    -- Play breach sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Lock breached successfully!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(entity:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track lock shot breach statistics\nhook.Add(\"LockShotBreach\", \"TrackLockShotBreachStats\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Track breach frequency\n        local breachFrequency = char:getData(\"lock_shot_breach_frequency\", 0)\n        char:setData(\"lock_shot_breach_frequency\", breachFrequency + 1)\n\n        -- Track breach patterns\n        local breachPatterns = char:getData(\"lock_shot_breach_patterns\", {})\n        table.insert(breachPatterns, {\n            entity = entity:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"lock_shot_breach_patterns\", breachPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/shootlock/hooks/#lockshotfailed","title":"LockShotFailed","text":"<p>Purpose</p> <p>Called when a lock shot attempt fails.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose lock shot failed.</li> <li><code>entity</code> (Entity): The door entity that was shot.</li> <li><code>dmgInfo</code> (CTakeDamageInfo): The damage information.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A lock shot attempt fails - When the shot doesn't hit the lock properly - After <code>LockShotAttempt</code> hook</p> <p>Example Usage</p> <pre><code>-- Track lock shot failures\nhook.Add(\"LockShotFailed\", \"TrackLockShotFailures\", function(client, entity, dmgInfo)\n    local char = client:getChar()\n    if char then\n        local shotFailures = char:getData(\"lock_shot_failures\", 0)\n        char:setData(\"lock_shot_failures\", shotFailures + 1)\n    end\n\n    lia.log.add(client, \"lockShotFailed\", entity)\nend)\n\n-- Apply lock shot failure effects\nhook.Add(\"LockShotFailed\", \"LockShotFailureEffects\", function(client, entity, dmgInfo)\n    -- Play failure sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Lock shot failed!\")\nend)\n\n-- Track lock shot failure statistics\nhook.Add(\"LockShotFailed\", \"TrackLockShotFailureStats\", function(client, entity, dmgInfo)\n    local char = client:getChar()\n    if char then\n        -- Track failure frequency\n        local failureFrequency = char:getData(\"lock_shot_failure_frequency\", 0)\n        char:setData(\"lock_shot_failure_frequency\", failureFrequency + 1)\n\n        -- Track failure patterns\n        local failurePatterns = char:getData(\"lock_shot_failure_patterns\", {})\n        table.insert(failurePatterns, {\n            entity = entity:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"lock_shot_failure_patterns\", failurePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/shootlock/hooks/#lockshotsuccess","title":"LockShotSuccess","text":"<p>Purpose</p> <p>Called when a lock shot is successful.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who successfully shot the lock.</li> <li><code>entity</code> (Entity): The door entity that was successfully shot.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A lock shot is successful - After <code>LockShotBreach</code> hook - When the door is unlocked</p> <p>Example Usage</p> <pre><code>-- Track lock shot successes\nhook.Add(\"LockShotSuccess\", \"TrackLockShotSuccesses\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        local shotSuccesses = char:getData(\"lock_shot_successes\", 0)\n        char:setData(\"lock_shot_successes\", shotSuccesses + 1)\n    end\n\n    lia.log.add(client, \"lockShotSuccess\", entity)\nend)\n\n-- Apply lock shot success effects\nhook.Add(\"LockShotSuccess\", \"LockShotSuccessEffects\", function(client, entity)\n    -- Play success sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Lock shot successful!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(entity:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track lock shot success statistics\nhook.Add(\"LockShotSuccess\", \"TrackLockShotSuccessStats\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Track success frequency\n        local successFrequency = char:getData(\"lock_shot_success_frequency\", 0)\n        char:setData(\"lock_shot_success_frequency\", successFrequency + 1)\n\n        -- Track success patterns\n        local successPatterns = char:getData(\"lock_shot_success_patterns\", {})\n        table.insert(successPatterns, {\n            entity = entity:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"lock_shot_success_patterns\", successPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/simple_lockpicking/about/","title":"About","text":"About <p>Name: Simple Lockpicking</p> <p>Description:</p> <p>Adds a simple lockpick tool for doors, logging of successful picks, brute-force style gameplay, configurable pick time, and chance for tools to break.</p> Features <ul> <li>Adds a simple lockpick tool for doors</li> <li>Adds logging of successful picks</li> <li>Adds brute-force style gameplay</li> <li>Adds configurable pick time</li> <li>Adds chance for tools to break</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/simple_lockpicking/changelog/","title":"Changelog","text":""},{"location":"modules/simple_lockpicking/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/simple_lockpicking/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/simple_lockpicking/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Simple Lockpicking module for managing lockpicking functionality.</p>"},{"location":"modules/simple_lockpicking/hooks/#canplayerlockpick","title":"CanPlayerLockpick","text":"<p>Purpose</p> <p>Called to determine if a player can lockpick an entity.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player attempting to lockpick.</li> <li><code>target</code> (Entity): The entity being lockpicked.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player attempts to lockpick an entity - Before <code>LockpickStart</code> hook - Before any lockpicking validation</p> <p>Example Usage</p> <pre><code>-- Control lockpicking\nhook.Add(\"CanPlayerLockpick\", \"ControlLockpicking\", function(player, target)\n    local char = player:getChar()\n    if char then\n        -- Check if lockpicking is disabled\n        if char:getData(\"lockpicking_disabled\", false) then\n            return false\n        end\n\n        -- Check if player is in a restricted area\n        if char:getData(\"in_restricted_area\", false) then\n            return false\n        end\n\n        -- Check if player is in a vehicle\n        if player:InVehicle() then\n            return false\n        end\n\n        -- Check if player is in water\n        if player:WaterLevel() &gt;= 2 then\n            return false\n        end\n\n        -- Check if player is handcuffed\n        if player:IsHandcuffed() then\n            return false\n        end\n\n        -- Check cooldown\n        local lastLockpick = char:getData(\"last_lockpick_time\", 0)\n        if os.time() - lastLockpick &lt; 5 then -- 5 second cooldown\n            return false\n        end\n\n        -- Update last lockpick time\n        char:setData(\"last_lockpick_time\", os.time())\n    end\n\n    return true\nend)\n\n-- Track lockpicking attempts\nhook.Add(\"CanPlayerLockpick\", \"TrackLockpickingAttempts\", function(player, target)\n    local char = player:getChar()\n    if char then\n        local lockpickingAttempts = char:getData(\"lockpicking_attempts\", 0)\n        char:setData(\"lockpicking_attempts\", lockpickingAttempts + 1)\n    end\nend)\n\n-- Apply lockpicking check effects\nhook.Add(\"CanPlayerLockpick\", \"LockpickingCheckEffects\", function(player, target)\n    local char = player:getChar()\n    if char then\n        -- Check if lockpicking is disabled\n        if char:getData(\"lockpicking_disabled\", false) then\n            player:notify(\"Lockpicking is disabled!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/simple_lockpicking/hooks/#lockpickfinished","title":"LockpickFinished","text":"<p>Purpose</p> <p>Called when lockpicking is finished (successful or interrupted).</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who was lockpicking.</li> <li><code>target</code> (Entity): The entity that was being lockpicked.</li> <li><code>success</code> (boolean): Whether the lockpicking was successful.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Lockpicking is finished (successful or interrupted) - After <code>LockpickSuccess</code> or <code>LockpickInterrupted</code> hook - When the lockpicking process ends</p> <p>Example Usage</p> <pre><code>-- Track lockpicking completion\nhook.Add(\"LockpickFinished\", \"TrackLockpickingCompletion\", function(player, target, success)\n    local char = player:getChar()\n    if char then\n        local lockpickingCompletions = char:getData(\"lockpicking_completions\", 0)\n        char:setData(\"lockpicking_completions\", lockpickingCompletions + 1)\n\n        -- Track success/failure patterns\n        local successPatterns = char:getData(\"lockpicking_success_patterns\", {})\n        successPatterns[success] = (successPatterns[success] or 0) + 1\n        char:setData(\"lockpicking_success_patterns\", successPatterns)\n    end\n\n    lia.log.add(player, \"lockpickFinished\", target, success)\nend)\n\n-- Apply lockpicking completion effects\nhook.Add(\"LockpickFinished\", \"LockpickingCompletionEffects\", function(player, target, success)\n    -- Play completion sound\n    player:EmitSound(success and \"buttons/button14.wav\" or \"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, success and Color(0, 255, 0, 15) or Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    local status = success and \"successful\" or \"interrupted\"\n    player:notify(\"Lockpicking \" .. status .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(target:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track lockpicking completion statistics\nhook.Add(\"LockpickFinished\", \"TrackLockpickingCompletionStats\", function(player, target, success)\n    local char = player:getChar()\n    if char then\n        -- Track completion frequency\n        local completionFrequency = char:getData(\"lockpicking_completion_frequency\", 0)\n        char:setData(\"lockpicking_completion_frequency\", completionFrequency + 1)\n\n        -- Track completion patterns\n        local completionPatterns = char:getData(\"lockpicking_completion_patterns\", {})\n        table.insert(completionPatterns, {\n            target = target:GetClass(),\n            success = success,\n            time = os.time()\n        })\n        char:setData(\"lockpicking_completion_patterns\", completionPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/simple_lockpicking/hooks/#lockpickinterrupted","title":"LockpickInterrupted","text":"<p>Purpose</p> <p>Called when lockpicking is interrupted.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose lockpicking was interrupted.</li> <li><code>target</code> (Entity): The entity that was being lockpicked.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Lockpicking is interrupted - Before <code>LockpickFinished</code> hook - When the lockpicking process is stopped</p> <p>Example Usage</p> <pre><code>-- Track lockpicking interruptions\nhook.Add(\"LockpickInterrupted\", \"TrackLockpickingInterruptions\", function(player, target)\n    local char = player:getChar()\n    if char then\n        local lockpickingInterruptions = char:getData(\"lockpicking_interruptions\", 0)\n        char:setData(\"lockpicking_interruptions\", lockpickingInterruptions + 1)\n    end\n\n    lia.log.add(player, \"lockpickInterrupted\", target)\nend)\n\n-- Apply lockpicking interruption effects\nhook.Add(\"LockpickInterrupted\", \"LockpickingInterruptionEffects\", function(player, target)\n    -- Play interruption sound\n    player:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"Lockpicking interrupted!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(target:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track lockpicking interruption statistics\nhook.Add(\"LockpickInterrupted\", \"TrackLockpickingInterruptionStats\", function(player, target)\n    local char = player:getChar()\n    if char then\n        -- Track interruption frequency\n        local interruptionFrequency = char:getData(\"lockpicking_interruption_frequency\", 0)\n        char:setData(\"lockpicking_interruption_frequency\", interruptionFrequency + 1)\n\n        -- Track interruption patterns\n        local interruptionPatterns = char:getData(\"lockpicking_interruption_patterns\", {})\n        table.insert(interruptionPatterns, {\n            target = target:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"lockpicking_interruption_patterns\", interruptionPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/simple_lockpicking/hooks/#lockpickstart","title":"LockpickStart","text":"<p>Purpose</p> <p>Called when lockpicking starts.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player starting to lockpick.</li> <li><code>target</code> (Entity): The entity being lockpicked.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Lockpicking starts - After <code>CanPlayerLockpick</code> hook - When the lockpicking process begins</p> <p>Example Usage</p> <pre><code>-- Track lockpicking starts\nhook.Add(\"LockpickStart\", \"TrackLockpickingStarts\", function(player, target)\n    local char = player:getChar()\n    if char then\n        local lockpickingStarts = char:getData(\"lockpicking_starts\", 0)\n        char:setData(\"lockpicking_starts\", lockpickingStarts + 1)\n    end\n\n    lia.log.add(player, \"lockpickStart\", target)\nend)\n\n-- Apply lockpicking start effects\nhook.Add(\"LockpickStart\", \"LockpickingStartEffects\", function(player, target)\n    -- Play start sound\n    player:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    player:notify(\"Starting to lockpick...\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(target:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track lockpicking start statistics\nhook.Add(\"LockpickStart\", \"TrackLockpickingStartStats\", function(player, target)\n    local char = player:getChar()\n    if char then\n        -- Track start frequency\n        local startFrequency = char:getData(\"lockpicking_start_frequency\", 0)\n        char:setData(\"lockpicking_start_frequency\", startFrequency + 1)\n\n        -- Track start patterns\n        local startPatterns = char:getData(\"lockpicking_start_patterns\", {})\n        table.insert(startPatterns, {\n            target = target:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"lockpicking_start_patterns\", startPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/simple_lockpicking/hooks/#lockpicksuccess","title":"LockpickSuccess","text":"<p>Purpose</p> <p>Called when lockpicking is successful.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who successfully lockpicked.</li> <li><code>target</code> (Entity): The entity that was successfully lockpicked.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - Lockpicking is successful - Before <code>LockpickFinished</code> hook - When the entity is unlocked</p> <p>Example Usage</p> <pre><code>-- Track lockpicking successes\nhook.Add(\"LockpickSuccess\", \"TrackLockpickingSuccesses\", function(player, target)\n    local char = player:getChar()\n    if char then\n        local lockpickingSuccesses = char:getData(\"lockpicking_successes\", 0)\n        char:setData(\"lockpicking_successes\", lockpickingSuccesses + 1)\n    end\n\n    lia.log.add(player, \"lockpickSuccess\", target)\nend)\n\n-- Apply lockpicking success effects\nhook.Add(\"LockpickSuccess\", \"LockpickingSuccessEffects\", function(player, target)\n    -- Play success sound\n    player:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"Lockpicking successful!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(target:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track lockpicking success statistics\nhook.Add(\"LockpickSuccess\", \"TrackLockpickingSuccessStats\", function(player, target)\n    local char = player:getChar()\n    if char then\n        -- Track success frequency\n        local successFrequency = char:getData(\"lockpicking_success_frequency\", 0)\n        char:setData(\"lockpicking_success_frequency\", successFrequency + 1)\n\n        -- Track success patterns\n        local successPatterns = char:getData(\"lockpicking_success_patterns\", {})\n        table.insert(successPatterns, {\n            target = target:GetClass(),\n            time = os.time()\n        })\n        char:setData(\"lockpicking_success_patterns\", successPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/slots/about/","title":"About","text":"About <p>Name: Slot Machine</p> <p>Description:</p> <p>Adds a slot machine minigame, a workshop model for the machine, handling of payouts to winners, customizable payout odds, and sound and animation effects.</p> Features <ul> <li>Adds a slot machine minigame</li> <li>Adds a workshop model for the machine</li> <li>Adds handling of payouts to winners</li> <li>Adds customizable payout odds</li> <li>Adds sound and animation effects</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/slots/changelog/","title":"Changelog","text":""},{"location":"modules/slots/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/slots/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/slots/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Slots module for managing slot machine functionality.</p>"},{"location":"modules/slots/hooks/#slotmachineend","title":"SlotMachineEnd","text":"<p>Purpose</p> <p>Called when a slot machine game ends.</p> <p>Parameters</p> <ul> <li><code>machine</code> (Entity): The slot machine entity.</li> <li><code>client</code> (Player): The player who played the machine.</li> <li><code>payout</code> (number): The payout amount (0 if no win).</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A slot machine game ends - After <code>SlotMachinePayout</code> hook - When the game is complete</p> <p>Example Usage</p> <pre><code>-- Track slot machine game endings\nhook.Add(\"SlotMachineEnd\", \"TrackSlotMachineGameEndings\", function(machine, client, payout)\n    local char = client:getChar()\n    if char then\n        local gameEndings = char:getData(\"slot_machine_game_endings\", 0)\n        char:setData(\"slot_machine_game_endings\", gameEndings + 1)\n\n        -- Track payout patterns\n        local payoutPatterns = char:getData(\"slot_machine_payout_patterns\", {})\n        payoutPatterns[payout] = (payoutPatterns[payout] or 0) + 1\n        char:setData(\"slot_machine_payout_patterns\", payoutPatterns)\n    end\n\n    lia.log.add(client, \"slotMachineGameEnded\", machine, payout)\nend)\n\n-- Apply slot machine game ending effects\nhook.Add(\"SlotMachineEnd\", \"SlotMachineGameEndingEffects\", function(machine, client, payout)\n    -- Play ending sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    local status = payout &gt; 0 and \"won\" or \"lost\"\n    client:notify(\"Slot machine game ended! You \" .. status .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(machine:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track slot machine game ending statistics\nhook.Add(\"SlotMachineEnd\", \"TrackSlotMachineGameEndingStats\", function(machine, client, payout)\n    local char = client:getChar()\n    if char then\n        -- Track ending frequency\n        local endingFrequency = char:getData(\"slot_machine_ending_frequency\", 0)\n        char:setData(\"slot_machine_ending_frequency\", endingFrequency + 1)\n\n        -- Track ending patterns\n        local endingPatterns = char:getData(\"slot_machine_ending_patterns\", {})\n        table.insert(endingPatterns, {\n            payout = payout,\n            time = os.time()\n        })\n        char:setData(\"slot_machine_ending_patterns\", endingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/slots/hooks/#slotmachinepayout","title":"SlotMachinePayout","text":"<p>Purpose</p> <p>Called when a slot machine pays out to a player.</p> <p>Parameters</p> <ul> <li><code>machine</code> (Entity): The slot machine entity.</li> <li><code>client</code> (Player): The player who won the payout.</li> <li><code>payout</code> (number): The payout amount.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A slot machine pays out to a player - After <code>SlotMachineStart</code> hook - Before <code>SlotMachineEnd</code> hook</p> <p>Example Usage</p> <pre><code>-- Track slot machine payouts\nhook.Add(\"SlotMachinePayout\", \"TrackSlotMachinePayouts\", function(machine, client, payout)\n    local char = client:getChar()\n    if char then\n        local payouts = char:getData(\"slot_machine_payouts\", 0)\n        char:setData(\"slot_machine_payouts\", payouts + 1)\n\n        -- Track total winnings\n        local totalWinnings = char:getData(\"slot_machine_total_winnings\", 0)\n        char:setData(\"slot_machine_total_winnings\", totalWinnings + payout)\n    end\n\n    lia.log.add(client, \"slotMachinePayout\", machine, payout)\nend)\n\n-- Apply slot machine payout effects\nhook.Add(\"SlotMachinePayout\", \"SlotMachinePayoutEffects\", function(machine, client, payout)\n    -- Play payout sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify player\n    client:notify(\"Slot machine payout: \" .. payout .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(machine:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track slot machine payout statistics\nhook.Add(\"SlotMachinePayout\", \"TrackSlotMachinePayoutStats\", function(machine, client, payout)\n    local char = client:getChar()\n    if char then\n        -- Track payout frequency\n        local payoutFrequency = char:getData(\"slot_machine_payout_frequency\", 0)\n        char:setData(\"slot_machine_payout_frequency\", payoutFrequency + 1)\n\n        -- Track payout patterns\n        local payoutPatterns = char:getData(\"slot_machine_payout_patterns\", {})\n        table.insert(payoutPatterns, {\n            payout = payout,\n            time = os.time()\n        })\n        char:setData(\"slot_machine_payout_patterns\", payoutPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/slots/hooks/#slotmachinestart","title":"SlotMachineStart","text":"<p>Purpose</p> <p>Called when a slot machine game starts.</p> <p>Parameters</p> <ul> <li><code>machine</code> (Entity): The slot machine entity.</li> <li><code>client</code> (Player): The player who started the game.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A slot machine game starts - After <code>SlotMachineUse</code> hook - When the game begins</p> <p>Example Usage</p> <pre><code>-- Track slot machine game starts\nhook.Add(\"SlotMachineStart\", \"TrackSlotMachineGameStarts\", function(machine, client)\n    local char = client:getChar()\n    if char then\n        local gameStarts = char:getData(\"slot_machine_game_starts\", 0)\n        char:setData(\"slot_machine_game_starts\", gameStarts + 1)\n    end\n\n    lia.log.add(client, \"slotMachineGameStarted\", machine)\nend)\n\n-- Apply slot machine game start effects\nhook.Add(\"SlotMachineStart\", \"SlotMachineGameStartEffects\", function(machine, client)\n    -- Play start sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify player\n    client:notify(\"Slot machine game started!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(machine:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track slot machine game start statistics\nhook.Add(\"SlotMachineStart\", \"TrackSlotMachineGameStartStats\", function(machine, client)\n    local char = client:getChar()\n    if char then\n        -- Track start frequency\n        local startFrequency = char:getData(\"slot_machine_start_frequency\", 0)\n        char:setData(\"slot_machine_start_frequency\", startFrequency + 1)\n\n        -- Track start patterns\n        local startPatterns = char:getData(\"slot_machine_start_patterns\", {})\n        table.insert(startPatterns, {\n            time = os.time()\n        })\n        char:setData(\"slot_machine_start_patterns\", startPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/slots/hooks/#slotmachineuse","title":"SlotMachineUse","text":"<p>Purpose</p> <p>Called when a player uses a slot machine.</p> <p>Parameters</p> <ul> <li><code>machine</code> (Entity): The slot machine entity.</li> <li><code>client</code> (Player): The player using the machine.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player uses a slot machine - Before <code>SlotMachineStart</code> hook - When the use interaction begins</p> <p>Example Usage</p> <pre><code>-- Track slot machine usage\nhook.Add(\"SlotMachineUse\", \"TrackSlotMachineUsage\", function(machine, client)\n    local char = client:getChar()\n    if char then\n        local machineUsage = char:getData(\"slot_machine_usage\", 0)\n        char:setData(\"slot_machine_usage\", machineUsage + 1)\n    end\n\n    lia.log.add(client, \"slotMachineUsed\", machine)\nend)\n\n-- Apply slot machine usage effects\nhook.Add(\"SlotMachineUse\", \"SlotMachineUsageEffects\", function(machine, client)\n    -- Play usage sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.2, 0)\n\n    -- Notify player\n    client:notify(\"Using slot machine...\")\nend)\n\n-- Track slot machine usage statistics\nhook.Add(\"SlotMachineUse\", \"TrackSlotMachineUsageStats\", function(machine, client)\n    local char = client:getChar()\n    if char then\n        -- Track usage frequency\n        local usageFrequency = char:getData(\"slot_machine_usage_frequency\", 0)\n        char:setData(\"slot_machine_usage_frequency\", usageFrequency + 1)\n\n        -- Track usage patterns\n        local usagePatterns = char:getData(\"slot_machine_usage_patterns\", {})\n        table.insert(usagePatterns, {\n            time = os.time()\n        })\n        char:setData(\"slot_machine_usage_patterns\", usagePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/slowweapons/about/","title":"About","text":"About <p>Name: Slow Weapons</p> <p>Description:</p> <p>Adds slower movement while holding heavy weapons, speed penalties defined per weapon, encouragement for strategic choices, customizable weapon speed table, and automatic speed restore when switching.</p> Features <ul> <li>Adds slower movement while holding heavy weapons</li> <li>Adds speed penalties defined per weapon</li> <li>Adds encouragement for strategic choices</li> <li>Adds customizable weapon speed table</li> <li>Adds automatic speed restore when switching</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/slowweapons/changelog/","title":"Changelog","text":""},{"location":"modules/slowweapons/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/slowweapons/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/slowweapons/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Slow Weapons module for managing weapon movement speed penalties.</p>"},{"location":"modules/slowweapons/hooks/#applyweaponslowdown","title":"ApplyWeaponSlowdown","text":"<p>Purpose</p> <p>Called when a weapon slowdown is being applied to a player's movement.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose movement is being slowed down.</li> <li><code>weapon</code> (Weapon): The weapon causing the slowdown.</li> <li><code>moveData</code> (CMoveData): The movement data being modified.</li> <li><code>speed</code> (number): The speed value being applied.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player is holding a weapon that has a speed penalty - Before the movement speed is actually applied - After <code>OverrideSlowWeaponSpeed</code> hook</p> <p>Example Usage</p> <pre><code>-- Track weapon slowdown applications\nhook.Add(\"ApplyWeaponSlowdown\", \"TrackWeaponSlowdown\", function(client, weapon, moveData, speed)\n    local char = client:getChar()\n    if char then\n        local slowdowns = char:getData(\"weapon_slowdowns\", 0)\n        char:setData(\"weapon_slowdowns\", slowdowns + 1)\n\n        -- Track weapon types\n        local weaponType = weapon:GetClass()\n        local weaponSlowdowns = char:getData(\"weapon_type_slowdowns\", {})\n        weaponSlowdowns[weaponType] = (weaponSlowdowns[weaponType] or 0) + 1\n        char:setData(\"weapon_type_slowdowns\", weaponSlowdowns)\n    end\n\n    lia.log.add(client, \"weaponSlowdownApplied\", weapon:GetClass(), speed)\nend)\n\n-- Apply slowdown effects\nhook.Add(\"ApplyWeaponSlowdown\", \"SlowdownEffects\", function(client, weapon, moveData, speed)\n    -- Play slowdown sound\n    client:EmitSound(\"player/pl_jump1.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 5), 0.3, 0)\n\n    -- Notify client\n    client:notify(\"Weapon slowdown applied: \" .. weapon:GetClass())\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track slowdown statistics\nhook.Add(\"ApplyWeaponSlowdown\", \"TrackSlowdownStats\", function(client, weapon, moveData, speed)\n    local char = client:getChar()\n    if char then\n        -- Track slowdown frequency\n        local slowdownFrequency = char:getData(\"weapon_slowdown_frequency\", 0)\n        char:setData(\"weapon_slowdown_frequency\", slowdownFrequency + 1)\n\n        -- Track slowdown patterns\n        local slowdownPatterns = char:getData(\"weapon_slowdown_patterns\", {})\n        table.insert(slowdownPatterns, {\n            weapon = weapon:GetClass(),\n            speed = speed,\n            time = os.time()\n        })\n        char:setData(\"weapon_slowdown_patterns\", slowdownPatterns)\n\n        -- Track speed reduction\n        local baseSpeed = client:GetWalkSpeed()\n        local speedReduction = baseSpeed - speed\n        char:setData(\"total_speed_reduction\", char:getData(\"total_speed_reduction\", 0) + speedReduction)\n    end\nend)\n</code></pre>"},{"location":"modules/slowweapons/hooks/#overrideslowweaponspeed","title":"OverrideSlowWeaponSpeed","text":"<p>Purpose</p> <p>Called to allow overriding the slow weapon speed value before it's applied.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose weapon speed is being calculated.</li> <li><code>weapon</code> (Weapon): The weapon being held.</li> <li><code>baseSpeed</code> (number): The base speed value for the weapon.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player is holding a weapon that has a speed penalty - Before the speed is calculated and applied - Before <code>ApplyWeaponSlowdown</code> hook</p> <p>Example Usage</p> <pre><code>-- Override weapon speed based on character attributes\nhook.Add(\"OverrideSlowWeaponSpeed\", \"OverrideWeaponSpeed\", function(client, weapon, baseSpeed)\n    local char = client:getChar()\n    if char then\n        -- Apply character-specific modifications\n        local strength = char:getData(\"strength\", 50)\n        local speedModifier = 1 + (strength - 50) / 100 -- 0.5x to 1.5x based on strength\n\n        -- Apply weapon-specific modifications\n        local weaponType = weapon:GetClass()\n        if weaponType == \"weapon_rifle\" then\n            speedModifier = speedModifier * 0.8 -- Rifles are heavier\n        elseif weaponType == \"weapon_pistol\" then\n            speedModifier = speedModifier * 1.2 -- Pistols are lighter\n        end\n\n        -- Apply character perks\n        if char:getData(\"lightweight_perk\", false) then\n            speedModifier = speedModifier * 1.3\n        end\n\n        -- Apply temporary effects\n        if char:getData(\"adrenaline_boost\", false) then\n            speedModifier = speedModifier * 1.5\n        end\n\n        return baseSpeed * speedModifier\n    end\nend)\n\n-- Track weapon speed overrides\nhook.Add(\"OverrideSlowWeaponSpeed\", \"TrackWeaponSpeedOverrides\", function(client, weapon, baseSpeed)\n    local char = client:getChar()\n    if char then\n        local overrides = char:getData(\"weapon_speed_overrides\", 0)\n        char:setData(\"weapon_speed_overrides\", overrides + 1)\n\n        -- Track weapon types\n        local weaponType = weapon:GetClass()\n        local weaponOverrides = char:getData(\"weapon_type_overrides\", {})\n        weaponOverrides[weaponType] = (weaponOverrides[weaponType] or 0) + 1\n        char:setData(\"weapon_type_overrides\", weaponOverrides)\n    end\nend)\n\n-- Apply speed override effects\nhook.Add(\"OverrideSlowWeaponSpeed\", \"SpeedOverrideEffects\", function(client, weapon, baseSpeed)\n    -- Play override sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.2, 0)\n\n    -- Notify client\n    client:notify(\"Weapon speed override: \" .. weapon:GetClass())\nend)\n</code></pre>"},{"location":"modules/slowweapons/hooks/#postapplyweaponslowdown","title":"PostApplyWeaponSlowdown","text":"<p>Purpose</p> <p>Called after a weapon slowdown has been applied to a player's movement.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose movement was slowed down.</li> <li><code>weapon</code> (Weapon): The weapon that caused the slowdown.</li> <li><code>moveData</code> (CMoveData): The movement data that was modified.</li> <li><code>speed</code> (number): The speed value that was applied.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A weapon slowdown has been successfully applied - After the movement speed has been set - After <code>ApplyWeaponSlowdown</code> hook</p> <p>Example Usage</p> <pre><code>-- Track weapon slowdown completion\nhook.Add(\"PostApplyWeaponSlowdown\", \"TrackWeaponSlowdownCompletion\", function(client, weapon, moveData, speed)\n    local char = client:getChar()\n    if char then\n        local slowdownsCompleted = char:getData(\"weapon_slowdowns_completed\", 0)\n        char:setData(\"weapon_slowdowns_completed\", slowdownsCompleted + 1)\n\n        -- Track completion patterns\n        local completionPatterns = char:getData(\"weapon_slowdown_completion_patterns\", {})\n        table.insert(completionPatterns, {\n            weapon = weapon:GetClass(),\n            speed = speed,\n            time = os.time()\n        })\n        char:setData(\"weapon_slowdown_completion_patterns\", completionPatterns)\n    end\n\n    lia.log.add(client, \"weaponSlowdownCompleted\", weapon:GetClass(), speed)\nend)\n\n-- Apply post-slowdown effects\nhook.Add(\"PostApplyWeaponSlowdown\", \"PostSlowdownEffects\", function(client, weapon, moveData, speed)\n    -- Play completion sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.5, 0)\n\n    -- Notify client\n    client:notify(\"Weapon slowdown applied successfully!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track post-slowdown statistics\nhook.Add(\"PostApplyWeaponSlowdown\", \"TrackPostSlowdownStats\", function(client, weapon, moveData, speed)\n    local char = client:getChar()\n    if char then\n        -- Track completion frequency\n        local completionFrequency = char:getData(\"weapon_slowdown_completion_frequency\", 0)\n        char:setData(\"weapon_slowdown_completion_frequency\", completionFrequency + 1)\n\n        -- Track speed effectiveness\n        local baseSpeed = client:GetWalkSpeed()\n        local speedReduction = baseSpeed - speed\n        local effectiveness = speedReduction / baseSpeed\n        char:setData(\"weapon_slowdown_effectiveness\", char:getData(\"weapon_slowdown_effectiveness\", 0) + effectiveness)\n    end\nend)\n</code></pre>"},{"location":"modules/steamgrouprewards/about/","title":"About","text":"About <p>Name: Steam Group Rewards</p> <p>Description:</p> <p>Provides a Steam group membership rewards system that automatically checks player membership in your Steam group and rewards them with in-game currency for joining. Features automatic group member checking, manual claim system, and configurable rewards.</p> Features <ul> <li>Automatic Steam group membership checking every 5 minutes</li> <li>Manual membership verification on demand</li> <li>Configurable money rewards for group members</li> <li>One-time claim per character system</li> <li>Player commands for easy group access and reward claiming</li> <li>Server-side tracking of claimed rewards</li> </ul> Configuration <ul> <li>GroupID: Your Steam group ID/name (set in module.lua)</li> <li>MoneyReward: Amount of money to reward players (default: 500, set in module.lua)</li> </ul> Player Commands <ul> <li><code>/group</code>: Opens your Steam group page in the player's browser</li> <li><code>/claim</code>: Claims the group membership reward (if eligible)</li> </ul> Setup Instructions <ol> <li>Set your Steam group ID in <code>module.lua</code> (line 8): <code>MODULE.GroupID = \"yourgroupname\"</code></li> <li>Optionally adjust the money reward amount (line 9): <code>MODULE.MoneyReward = 500</code></li> <li>Players use <code>/group</code> to join your Steam group</li> <li>After joining, players use <code>/claim</code> to receive their reward</li> <li>The system automatically checks group membership every 5 minutes</li> </ol> <p>DOWNLOAD HERE</p>"},{"location":"modules/steamgrouprewards/changelog/","title":"Changelog","text":""},{"location":"modules/steamgrouprewards/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/tying/about/","title":"About","text":"About <p>Name: Tying</p> <p>Description:</p> <p>Adds handcuff items that restrain players, logging for tie and untie events, support for roleplay arrests, timed escape minigames for prisoners, and compatibility with the search submodule.</p> Features <ul> <li>Adds handcuff items that restrain players</li> <li>Adds logging for tie and untie events</li> <li>Adds support for roleplay arrests</li> <li>Adds timed escape minigames for prisoners</li> <li>Adds compatibility with the search submodule</li> </ul> Submodules Search Tied Players <p>Name: Search Tied Players</p> <p>Description:</p> <p>Adds searching of tied players' inventories, ability to confiscate contraband, seamless integration with the tying module, a configurable list of illegal items, and logging of confiscated belongings.</p> Features <ul> <li>Adds searching of tied players' inventories</li> <li>Adds ability to confiscate contraband</li> <li>Adds seamless integration with the tying module</li> <li>Adds a configurable list of illegal items</li> <li>Adds logging of confiscated belongings</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/tying/changelog/","title":"Changelog","text":""},{"location":"modules/tying/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency:</li> <li><code>IsHandcuffed()</code> \u2192 <code>isHandcuffed()</code></li> <li><code>StartHandcuffAnim()</code> \u2192 <code>startHandcuffAnim()</code></li> <li><code>EndHandcuffAnim()</code> \u2192 <code>endHandcuffAnim()</code></li> <li><code>IsBeingSearched()</code> \u2192 <code>isBeingSearched()</code></li> </ul>"},{"location":"modules/tying/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/tying/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/tying/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Tying module for managing player handcuffing and restraint functionality.</p>"},{"location":"modules/tying/hooks/#playerfinishuntying","title":"PlayerFinishUnTying","text":"<p>Purpose</p> <p>Called when a player has finished untying another player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who performed the untying.</li> <li><code>entity</code> (Player): The player who was untied.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player successfully completes the untying action - The handcuff removal process is finished - After <code>PlayerStartUnTying</code> hook</p> <p>Example Usage</p> <pre><code>-- Track untying completion\nhook.Add(\"PlayerFinishUnTying\", \"TrackUnTyingCompletion\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        local untyingsCompleted = char:getData(\"untyings_completed\", 0)\n        char:setData(\"untyings_completed\", untyingsCompleted + 1)\n\n        -- Track untying targets\n        local untyingTargets = char:getData(\"untying_targets\", {})\n        untyingTargets[entity:SteamID()] = (untyingTargets[entity:SteamID()] or 0) + 1\n        char:setData(\"untying_targets\", untyingTargets)\n    end\n\n    lia.log.add(client, \"untyingCompleted\", entity:Name())\nend)\n\n-- Apply untying completion effects\nhook.Add(\"PlayerFinishUnTying\", \"UnTyingCompletionEffects\", function(client, entity)\n    -- Play completion sound\n    client:EmitSound(\"npc/roller/blade_in.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.5, 0)\n\n    -- Notify players\n    client:notify(\"Successfully untied \" .. entity:Name() .. \"!\")\n    entity:notify(\"You have been untied by \" .. client:Name() .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(entity:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track untying statistics\nhook.Add(\"PlayerFinishUnTying\", \"TrackUnTyingStats\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Track untying frequency\n        local untyingFrequency = char:getData(\"untying_frequency\", 0)\n        char:setData(\"untying_frequency\", untyingFrequency + 1)\n\n        -- Track untying patterns\n        local untyingPatterns = char:getData(\"untying_patterns\", {})\n        table.insert(untyingPatterns, {\n            target = entity:Name(),\n            time = os.time()\n        })\n        char:setData(\"untying_patterns\", untyingPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/tying/hooks/#playerhandcuffed","title":"PlayerHandcuffed","text":"<p>Purpose</p> <p>Called when a player has been handcuffed.</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player who was handcuffed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player is successfully handcuffed - The handcuff process is completed - After <code>PlayerStartHandcuff</code> hook</p> <p>Example Usage</p> <pre><code>-- Track handcuffing\nhook.Add(\"PlayerHandcuffed\", \"TrackHandcuffing\", function(target)\n    local char = target:getChar()\n    if char then\n        local handcuffs = char:getData(\"handcuffs\", 0)\n        char:setData(\"handcuffs\", handcuffs + 1)\n\n        -- Set handcuff data\n        char:setData(\"handcuffed\", true)\n        char:setData(\"handcuff_time\", os.time())\n    end\n\n    lia.log.add(target, \"handcuffed\")\nend)\n\n-- Apply handcuff effects\nhook.Add(\"PlayerHandcuffed\", \"HandcuffEffects\", function(target)\n    -- Play handcuff sound\n    target:EmitSound(\"npc/roller/blade_out.wav\", 75, 100)\n\n    -- Apply screen effect\n    target:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 15), 0.5, 0)\n\n    -- Notify target\n    target:notify(\"You have been handcuffed!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(target:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track handcuff statistics\nhook.Add(\"PlayerHandcuffed\", \"TrackHandcuffStats\", function(target)\n    local char = target:getChar()\n    if char then\n        -- Track handcuff frequency\n        local handcuffFrequency = char:getData(\"handcuff_frequency\", 0)\n        char:setData(\"handcuff_frequency\", handcuffFrequency + 1)\n\n        -- Track handcuff patterns\n        local handcuffPatterns = char:getData(\"handcuff_patterns\", {})\n        table.insert(handcuffPatterns, {\n            time = os.time()\n        })\n        char:setData(\"handcuff_patterns\", handcuffPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/tying/hooks/#playerstarthandcuff","title":"PlayerStartHandcuff","text":"<p>Purpose</p> <p>Called when a player is about to be handcuffed.</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player who is about to be handcuffed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player is about to be handcuffed - Before the handcuff process begins - Before <code>PlayerHandcuffed</code> hook</p> <p>Example Usage</p> <pre><code>-- Track handcuff attempts\nhook.Add(\"PlayerStartHandcuff\", \"TrackHandcuffAttempts\", function(target)\n    local char = target:getChar()\n    if char then\n        local handcuffAttempts = char:getData(\"handcuff_attempts\", 0)\n        char:setData(\"handcuff_attempts\", handcuffAttempts + 1)\n    end\n\n    lia.log.add(target, \"handcuffAttempt\")\nend)\n\n-- Apply handcuff start effects\nhook.Add(\"PlayerStartHandcuff\", \"HandcuffStartEffects\", function(target)\n    -- Play start sound\n    target:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    target:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.3, 0)\n\n    -- Notify target\n    target:notify(\"You are about to be handcuffed!\")\nend)\n\n-- Validate handcuff start\nhook.Add(\"PlayerStartHandcuff\", \"ValidateHandcuffStart\", function(target)\n    local char = target:getChar()\n    if char then\n        -- Check if already handcuffed\n        if char:getData(\"handcuffed\", false) then\n            target:notify(\"You are already handcuffed!\")\n            return false\n        end\n\n        -- Check handcuff cooldown\n        local lastHandcuff = char:getData(\"last_handcuff_time\", 0)\n        if os.time() - lastHandcuff &lt; 5 then -- 5 second cooldown\n            target:notify(\"Please wait before being handcuffed again!\")\n            return false\n        end\n\n        -- Update last handcuff time\n        char:setData(\"last_handcuff_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/tying/hooks/#playerstartuntying","title":"PlayerStartUnTying","text":"<p>Purpose</p> <p>Called when a player starts untying another player.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is starting to untie.</li> <li><code>entity</code> (Player): The player who is being untied.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player starts the untying action - Before the untying process begins - Before <code>PlayerFinishUnTying</code> hook</p> <p>Example Usage</p> <pre><code>-- Track untying attempts\nhook.Add(\"PlayerStartUnTying\", \"TrackUnTyingAttempts\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        local untyingAttempts = char:getData(\"untying_attempts\", 0)\n        char:setData(\"untying_attempts\", untyingAttempts + 1)\n    end\n\n    lia.log.add(client, \"untyingAttempt\", entity:Name())\nend)\n\n-- Apply untying start effects\nhook.Add(\"PlayerStartUnTying\", \"UnTyingStartEffects\", function(client, entity)\n    -- Play start sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 255, 10), 0.3, 0)\n\n    -- Notify players\n    client:notify(\"Starting to untie \" .. entity:Name() .. \"...\")\n    entity:notify(\"You are being untied by \" .. client:Name() .. \"...\")\nend)\n\n-- Validate untying start\nhook.Add(\"PlayerStartUnTying\", \"ValidateUnTyingStart\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Check if target is handcuffed\n        if not entity:IsHandcuffed() then\n            client:notify(\"This player is not handcuffed!\")\n            return false\n        end\n\n        -- Check untying cooldown\n        local lastUntying = char:getData(\"last_untying_time\", 0)\n        if os.time() - lastUntying &lt; 3 then -- 3 second cooldown\n            client:notify(\"Please wait before untying again!\")\n            return false\n        end\n\n        -- Update last untying time\n        char:setData(\"last_untying_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/tying/hooks/#playerunhandcuffed","title":"PlayerUnhandcuffed","text":"<p>Purpose</p> <p>Called when a player has been unhandcuffed.</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player who was unhandcuffed.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player is successfully unhandcuffed - The handcuff removal process is completed - After <code>ResetSubModuleCuffData</code> hook</p> <p>Example Usage</p> <pre><code>-- Track unhandcuffing\nhook.Add(\"PlayerUnhandcuffed\", \"TrackUnhandcuffing\", function(target)\n    local char = target:getChar()\n    if char then\n        local unhandcuffs = char:getData(\"unhandcuffs\", 0)\n        char:setData(\"unhandcuffs\", unhandcuffs + 1)\n\n        -- Clear handcuff data\n        char:setData(\"handcuffed\", false)\n        char:setData(\"handcuff_time\", nil)\n    end\n\n    lia.log.add(target, \"unhandcuffed\")\nend)\n\n-- Apply unhandcuff effects\nhook.Add(\"PlayerUnhandcuffed\", \"UnhandcuffEffects\", function(target)\n    -- Play unhandcuff sound\n    target:EmitSound(\"npc/roller/blade_in.wav\", 75, 100)\n\n    -- Apply screen effect\n    target:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify target\n    target:notify(\"You have been unhandcuffed!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(target:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track unhandcuff statistics\nhook.Add(\"PlayerUnhandcuffed\", \"TrackUnhandcuffStats\", function(target)\n    local char = target:getChar()\n    if char then\n        -- Track unhandcuff frequency\n        local unhandcuffFrequency = char:getData(\"unhandcuff_frequency\", 0)\n        char:setData(\"unhandcuff_frequency\", unhandcuffFrequency + 1)\n\n        -- Track unhandcuff patterns\n        local unhandcuffPatterns = char:getData(\"unhandcuff_patterns\", {})\n        table.insert(unhandcuffPatterns, {\n            time = os.time()\n        })\n        char:setData(\"unhandcuff_patterns\", unhandcuffPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/tying/hooks/#playeruntieaborted","title":"PlayerUnTieAborted","text":"<p>Purpose</p> <p>Called when a player's untying action is aborted.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who was untying.</li> <li><code>entity</code> (Player): The player who was being untied.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's untying action is interrupted - The untying process is cancelled - After <code>PlayerStartUnTying</code> hook</p> <p>Example Usage</p> <pre><code>-- Track untying aborts\nhook.Add(\"PlayerUnTieAborted\", \"TrackUnTyingAborts\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        local untyingAborts = char:getData(\"untying_aborts\", 0)\n        char:setData(\"untying_aborts\", untyingAborts + 1)\n    end\n\n    lia.log.add(client, \"untyingAborted\", entity:Name())\nend)\n\n-- Apply untying abort effects\nhook.Add(\"PlayerUnTieAborted\", \"UnTyingAbortEffects\", function(client, entity)\n    -- Play abort sound\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 10), 0.3, 0)\n\n    -- Notify players\n    client:notify(\"Untying aborted!\")\n    entity:notify(\"Untying was aborted!\")\nend)\n\n-- Track untying abort patterns\nhook.Add(\"PlayerUnTieAborted\", \"TrackUnTyingAbortPatterns\", function(client, entity)\n    local char = client:getChar()\n    if char then\n        -- Track abort frequency\n        local abortFrequency = char:getData(\"untying_abort_frequency\", 0)\n        char:setData(\"untying_abort_frequency\", abortFrequency + 1)\n\n        -- Track abort patterns\n        local abortPatterns = char:getData(\"untying_abort_patterns\", {})\n        table.insert(abortPatterns, {\n            target = entity:Name(),\n            time = os.time()\n        })\n        char:setData(\"untying_abort_patterns\", abortPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/tying/hooks/#resetsubmodulecuffdata","title":"ResetSubModuleCuffData","text":"<p>Purpose</p> <p>Called when handcuff data needs to be reset for submodules.</p> <p>Parameters</p> <ul> <li><code>target</code> (Player): The player whose handcuff data is being reset.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player is unhandcuffed - Handcuff data needs to be cleared - Before <code>PlayerUnhandcuffed</code> hook</p> <p>Example Usage</p> <pre><code>-- Reset handcuff data for submodules\nhook.Add(\"ResetSubModuleCuffData\", \"ResetHandcuffData\", function(target)\n    local char = target:getChar()\n    if char then\n        -- Clear all handcuff related data\n        char:setData(\"handcuffed\", false)\n        char:setData(\"handcuff_time\", nil)\n        char:setData(\"handcuff_attacker\", nil)\n        char:setData(\"handcuff_reason\", nil)\n\n        -- Clear submodule specific data\n        char:setData(\"search_data\", nil)\n        char:setData(\"confiscated_items\", nil)\n        char:setData(\"handcuff_restrictions\", nil)\n    end\n\n    lia.log.add(target, \"handcuffDataReset\")\nend)\n\n-- Apply data reset effects\nhook.Add(\"ResetSubModuleCuffData\", \"DataResetEffects\", function(target)\n    -- Play reset sound\n    target:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    target:ScreenFade(SCREENFADE.IN, Color(0, 255, 255, 5), 0.2, 0)\n\n    -- Notify target\n    target:notify(\"Handcuff data reset!\")\nend)\n\n-- Track data reset statistics\nhook.Add(\"ResetSubModuleCuffData\", \"TrackDataResetStats\", function(target)\n    local char = target:getChar()\n    if char then\n        -- Track reset frequency\n        local dataResets = char:getData(\"handcuff_data_resets\", 0)\n        char:setData(\"handcuff_data_resets\", dataResets + 1)\n\n        -- Track reset patterns\n        local resetPatterns = char:getData(\"handcuff_reset_patterns\", {})\n        table.insert(resetPatterns, {\n            time = os.time()\n        })\n        char:setData(\"handcuff_reset_patterns\", resetPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/utilities/about/","title":"About","text":"About <p>Name: Code Utilities</p> <p>Description:</p> <p>Adds extra helper functions in lia.util, simplified utilities for common scripting tasks, a central library used by other modules, utilities for networking data, and shared constants for modules.</p> Features <ul> <li>Adds extra helper functions in lia.util</li> <li>Adds simplified utilities for common scripting tasks</li> <li>Adds a central library used by other modules</li> <li>Adds utilities for networking data</li> <li>Adds shared constants for modules</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/utilities/changelog/","title":"Changelog","text":""},{"location":"modules/utilities/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency:</li> <li><code>SpeedTest</code> \u2192 <code>speedTest</code></li> <li><code>DaysBetween</code> \u2192 <code>daysBetween</code></li> <li><code>LerpHSV</code> \u2192 <code>lerpHSV</code></li> <li><code>Darken</code> \u2192 <code>darken</code></li> <li><code>LerpColor</code> \u2192 <code>lerpColor</code></li> <li><code>Blend</code> \u2192 <code>blend</code></li> <li><code>Rainbow</code> \u2192 <code>rainbow</code></li> <li><code>ColorCycle</code> \u2192 <code>colorCycle</code></li> <li><code>ColorToHex</code> \u2192 <code>colorToHex</code></li> <li><code>Lighten</code> \u2192 <code>lighten</code></li> <li><code>SecondsToDHMS</code> \u2192 <code>secondsToDHMS</code></li> <li><code>HMSToSeconds</code> \u2192 <code>hMSToSeconds</code></li> <li><code>FormatTimestamp</code> \u2192 <code>formatTimestamp</code></li> <li><code>WeekdayName</code> \u2192 <code>weekdayName</code></li> <li><code>TimeUntil</code> \u2192 <code>timeUntil</code></li> <li><code>CurrentLocalTime</code> \u2192 <code>currentLocalTime</code></li> <li><code>TimeDifference</code> \u2192 <code>timeDifference</code></li> <li><code>SerializeVector</code> \u2192 <code>serializeVector</code></li> <li><code>DeserializeVector</code> \u2192 <code>deserializeVector</code></li> <li><code>SerializeAngle</code> \u2192 <code>serializeAngle</code></li> <li><code>DeserializeAngle</code> \u2192 <code>deserializeAngle</code></li> </ul>"},{"location":"modules/utilities/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/utilities/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/utilities/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Utilities module for managing utility functions and entity spawning.</p>"},{"location":"modules/utilities/hooks/#codeutilsloaded","title":"CodeUtilsLoaded","text":"<p>Purpose</p> <p>Called when the utilities module has finished loading.</p> <p>Parameters</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - The utilities module has finished initializing - All utility functions are available - The module is ready for use</p> <p>Example Usage</p> <pre><code>-- Track utilities loading\nhook.Add(\"CodeUtilsLoaded\", \"TrackUtilsLoading\", function()\n    lia.log.add(nil, \"utilitiesLoaded\")\n\n    -- Notify all players\n    for _, ply in player.Iterator() do\n        ply:notify(\"Utilities module loaded!\")\n    end\nend)\n\n-- Apply loading effects\nhook.Add(\"CodeUtilsLoaded\", \"UtilsLoadingEffects\", function()\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(Vector(0, 0, 0))\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Print loading message\n    print(\"Utilities module loaded successfully!\")\nend)\n\n-- Initialize utilities data\nhook.Add(\"CodeUtilsLoaded\", \"InitializeUtilsData\", function()\n    -- Set up utilities data\n    lia.data.set(\"utilities_loaded\", true)\n    lia.data.set(\"utilities_load_time\", os.time())\n\n    -- Initialize utility counters\n    lia.data.set(\"utility_props_spawned\", 0)\n    lia.data.set(\"utility_entities_spawned\", 0)\nend)\n</code></pre>"},{"location":"modules/utilities/hooks/#utilityentityspawned","title":"UtilityEntitySpawned","text":"<p>Purpose</p> <p>Called when a utility entity has been spawned.</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The entity that was spawned.</li> <li><code>class</code> (string): The class name of the entity.</li> <li><code>position</code> (Vector): The position where the entity was spawned.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A utility entity is spawned using <code>lia.utilities.spawnEntities</code> - The entity is successfully created and positioned - After the entity is spawned</p> <p>Example Usage</p> <pre><code>-- Track utility entity spawning\nhook.Add(\"UtilityEntitySpawned\", \"TrackUtilityEntitySpawning\", function(entity, class, position)\n    local entitySpawns = lia.data.get(\"utility_entities_spawned\", 0)\n    lia.data.set(\"utility_entities_spawned\", entitySpawns + 1)\n\n    -- Track entity types\n    local entityTypes = lia.data.get(\"utility_entity_types\", {})\n    entityTypes[class] = (entityTypes[class] or 0) + 1\n    lia.data.set(\"utility_entity_types\", entityTypes)\n\n    lia.log.add(nil, \"utilityEntitySpawned\", class, position)\nend)\n\n-- Apply entity spawn effects\nhook.Add(\"UtilityEntitySpawned\", \"UtilityEntitySpawnEffects\", function(entity, class, position)\n    -- Play spawn sound\n    entity:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(position)\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Notify nearby players\n    for _, ply in player.Iterator() do\n        if ply:GetPos():Distance(position) &lt; 500 then\n            ply:notify(\"Utility entity spawned: \" .. class)\n        end\n    end\nend)\n\n-- Track entity spawn statistics\nhook.Add(\"UtilityEntitySpawned\", \"TrackEntitySpawnStats\", function(entity, class, position)\n    -- Track spawn frequency\n    local spawnFrequency = lia.data.get(\"utility_entity_spawn_frequency\", 0)\n    lia.data.set(\"utility_entity_spawn_frequency\", spawnFrequency + 1)\n\n    -- Track spawn patterns\n    local spawnPatterns = lia.data.get(\"utility_entity_spawn_patterns\", {})\n    table.insert(spawnPatterns, {\n        class = class,\n        position = position,\n        time = os.time()\n    })\n    lia.data.set(\"utility_entity_spawn_patterns\", spawnPatterns)\nend)\n</code></pre>"},{"location":"modules/utilities/hooks/#utilitypropspawned","title":"UtilityPropSpawned","text":"<p>Purpose</p> <p>Called when a utility prop has been spawned.</p> <p>Parameters</p> <ul> <li><code>entity</code> (Entity): The prop entity that was spawned.</li> <li><code>model</code> (string): The model path of the prop.</li> <li><code>position</code> (Vector): The position where the prop was spawned.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A utility prop is spawned using <code>lia.utilities.spawnProp</code> - The prop is successfully created and positioned - After the prop is spawned</p> <p>Example Usage</p> <pre><code>-- Track utility prop spawning\nhook.Add(\"UtilityPropSpawned\", \"TrackUtilityPropSpawning\", function(entity, model, position)\n    local propSpawns = lia.data.get(\"utility_props_spawned\", 0)\n    lia.data.set(\"utility_props_spawned\", propSpawns + 1)\n\n    -- Track prop models\n    local propModels = lia.data.get(\"utility_prop_models\", {})\n    propModels[model] = (propModels[model] or 0) + 1\n    lia.data.set(\"utility_prop_models\", propModels)\n\n    lia.log.add(nil, \"utilityPropSpawned\", model, position)\nend)\n\n-- Apply prop spawn effects\nhook.Add(\"UtilityPropSpawned\", \"UtilityPropSpawnEffects\", function(entity, model, position)\n    -- Play spawn sound\n    entity:EmitSound(\"buttons/button15.wav\", 75, 100)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(position)\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\n\n    -- Notify nearby players\n    for _, ply in player.Iterator() do\n        if ply:GetPos():Distance(position) &lt; 500 then\n            ply:notify(\"Utility prop spawned: \" .. model)\n        end\n    end\nend)\n\n-- Track prop spawn statistics\nhook.Add(\"UtilityPropSpawned\", \"TrackPropSpawnStats\", function(entity, model, position)\n    -- Track spawn frequency\n    local spawnFrequency = lia.data.get(\"utility_prop_spawn_frequency\", 0)\n    lia.data.set(\"utility_prop_spawn_frequency\", spawnFrequency + 1)\n\n    -- Track spawn patterns\n    local spawnPatterns = lia.data.get(\"utility_prop_spawn_patterns\", {})\n    table.insert(spawnPatterns, {\n        model = model,\n        position = position,\n        time = os.time()\n    })\n    lia.data.set(\"utility_prop_spawn_patterns\", spawnPatterns)\nend)\n</code></pre>"},{"location":"modules/utilities/libraries/","title":"lia.utilities Library","text":""},{"location":"modules/utilities/libraries/#overview","title":"Overview","text":"<p>Utility helpers for colors, time, math, debug printing, and simple entity spawning.</p>"},{"location":"modules/utilities/libraries/#speedtest","title":"speedTest","text":"<p>Purpose</p> <p>Run a function repeatedly and measure the elapsed time.</p> <p>When Called</p> <p>This function is used when: - Benchmarking a function's performance</p> <p>Parameters</p> <ul> <li><code>func</code> (function): Function to call.</li> <li><code>n</code> (number): Number of iterations.</li> </ul> <p>Returns</p> <ul> <li><code>seconds</code> (number): Elapsed time in seconds.</li> </ul> <p>Realm</p> <p>Shared.</p> <p>Example Usage</p> <pre><code>local took = lia.utilities.speedTest(function() end, 1e5)\nprint(took)\n</code></pre>"},{"location":"modules/utilities/libraries/#daysbetween","title":"daysBetween","text":"<p>Purpose</p> <p>Return the number of days between two timestamps/strings.</p> <p>When Called</p> <p>This function is used when: - Comparing dates for cooldowns or reports</p> <p>Parameters</p> <ul> <li><code>t1</code> (string|number): First time.</li> <li><code>t2</code> (string|number): Second time.</li> </ul> <p>Returns</p> <ul> <li><code>days</code> (number): Whole or fractional days between.</li> </ul> <p>Realm</p> <p>Shared.</p> <p>Example Usage</p> <pre><code>local days = lia.utilities.daysBetween(os.time(), os.time() + 172800)\n</code></pre>"},{"location":"modules/utilities/libraries/#lerphsv","title":"lerpHSV","text":"<p>Purpose</p> <p>Interpolate between two colors in HSV space.</p> <p>When Called</p> <p>This function is used when: - Animating color transitions</p> <p>Parameters</p> <ul> <li><code>c1</code> (Color): Start color.</li> <li><code>c2</code> (Color): End color.</li> <li><code>maxVal</code> (number): Max range value.</li> <li><code>curVal</code> (number): Current position.</li> <li><code>minVal</code> (number): Min range value.</li> </ul> <p>Returns</p> <ul> <li><code>color</code> (Color): Interpolated color.</li> </ul> <p>Realm</p> <p>Shared.</p> <p>Example Usage</p> <pre><code>local c = lia.utilities.lerpHSV(Color(255,0,0), Color(0,0,255), 1, 0.5, 0)\n</code></pre>"},{"location":"modules/utilities/libraries/#darken","title":"darken","text":"<p>Purpose</p> <p>Return a darker version of a color.</p> <p>Parameters</p> <ul> <li><code>col</code> (Color): Base color.</li> <li><code>amt</code> (number): Amount 0-1.</li> </ul> <p>Returns</p> <ul> <li><code>color</code> (Color)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#lerpcolor","title":"lerpColor","text":"<p>Purpose</p> <p>Linear interpolate between two colors in RGB space.</p> <p>Parameters</p> <ul> <li><code>f</code> (number): Fraction 0-1.</li> <li><code>from</code> (Color): Start.</li> <li><code>to</code> (Color): End.</li> </ul> <p>Returns</p> <ul> <li><code>color</code> (Color)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#blend","title":"blend","text":"<p>Purpose</p> <p>Blend two colors by ratio.</p> <p>Parameters</p> <ul> <li><code>a</code> (Color)</li> <li><code>b</code> (Color)</li> <li><code>r</code> (number): Ratio 0-1.</li> </ul> <p>Returns</p> <ul> <li><code>color</code> (Color)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#rgb","title":"rgb","text":"<p>Purpose</p> <p>Shorthand to create a Color.</p> <p>Parameters</p> <ul> <li><code>r</code> (number)</li> <li><code>g</code> (number)</li> <li><code>b</code> (number)</li> </ul> <p>Returns</p> <ul> <li><code>color</code> (Color)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#rainbow","title":"rainbow","text":"<p>Purpose</p> <p>Return a cycling rainbow color over time.</p> <p>Parameters</p> <ul> <li><code>freq</code> (number): Speed factor.</li> </ul> <p>Returns</p> <ul> <li><code>color</code> (Color)</li> </ul> <p>Realm</p> <p>Client.</p>"},{"location":"modules/utilities/libraries/#colorcycle","title":"colorCycle","text":"<p>Purpose</p> <p>Cycle between two colors over time.</p> <p>Parameters</p> <ul> <li><code>a</code> (Color)</li> <li><code>b</code> (Color)</li> <li><code>f</code> (number): Frequency.</li> </ul> <p>Returns</p> <ul> <li><code>color</code> (Color)</li> </ul> <p>Realm</p> <p>Client.</p>"},{"location":"modules/utilities/libraries/#colortohex","title":"colorToHex","text":"<p>Purpose</p> <p>Convert a Color to a <code>0xRRGGBB</code> hex string.</p> <p>Parameters</p> <ul> <li><code>c</code> (Color)</li> </ul> <p>Returns</p> <ul> <li><code>hex</code> (string)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#lighten","title":"lighten","text":"<p>Purpose</p> <p>Return a lighter version of a color.</p> <p>Parameters</p> <ul> <li><code>col</code> (Color)</li> <li><code>amt</code> (number): 0-1.</li> </ul> <p>Returns</p> <ul> <li><code>color</code> (Color)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#totext","title":"toText","text":"<p>Purpose</p> <p>Serialize a Color to a human readable string.</p> <p>Parameters</p> <ul> <li><code>c</code> (Color)</li> </ul> <p>Returns</p> <ul> <li><code>text</code> (string|nil)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#secondstodhms","title":"secondsToDHMS","text":"<p>Purpose</p> <p>Convert seconds into days, hours, minutes, seconds.</p> <p>Parameters</p> <ul> <li><code>sec</code> (number)</li> </ul> <p>Returns</p> <ul> <li><code>d</code> (number), <code>h</code> (number), <code>m</code> (number), <code>s</code> (number)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#hmstoseconds","title":"hMSToSeconds","text":"<p>Purpose</p> <p>Convert hours/minutes/seconds to seconds.</p> <p>Parameters</p> <ul> <li><code>h</code> (number)</li> <li><code>m</code> (number)</li> <li><code>s</code> (number)</li> </ul> <p>Returns</p> <ul> <li><code>seconds</code> (number)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#formattimestamp","title":"formatTimestamp","text":"<p>Purpose</p> <p>Format a timestamp into a locale-friendly table/string.</p> <p>Parameters</p> <ul> <li><code>ts</code> (number)</li> </ul> <p>Returns</p> <ul> <li><code>t</code> (table|string): Formatted time.</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#weekdayname","title":"weekdayName","text":"<p>Purpose</p> <p>Parse a time string and return weekday name.</p> <p>Parameters</p> <ul> <li><code>str</code> (string)</li> </ul> <p>Returns</p> <ul> <li><code>name</code> (string)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#timeuntil","title":"timeUntil","text":"<p>Purpose</p> <p>Time difference until a future time string.</p> <p>Parameters</p> <ul> <li><code>str</code> (string)</li> </ul> <p>Returns</p> <ul> <li><code>seconds</code> (number)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#currentlocaltime","title":"currentLocalTime","text":"<p>Purpose</p> <p>Return the current local time table.</p> <p>Parameters</p> <p>None.</p> <p>Returns</p> <ul> <li><code>t</code> (table)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#timedifference","title":"timeDifference","text":"<p>Purpose</p> <p>Return a human-friendly difference between now and a time string.</p> <p>Parameters</p> <ul> <li><code>str</code> (string)</li> </ul> <p>Returns</p> <ul> <li><code>text</code> (string)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#serializevector","title":"serializeVector","text":"<p>Purpose</p> <p>Serialize a <code>Vector</code> to JSON.</p> <p>Parameters</p> <ul> <li><code>v</code> (Vector)</li> </ul> <p>Returns</p> <ul> <li><code>json</code> (string)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#deserializevector","title":"deserializeVector","text":"<p>Purpose</p> <p>Deserialize JSON into a <code>Vector</code>.</p> <p>Parameters</p> <ul> <li><code>data</code> (string)</li> </ul> <p>Returns</p> <ul> <li><code>v</code> (Vector)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#serializeangle","title":"serializeAngle","text":"<p>Purpose</p> <p>Serialize an <code>Angle</code> to JSON.</p> <p>Parameters</p> <ul> <li><code>a</code> (Angle)</li> </ul> <p>Returns</p> <ul> <li><code>json</code> (string)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#deserializeangle","title":"deserializeAngle","text":"<p>Purpose</p> <p>Deserialize JSON into an <code>Angle</code>.</p> <p>Parameters</p> <ul> <li><code>data</code> (string)</li> </ul> <p>Returns</p> <ul> <li><code>a</code> (Angle)</li> </ul> <p>Realm</p> <p>Shared.</p>"},{"location":"modules/utilities/libraries/#dprint","title":"dprint","text":"<p>Purpose</p> <p>Print a prefixed debug line to console.</p> <p>Parameters</p> <ul> <li><code>...</code> (any): Values to print.</li> </ul> <p>Returns</p> <p>None.</p> <p>Realm</p> <p>Shared.</p> <p>Example Usage</p> <pre><code>lia.utilities.dprint(\"Loaded\")\n</code></pre>"},{"location":"modules/utilities/libraries/#spawnprop","title":"spawnProp","text":"<p>Purpose</p> <p>Spawn a physics prop with optional force, lifetime, angle, and color.</p> <p>When Called</p> <p>This function is used when: - Spawning temporary props server-side</p> <p>Parameters</p> <ul> <li><code>model</code> (string)</li> <li><code>pos</code> (Vector)</li> <li><code>force</code> (Vector|nil)</li> <li><code>life</code> (number|nil): Auto-remove after seconds.</li> <li><code>ang</code> (Angle|nil)</li> <li><code>col</code> (Color|nil)</li> </ul> <p>Returns</p> <ul> <li><code>ent</code> (Entity): The spawned entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>Example Usage</p> <pre><code>local ent = lia.utilities.spawnProp(\"models/props_c17/oildrum001.mdl\", Vector(0,0,64))\n</code></pre>"},{"location":"modules/utilities/libraries/#spawnentities","title":"spawnEntities","text":"<p>Purpose</p> <p>Spawn multiple entities from a class-&gt;properties table.</p> <p>Parameters</p> <ul> <li><code>tbl</code> (table): Map of class to properties.</li> </ul> <p>Returns</p> <p>None.</p> <p>Realm</p> <p>Server.</p> <p>Example Usage</p> <pre><code>lia.utilities.spawnEntities({\n  [\"prop_physics\"] = { model = \"models/props_junk/wood_crate001a.mdl\", pos = Vector(0,0,64) }\n})\n</code></pre>"},{"location":"modules/viewbob/about/","title":"About","text":"About <p>Name: View Bob</p> <p>Description:</p> <p>Adds camera bobbing while moving, adjustable intensity, hooks to modify view punch, and configuration for bobbing frequency.</p> Features <ul> <li>Adds camera bobbing while moving</li> <li>Adds adjustable intensity</li> <li>Adds hooks to modify view punch</li> <li>Adds configuration for bobbing frequency</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/viewbob/changelog/","title":"Changelog","text":""},{"location":"modules/viewbob/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/viewbob/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/viewbob/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the View Bob module for managing camera bobbing and view punch effects.</p>"},{"location":"modules/viewbob/hooks/#postviewpunch","title":"PostViewPunch","text":"<p>Purpose</p> <p>Called after a view punch has been applied to the player's camera.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose view was punched.</li> <li><code>angleX</code> (number): The X-axis angle of the view punch.</li> <li><code>angleY</code> (number): The Y-axis angle of the view punch.</li> <li><code>angleZ</code> (number): The Z-axis angle of the view punch.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A view punch has been applied to the player's camera - After <code>ViewBobPunch</code> hook - After the <code>ViewPunch</code> function has been called</p> <p>Example Usage</p> <pre><code>-- Track view punch effects\nhook.Add(\"PostViewPunch\", \"TrackViewPunchEffects\", function(client, angleX, angleY, angleZ)\n    local char = client:getChar()\n    if char then\n        local viewPunches = char:getData(\"view_punches\", 0)\n        char:setData(\"view_punches\", viewPunches + 1)\n\n        -- Track punch intensity\n        local punchIntensity = math.sqrt(angleX^2 + angleY^2 + angleZ^2)\n        char:setData(\"total_punch_intensity\", char:getData(\"total_punch_intensity\", 0) + punchIntensity)\n    end\nend)\n\n-- Apply post-punch effects\nhook.Add(\"PostViewPunch\", \"PostPunchEffects\", function(client, angleX, angleY, angleZ)\n    -- Play punch sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 255, 5), 0.3, 0)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track punch patterns\nhook.Add(\"PostViewPunch\", \"TrackPunchPatterns\", function(client, angleX, angleY, angleZ)\n    local char = client:getChar()\n    if char then\n        -- Track punch directions\n        local punchDirections = char:getData(\"punch_directions\", {})\n        if angleX &gt; 0 then\n            punchDirections.x_positive = (punchDirections.x_positive or 0) + 1\n        elseif angleX &lt; 0 then\n            punchDirections.x_negative = (punchDirections.x_negative or 0) + 1\n        end\n\n        if angleY &gt; 0 then\n            punchDirections.y_positive = (punchDirections.y_positive or 0) + 1\n        elseif angleY &lt; 0 then\n            punchDirections.y_negative = (punchDirections.y_negative or 0) + 1\n        end\n\n        if angleZ &gt; 0 then\n            punchDirections.z_positive = (punchDirections.z_positive or 0) + 1\n        elseif angleZ &lt; 0 then\n            punchDirections.z_negative = (punchDirections.z_negative or 0) + 1\n        end\n\n        char:setData(\"punch_directions\", punchDirections)\n    end\nend)\n\n-- Apply punch restrictions\nhook.Add(\"PostViewPunch\", \"ApplyPunchRestrictions\", function(client, angleX, angleY, angleZ)\n    local char = client:getChar()\n    if char then\n        -- Check punch cooldown\n        local lastPunch = char:getData(\"last_punch_time\", 0)\n        if os.time() - lastPunch &lt; 1 then -- 1 second cooldown\n            char:setData(\"punch_cooldown_warning\", true)\n            client:notify(\"View punch cooldown active!\")\n        end\n\n        -- Update last punch time\n        char:setData(\"last_punch_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/viewbob/hooks/#previewpunch","title":"PreViewPunch","text":"<p>Purpose</p> <p>Called before a view punch is applied to the player's camera.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose view will be punched.</li> <li><code>angleX</code> (number): The X-axis angle of the view punch.</li> <li><code>angleY</code> (number): The Y-axis angle of the view punch.</li> <li><code>angleZ</code> (number): The Z-axis angle of the view punch.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A view punch is about to be applied - Before <code>ViewBobPunch</code> hook - Before the <code>ViewPunch</code> function is called</p> <p>Example Usage</p> <pre><code>-- Validate view punch\nhook.Add(\"PreViewPunch\", \"ValidateViewPunch\", function(client, angleX, angleY, angleZ)\n    local char = client:getChar()\n    if char then\n        -- Check if view punch is disabled\n        if char:getData(\"view_punch_disabled\", false) then\n            client:notify(\"View punch is disabled!\")\n            return false\n        end\n\n        -- Check punch limits\n        local punchIntensity = math.sqrt(angleX^2 + angleY^2 + angleZ^2)\n        if punchIntensity &gt; 10 then\n            client:notify(\"View punch intensity too high!\")\n            return false\n        end\n    end\nend)\n\n-- Modify view punch values\nhook.Add(\"PreViewPunch\", \"ModifyViewPunch\", function(client, angleX, angleY, angleZ)\n    local char = client:getChar()\n    if char then\n        -- Apply punch multiplier\n        local punchMultiplier = char:getData(\"punch_multiplier\", 1)\n        angleX = angleX * punchMultiplier\n        angleY = angleY * punchMultiplier\n        angleZ = angleZ * punchMultiplier\n\n        -- Apply punch dampening\n        local punchDampening = char:getData(\"punch_dampening\", 1)\n        angleX = angleX * punchDampening\n        angleY = angleY * punchDampening\n        angleZ = angleZ * punchDampening\n    end\nend)\n\n-- Track view punch attempts\nhook.Add(\"PreViewPunch\", \"TrackViewPunchAttempts\", function(client, angleX, angleY, angleZ)\n    local char = client:getChar()\n    if char then\n        local punchAttempts = char:getData(\"punch_attempts\", 0)\n        char:setData(\"punch_attempts\", punchAttempts + 1)\n\n        -- Track punch frequency\n        local lastPunch = char:getData(\"last_punch_time\", 0)\n        char:setData(\"last_punch_time\", os.time())\n\n        if os.time() - lastPunch &lt; 1 then\n            char:setData(\"rapid_punch_attempts\", char:getData(\"rapid_punch_attempts\", 0) + 1)\n        end\n    end\nend)\n\n-- Apply pre-punch effects\nhook.Add(\"PreViewPunch\", \"PrePunchEffects\", function(client, angleX, angleY, angleZ)\n    -- Play pre-punch sound\n    client:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.2, 0)\nend)\n</code></pre>"},{"location":"modules/viewbob/hooks/#viewbobpunch","title":"ViewBobPunch","text":"<p>Purpose</p> <p>Called when a view punch is being applied during view bobbing.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose view is being punched.</li> <li><code>angleX</code> (number): The X-axis angle of the view punch.</li> <li><code>angleY</code> (number): The Y-axis angle of the view punch.</li> <li><code>angleZ</code> (number): The Z-axis angle of the view punch.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A view punch is being applied during movement - After <code>PreViewPunch</code> hook - Before the <code>ViewPunch</code> function is called</p> <p>Example Usage</p> <pre><code>-- Track view bob punches\nhook.Add(\"ViewBobPunch\", \"TrackViewBobPunches\", function(client, angleX, angleY, angleZ)\n    local char = client:getChar()\n    if char then\n        local viewBobPunches = char:getData(\"view_bob_punches\", 0)\n        char:setData(\"view_bob_punches\", viewBobPunches + 1)\n\n        -- Track punch intensity\n        local punchIntensity = math.sqrt(angleX^2 + angleY^2 + angleZ^2)\n        char:setData(\"total_bob_intensity\", char:getData(\"total_bob_intensity\", 0) + punchIntensity)\n    end\nend)\n\n-- Apply view bob effects\nhook.Add(\"ViewBobPunch\", \"ViewBobEffects\", function(client, angleX, angleY, angleZ)\n    -- Play bob sound\n    client:EmitSound(\"player/pl_jump1.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 3), 0.1, 0)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Customize view bob behavior\nhook.Add(\"ViewBobPunch\", \"CustomizeViewBob\", function(client, angleX, angleY, angleZ)\n    local char = client:getChar()\n    if char then\n        -- Apply character-specific modifications\n        local bobStyle = char:getData(\"bob_style\", \"normal\")\n\n        if bobStyle == \"aggressive\" then\n            angleX = angleX * 1.5\n            angleY = angleY * 1.5\n            angleZ = angleZ * 1.5\n        elseif bobStyle == \"subtle\" then\n            angleX = angleX * 0.5\n            angleY = angleY * 0.5\n            angleZ = angleZ * 0.5\n        end\n\n        -- Apply movement-based modifications\n        if client:KeyDown(IN_SPEED) then\n            angleX = angleX * 1.2\n            angleY = angleY * 1.2\n            angleZ = angleZ * 1.2\n        elseif client:KeyDown(IN_DUCK) then\n            angleX = angleX * 0.8\n            angleY = angleY * 0.8\n            angleZ = angleZ * 0.8\n        end\n    end\nend)\n\n-- Track view bob patterns\nhook.Add(\"ViewBobPunch\", \"TrackViewBobPatterns\", function(client, angleX, angleY, angleZ)\n    local char = client:getChar()\n    if char then\n        -- Track movement patterns\n        local movementPatterns = char:getData(\"movement_patterns\", {})\n        local pattern = \"unknown\"\n\n        if client:KeyDown(IN_FORWARD) then\n            pattern = \"forward\"\n        elseif client:KeyDown(IN_BACK) then\n            pattern = \"backward\"\n        elseif client:KeyDown(IN_MOVERIGHT) then\n            pattern = \"right\"\n        elseif client:KeyDown(IN_MOVELEFT) then\n            pattern = \"left\"\n        end\n\n        movementPatterns[pattern] = (movementPatterns[pattern] or 0) + 1\n        char:setData(\"movement_patterns\", movementPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/viewbob/hooks/#viewbobstep","title":"ViewBobStep","text":"<p>Purpose</p> <p>Called when determining the step value for view bobbing.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player whose step value is being determined.</li> <li><code>stepValue</code> (number): The current step value (1 or -1).</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A player takes a step while moving - The step value is being determined for view bobbing - Before the view punch is applied</p> <p>Example Usage</p> <pre><code>-- Customize step value\nhook.Add(\"ViewBobStep\", \"CustomizeStepValue\", function(client, stepValue)\n    local char = client:getChar()\n    if char then\n        -- Apply character-specific step modifications\n        local stepStyle = char:getData(\"step_style\", \"normal\")\n\n        if stepStyle == \"irregular\" then\n            -- Make steps more irregular\n            if math.random(1, 10) &lt;= 3 then\n                stepValue = stepValue * -1\n            end\n        elseif stepStyle == \"rhythmic\" then\n            -- Make steps more rhythmic\n            local stepCount = char:getData(\"step_count\", 0)\n            char:setData(\"step_count\", stepCount + 1)\n\n            if stepCount % 4 == 0 then\n                stepValue = stepValue * 1.5\n            end\n        end\n\n        -- Apply movement-based modifications\n        if client:KeyDown(IN_SPEED) then\n            stepValue = stepValue * 1.2\n        elseif client:KeyDown(IN_DUCK) then\n            stepValue = stepValue * 0.8\n        end\n    end\n\n    return stepValue\nend)\n\n-- Track step patterns\nhook.Add(\"ViewBobStep\", \"TrackStepPatterns\", function(client, stepValue)\n    local char = client:getChar()\n    if char then\n        local stepCount = char:getData(\"step_count\", 0)\n        char:setData(\"step_count\", stepCount + 1)\n\n        -- Track step frequency\n        local lastStep = char:getData(\"last_step_time\", 0)\n        char:setData(\"last_step_time\", os.time())\n\n        if os.time() - lastStep &lt; 1 then\n            char:setData(\"rapid_steps\", char:getData(\"rapid_steps\", 0) + 1)\n        end\n\n        -- Track step directions\n        local stepDirections = char:getData(\"step_directions\", {})\n        if stepValue &gt; 0 then\n            stepDirections.positive = (stepDirections.positive or 0) + 1\n        else\n            stepDirections.negative = (stepDirections.negative or 0) + 1\n        end\n        char:setData(\"step_directions\", stepDirections)\n    end\nend)\n\n-- Apply step effects\nhook.Add(\"ViewBobStep\", \"StepEffects\", function(client, stepValue)\n    -- Play step sound\n    client:EmitSound(\"player/pl_step1.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 2), 0.1, 0)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Apply step restrictions\nhook.Add(\"ViewBobStep\", \"ApplyStepRestrictions\", function(client, stepValue)\n    local char = client:getChar()\n    if char then\n        -- Check if view bobbing is disabled\n        if char:getData(\"view_bob_disabled\", false) then\n            return 0\n        end\n\n        -- Check step cooldown\n        local lastStep = char:getData(\"last_step_time\", 0)\n        if os.time() - lastStep &lt; 0.1 then -- 0.1 second cooldown\n            return stepValue * 0.5\n        end\n\n        -- Update last step time\n        char:setData(\"last_step_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/vmanip/about/","title":"About","text":"About <p>Name: View Manipulation</p> <p>Description:</p> <p>Adds VManip animation support, hand gestures for items, functionality within Lilia, API for custom gesture triggers, and fallback animations when VManip is missing.</p> Features <ul> <li>Adds VManip animation support</li> <li>Adds hand gestures for items</li> <li>Adds functionality within Lilia</li> <li>Adds API for custom gesture triggers</li> <li>Adds fallback animations when VManip is missing</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/vmanip/changelog/","title":"Changelog","text":""},{"location":"modules/vmanip/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/vmanip/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/vmanip/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the View Manipulation module for managing VManip animations and item interactions.</p>"},{"location":"modules/vmanip/hooks/#prevmanippickup","title":"PreVManipPickup","text":"<p>Purpose</p> <p>Called before a VManip pickup animation is triggered for an item.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is picking up the item.</li> <li><code>item</code> (Item): The item being picked up.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player interacts with an item that has VManip support - Before the pickup animation is sent to the client - Before <code>VManipPickup</code> hook</p> <p>Example Usage</p> <pre><code>-- Track VManip pickup attempts\nhook.Add(\"PreVManipPickup\", \"TrackVManipPickups\", function(client, item)\n    local char = client:getChar()\n    if char then\n        local vmanipPickups = char:getData(\"vmanip_pickups\", 0)\n        char:setData(\"vmanip_pickups\", vmanipPickups + 1)\n\n        -- Track item types\n        local itemTypes = char:getData(\"vmanip_item_types\", {})\n        itemTypes[item.uniqueID] = (itemTypes[item.uniqueID] or 0) + 1\n        char:setData(\"vmanip_item_types\", itemTypes)\n    end\n\n    lia.log.add(client, \"vmanipPickupAttempt\", item.uniqueID)\nend)\n\n-- Apply pickup restrictions\nhook.Add(\"PreVManipPickup\", \"ApplyPickupRestrictions\", function(client, item)\n    local char = client:getChar()\n    if char then\n        -- Check if VManip is disabled\n        if char:getData(\"vmanip_disabled\", false) then\n            client:notify(\"VManip animations are disabled!\")\n            return false\n        end\n\n        -- Check pickup cooldown\n        local lastPickup = char:getData(\"last_vmanip_pickup_time\", 0)\n        if os.time() - lastPickup &lt; 2 then -- 2 second cooldown\n            client:notify(\"Please wait before picking up another item!\")\n            return false\n        end\n\n        -- Check item restrictions\n        if item.VManipDisabled then\n            client:notify(\"This item cannot be picked up with VManip!\")\n            return false\n        end\n\n        -- Update last pickup time\n        char:setData(\"last_vmanip_pickup_time\", os.time())\n    end\nend)\n\n-- Modify pickup behavior\nhook.Add(\"PreVManipPickup\", \"ModifyPickupBehavior\", function(client, item)\n    local char = client:getChar()\n    if char then\n        -- Apply character-specific modifications\n        local pickupStyle = char:getData(\"pickup_style\", \"normal\")\n\n        if pickupStyle == \"aggressive\" then\n            -- Make pickup more aggressive\n            item.VManipDisabled = false\n        elseif pickupStyle == \"careful\" then\n            -- Make pickup more careful\n            item.VManipDisabled = true\n        end\n\n        -- Apply item-specific modifications\n        if item.uniqueID == \"weapon_*\" then\n            -- Special handling for weapons\n            char:setData(\"weapon_pickup_count\", char:getData(\"weapon_pickup_count\", 0) + 1)\n        elseif item.uniqueID == \"food_*\" then\n            -- Special handling for food\n            char:setData(\"food_pickup_count\", char:getData(\"food_pickup_count\", 0) + 1)\n        end\n    end\nend)\n\n-- Apply pickup effects\nhook.Add(\"PreVManipPickup\", \"PickupEffects\", function(client, item)\n    -- Play pickup sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.5, 0)\n\n    -- Notify client\n    client:notify(\"Picking up \" .. item.name .. \" with VManip!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n</code></pre>"},{"location":"modules/vmanip/hooks/#vmanipanimationplayed","title":"VManipAnimationPlayed","text":"<p>Purpose</p> <p>Called when a VManip animation has been played on the client.</p> <p>Parameters</p> <ul> <li><code>itemID</code> (string): The unique ID of the item that triggered the animation.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A VManip animation has been played - After the animation is sent from the server - After <code>VManipChooseAnim</code> hook</p> <p>Example Usage</p> <pre><code>-- Track VManip animation playback\nhook.Add(\"VManipAnimationPlayed\", \"TrackVManipAnimations\", function(itemID)\n    local char = LocalPlayer():getChar()\n    if char then\n        local animationsPlayed = char:getData(\"vmanip_animations_played\", 0)\n        char:setData(\"vmanip_animations_played\", animationsPlayed + 1)\n\n        -- Track specific item animations\n        local itemAnimations = char:getData(\"vmanip_item_animations\", {})\n        itemAnimations[itemID] = (itemAnimations[itemID] or 0) + 1\n        char:setData(\"vmanip_item_animations\", itemAnimations)\n    end\nend)\n\n-- Apply animation effects\nhook.Add(\"VManipAnimationPlayed\", \"AnimationEffects\", function(itemID)\n    -- Play animation sound\n    LocalPlayer():EmitSound(\"buttons/button15.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.5, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"VManip animation played for \" .. itemID .. \"!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(LocalPlayer():GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track animation statistics\nhook.Add(\"VManipAnimationPlayed\", \"TrackAnimationStats\", function(itemID)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Track animation frequency\n        local animationFrequency = char:getData(\"vmanip_animation_frequency\", 0)\n        char:setData(\"vmanip_animation_frequency\", animationFrequency + 1)\n\n        -- Track animation patterns\n        local animationPatterns = char:getData(\"vmanip_animation_patterns\", {})\n        table.insert(animationPatterns, {\n            item = itemID,\n            time = os.time()\n        })\n        char:setData(\"vmanip_animation_patterns\", animationPatterns)\n\n        -- Track animation duration\n        local animationDuration = char:getData(\"total_vmanip_animation_duration\", 0)\n        char:setData(\"total_vmanip_animation_duration\", animationDuration + 2) -- Default 2 second duration\n    end\nend)\n\n-- Apply animation restrictions\nhook.Add(\"VManipAnimationPlayed\", \"ApplyAnimationRestrictions\", function(itemID)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if animations are disabled\n        if char:getData(\"vmanip_animations_disabled\", false) then\n            LocalPlayer():notify(\"VManip animations are disabled!\")\n            return false\n        end\n\n        -- Check animation cooldown\n        local lastAnimation = char:getData(\"last_vmanip_animation_time\", 0)\n        if os.time() - lastAnimation &lt; 1 then -- 1 second cooldown\n            LocalPlayer():notify(\"Please wait before playing another animation!\")\n            return false\n        end\n\n        -- Update last animation time\n        char:setData(\"last_vmanip_animation_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/vmanip/hooks/#vmanipchooseanim","title":"VManipChooseAnim","text":"<p>Purpose</p> <p>Called when choosing which VManip animation to play for an item.</p> <p>Parameters</p> <ul> <li><code>itemID</code> (string): The unique ID of the item requesting an animation.</li> </ul> <p>Realm</p> <p>Client.</p> <p>When Called</p> <p>This hook is triggered when: - A VManip animation is about to be played - Before the animation is selected - Before <code>VManipAnimationPlayed</code> hook</p> <p>Example Usage</p> <pre><code>-- Customize animation selection\nhook.Add(\"VManipChooseAnim\", \"CustomizeAnimationSelection\", function(itemID)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Apply character-specific animation preferences\n        local animationStyle = char:getData(\"animation_style\", \"normal\")\n\n        if animationStyle == \"aggressive\" then\n            -- Choose more aggressive animations\n            if itemID == \"weapon_*\" then\n                return \"interactaggressive\"\n            elseif itemID == \"food_*\" then\n                return \"interactquick\"\n            end\n        elseif animationStyle == \"careful\" then\n            -- Choose more careful animations\n            if itemID == \"weapon_*\" then\n                return \"interactcareful\"\n            elseif itemID == \"food_*\" then\n                return \"interactslow\"\n            end\n        elseif animationStyle == \"dramatic\" then\n            -- Choose more dramatic animations\n            if itemID == \"weapon_*\" then\n                return \"interactdramatic\"\n            elseif itemID == \"food_*\" then\n                return \"interacttheatrical\"\n            end\n        end\n\n        -- Apply item-specific animations\n        if itemID == \"weapon_pistol\" then\n            return \"interactpistol\"\n        elseif itemID == \"weapon_rifle\" then\n            return \"interactrifle\"\n        elseif itemID == \"food_bread\" then\n            return \"interactbread\"\n        elseif itemID == \"food_water\" then\n            return \"interactwater\"\n        end\n    end\n\n    -- Return default animation\n    return \"interactslower\"\nend)\n\n-- Track animation selection\nhook.Add(\"VManipChooseAnim\", \"TrackAnimationSelection\", function(itemID)\n    local char = LocalPlayer():getChar()\n    if char then\n        local animationSelections = char:getData(\"vmanip_animation_selections\", 0)\n        char:setData(\"vmanip_animation_selections\", animationSelections + 1)\n\n        -- Track item-specific selections\n        local itemSelections = char:getData(\"vmanip_item_selections\", {})\n        itemSelections[itemID] = (itemSelections[itemID] or 0) + 1\n        char:setData(\"vmanip_item_selections\", itemSelections)\n    end\nend)\n\n-- Apply animation selection effects\nhook.Add(\"VManipChooseAnim\", \"AnimationSelectionEffects\", function(itemID)\n    -- Play selection sound\n    LocalPlayer():EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    LocalPlayer():ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 5), 0.3, 0)\n\n    -- Notify player\n    LocalPlayer():notify(\"Choosing VManip animation for \" .. itemID .. \"!\")\nend)\n\n-- Apply animation selection restrictions\nhook.Add(\"VManipChooseAnim\", \"ApplyAnimationSelectionRestrictions\", function(itemID)\n    local char = LocalPlayer():getChar()\n    if char then\n        -- Check if animation selection is disabled\n        if char:getData(\"vmanip_animation_selection_disabled\", false) then\n            LocalPlayer():notify(\"VManip animation selection is disabled!\")\n            return \"interactdisabled\"\n        end\n\n        -- Check selection cooldown\n        local lastSelection = char:getData(\"last_animation_selection_time\", 0)\n        if os.time() - lastSelection &lt; 0.5 then -- 0.5 second cooldown\n            return \"interactcooldown\"\n        end\n\n        -- Update last selection time\n        char:setData(\"last_animation_selection_time\", os.time())\n    end\nend)\n</code></pre>"},{"location":"modules/vmanip/hooks/#vmanippickup","title":"VManipPickup","text":"<p>Purpose</p> <p>Called when a VManip pickup animation is triggered for an item.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is picking up the item.</li> <li><code>item</code> (Item): The item being picked up.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A VManip pickup animation is triggered - After <code>PreVManipPickup</code> hook - After the animation is sent to the client</p> <p>Example Usage</p> <pre><code>-- Track VManip pickup completion\nhook.Add(\"VManipPickup\", \"TrackVManipPickupCompletion\", function(client, item)\n    local char = client:getChar()\n    if char then\n        local vmanipPickupsCompleted = char:getData(\"vmanip_pickups_completed\", 0)\n        char:setData(\"vmanip_pickups_completed\", vmanipPickupsCompleted + 1)\n\n        -- Track pickup success rate\n        local pickupAttempts = char:getData(\"vmanip_pickup_attempts\", 0)\n        local pickupSuccesses = char:getData(\"vmanip_pickup_successes\", 0)\n        char:setData(\"vmanip_pickup_successes\", pickupSuccesses + 1)\n\n        local successRate = pickupSuccesses / pickupAttempts\n        char:setData(\"vmanip_pickup_success_rate\", successRate)\n    end\n\n    lia.log.add(client, \"vmanipPickupCompleted\", item.uniqueID)\nend)\n\n-- Apply pickup completion effects\nhook.Add(\"VManipPickup\", \"PickupCompletionEffects\", function(client, item)\n    -- Play completion sound\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 15), 0.5, 0)\n\n    -- Notify client\n    client:notify(\"Successfully picked up \" .. item.name .. \" with VManip!\")\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(client:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track pickup statistics\nhook.Add(\"VManipPickup\", \"TrackPickupStats\", function(client, item)\n    local char = client:getChar()\n    if char then\n        -- Track pickup frequency\n        local pickupFrequency = char:getData(\"vmanip_pickup_frequency\", 0)\n        char:setData(\"vmanip_pickup_frequency\", pickupFrequency + 1)\n\n        -- Track pickup patterns\n        local pickupPatterns = char:getData(\"vmanip_pickup_patterns\", {})\n        table.insert(pickupPatterns, {\n            item = item.uniqueID,\n            time = os.time()\n        })\n        char:setData(\"vmanip_pickup_patterns\", pickupPatterns)\n\n        -- Track pickup duration\n        local pickupDuration = char:getData(\"total_vmanip_pickup_duration\", 0)\n        char:setData(\"total_vmanip_pickup_duration\", pickupDuration + 2) -- Default 2 second duration\n    end\nend)\n\n-- Award pickup achievements\nhook.Add(\"VManipPickup\", \"PickupAchievements\", function(client, item)\n    local char = client:getChar()\n    if char then\n        local totalPickups = char:getData(\"vmanip_pickups_completed\", 0)\n\n        if totalPickups == 1 then\n            client:notify(\"Achievement: First VManip Pickup!\")\n        elseif totalPickups == 10 then\n            client:notify(\"Achievement: VManip Enthusiast!\")\n        elseif totalPickups == 50 then\n            client:notify(\"Achievement: VManip Master!\")\n        end\n\n        -- Check for specific item achievements\n        local itemPickups = char:getData(\"vmanip_item_pickups\", {})\n        itemPickups[item.uniqueID] = (itemPickups[item.uniqueID] or 0) + 1\n        char:setData(\"vmanip_item_pickups\", itemPickups)\n\n        if itemPickups[item.uniqueID] == 1 then\n            client:notify(\"Achievement: First time picking up \" .. item.name .. \" with VManip!\")\n        end\n    end\nend)\n</code></pre>"},{"location":"modules/wartable/about/","title":"About","text":"About <p>Name: War Table</p> <p>Description:</p> <p>Adds an interactive 3D war table, the ability to plan operations on a map, a workshop model, marker placement for strategies, and support for multiple map layouts.</p> Features <ul> <li>Adds an interactive 3D war table</li> <li>Adds the ability to plan operations on a map</li> <li>Adds a workshop model</li> <li>Adds marker placement for strategies</li> <li>Adds support for multiple map layouts</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/wartable/changelog/","title":"Changelog","text":""},{"location":"modules/wartable/changelog/#version-12","title":"Version 1.2","text":"<ul> <li>Changed: Updated function naming convention from PascalCase to camelCase for consistency</li> </ul>"},{"location":"modules/wartable/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/wartable/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/wartable/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the War Table module for managing interactive war table functionality.</p>"},{"location":"modules/wartable/hooks/#postwartableclear","title":"PostWarTableClear","text":"<p>Purpose</p> <p>Called after a war table has been cleared.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who cleared the table.</li> <li><code>tableEnt</code> (Entity): The war table entity that was cleared.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A war table has been successfully cleared - After <code>WarTableCleared</code> hook - After the clear operation is complete</p> <p>Example Usage</p> <pre><code>-- Track war table clear completion\nhook.Add(\"PostWarTableClear\", \"TrackWarTableClear\", function(client, tableEnt)\n    local char = client:getChar()\n    if char then\n        local tableClears = char:getData(\"war_table_clears\", 0)\n        char:setData(\"war_table_clears\", tableClears + 1)\n    end\n    lia.log.add(client, \"warTableCleared\", tableEnt:GetPos())\nend)\n\n-- Apply clear effects\nhook.Add(\"PostWarTableClear\", \"WarTableClearEffects\", function(client, tableEnt)\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.5, 0)\n    client:notify(\"War table cleared!\")\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#postwartablemapchange","title":"PostWarTableMapChange","text":"<p>Purpose</p> <p>Called after a war table map has been changed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who changed the map.</li> <li><code>tableEnt</code> (Entity): The war table entity.</li> <li><code>text</code> (string): The new map URL or path.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A war table map has been successfully changed - After <code>WarTableMapChanged</code> hook - After the map change is broadcast</p> <p>Example Usage</p> <pre><code>-- Track war table map changes\nhook.Add(\"PostWarTableMapChange\", \"TrackWarTableMapChange\", function(client, tableEnt, text)\n    local char = client:getChar()\n    if char then\n        local mapChanges = char:getData(\"war_table_map_changes\", 0)\n        char:setData(\"war_table_map_changes\", mapChanges + 1)\n    end\n    lia.log.add(client, \"warTableMapChanged\", text)\nend)\n\n-- Apply map change effects\nhook.Add(\"PostWarTableMapChange\", \"WarTableMapChangeEffects\", function(client, tableEnt, text)\n    client:EmitSound(\"buttons/button15.wav\", 75, 100)\n    client:ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 10), 0.5, 0)\n    client:notify(\"War table map changed!\")\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#postwartablemarkerplace","title":"PostWarTableMarkerPlace","text":"<p>Purpose</p> <p>Called after a marker has been placed on the war table.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who placed the marker.</li> <li><code>marker</code> (Entity): The marker entity that was placed.</li> <li><code>tableEnt</code> (Entity): The war table entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A marker has been successfully placed on the war table - After <code>WarTableMarkerPlaced</code> hook - After the marker is created and configured</p> <p>Example Usage</p> <pre><code>-- Track war table marker placement\nhook.Add(\"PostWarTableMarkerPlace\", \"TrackWarTableMarkerPlace\", function(client, marker, tableEnt)\n    local char = client:getChar()\n    if char then\n        local markersPlaced = char:getData(\"war_table_markers_placed\", 0)\n        char:setData(\"war_table_markers_placed\", markersPlaced + 1)\n    end\n    lia.log.add(client, \"warTableMarkerPlaced\", marker:GetPos())\nend)\n\n-- Apply marker placement effects\nhook.Add(\"PostWarTableMarkerPlace\", \"WarTableMarkerPlaceEffects\", function(client, marker, tableEnt)\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.5, 0)\n    client:notify(\"Marker placed on war table!\")\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#postwartablemarkerremove","title":"PostWarTableMarkerRemove","text":"<p>Purpose</p> <p>Called after a marker has been removed from the war table.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who removed the marker.</li> <li><code>ent</code> (Entity): The marker entity that was removed.</li> <li><code>tableEnt</code> (Entity): The war table entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A marker has been successfully removed from the war table - After <code>WarTableMarkerRemoved</code> hook - After the marker is destroyed</p> <p>Example Usage</p> <pre><code>-- Track war table marker removal\nhook.Add(\"PostWarTableMarkerRemove\", \"TrackWarTableMarkerRemove\", function(client, ent, tableEnt)\n    local char = client:getChar()\n    if char then\n        local markersRemoved = char:getData(\"war_table_markers_removed\", 0)\n        char:setData(\"war_table_markers_removed\", markersRemoved + 1)\n    end\n    lia.log.add(client, \"warTableMarkerRemoved\", ent:GetPos())\nend)\n\n-- Apply marker removal effects\nhook.Add(\"PostWarTableMarkerRemove\", \"WarTableMarkerRemoveEffects\", function(client, ent, tableEnt)\n    client:EmitSound(\"buttons/button17.wav\", 75, 100)\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 10), 0.5, 0)\n    client:notify(\"Marker removed from war table!\")\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#postwartableused","title":"PostWarTableUsed","text":"<p>Purpose</p> <p>Called after a war table has been used.</p> <p>Parameters</p> <ul> <li><code>activator</code> (Player): The player who used the war table.</li> <li><code>tableEnt</code> (Entity): The war table entity that was used.</li> <li><code>isSprinting</code> (boolean): Whether the player was sprinting when using the table.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A war table has been successfully used - After <code>WarTableUsed</code> hook - After the use operation is complete</p> <p>Example Usage</p> <pre><code>-- Track war table usage\nhook.Add(\"PostWarTableUsed\", \"TrackWarTableUsed\", function(activator, tableEnt, isSprinting)\n    local char = activator:getChar()\n    if char then\n        local tableUses = char:getData(\"war_table_uses\", 0)\n        char:setData(\"war_table_uses\", tableUses + 1)\n    end\n    lia.log.add(activator, \"warTableUsed\", tableEnt:GetPos())\nend)\n\n-- Apply usage effects\nhook.Add(\"PostWarTableUsed\", \"WarTableUsedEffects\", function(activator, tableEnt, isSprinting)\n    activator:EmitSound(\"buttons/button18.wav\", 75, 100)\n    activator:ScreenFade(SCREENFADE.IN, Color(255, 0, 255, 10), 0.5, 0)\n    activator:notify(\"War table used!\")\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#prewartableclear","title":"PreWarTableClear","text":"<p>Purpose</p> <p>Called before a war table is cleared.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is clearing the table.</li> <li><code>tableEnt</code> (Entity): The war table entity that will be cleared.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A war table is about to be cleared - Before the clear operation begins - Before <code>WarTableCleared</code> hook</p> <p>Example Usage</p> <pre><code>-- Validate war table clear\nhook.Add(\"PreWarTableClear\", \"ValidateWarTableClear\", function(client, tableEnt)\n    local char = client:getChar()\n    if char then\n        if char:getData(\"war_table_clear_disabled\", false) then\n            client:notify(\"War table clearing is disabled!\")\n            return false\n        end\n    end\nend)\n\n-- Track clear attempts\nhook.Add(\"PreWarTableClear\", \"TrackWarTableClearAttempts\", function(client, tableEnt)\n    local char = client:getChar()\n    if char then\n        local clearAttempts = char:getData(\"war_table_clear_attempts\", 0)\n        char:setData(\"war_table_clear_attempts\", clearAttempts + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#prewartablemapchange","title":"PreWarTableMapChange","text":"<p>Purpose</p> <p>Called before a war table map is changed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is changing the map.</li> <li><code>tableEnt</code> (Entity): The war table entity.</li> <li><code>text</code> (string): The new map URL or path.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A war table map is about to be changed - Before the map change operation begins - Before <code>WarTableMapChanged</code> hook</p> <p>Example Usage</p> <pre><code>-- Validate war table map change\nhook.Add(\"PreWarTableMapChange\", \"ValidateWarTableMapChange\", function(client, tableEnt, text)\n    local char = client:getChar()\n    if char then\n        if char:getData(\"war_table_map_change_disabled\", false) then\n            client:notify(\"War table map changes are disabled!\")\n            return false\n        end\n    end\nend)\n\n-- Track map change attempts\nhook.Add(\"PreWarTableMapChange\", \"TrackWarTableMapChangeAttempts\", function(client, tableEnt, text)\n    local char = client:getChar()\n    if char then\n        local mapChangeAttempts = char:getData(\"war_table_map_change_attempts\", 0)\n        char:setData(\"war_table_map_change_attempts\", mapChangeAttempts + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#prewartablemarkerplace","title":"PreWarTableMarkerPlace","text":"<p>Purpose</p> <p>Called before a marker is placed on the war table.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is placing the marker.</li> <li><code>pos</code> (Vector): The position where the marker will be placed.</li> <li><code>bodygroups</code> (table): The bodygroup configuration for the marker.</li> <li><code>tableEnt</code> (Entity): The war table entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A marker is about to be placed on the war table - Before the marker creation begins - Before <code>WarTableMarkerPlaced</code> hook</p> <p>Example Usage</p> <pre><code>-- Validate war table marker placement\nhook.Add(\"PreWarTableMarkerPlace\", \"ValidateWarTableMarkerPlace\", function(client, pos, bodygroups, tableEnt)\n    local char = client:getChar()\n    if char then\n        if char:getData(\"war_table_marker_placement_disabled\", false) then\n            client:notify(\"War table marker placement is disabled!\")\n            return false\n        end\n    end\nend)\n\n-- Track marker placement attempts\nhook.Add(\"PreWarTableMarkerPlace\", \"TrackWarTableMarkerPlaceAttempts\", function(client, pos, bodygroups, tableEnt)\n    local char = client:getChar()\n    if char then\n        local markerPlaceAttempts = char:getData(\"war_table_marker_place_attempts\", 0)\n        char:setData(\"war_table_marker_place_attempts\", markerPlaceAttempts + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#prewartablemarkerremove","title":"PreWarTableMarkerRemove","text":"<p>Purpose</p> <p>Called before a marker is removed from the war table.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who is removing the marker.</li> <li><code>ent</code> (Entity): The marker entity that will be removed.</li> <li><code>tableEnt</code> (Entity): The war table entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A marker is about to be removed from the war table - Before the marker destruction begins - Before <code>WarTableMarkerRemoved</code> hook</p> <p>Example Usage</p> <pre><code>-- Validate war table marker removal\nhook.Add(\"PreWarTableMarkerRemove\", \"ValidateWarTableMarkerRemove\", function(client, ent, tableEnt)\n    local char = client:getChar()\n    if char then\n        if char:getData(\"war_table_marker_removal_disabled\", false) then\n            client:notify(\"War table marker removal is disabled!\")\n            return false\n        end\n    end\nend)\n\n-- Track marker removal attempts\nhook.Add(\"PreWarTableMarkerRemove\", \"TrackWarTableMarkerRemoveAttempts\", function(client, ent, tableEnt)\n    local char = client:getChar()\n    if char then\n        local markerRemoveAttempts = char:getData(\"war_table_marker_remove_attempts\", 0)\n        char:setData(\"war_table_marker_remove_attempts\", markerRemoveAttempts + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#prewartableused","title":"PreWarTableUsed","text":"<p>Purpose</p> <p>Called before a war table is used.</p> <p>Parameters</p> <ul> <li><code>activator</code> (Player): The player who is using the war table.</li> <li><code>tableEnt</code> (Entity): The war table entity that will be used.</li> <li><code>isSprinting</code> (boolean): Whether the player is sprinting.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A war table is about to be used - Before the use operation begins - Before <code>WarTableUsed</code> hook</p> <p>Example Usage</p> <pre><code>-- Validate war table usage\nhook.Add(\"PreWarTableUsed\", \"ValidateWarTableUsed\", function(activator, tableEnt, isSprinting)\n    local char = activator:getChar()\n    if char then\n        if char:getData(\"war_table_usage_disabled\", false) then\n            activator:notify(\"War table usage is disabled!\")\n            return false\n        end\n    end\nend)\n\n-- Track usage attempts\nhook.Add(\"PreWarTableUsed\", \"TrackWarTableUsedAttempts\", function(activator, tableEnt, isSprinting)\n    local char = activator:getChar()\n    if char then\n        local usageAttempts = char:getData(\"war_table_usage_attempts\", 0)\n        char:setData(\"war_table_usage_attempts\", usageAttempts + 1)\n    end\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#wartablecleared","title":"WarTableCleared","text":"<p>Purpose</p> <p>Called when a war table has been cleared.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who cleared the table.</li> <li><code>tableEnt</code> (Entity): The war table entity that was cleared.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A war table has been cleared - After <code>PreWarTableClear</code> hook - Before <code>PostWarTableClear</code> hook</p> <p>Example Usage</p> <pre><code>-- Track war table clear\nhook.Add(\"WarTableCleared\", \"TrackWarTableCleared\", function(client, tableEnt)\n    local char = client:getChar()\n    if char then\n        local tableClears = char:getData(\"war_table_clears\", 0)\n        char:setData(\"war_table_clears\", tableClears + 1)\n    end\n    lia.log.add(client, \"warTableCleared\", tableEnt:GetPos())\nend)\n\n-- Apply clear effects\nhook.Add(\"WarTableCleared\", \"WarTableClearedEffects\", function(client, tableEnt)\n    client:EmitSound(\"buttons/button14.wav\", 75, 100)\n    client:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 10), 0.5, 0)\n    client:notify(\"War table cleared!\")\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#wartablemapchanged","title":"WarTableMapChanged","text":"<p>Purpose</p> <p>Called when a war table map has been changed.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who changed the map.</li> <li><code>tableEnt</code> (Entity): The war table entity.</li> <li><code>text</code> (string): The new map URL or path.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A war table map has been changed - After <code>PreWarTableMapChange</code> hook - Before <code>PostWarTableMapChange</code> hook</p> <p>Example Usage</p> <pre><code>-- Track war table map change\nhook.Add(\"WarTableMapChanged\", \"TrackWarTableMapChanged\", function(client, tableEnt, text)\n    local char = client:getChar()\n    if char then\n        local mapChanges = char:getData(\"war_table_map_changes\", 0)\n        char:setData(\"war_table_map_changes\", mapChanges + 1)\n    end\n    lia.log.add(client, \"warTableMapChanged\", text)\nend)\n\n-- Apply map change effects\nhook.Add(\"WarTableMapChanged\", \"WarTableMapChangedEffects\", function(client, tableEnt, text)\n    client:EmitSound(\"buttons/button15.wav\", 75, 100)\n    client:ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 10), 0.5, 0)\n    client:notify(\"War table map changed!\")\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#wartablemarkerplaced","title":"WarTableMarkerPlaced","text":"<p>Purpose</p> <p>Called when a marker has been placed on the war table.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who placed the marker.</li> <li><code>marker</code> (Entity): The marker entity that was placed.</li> <li><code>tableEnt</code> (Entity): The war table entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A marker has been placed on the war table - After <code>PreWarTableMarkerPlace</code> hook - Before <code>PostWarTableMarkerPlace</code> hook</p> <p>Example Usage</p> <pre><code>-- Track war table marker placement\nhook.Add(\"WarTableMarkerPlaced\", \"TrackWarTableMarkerPlaced\", function(client, marker, tableEnt)\n    local char = client:getChar()\n    if char then\n        local markersPlaced = char:getData(\"war_table_markers_placed\", 0)\n        char:setData(\"war_table_markers_placed\", markersPlaced + 1)\n    end\n    lia.log.add(client, \"warTableMarkerPlaced\", marker:GetPos())\nend)\n\n-- Apply marker placement effects\nhook.Add(\"WarTableMarkerPlaced\", \"WarTableMarkerPlacedEffects\", function(client, marker, tableEnt)\n    client:EmitSound(\"buttons/button16.wav\", 75, 100)\n    client:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.5, 0)\n    client:notify(\"Marker placed on war table!\")\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#wartablemarkerremoved","title":"WarTableMarkerRemoved","text":"<p>Purpose</p> <p>Called when a marker has been removed from the war table.</p> <p>Parameters</p> <ul> <li><code>client</code> (Player): The player who removed the marker.</li> <li><code>ent</code> (Entity): The marker entity that was removed.</li> <li><code>tableEnt</code> (Entity): The war table entity.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A marker has been removed from the war table - After <code>PreWarTableMarkerRemove</code> hook - Before <code>PostWarTableMarkerRemove</code> hook</p> <p>Example Usage</p> <pre><code>-- Track war table marker removal\nhook.Add(\"WarTableMarkerRemoved\", \"TrackWarTableMarkerRemoved\", function(client, ent, tableEnt)\n    local char = client:getChar()\n    if char then\n        local markersRemoved = char:getData(\"war_table_markers_removed\", 0)\n        char:setData(\"war_table_markers_removed\", markersRemoved + 1)\n    end\n    lia.log.add(client, \"warTableMarkerRemoved\", ent:GetPos())\nend)\n\n-- Apply marker removal effects\nhook.Add(\"WarTableMarkerRemoved\", \"WarTableMarkerRemovedEffects\", function(client, ent, tableEnt)\n    client:EmitSound(\"buttons/button17.wav\", 75, 100)\n    client:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 10), 0.5, 0)\n    client:notify(\"Marker removed from war table!\")\nend)\n</code></pre>"},{"location":"modules/wartable/hooks/#wartableused","title":"WarTableUsed","text":"<p>Purpose</p> <p>Called when a war table has been used.</p> <p>Parameters</p> <ul> <li><code>activator</code> (Player): The player who used the war table.</li> <li><code>tableEnt</code> (Entity): The war table entity that was used.</li> <li><code>isSprinting</code> (boolean): Whether the player was sprinting.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A war table has been used - After <code>PreWarTableUsed</code> hook - Before <code>PostWarTableUsed</code> hook</p> <p>Example Usage</p> <pre><code>-- Track war table usage\nhook.Add(\"WarTableUsed\", \"TrackWarTableUsed\", function(activator, tableEnt, isSprinting)\n    local char = activator:getChar()\n    if char then\n        local tableUses = char:getData(\"war_table_uses\", 0)\n        char:setData(\"war_table_uses\", tableUses + 1)\n    end\n    lia.log.add(activator, \"warTableUsed\", tableEnt:GetPos())\nend)\n\n-- Apply usage effects\nhook.Add(\"WarTableUsed\", \"WarTableUsedEffects\", function(activator, tableEnt, isSprinting)\n    activator:EmitSound(\"buttons/button18.wav\", 75, 100)\n    activator:ScreenFade(SCREENFADE.IN, Color(255, 0, 255, 10), 0.5, 0)\n    activator:notify(\"War table used!\")\nend)\n</code></pre>"},{"location":"modules/wordfilter/about/","title":"About","text":"About <p>Name: Word Filter</p> <p>Description:</p> <p>Adds chat word filtering, blocking of banned phrases, an easy-to-extend list, and admin commands to modify the list.</p> Features <ul> <li>Adds chat word filtering</li> <li>Adds blocking of banned phrases</li> <li>Adds an easy-to-extend list</li> <li>Adds admin commands to modify the list</li> </ul> <p>DOWNLOAD HERE</p>"},{"location":"modules/wordfilter/changelog/","title":"Changelog","text":""},{"location":"modules/wordfilter/changelog/#version-11","title":"Version 1.1","text":"<ul> <li>Created docs</li> </ul>"},{"location":"modules/wordfilter/changelog/#version-10","title":"Version 1.0","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"modules/wordfilter/hooks/","title":"Hooks","text":"<p>This document describes the hooks available in the Word Filter module for managing chat word filtering and content moderation.</p>"},{"location":"modules/wordfilter/hooks/#filtercheckfailed","title":"FilterCheckFailed","text":"<p>Purpose</p> <p>Called when a word filter check fails (filtered word detected).</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who used the filtered word.</li> <li><code>text</code> (string): The original text that was filtered.</li> <li><code>bad</code> (string): The specific word that was filtered.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's message contains a filtered word - After <code>FilteredWordUsed</code> hook - After <code>PostFilterCheck</code> hook with false result</p> <p>Example Usage</p> <pre><code>-- Track filter check failures\nhook.Add(\"FilterCheckFailed\", \"TrackFilterCheckFailures\", function(player, text, bad)\n    local char = player:getChar()\n    if char then\n        local filterFailures = char:getData(\"filter_check_failures\", 0)\n        char:setData(\"filter_check_failures\", filterFailures + 1)\n\n        -- Track specific filtered words\n        local filteredWords = char:getData(\"filtered_words_used\", {})\n        filteredWords[bad] = (filteredWords[bad] or 0) + 1\n        char:setData(\"filtered_words_used\", filteredWords)\n    end\n\n    lia.log.add(player, \"filterCheckFailed\", bad, text)\nend)\n\n-- Apply filter failure effects\nhook.Add(\"FilterCheckFailed\", \"FilterFailureEffects\", function(player, text, bad)\n    -- Play failure sound\n    player:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 10), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"Your message contained a filtered word: \" .. bad)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track filter failure patterns\nhook.Add(\"FilterCheckFailed\", \"TrackFilterFailurePatterns\", function(player, text, bad)\n    local char = player:getChar()\n    if char then\n        -- Track failure frequency\n        local failureFrequency = char:getData(\"filter_failure_frequency\", 0)\n        char:setData(\"filter_failure_frequency\", failureFrequency + 1)\n\n        -- Track failure patterns\n        local failurePatterns = char:getData(\"filter_failure_patterns\", {})\n        table.insert(failurePatterns, {\n            word = bad,\n            text = text,\n            time = os.time()\n        })\n        char:setData(\"filter_failure_patterns\", failurePatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/wordfilter/hooks/#filtercheckpassed","title":"FilterCheckPassed","text":"<p>Purpose</p> <p>Called when a word filter check passes (no filtered words detected).</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose message passed the filter.</li> <li><code>text</code> (string): The text that passed the filter.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's message passes the word filter - After <code>PostFilterCheck</code> hook with true result - When no filtered words are found</p> <p>Example Usage</p> <pre><code>-- Track filter check passes\nhook.Add(\"FilterCheckPassed\", \"TrackFilterCheckPasses\", function(player, text)\n    local char = player:getChar()\n    if char then\n        local filterPasses = char:getData(\"filter_check_passes\", 0)\n        char:setData(\"filter_check_passes\", filterPasses + 1)\n\n        -- Track clean messages\n        local cleanMessages = char:getData(\"clean_messages\", 0)\n        char:setData(\"clean_messages\", cleanMessages + 1)\n    end\nend)\n\n-- Apply filter pass effects\nhook.Add(\"FilterCheckPassed\", \"FilterPassEffects\", function(player, text)\n    -- Play pass sound\n    player:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.3, 0)\n\n    -- Notify player\n    player:notify(\"Message sent successfully!\")\nend)\n\n-- Track filter pass patterns\nhook.Add(\"FilterCheckPassed\", \"TrackFilterPassPatterns\", function(player, text)\n    local char = player:getChar()\n    if char then\n        -- Track pass frequency\n        local passFrequency = char:getData(\"filter_pass_frequency\", 0)\n        char:setData(\"filter_pass_frequency\", passFrequency + 1)\n\n        -- Track pass patterns\n        local passPatterns = char:getData(\"filter_pass_patterns\", {})\n        table.insert(passPatterns, {\n            text = text,\n            time = os.time()\n        })\n        char:setData(\"filter_pass_patterns\", passPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/wordfilter/hooks/#filteredwordused","title":"FilteredWordUsed","text":"<p>Purpose</p> <p>Called when a filtered word is detected in a player's message.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player who used the filtered word.</li> <li><code>bad</code> (string): The specific word that was filtered.</li> <li><code>text</code> (string): The original text that contained the filtered word.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player's message contains a filtered word - After <code>PreFilterCheck</code> hook - Before <code>PostFilterCheck</code> hook with false result</p> <p>Example Usage</p> <pre><code>-- Track filtered word usage\nhook.Add(\"FilteredWordUsed\", \"TrackFilteredWordUsage\", function(player, bad, text)\n    local char = player:getChar()\n    if char then\n        local filteredWordUsage = char:getData(\"filtered_word_usage\", 0)\n        char:setData(\"filtered_word_usage\", filteredWordUsage + 1)\n\n        -- Track specific filtered words\n        local filteredWords = char:getData(\"filtered_words_used\", {})\n        filteredWords[bad] = (filteredWords[bad] or 0) + 1\n        char:setData(\"filtered_words_used\", filteredWords)\n    end\n\n    lia.log.add(player, \"filteredWordUsed\", bad, text)\nend)\n\n-- Apply filtered word effects\nhook.Add(\"FilteredWordUsed\", \"FilteredWordEffects\", function(player, bad, text)\n    -- Play filtered word sound\n    player:EmitSound(\"buttons/button17.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(255, 255, 0, 10), 0.5, 0)\n\n    -- Notify player\n    player:notify(\"Filtered word detected: \" .. bad)\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(player:GetPos())\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track filtered word patterns\nhook.Add(\"FilteredWordUsed\", \"TrackFilteredWordPatterns\", function(player, bad, text)\n    local char = player:getChar()\n    if char then\n        -- Track filtered word frequency\n        local filteredWordFrequency = char:getData(\"filtered_word_frequency\", 0)\n        char:setData(\"filtered_word_frequency\", filteredWordFrequency + 1)\n\n        -- Track filtered word patterns\n        local filteredWordPatterns = char:getData(\"filtered_word_patterns\", {})\n        table.insert(filteredWordPatterns, {\n            word = bad,\n            text = text,\n            time = os.time()\n        })\n        char:setData(\"filtered_word_patterns\", filteredWordPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/wordfilter/hooks/#postfiltercheck","title":"PostFilterCheck","text":"<p>Purpose</p> <p>Called after a word filter check has been completed.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose message was checked.</li> <li><code>text</code> (string): The text that was checked.</li> <li><code>passed</code> (boolean): Whether the filter check passed (true) or failed (false).</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A word filter check has been completed - After <code>PreFilterCheck</code> hook - After all filtering logic has been processed</p> <p>Example Usage</p> <pre><code>-- Track filter check completion\nhook.Add(\"PostFilterCheck\", \"TrackFilterCheckCompletion\", function(player, text, passed)\n    local char = player:getChar()\n    if char then\n        local filterChecks = char:getData(\"filter_checks\", 0)\n        char:setData(\"filter_checks\", filterChecks + 1)\n\n        -- Track filter check results\n        local filterResults = char:getData(\"filter_results\", {})\n        filterResults[passed and \"passed\" or \"failed\"] = (filterResults[passed and \"passed\" or \"failed\"] or 0) + 1\n        char:setData(\"filter_results\", filterResults)\n    end\nend)\n\n-- Apply filter check completion effects\nhook.Add(\"PostFilterCheck\", \"FilterCheckCompletionEffects\", function(player, text, passed)\n    if passed then\n        -- Play pass sound\n        player:EmitSound(\"buttons/button14.wav\", 75, 100)\n\n        -- Apply screen effect\n        player:ScreenFade(SCREENFADE.IN, Color(0, 255, 0, 5), 0.3, 0)\n    else\n        -- Play fail sound\n        player:EmitSound(\"buttons/button16.wav\", 75, 100)\n\n        -- Apply screen effect\n        player:ScreenFade(SCREENFADE.IN, Color(255, 0, 0, 10), 0.5, 0)\n    end\nend)\n\n-- Track filter check statistics\nhook.Add(\"PostFilterCheck\", \"TrackFilterCheckStats\", function(player, text, passed)\n    local char = player:getChar()\n    if char then\n        -- Track filter check frequency\n        local filterCheckFrequency = char:getData(\"filter_check_frequency\", 0)\n        char:setData(\"filter_check_frequency\", filterCheckFrequency + 1)\n\n        -- Track filter check patterns\n        local filterCheckPatterns = char:getData(\"filter_check_patterns\", {})\n        table.insert(filterCheckPatterns, {\n            text = text,\n            passed = passed,\n            time = os.time()\n        })\n        char:setData(\"filter_check_patterns\", filterCheckPatterns)\n    end\nend)\n</code></pre>"},{"location":"modules/wordfilter/hooks/#prefiltercheck","title":"PreFilterCheck","text":"<p>Purpose</p> <p>Called before a word filter check is performed on a player's message.</p> <p>Parameters</p> <ul> <li><code>player</code> (Player): The player whose message will be checked.</li> <li><code>text</code> (string): The text that will be checked.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A player sends a message - Before the word filter check begins - Before any filtering logic is processed</p> <p>Example Usage</p> <pre><code>-- Validate filter check\nhook.Add(\"PreFilterCheck\", \"ValidateFilterCheck\", function(player, text)\n    local char = player:getChar()\n    if char then\n        -- Check if filter is disabled\n        if char:getData(\"word_filter_disabled\", false) then\n            player:notify(\"Word filter is disabled!\")\n            return false\n        end\n\n        -- Check filter cooldown\n        local lastFilter = char:getData(\"last_filter_check_time\", 0)\n        if os.time() - lastFilter &lt; 1 then -- 1 second cooldown\n            player:notify(\"Please wait before sending another message!\")\n            return false\n        end\n\n        -- Update last filter time\n        char:setData(\"last_filter_check_time\", os.time())\n    end\nend)\n\n-- Track filter check attempts\nhook.Add(\"PreFilterCheck\", \"TrackFilterCheckAttempts\", function(player, text)\n    local char = player:getChar()\n    if char then\n        local filterAttempts = char:getData(\"filter_check_attempts\", 0)\n        char:setData(\"filter_check_attempts\", filterAttempts + 1)\n\n        -- Track message patterns\n        local messagePatterns = char:getData(\"message_patterns\", {})\n        table.insert(messagePatterns, {\n            text = text,\n            time = os.time()\n        })\n        char:setData(\"message_patterns\", messagePatterns)\n    end\nend)\n\n-- Apply pre-filter effects\nhook.Add(\"PreFilterCheck\", \"PreFilterEffects\", function(player, text)\n    -- Play pre-filter sound\n    player:EmitSound(\"ui/buttonclick.wav\", 75, 100)\n\n    -- Apply screen effect\n    player:ScreenFade(SCREENFADE.IN, Color(0, 0, 255, 5), 0.2, 0)\nend)\n</code></pre>"},{"location":"modules/wordfilter/hooks/#wordaddedtofilter","title":"WordAddedToFilter","text":"<p>Purpose</p> <p>Called when a word is added to the filter list.</p> <p>Parameters</p> <ul> <li><code>word</code> (string): The word that was added to the filter.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A word is added to the word filter - After the word is saved to the database - When the filter list is updated</p> <p>Example Usage</p> <pre><code>-- Track word additions\nhook.Add(\"WordAddedToFilter\", \"TrackWordAdditions\", function(word)\n    lia.log.add(nil, \"wordAddedToFilter\", word)\n\n    -- Notify all players\n    for _, ply in player.Iterator() do\n        ply:notify(\"Word '\" .. word .. \"' added to filter!\")\n    end\nend)\n\n-- Apply word addition effects\nhook.Add(\"WordAddedToFilter\", \"WordAdditionEffects\", function(word)\n    -- Play addition sound\n    for _, ply in player.Iterator() do\n        ply:EmitSound(\"buttons/button14.wav\", 75, 100)\n    end\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(Vector(0, 0, 0))\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track word addition statistics\nhook.Add(\"WordAddedToFilter\", \"TrackWordAdditionStats\", function(word)\n    -- Track total words added\n    local totalWordsAdded = lia.data.get(\"total_words_added\", 0)\n    lia.data.set(\"total_words_added\", totalWordsAdded + 1)\n\n    -- Track word addition frequency\n    local wordAdditionFrequency = lia.data.get(\"word_addition_frequency\", 0)\n    lia.data.set(\"word_addition_frequency\", wordAdditionFrequency + 1)\nend)\n</code></pre>"},{"location":"modules/wordfilter/hooks/#wordremovedfromfilter","title":"WordRemovedFromFilter","text":"<p>Purpose</p> <p>Called when a word is removed from the filter list.</p> <p>Parameters</p> <ul> <li><code>word</code> (string): The word that was removed from the filter.</li> </ul> <p>Realm</p> <p>Server.</p> <p>When Called</p> <p>This hook is triggered when: - A word is removed from the word filter - After the word is removed from the database - When the filter list is updated</p> <p>Example Usage</p> <pre><code>-- Track word removals\nhook.Add(\"WordRemovedFromFilter\", \"TrackWordRemovals\", function(word)\n    lia.log.add(nil, \"wordRemovedFromFilter\", word)\n\n    -- Notify all players\n    for _, ply in player.Iterator() do\n        ply:notify(\"Word '\" .. word .. \"' removed from filter!\")\n    end\nend)\n\n-- Apply word removal effects\nhook.Add(\"WordRemovedFromFilter\", \"WordRemovalEffects\", function(word)\n    -- Play removal sound\n    for _, ply in player.Iterator() do\n        ply:EmitSound(\"buttons/button16.wav\", 75, 100)\n    end\n\n    -- Create particle effect\n    local effect = EffectData()\n    effect:SetOrigin(Vector(0, 0, 0))\n    effect:SetMagnitude(1)\n    effect:SetScale(1)\n    util.Effect(\"Explosion\", effect)\nend)\n\n-- Track word removal statistics\nhook.Add(\"WordRemovedFromFilter\", \"TrackWordRemovalStats\", function(word)\n    -- Track total words removed\n    local totalWordsRemoved = lia.data.get(\"total_words_removed\", 0)\n    lia.data.set(\"total_words_removed\", totalWordsRemoved + 1)\n\n    -- Track word removal frequency\n    local wordRemovalFrequency = lia.data.get(\"word_removal_frequency\", 0)\n    lia.data.set(\"word_removal_frequency\", wordRemovalFrequency + 1)\nend)\n</code></pre>"}]}